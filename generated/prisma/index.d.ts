
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Province
 * 
 */
export type Province = $Result.DefaultSelection<Prisma.$ProvincePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model AccessContent
 * 
 */
export type AccessContent = $Result.DefaultSelection<Prisma.$AccessContentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model SubLevel
 * 
 */
export type SubLevel = $Result.DefaultSelection<Prisma.$SubLevelPayload>
/**
 * Model InnerLevel
 * 
 */
export type InnerLevel = $Result.DefaultSelection<Prisma.$InnerLevelPayload>
/**
 * Model Gempo
 * 
 */
export type Gempo = $Result.DefaultSelection<Prisma.$GempoPayload>
/**
 * Model Championship
 * 
 */
export type Championship = $Result.DefaultSelection<Prisma.$ChampionshipPayload>
/**
 * Model GempoRecord
 * 
 */
export type GempoRecord = $Result.DefaultSelection<Prisma.$GempoRecordPayload>
/**
 * Model ChampionshipRecord
 * 
 */
export type ChampionshipRecord = $Result.DefaultSelection<Prisma.$ChampionshipRecordPayload>
/**
 * Model UserLogin
 * 
 */
export type UserLogin = $Result.DefaultSelection<Prisma.$UserLoginPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminOperationHistory
 * 
 */
export type AdminOperationHistory = $Result.DefaultSelection<Prisma.$AdminOperationHistoryPayload>
/**
 * Model AdminAuthority
 * 
 */
export type AdminAuthority = $Result.DefaultSelection<Prisma.$AdminAuthorityPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model BannerLocation
 * 
 */
export type BannerLocation = $Result.DefaultSelection<Prisma.$BannerLocationPayload>
/**
 * Model BannerVisitor
 * 
 */
export type BannerVisitor = $Result.DefaultSelection<Prisma.$BannerVisitorPayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model TestParticipant
 * 
 */
export type TestParticipant = $Result.DefaultSelection<Prisma.$TestParticipantPayload>
/**
 * Model TestParticipantRecord
 * 
 */
export type TestParticipantRecord = $Result.DefaultSelection<Prisma.$TestParticipantRecordPayload>
/**
 * Model Background
 * 
 */
export type Background = $Result.DefaultSelection<Prisma.$BackgroundPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherRedemeer
 * 
 */
export type VoucherRedemeer = $Result.DefaultSelection<Prisma.$VoucherRedemeerPayload>
/**
 * Model AdminTransaction
 * 
 */
export type AdminTransaction = $Result.DefaultSelection<Prisma.$AdminTransactionPayload>
/**
 * Model AdminTransactionArchive
 * 
 */
export type AdminTransactionArchive = $Result.DefaultSelection<Prisma.$AdminTransactionArchivePayload>
/**
 * Model UserTransaction
 * 
 */
export type UserTransaction = $Result.DefaultSelection<Prisma.$UserTransactionPayload>
/**
 * Model UserTransactionArchive
 * 
 */
export type UserTransactionArchive = $Result.DefaultSelection<Prisma.$UserTransactionArchivePayload>
/**
 * Model MultiplayerRoom
 * 
 */
export type MultiplayerRoom = $Result.DefaultSelection<Prisma.$MultiplayerRoomPayload>
/**
 * Model MultiPlayerMember
 * 
 */
export type MultiPlayerMember = $Result.DefaultSelection<Prisma.$MultiPlayerMemberPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  Developer: 'Developer',
  SuperAdmin: 'SuperAdmin',
  Admin: 'Admin',
  SchoolAdmin: 'SchoolAdmin',
  Teacher: 'Teacher',
  User: 'User'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AccountType: {
  LMS: 'LMS',
  Self: 'Self'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const VoucherType: {
  Discount: 'Discount',
  FixedPrice: 'FixedPrice'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const QuestionType: {
  Addition: 'Addition',
  Multiplication: 'Multiplication',
  Subtraction: 'Subtraction',
  Division: 'Division',
  Bakalkubagi: 'Bakalkubagi'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const TestType: {
  PreTest: 'PreTest',
  PostTest: 'PostTest',
  FirstPreTest: 'FirstPreTest',
  Contest: 'Contest'
};

export type TestType = (typeof TestType)[keyof typeof TestType]


export const TestCategory: {
  Teacher: 'Teacher',
  Student: 'Student'
};

export type TestCategory = (typeof TestCategory)[keyof typeof TestCategory]


export const Operation: {
  None: 'None',
  Create: 'Create',
  Update: 'Update',
  Delete: 'Delete'
};

export type Operation = (typeof Operation)[keyof typeof Operation]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type TestType = $Enums.TestType

export const TestType: typeof $Enums.TestType

export type TestCategory = $Enums.TestCategory

export const TestCategory: typeof $Enums.TestCategory

export type Operation = $Enums.Operation

export const Operation: typeof $Enums.Operation

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Provinces
 * const provinces = await prisma.province.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Provinces
   * const provinces = await prisma.province.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.province`: Exposes CRUD operations for the **Province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.ProvinceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessContent`: Exposes CRUD operations for the **AccessContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessContents
    * const accessContents = await prisma.accessContent.findMany()
    * ```
    */
  get accessContent(): Prisma.AccessContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subLevel`: Exposes CRUD operations for the **SubLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubLevels
    * const subLevels = await prisma.subLevel.findMany()
    * ```
    */
  get subLevel(): Prisma.SubLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.innerLevel`: Exposes CRUD operations for the **InnerLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InnerLevels
    * const innerLevels = await prisma.innerLevel.findMany()
    * ```
    */
  get innerLevel(): Prisma.InnerLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gempo`: Exposes CRUD operations for the **Gempo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gempos
    * const gempos = await prisma.gempo.findMany()
    * ```
    */
  get gempo(): Prisma.GempoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championship`: Exposes CRUD operations for the **Championship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Championships
    * const championships = await prisma.championship.findMany()
    * ```
    */
  get championship(): Prisma.ChampionshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gempoRecord`: Exposes CRUD operations for the **GempoRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GempoRecords
    * const gempoRecords = await prisma.gempoRecord.findMany()
    * ```
    */
  get gempoRecord(): Prisma.GempoRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championshipRecord`: Exposes CRUD operations for the **ChampionshipRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChampionshipRecords
    * const championshipRecords = await prisma.championshipRecord.findMany()
    * ```
    */
  get championshipRecord(): Prisma.ChampionshipRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLogin`: Exposes CRUD operations for the **UserLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLogins
    * const userLogins = await prisma.userLogin.findMany()
    * ```
    */
  get userLogin(): Prisma.UserLoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminOperationHistory`: Exposes CRUD operations for the **AdminOperationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminOperationHistories
    * const adminOperationHistories = await prisma.adminOperationHistory.findMany()
    * ```
    */
  get adminOperationHistory(): Prisma.AdminOperationHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuthority`: Exposes CRUD operations for the **AdminAuthority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuthorities
    * const adminAuthorities = await prisma.adminAuthority.findMany()
    * ```
    */
  get adminAuthority(): Prisma.AdminAuthorityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerLocation`: Exposes CRUD operations for the **BannerLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerLocations
    * const bannerLocations = await prisma.bannerLocation.findMany()
    * ```
    */
  get bannerLocation(): Prisma.BannerLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerVisitor`: Exposes CRUD operations for the **BannerVisitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerVisitors
    * const bannerVisitors = await prisma.bannerVisitor.findMany()
    * ```
    */
  get bannerVisitor(): Prisma.BannerVisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParticipant`: Exposes CRUD operations for the **TestParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParticipants
    * const testParticipants = await prisma.testParticipant.findMany()
    * ```
    */
  get testParticipant(): Prisma.TestParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParticipantRecord`: Exposes CRUD operations for the **TestParticipantRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParticipantRecords
    * const testParticipantRecords = await prisma.testParticipantRecord.findMany()
    * ```
    */
  get testParticipantRecord(): Prisma.TestParticipantRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.background`: Exposes CRUD operations for the **Background** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backgrounds
    * const backgrounds = await prisma.background.findMany()
    * ```
    */
  get background(): Prisma.BackgroundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucherRedemeer`: Exposes CRUD operations for the **VoucherRedemeer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherRedemeers
    * const voucherRedemeers = await prisma.voucherRedemeer.findMany()
    * ```
    */
  get voucherRedemeer(): Prisma.VoucherRedemeerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminTransaction`: Exposes CRUD operations for the **AdminTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminTransactions
    * const adminTransactions = await prisma.adminTransaction.findMany()
    * ```
    */
  get adminTransaction(): Prisma.AdminTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminTransactionArchive`: Exposes CRUD operations for the **AdminTransactionArchive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminTransactionArchives
    * const adminTransactionArchives = await prisma.adminTransactionArchive.findMany()
    * ```
    */
  get adminTransactionArchive(): Prisma.AdminTransactionArchiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTransaction`: Exposes CRUD operations for the **UserTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTransactions
    * const userTransactions = await prisma.userTransaction.findMany()
    * ```
    */
  get userTransaction(): Prisma.UserTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTransactionArchive`: Exposes CRUD operations for the **UserTransactionArchive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTransactionArchives
    * const userTransactionArchives = await prisma.userTransactionArchive.findMany()
    * ```
    */
  get userTransactionArchive(): Prisma.UserTransactionArchiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multiplayerRoom`: Exposes CRUD operations for the **MultiplayerRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiplayerRooms
    * const multiplayerRooms = await prisma.multiplayerRoom.findMany()
    * ```
    */
  get multiplayerRoom(): Prisma.MultiplayerRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multiPlayerMember`: Exposes CRUD operations for the **MultiPlayerMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiPlayerMembers
    * const multiPlayerMembers = await prisma.multiPlayerMember.findMany()
    * ```
    */
  get multiPlayerMember(): Prisma.MultiPlayerMemberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Province: 'Province',
    City: 'City',
    School: 'School',
    AccessContent: 'AccessContent',
    User: 'User',
    Device: 'Device',
    Zone: 'Zone',
    Level: 'Level',
    SubLevel: 'SubLevel',
    InnerLevel: 'InnerLevel',
    Gempo: 'Gempo',
    Championship: 'Championship',
    GempoRecord: 'GempoRecord',
    ChampionshipRecord: 'ChampionshipRecord',
    UserLogin: 'UserLogin',
    Admin: 'Admin',
    AdminOperationHistory: 'AdminOperationHistory',
    AdminAuthority: 'AdminAuthority',
    Banner: 'Banner',
    BannerLocation: 'BannerLocation',
    BannerVisitor: 'BannerVisitor',
    Test: 'Test',
    TestParticipant: 'TestParticipant',
    TestParticipantRecord: 'TestParticipantRecord',
    Background: 'Background',
    Setting: 'Setting',
    Voucher: 'Voucher',
    VoucherRedemeer: 'VoucherRedemeer',
    AdminTransaction: 'AdminTransaction',
    AdminTransactionArchive: 'AdminTransactionArchive',
    UserTransaction: 'UserTransaction',
    UserTransactionArchive: 'UserTransactionArchive',
    MultiplayerRoom: 'MultiplayerRoom',
    MultiPlayerMember: 'MultiPlayerMember'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "province" | "city" | "school" | "accessContent" | "user" | "device" | "zone" | "level" | "subLevel" | "innerLevel" | "gempo" | "championship" | "gempoRecord" | "championshipRecord" | "userLogin" | "admin" | "adminOperationHistory" | "adminAuthority" | "banner" | "bannerLocation" | "bannerVisitor" | "test" | "testParticipant" | "testParticipantRecord" | "background" | "setting" | "voucher" | "voucherRedemeer" | "adminTransaction" | "adminTransactionArchive" | "userTransaction" | "userTransactionArchive" | "multiplayerRoom" | "multiPlayerMember"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Province: {
        payload: Prisma.$ProvincePayload<ExtArgs>
        fields: Prisma.ProvinceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findFirst: {
            args: Prisma.ProvinceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findMany: {
            args: Prisma.ProvinceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          create: {
            args: Prisma.ProvinceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          createMany: {
            args: Prisma.ProvinceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvinceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          delete: {
            args: Prisma.ProvinceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          update: {
            args: Prisma.ProvinceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          deleteMany: {
            args: Prisma.ProvinceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvinceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          upsert: {
            args: Prisma.ProvinceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          aggregate: {
            args: Prisma.ProvinceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvince>
          }
          groupBy: {
            args: Prisma.ProvinceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinceCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinceCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      AccessContent: {
        payload: Prisma.$AccessContentPayload<ExtArgs>
        fields: Prisma.AccessContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>
          }
          findFirst: {
            args: Prisma.AccessContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>
          }
          findMany: {
            args: Prisma.AccessContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>[]
          }
          create: {
            args: Prisma.AccessContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>
          }
          createMany: {
            args: Prisma.AccessContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>[]
          }
          delete: {
            args: Prisma.AccessContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>
          }
          update: {
            args: Prisma.AccessContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>
          }
          deleteMany: {
            args: Prisma.AccessContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>[]
          }
          upsert: {
            args: Prisma.AccessContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessContentPayload>
          }
          aggregate: {
            args: Prisma.AccessContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessContent>
          }
          groupBy: {
            args: Prisma.AccessContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessContentCountArgs<ExtArgs>
            result: $Utils.Optional<AccessContentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      SubLevel: {
        payload: Prisma.$SubLevelPayload<ExtArgs>
        fields: Prisma.SubLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          findFirst: {
            args: Prisma.SubLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          findMany: {
            args: Prisma.SubLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          create: {
            args: Prisma.SubLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          createMany: {
            args: Prisma.SubLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          delete: {
            args: Prisma.SubLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          update: {
            args: Prisma.SubLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          deleteMany: {
            args: Prisma.SubLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          upsert: {
            args: Prisma.SubLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          aggregate: {
            args: Prisma.SubLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubLevel>
          }
          groupBy: {
            args: Prisma.SubLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubLevelCountArgs<ExtArgs>
            result: $Utils.Optional<SubLevelCountAggregateOutputType> | number
          }
        }
      }
      InnerLevel: {
        payload: Prisma.$InnerLevelPayload<ExtArgs>
        fields: Prisma.InnerLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InnerLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InnerLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          findFirst: {
            args: Prisma.InnerLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InnerLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          findMany: {
            args: Prisma.InnerLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          create: {
            args: Prisma.InnerLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          createMany: {
            args: Prisma.InnerLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InnerLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          delete: {
            args: Prisma.InnerLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          update: {
            args: Prisma.InnerLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          deleteMany: {
            args: Prisma.InnerLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InnerLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InnerLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          upsert: {
            args: Prisma.InnerLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          aggregate: {
            args: Prisma.InnerLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInnerLevel>
          }
          groupBy: {
            args: Prisma.InnerLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<InnerLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.InnerLevelCountArgs<ExtArgs>
            result: $Utils.Optional<InnerLevelCountAggregateOutputType> | number
          }
        }
      }
      Gempo: {
        payload: Prisma.$GempoPayload<ExtArgs>
        fields: Prisma.GempoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GempoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GempoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          findFirst: {
            args: Prisma.GempoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GempoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          findMany: {
            args: Prisma.GempoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          create: {
            args: Prisma.GempoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          createMany: {
            args: Prisma.GempoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GempoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          delete: {
            args: Prisma.GempoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          update: {
            args: Prisma.GempoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          deleteMany: {
            args: Prisma.GempoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GempoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GempoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          upsert: {
            args: Prisma.GempoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          aggregate: {
            args: Prisma.GempoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGempo>
          }
          groupBy: {
            args: Prisma.GempoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GempoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GempoCountArgs<ExtArgs>
            result: $Utils.Optional<GempoCountAggregateOutputType> | number
          }
        }
      }
      Championship: {
        payload: Prisma.$ChampionshipPayload<ExtArgs>
        fields: Prisma.ChampionshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          findMany: {
            args: Prisma.ChampionshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          create: {
            args: Prisma.ChampionshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          createMany: {
            args: Prisma.ChampionshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          update: {
            args: Prisma.ChampionshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionship>
          }
          groupBy: {
            args: Prisma.ChampionshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipCountAggregateOutputType> | number
          }
        }
      }
      GempoRecord: {
        payload: Prisma.$GempoRecordPayload<ExtArgs>
        fields: Prisma.GempoRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GempoRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GempoRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          findFirst: {
            args: Prisma.GempoRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GempoRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          findMany: {
            args: Prisma.GempoRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          create: {
            args: Prisma.GempoRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          createMany: {
            args: Prisma.GempoRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GempoRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          delete: {
            args: Prisma.GempoRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          update: {
            args: Prisma.GempoRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          deleteMany: {
            args: Prisma.GempoRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GempoRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GempoRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          upsert: {
            args: Prisma.GempoRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          aggregate: {
            args: Prisma.GempoRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGempoRecord>
          }
          groupBy: {
            args: Prisma.GempoRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<GempoRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.GempoRecordCountArgs<ExtArgs>
            result: $Utils.Optional<GempoRecordCountAggregateOutputType> | number
          }
        }
      }
      ChampionshipRecord: {
        payload: Prisma.$ChampionshipRecordPayload<ExtArgs>
        fields: Prisma.ChampionshipRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          findMany: {
            args: Prisma.ChampionshipRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          create: {
            args: Prisma.ChampionshipRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          createMany: {
            args: Prisma.ChampionshipRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          update: {
            args: Prisma.ChampionshipRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionshipRecord>
          }
          groupBy: {
            args: Prisma.ChampionshipRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipRecordCountAggregateOutputType> | number
          }
        }
      }
      UserLogin: {
        payload: Prisma.$UserLoginPayload<ExtArgs>
        fields: Prisma.UserLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          findFirst: {
            args: Prisma.UserLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          findMany: {
            args: Prisma.UserLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          create: {
            args: Prisma.UserLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          createMany: {
            args: Prisma.UserLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLoginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          delete: {
            args: Prisma.UserLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          update: {
            args: Prisma.UserLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          deleteMany: {
            args: Prisma.UserLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLoginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          upsert: {
            args: Prisma.UserLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          aggregate: {
            args: Prisma.UserLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLogin>
          }
          groupBy: {
            args: Prisma.UserLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLoginCountArgs<ExtArgs>
            result: $Utils.Optional<UserLoginCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminOperationHistory: {
        payload: Prisma.$AdminOperationHistoryPayload<ExtArgs>
        fields: Prisma.AdminOperationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminOperationHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          findFirst: {
            args: Prisma.AdminOperationHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          findMany: {
            args: Prisma.AdminOperationHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          create: {
            args: Prisma.AdminOperationHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          createMany: {
            args: Prisma.AdminOperationHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          delete: {
            args: Prisma.AdminOperationHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          update: {
            args: Prisma.AdminOperationHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AdminOperationHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminOperationHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          upsert: {
            args: Prisma.AdminOperationHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          aggregate: {
            args: Prisma.AdminOperationHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminOperationHistory>
          }
          groupBy: {
            args: Prisma.AdminOperationHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminOperationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminOperationHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AdminOperationHistoryCountAggregateOutputType> | number
          }
        }
      }
      AdminAuthority: {
        payload: Prisma.$AdminAuthorityPayload<ExtArgs>
        fields: Prisma.AdminAuthorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuthorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuthorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          findFirst: {
            args: Prisma.AdminAuthorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuthorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          findMany: {
            args: Prisma.AdminAuthorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          create: {
            args: Prisma.AdminAuthorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          createMany: {
            args: Prisma.AdminAuthorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuthorityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          delete: {
            args: Prisma.AdminAuthorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          update: {
            args: Prisma.AdminAuthorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuthorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuthorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuthorityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuthorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          aggregate: {
            args: Prisma.AdminAuthorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuthority>
          }
          groupBy: {
            args: Prisma.AdminAuthorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuthorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuthorityCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuthorityCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      BannerLocation: {
        payload: Prisma.$BannerLocationPayload<ExtArgs>
        fields: Prisma.BannerLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          findFirst: {
            args: Prisma.BannerLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          findMany: {
            args: Prisma.BannerLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>[]
          }
          create: {
            args: Prisma.BannerLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          createMany: {
            args: Prisma.BannerLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>[]
          }
          delete: {
            args: Prisma.BannerLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          update: {
            args: Prisma.BannerLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          deleteMany: {
            args: Prisma.BannerLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>[]
          }
          upsert: {
            args: Prisma.BannerLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          aggregate: {
            args: Prisma.BannerLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerLocation>
          }
          groupBy: {
            args: Prisma.BannerLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerLocationCountArgs<ExtArgs>
            result: $Utils.Optional<BannerLocationCountAggregateOutputType> | number
          }
        }
      }
      BannerVisitor: {
        payload: Prisma.$BannerVisitorPayload<ExtArgs>
        fields: Prisma.BannerVisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerVisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerVisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          findFirst: {
            args: Prisma.BannerVisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerVisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          findMany: {
            args: Prisma.BannerVisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          create: {
            args: Prisma.BannerVisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          createMany: {
            args: Prisma.BannerVisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerVisitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          delete: {
            args: Prisma.BannerVisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          update: {
            args: Prisma.BannerVisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          deleteMany: {
            args: Prisma.BannerVisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerVisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerVisitorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          upsert: {
            args: Prisma.BannerVisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          aggregate: {
            args: Prisma.BannerVisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerVisitor>
          }
          groupBy: {
            args: Prisma.BannerVisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerVisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerVisitorCountArgs<ExtArgs>
            result: $Utils.Optional<BannerVisitorCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      TestParticipant: {
        payload: Prisma.$TestParticipantPayload<ExtArgs>
        fields: Prisma.TestParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          findFirst: {
            args: Prisma.TestParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          findMany: {
            args: Prisma.TestParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          create: {
            args: Prisma.TestParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          createMany: {
            args: Prisma.TestParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          delete: {
            args: Prisma.TestParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          update: {
            args: Prisma.TestParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TestParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          upsert: {
            args: Prisma.TestParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          aggregate: {
            args: Prisma.TestParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParticipant>
          }
          groupBy: {
            args: Prisma.TestParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantCountAggregateOutputType> | number
          }
        }
      }
      TestParticipantRecord: {
        payload: Prisma.$TestParticipantRecordPayload<ExtArgs>
        fields: Prisma.TestParticipantRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParticipantRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          findFirst: {
            args: Prisma.TestParticipantRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParticipantRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          findMany: {
            args: Prisma.TestParticipantRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          create: {
            args: Prisma.TestParticipantRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          createMany: {
            args: Prisma.TestParticipantRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParticipantRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          delete: {
            args: Prisma.TestParticipantRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          update: {
            args: Prisma.TestParticipantRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          deleteMany: {
            args: Prisma.TestParticipantRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParticipantRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          upsert: {
            args: Prisma.TestParticipantRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          aggregate: {
            args: Prisma.TestParticipantRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParticipantRecord>
          }
          groupBy: {
            args: Prisma.TestParticipantRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParticipantRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantRecordCountAggregateOutputType> | number
          }
        }
      }
      Background: {
        payload: Prisma.$BackgroundPayload<ExtArgs>
        fields: Prisma.BackgroundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackgroundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackgroundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findFirst: {
            args: Prisma.BackgroundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackgroundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findMany: {
            args: Prisma.BackgroundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          create: {
            args: Prisma.BackgroundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          createMany: {
            args: Prisma.BackgroundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackgroundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          delete: {
            args: Prisma.BackgroundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          update: {
            args: Prisma.BackgroundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          deleteMany: {
            args: Prisma.BackgroundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackgroundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BackgroundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          upsert: {
            args: Prisma.BackgroundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          aggregate: {
            args: Prisma.BackgroundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackground>
          }
          groupBy: {
            args: Prisma.BackgroundGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackgroundGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackgroundCountArgs<ExtArgs>
            result: $Utils.Optional<BackgroundCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherRedemeer: {
        payload: Prisma.$VoucherRedemeerPayload<ExtArgs>
        fields: Prisma.VoucherRedemeerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherRedemeerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherRedemeerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>
          }
          findFirst: {
            args: Prisma.VoucherRedemeerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherRedemeerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>
          }
          findMany: {
            args: Prisma.VoucherRedemeerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>[]
          }
          create: {
            args: Prisma.VoucherRedemeerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>
          }
          createMany: {
            args: Prisma.VoucherRedemeerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherRedemeerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>[]
          }
          delete: {
            args: Prisma.VoucherRedemeerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>
          }
          update: {
            args: Prisma.VoucherRedemeerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>
          }
          deleteMany: {
            args: Prisma.VoucherRedemeerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherRedemeerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherRedemeerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>[]
          }
          upsert: {
            args: Prisma.VoucherRedemeerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherRedemeerPayload>
          }
          aggregate: {
            args: Prisma.VoucherRedemeerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherRedemeer>
          }
          groupBy: {
            args: Prisma.VoucherRedemeerGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherRedemeerGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherRedemeerCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherRedemeerCountAggregateOutputType> | number
          }
        }
      }
      AdminTransaction: {
        payload: Prisma.$AdminTransactionPayload<ExtArgs>
        fields: Prisma.AdminTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          findFirst: {
            args: Prisma.AdminTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          findMany: {
            args: Prisma.AdminTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          create: {
            args: Prisma.AdminTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          createMany: {
            args: Prisma.AdminTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          delete: {
            args: Prisma.AdminTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          update: {
            args: Prisma.AdminTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          deleteMany: {
            args: Prisma.AdminTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          upsert: {
            args: Prisma.AdminTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          aggregate: {
            args: Prisma.AdminTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminTransaction>
          }
          groupBy: {
            args: Prisma.AdminTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionCountAggregateOutputType> | number
          }
        }
      }
      AdminTransactionArchive: {
        payload: Prisma.$AdminTransactionArchivePayload<ExtArgs>
        fields: Prisma.AdminTransactionArchiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminTransactionArchiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminTransactionArchiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>
          }
          findFirst: {
            args: Prisma.AdminTransactionArchiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminTransactionArchiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>
          }
          findMany: {
            args: Prisma.AdminTransactionArchiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>[]
          }
          create: {
            args: Prisma.AdminTransactionArchiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>
          }
          createMany: {
            args: Prisma.AdminTransactionArchiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminTransactionArchiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>[]
          }
          delete: {
            args: Prisma.AdminTransactionArchiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>
          }
          update: {
            args: Prisma.AdminTransactionArchiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>
          }
          deleteMany: {
            args: Prisma.AdminTransactionArchiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminTransactionArchiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminTransactionArchiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>[]
          }
          upsert: {
            args: Prisma.AdminTransactionArchiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionArchivePayload>
          }
          aggregate: {
            args: Prisma.AdminTransactionArchiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminTransactionArchive>
          }
          groupBy: {
            args: Prisma.AdminTransactionArchiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionArchiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminTransactionArchiveCountArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionArchiveCountAggregateOutputType> | number
          }
        }
      }
      UserTransaction: {
        payload: Prisma.$UserTransactionPayload<ExtArgs>
        fields: Prisma.UserTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>
          }
          findFirst: {
            args: Prisma.UserTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>
          }
          findMany: {
            args: Prisma.UserTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>[]
          }
          create: {
            args: Prisma.UserTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>
          }
          createMany: {
            args: Prisma.UserTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>[]
          }
          delete: {
            args: Prisma.UserTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>
          }
          update: {
            args: Prisma.UserTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>
          }
          deleteMany: {
            args: Prisma.UserTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>[]
          }
          upsert: {
            args: Prisma.UserTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionPayload>
          }
          aggregate: {
            args: Prisma.UserTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTransaction>
          }
          groupBy: {
            args: Prisma.UserTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<UserTransactionCountAggregateOutputType> | number
          }
        }
      }
      UserTransactionArchive: {
        payload: Prisma.$UserTransactionArchivePayload<ExtArgs>
        fields: Prisma.UserTransactionArchiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTransactionArchiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTransactionArchiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>
          }
          findFirst: {
            args: Prisma.UserTransactionArchiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTransactionArchiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>
          }
          findMany: {
            args: Prisma.UserTransactionArchiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>[]
          }
          create: {
            args: Prisma.UserTransactionArchiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>
          }
          createMany: {
            args: Prisma.UserTransactionArchiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTransactionArchiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>[]
          }
          delete: {
            args: Prisma.UserTransactionArchiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>
          }
          update: {
            args: Prisma.UserTransactionArchiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>
          }
          deleteMany: {
            args: Prisma.UserTransactionArchiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTransactionArchiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTransactionArchiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>[]
          }
          upsert: {
            args: Prisma.UserTransactionArchiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTransactionArchivePayload>
          }
          aggregate: {
            args: Prisma.UserTransactionArchiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTransactionArchive>
          }
          groupBy: {
            args: Prisma.UserTransactionArchiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTransactionArchiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTransactionArchiveCountArgs<ExtArgs>
            result: $Utils.Optional<UserTransactionArchiveCountAggregateOutputType> | number
          }
        }
      }
      MultiplayerRoom: {
        payload: Prisma.$MultiplayerRoomPayload<ExtArgs>
        fields: Prisma.MultiplayerRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiplayerRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiplayerRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          findFirst: {
            args: Prisma.MultiplayerRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiplayerRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          findMany: {
            args: Prisma.MultiplayerRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>[]
          }
          create: {
            args: Prisma.MultiplayerRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          createMany: {
            args: Prisma.MultiplayerRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultiplayerRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>[]
          }
          delete: {
            args: Prisma.MultiplayerRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          update: {
            args: Prisma.MultiplayerRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          deleteMany: {
            args: Prisma.MultiplayerRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultiplayerRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultiplayerRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>[]
          }
          upsert: {
            args: Prisma.MultiplayerRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          aggregate: {
            args: Prisma.MultiplayerRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultiplayerRoom>
          }
          groupBy: {
            args: Prisma.MultiplayerRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultiplayerRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiplayerRoomCountArgs<ExtArgs>
            result: $Utils.Optional<MultiplayerRoomCountAggregateOutputType> | number
          }
        }
      }
      MultiPlayerMember: {
        payload: Prisma.$MultiPlayerMemberPayload<ExtArgs>
        fields: Prisma.MultiPlayerMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiPlayerMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiPlayerMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          findFirst: {
            args: Prisma.MultiPlayerMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiPlayerMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          findMany: {
            args: Prisma.MultiPlayerMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>[]
          }
          create: {
            args: Prisma.MultiPlayerMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          createMany: {
            args: Prisma.MultiPlayerMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultiPlayerMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>[]
          }
          delete: {
            args: Prisma.MultiPlayerMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          update: {
            args: Prisma.MultiPlayerMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          deleteMany: {
            args: Prisma.MultiPlayerMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultiPlayerMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultiPlayerMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>[]
          }
          upsert: {
            args: Prisma.MultiPlayerMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          aggregate: {
            args: Prisma.MultiPlayerMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultiPlayerMember>
          }
          groupBy: {
            args: Prisma.MultiPlayerMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultiPlayerMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiPlayerMemberCountArgs<ExtArgs>
            result: $Utils.Optional<MultiPlayerMemberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    province?: ProvinceOmit
    city?: CityOmit
    school?: SchoolOmit
    accessContent?: AccessContentOmit
    user?: UserOmit
    device?: DeviceOmit
    zone?: ZoneOmit
    level?: LevelOmit
    subLevel?: SubLevelOmit
    innerLevel?: InnerLevelOmit
    gempo?: GempoOmit
    championship?: ChampionshipOmit
    gempoRecord?: GempoRecordOmit
    championshipRecord?: ChampionshipRecordOmit
    userLogin?: UserLoginOmit
    admin?: AdminOmit
    adminOperationHistory?: AdminOperationHistoryOmit
    adminAuthority?: AdminAuthorityOmit
    banner?: BannerOmit
    bannerLocation?: BannerLocationOmit
    bannerVisitor?: BannerVisitorOmit
    test?: TestOmit
    testParticipant?: TestParticipantOmit
    testParticipantRecord?: TestParticipantRecordOmit
    background?: BackgroundOmit
    setting?: SettingOmit
    voucher?: VoucherOmit
    voucherRedemeer?: VoucherRedemeerOmit
    adminTransaction?: AdminTransactionOmit
    adminTransactionArchive?: AdminTransactionArchiveOmit
    userTransaction?: UserTransactionOmit
    userTransactionArchive?: UserTransactionArchiveOmit
    multiplayerRoom?: MultiplayerRoomOmit
    multiPlayerMember?: MultiPlayerMemberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProvinceCountOutputType
   */

  export type ProvinceCountOutputType = {
    cities: number
    schools: number
    users: number
    adminAuthority: number
    bannerLocation: number
  }

  export type ProvinceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | ProvinceCountOutputTypeCountCitiesArgs
    schools?: boolean | ProvinceCountOutputTypeCountSchoolsArgs
    users?: boolean | ProvinceCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | ProvinceCountOutputTypeCountAdminAuthorityArgs
    bannerLocation?: boolean | ProvinceCountOutputTypeCountBannerLocationArgs
  }

  // Custom InputTypes
  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinceCountOutputType
     */
    select?: ProvinceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountBannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    schools: number
    users: number
    adminAuthority: number
    bannerLocation: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | CityCountOutputTypeCountSchoolsArgs
    users?: boolean | CityCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | CityCountOutputTypeCountAdminAuthorityArgs
    bannerLocation?: boolean | CityCountOutputTypeCountBannerLocationArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountBannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    adminAuthority: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | SchoolCountOutputTypeCountAdminAuthorityArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }


  /**
   * Count Type AccessContentCountOutputType
   */

  export type AccessContentCountOutputType = {
    userAccesses: number
    redemeers: number
  }

  export type AccessContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAccesses?: boolean | AccessContentCountOutputTypeCountUserAccessesArgs
    redemeers?: boolean | AccessContentCountOutputTypeCountRedemeersArgs
  }

  // Custom InputTypes
  /**
   * AccessContentCountOutputType without action
   */
  export type AccessContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContentCountOutputType
     */
    select?: AccessContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccessContentCountOutputType without action
   */
  export type AccessContentCountOutputTypeCountUserAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * AccessContentCountOutputType without action
   */
  export type AccessContentCountOutputTypeCountRedemeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedAccesses: number
    userAccesses: number
    zones: number
    redeemedAccesses: number
    UserLogin: number
    bannerVisitor: number
    testParticipant: number
    voucherRedemeer: number
    userTransactionArchive: number
    userTransaction: number
    multiPlayerMember: number
    testRecords: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedAccesses?: boolean | UserCountOutputTypeCountOwnedAccessesArgs
    userAccesses?: boolean | UserCountOutputTypeCountUserAccessesArgs
    zones?: boolean | UserCountOutputTypeCountZonesArgs
    redeemedAccesses?: boolean | UserCountOutputTypeCountRedeemedAccessesArgs
    UserLogin?: boolean | UserCountOutputTypeCountUserLoginArgs
    bannerVisitor?: boolean | UserCountOutputTypeCountBannerVisitorArgs
    testParticipant?: boolean | UserCountOutputTypeCountTestParticipantArgs
    voucherRedemeer?: boolean | UserCountOutputTypeCountVoucherRedemeerArgs
    userTransactionArchive?: boolean | UserCountOutputTypeCountUserTransactionArchiveArgs
    userTransaction?: boolean | UserCountOutputTypeCountUserTransactionArgs
    multiPlayerMember?: boolean | UserCountOutputTypeCountMultiPlayerMemberArgs
    testRecords?: boolean | UserCountOutputTypeCountTestRecordsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRedeemedAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBannerVisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoucherRedemeerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherRedemeerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserTransactionArchiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTransactionArchiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMultiPlayerMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiPlayerMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    levels: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    levels?: boolean | ZoneCountOutputTypeCountLevelsArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }


  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    subLevels: number
  }

  export type LevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subLevels?: boolean | LevelCountOutputTypeCountSubLevelsArgs
  }

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountSubLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubLevelWhereInput
  }


  /**
   * Count Type SubLevelCountOutputType
   */

  export type SubLevelCountOutputType = {
    innerLevels: number
  }

  export type SubLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    innerLevels?: boolean | SubLevelCountOutputTypeCountInnerLevelsArgs
  }

  // Custom InputTypes
  /**
   * SubLevelCountOutputType without action
   */
  export type SubLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevelCountOutputType
     */
    select?: SubLevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubLevelCountOutputType without action
   */
  export type SubLevelCountOutputTypeCountInnerLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InnerLevelWhereInput
  }


  /**
   * Count Type GempoCountOutputType
   */

  export type GempoCountOutputType = {
    records: number
  }

  export type GempoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | GempoCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * GempoCountOutputType without action
   */
  export type GempoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoCountOutputType
     */
    select?: GempoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GempoCountOutputType without action
   */
  export type GempoCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoRecordWhereInput
  }


  /**
   * Count Type ChampionshipCountOutputType
   */

  export type ChampionshipCountOutputType = {
    records: number
  }

  export type ChampionshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | ChampionshipCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * ChampionshipCountOutputType without action
   */
  export type ChampionshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipCountOutputType
     */
    select?: ChampionshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChampionshipCountOutputType without action
   */
  export type ChampionshipCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipRecordWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    authority: number
    operationHistories: number
    operations: number
    banner: number
    adminTransaction: number
    adminTransactionArchive: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authority?: boolean | AdminCountOutputTypeCountAuthorityArgs
    operationHistories?: boolean | AdminCountOutputTypeCountOperationHistoriesArgs
    operations?: boolean | AdminCountOutputTypeCountOperationsArgs
    banner?: boolean | AdminCountOutputTypeCountBannerArgs
    adminTransaction?: boolean | AdminCountOutputTypeCountAdminTransactionArgs
    adminTransactionArchive?: boolean | AdminCountOutputTypeCountAdminTransactionArchiveArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOperationHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdminTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdminTransactionArchiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionArchiveWhereInput
  }


  /**
   * Count Type AdminAuthorityCountOutputType
   */

  export type AdminAuthorityCountOutputType = {
    cities: number
    schools: number
  }

  export type AdminAuthorityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | AdminAuthorityCountOutputTypeCountCitiesArgs
    schools?: boolean | AdminAuthorityCountOutputTypeCountSchoolsArgs
  }

  // Custom InputTypes
  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthorityCountOutputType
     */
    select?: AdminAuthorityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }


  /**
   * Count Type BannerCountOutputType
   */

  export type BannerCountOutputType = {
    visitors: number
    bannerLocation: number
  }

  export type BannerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | BannerCountOutputTypeCountVisitorsArgs
    bannerLocation?: boolean | BannerCountOutputTypeCountBannerLocationArgs
  }

  // Custom InputTypes
  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerCountOutputType
     */
    select?: BannerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountBannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
  }


  /**
   * Count Type BannerLocationCountOutputType
   */

  export type BannerLocationCountOutputType = {
    cities: number
  }

  export type BannerLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | BannerLocationCountOutputTypeCountCitiesArgs
  }

  // Custom InputTypes
  /**
   * BannerLocationCountOutputType without action
   */
  export type BannerLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocationCountOutputType
     */
    select?: BannerLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BannerLocationCountOutputType without action
   */
  export type BannerLocationCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }


  /**
   * Count Type TestCountOutputType
   */

  export type TestCountOutputType = {
    participants: number
  }

  export type TestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | TestCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCountOutputType
     */
    select?: TestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
  }


  /**
   * Count Type TestParticipantCountOutputType
   */

  export type TestParticipantCountOutputType = {
    records: number
  }

  export type TestParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | TestParticipantCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * TestParticipantCountOutputType without action
   */
  export type TestParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantCountOutputType
     */
    select?: TestParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestParticipantCountOutputType without action
   */
  export type TestParticipantCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    redemeers: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemeers?: boolean | VoucherCountOutputTypeCountRedemeersArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountRedemeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherRedemeerWhereInput
  }


  /**
   * Count Type MultiplayerRoomCountOutputType
   */

  export type MultiplayerRoomCountOutputType = {
    members: number
  }

  export type MultiplayerRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MultiplayerRoomCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * MultiplayerRoomCountOutputType without action
   */
  export type MultiplayerRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoomCountOutputType
     */
    select?: MultiplayerRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultiplayerRoomCountOutputType without action
   */
  export type MultiplayerRoomCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiPlayerMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Province
   */

  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type ProvinceSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type ProvinceMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvinceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvinceCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProvinceAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type ProvinceSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type ProvinceMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvinceMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvinceCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProvinceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Province to aggregate.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }




  export type ProvinceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinceWhereInput
    orderBy?: ProvinceOrderByWithAggregationInput | ProvinceOrderByWithAggregationInput[]
    by: ProvinceScalarFieldEnum[] | ProvinceScalarFieldEnum
    having?: ProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _avg?: ProvinceAvgAggregateInputType
    _sum?: ProvinceSumAggregateInputType
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }

  export type ProvinceGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt: Date
    updatedAt: Date
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends ProvinceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      >
    >


  export type ProvinceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cities?: boolean | Province$citiesArgs<ExtArgs>
    schools?: boolean | Province$schoolsArgs<ExtArgs>
    users?: boolean | Province$usersArgs<ExtArgs>
    adminAuthority?: boolean | Province$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | Province$bannerLocationArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProvinceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "createdAt" | "updatedAt", ExtArgs["result"]["province"]>
  export type ProvinceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Province$citiesArgs<ExtArgs>
    schools?: boolean | Province$schoolsArgs<ExtArgs>
    users?: boolean | Province$usersArgs<ExtArgs>
    adminAuthority?: boolean | Province$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | Province$bannerLocationArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvinceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProvinceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProvincePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Province"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      bannerLocation: Prisma.$BannerLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["province"]>
    composites: {}
  }

  type ProvinceGetPayload<S extends boolean | null | undefined | ProvinceDefaultArgs> = $Result.GetResult<Prisma.$ProvincePayload, S>

  type ProvinceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvinceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvinceCountAggregateInputType | true
    }

  export interface ProvinceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Province'], meta: { name: 'Province' } }
    /**
     * Find zero or one Province that matches the filter.
     * @param {ProvinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvinceFindUniqueArgs>(args: SelectSubset<T, ProvinceFindUniqueArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Province that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvinceFindUniqueOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvinceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvinceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvinceFindFirstArgs>(args?: SelectSubset<T, ProvinceFindFirstArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Province that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvinceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvinceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinceWithIdOnly = await prisma.province.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProvinceFindManyArgs>(args?: SelectSubset<T, ProvinceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Province.
     * @param {ProvinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
     */
    create<T extends ProvinceCreateArgs>(args: SelectSubset<T, ProvinceCreateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provinces.
     * @param {ProvinceCreateManyArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvinceCreateManyArgs>(args?: SelectSubset<T, ProvinceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provinces and returns the data saved in the database.
     * @param {ProvinceCreateManyAndReturnArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvinceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvinceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Province.
     * @param {ProvinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
     */
    delete<T extends ProvinceDeleteArgs>(args: SelectSubset<T, ProvinceDeleteArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Province.
     * @param {ProvinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvinceUpdateArgs>(args: SelectSubset<T, ProvinceUpdateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provinces.
     * @param {ProvinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvinceDeleteManyArgs>(args?: SelectSubset<T, ProvinceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvinceUpdateManyArgs>(args: SelectSubset<T, ProvinceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces and returns the data updated in the database.
     * @param {ProvinceUpdateManyAndReturnArgs} args - Arguments to update many Provinces.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvinceUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvinceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Province.
     * @param {ProvinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
     */
    upsert<T extends ProvinceUpsertArgs>(args: SelectSubset<T, ProvinceUpsertArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends ProvinceCountArgs>(
      args?: Subset<T, ProvinceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): Prisma.PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinceGroupByArgs['orderBy'] }
        : { orderBy?: ProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Province model
   */
  readonly fields: ProvinceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Province$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Province$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends Province$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Province$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Province$usersArgs<ExtArgs> = {}>(args?: Subset<T, Province$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends Province$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, Province$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bannerLocation<T extends Province$bannerLocationArgs<ExtArgs> = {}>(args?: Subset<T, Province$bannerLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Province model
   */
  interface ProvinceFieldRefs {
    readonly id: FieldRef<"Province", 'String'>
    readonly name: FieldRef<"Province", 'String'>
    readonly longitude: FieldRef<"Province", 'Float'>
    readonly latitude: FieldRef<"Province", 'Float'>
    readonly geoId: FieldRef<"Province", 'String'>
    readonly createdAt: FieldRef<"Province", 'DateTime'>
    readonly updatedAt: FieldRef<"Province", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Province findUnique
   */
  export type ProvinceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findUniqueOrThrow
   */
  export type ProvinceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findFirst
   */
  export type ProvinceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findFirstOrThrow
   */
  export type ProvinceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findMany
   */
  export type ProvinceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Provinces to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province create
   */
  export type ProvinceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to create a Province.
     */
    data: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
  }

  /**
   * Province createMany
   */
  export type ProvinceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province createManyAndReturn
   */
  export type ProvinceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province update
   */
  export type ProvinceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to update a Province.
     */
    data: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
    /**
     * Choose, which Province to update.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province updateMany
   */
  export type ProvinceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province updateManyAndReturn
   */
  export type ProvinceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province upsert
   */
  export type ProvinceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The filter to search for the Province to update in case it exists.
     */
    where: ProvinceWhereUniqueInput
    /**
     * In case the Province found by the `where` argument doesn't exist, create a new Province with this data.
     */
    create: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
    /**
     * In case the Province was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
  }

  /**
   * Province delete
   */
  export type ProvinceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter which Province to delete.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province deleteMany
   */
  export type ProvinceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provinces to delete
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to delete.
     */
    limit?: number
  }

  /**
   * Province.cities
   */
  export type Province$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Province.schools
   */
  export type Province$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * Province.users
   */
  export type Province$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Province.adminAuthority
   */
  export type Province$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Province.bannerLocation
   */
  export type Province$bannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    cursor?: BannerLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * Province without action
   */
  export type ProvinceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type CitySumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    provinceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type CitySumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    schools?: boolean | City$schoolsArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    adminAuthority?: boolean | City$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | City$bannerLocationArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "provinceId" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    schools?: boolean | City$schoolsArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    adminAuthority?: boolean | City$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | City$bannerLocationArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      province: Prisma.$ProvincePayload<ExtArgs>
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      bannerLocation: Prisma.$BannerLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      provinceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schools<T extends City$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, City$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends City$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, City$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bannerLocation<T extends City$bannerLocationArgs<ExtArgs> = {}>(args?: Subset<T, City$bannerLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly longitude: FieldRef<"City", 'Float'>
    readonly latitude: FieldRef<"City", 'Float'>
    readonly geoId: FieldRef<"City", 'String'>
    readonly provinceId: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.schools
   */
  export type City$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * City.adminAuthority
   */
  export type City$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * City.bannerLocation
   */
  export type City$bannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    cursor?: BannerLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SchoolSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    identity: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    cityId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    identity: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    cityId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    identity: number
    name: number
    longitude: number
    latitude: number
    cityId: number
    provinceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SchoolSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    identity?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    identity?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    identity?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    adminAuthority?: boolean | School$adminAuthorityArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identity" | "name" | "longitude" | "latitude" | "cityId" | "provinceId" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    adminAuthority?: boolean | School$adminAuthorityArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identity: string
      name: string
      longitude: number
      latitude: number
      cityId: string
      provinceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends School$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, School$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly identity: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly longitude: FieldRef<"School", 'Float'>
    readonly latitude: FieldRef<"School", 'Float'>
    readonly cityId: FieldRef<"School", 'String'>
    readonly provinceId: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.adminAuthority
   */
  export type School$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model AccessContent
   */

  export type AggregateAccessContent = {
    _count: AccessContentCountAggregateOutputType | null
    _avg: AccessContentAvgAggregateOutputType | null
    _sum: AccessContentSumAggregateOutputType | null
    _min: AccessContentMinAggregateOutputType | null
    _max: AccessContentMaxAggregateOutputType | null
  }

  export type AccessContentAvgAggregateOutputType = {
    quota: number | null
    currentQuota: number | null
  }

  export type AccessContentSumAggregateOutputType = {
    quota: number | null
    currentQuota: number | null
  }

  export type AccessContentMinAggregateOutputType = {
    id: string | null
    expired: Date | null
    quota: number | null
    currentQuota: number | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessContentMaxAggregateOutputType = {
    id: string | null
    expired: Date | null
    quota: number | null
    currentQuota: number | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccessContentCountAggregateOutputType = {
    id: number
    expired: number
    quota: number
    currentQuota: number
    ownerId: number
    zones: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccessContentAvgAggregateInputType = {
    quota?: true
    currentQuota?: true
  }

  export type AccessContentSumAggregateInputType = {
    quota?: true
    currentQuota?: true
  }

  export type AccessContentMinAggregateInputType = {
    id?: true
    expired?: true
    quota?: true
    currentQuota?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessContentMaxAggregateInputType = {
    id?: true
    expired?: true
    quota?: true
    currentQuota?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccessContentCountAggregateInputType = {
    id?: true
    expired?: true
    quota?: true
    currentQuota?: true
    ownerId?: true
    zones?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccessContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessContent to aggregate.
     */
    where?: AccessContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessContents to fetch.
     */
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessContents
    **/
    _count?: true | AccessContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessContentMaxAggregateInputType
  }

  export type GetAccessContentAggregateType<T extends AccessContentAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessContent[P]>
      : GetScalarType<T[P], AggregateAccessContent[P]>
  }




  export type AccessContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessContentWhereInput
    orderBy?: AccessContentOrderByWithAggregationInput | AccessContentOrderByWithAggregationInput[]
    by: AccessContentScalarFieldEnum[] | AccessContentScalarFieldEnum
    having?: AccessContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessContentCountAggregateInputType | true
    _avg?: AccessContentAvgAggregateInputType
    _sum?: AccessContentSumAggregateInputType
    _min?: AccessContentMinAggregateInputType
    _max?: AccessContentMaxAggregateInputType
  }

  export type AccessContentGroupByOutputType = {
    id: string
    expired: Date
    quota: number
    currentQuota: number
    ownerId: string | null
    zones: string[]
    createdAt: Date
    updatedAt: Date
    _count: AccessContentCountAggregateOutputType | null
    _avg: AccessContentAvgAggregateOutputType | null
    _sum: AccessContentSumAggregateOutputType | null
    _min: AccessContentMinAggregateOutputType | null
    _max: AccessContentMaxAggregateOutputType | null
  }

  type GetAccessContentGroupByPayload<T extends AccessContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessContentGroupByOutputType[P]>
            : GetScalarType<T[P], AccessContentGroupByOutputType[P]>
        }
      >
    >


  export type AccessContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expired?: boolean
    quota?: boolean
    currentQuota?: boolean
    ownerId?: boolean
    zones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | AccessContent$ownerArgs<ExtArgs>
    userAccesses?: boolean | AccessContent$userAccessesArgs<ExtArgs>
    redemeers?: boolean | AccessContent$redemeersArgs<ExtArgs>
    _count?: boolean | AccessContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessContent"]>

  export type AccessContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expired?: boolean
    quota?: boolean
    currentQuota?: boolean
    ownerId?: boolean
    zones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | AccessContent$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["accessContent"]>

  export type AccessContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expired?: boolean
    quota?: boolean
    currentQuota?: boolean
    ownerId?: boolean
    zones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | AccessContent$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["accessContent"]>

  export type AccessContentSelectScalar = {
    id?: boolean
    expired?: boolean
    quota?: boolean
    currentQuota?: boolean
    ownerId?: boolean
    zones?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccessContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expired" | "quota" | "currentQuota" | "ownerId" | "zones" | "createdAt" | "updatedAt", ExtArgs["result"]["accessContent"]>
  export type AccessContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | AccessContent$ownerArgs<ExtArgs>
    userAccesses?: boolean | AccessContent$userAccessesArgs<ExtArgs>
    redemeers?: boolean | AccessContent$redemeersArgs<ExtArgs>
    _count?: boolean | AccessContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccessContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | AccessContent$ownerArgs<ExtArgs>
  }
  export type AccessContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | AccessContent$ownerArgs<ExtArgs>
  }

  export type $AccessContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessContent"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      userAccesses: Prisma.$UserPayload<ExtArgs>[]
      redemeers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expired: Date
      quota: number
      currentQuota: number
      ownerId: string | null
      zones: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accessContent"]>
    composites: {}
  }

  type AccessContentGetPayload<S extends boolean | null | undefined | AccessContentDefaultArgs> = $Result.GetResult<Prisma.$AccessContentPayload, S>

  type AccessContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessContentCountAggregateInputType | true
    }

  export interface AccessContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessContent'], meta: { name: 'AccessContent' } }
    /**
     * Find zero or one AccessContent that matches the filter.
     * @param {AccessContentFindUniqueArgs} args - Arguments to find a AccessContent
     * @example
     * // Get one AccessContent
     * const accessContent = await prisma.accessContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessContentFindUniqueArgs>(args: SelectSubset<T, AccessContentFindUniqueArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessContentFindUniqueOrThrowArgs} args - Arguments to find a AccessContent
     * @example
     * // Get one AccessContent
     * const accessContent = await prisma.accessContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessContentFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentFindFirstArgs} args - Arguments to find a AccessContent
     * @example
     * // Get one AccessContent
     * const accessContent = await prisma.accessContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessContentFindFirstArgs>(args?: SelectSubset<T, AccessContentFindFirstArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentFindFirstOrThrowArgs} args - Arguments to find a AccessContent
     * @example
     * // Get one AccessContent
     * const accessContent = await prisma.accessContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessContentFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessContents
     * const accessContents = await prisma.accessContent.findMany()
     * 
     * // Get first 10 AccessContents
     * const accessContents = await prisma.accessContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessContentWithIdOnly = await prisma.accessContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessContentFindManyArgs>(args?: SelectSubset<T, AccessContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessContent.
     * @param {AccessContentCreateArgs} args - Arguments to create a AccessContent.
     * @example
     * // Create one AccessContent
     * const AccessContent = await prisma.accessContent.create({
     *   data: {
     *     // ... data to create a AccessContent
     *   }
     * })
     * 
     */
    create<T extends AccessContentCreateArgs>(args: SelectSubset<T, AccessContentCreateArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessContents.
     * @param {AccessContentCreateManyArgs} args - Arguments to create many AccessContents.
     * @example
     * // Create many AccessContents
     * const accessContent = await prisma.accessContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessContentCreateManyArgs>(args?: SelectSubset<T, AccessContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessContents and returns the data saved in the database.
     * @param {AccessContentCreateManyAndReturnArgs} args - Arguments to create many AccessContents.
     * @example
     * // Create many AccessContents
     * const accessContent = await prisma.accessContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessContents and only return the `id`
     * const accessContentWithIdOnly = await prisma.accessContent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessContentCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessContent.
     * @param {AccessContentDeleteArgs} args - Arguments to delete one AccessContent.
     * @example
     * // Delete one AccessContent
     * const AccessContent = await prisma.accessContent.delete({
     *   where: {
     *     // ... filter to delete one AccessContent
     *   }
     * })
     * 
     */
    delete<T extends AccessContentDeleteArgs>(args: SelectSubset<T, AccessContentDeleteArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessContent.
     * @param {AccessContentUpdateArgs} args - Arguments to update one AccessContent.
     * @example
     * // Update one AccessContent
     * const accessContent = await prisma.accessContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessContentUpdateArgs>(args: SelectSubset<T, AccessContentUpdateArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessContents.
     * @param {AccessContentDeleteManyArgs} args - Arguments to filter AccessContents to delete.
     * @example
     * // Delete a few AccessContents
     * const { count } = await prisma.accessContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessContentDeleteManyArgs>(args?: SelectSubset<T, AccessContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessContents
     * const accessContent = await prisma.accessContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessContentUpdateManyArgs>(args: SelectSubset<T, AccessContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessContents and returns the data updated in the database.
     * @param {AccessContentUpdateManyAndReturnArgs} args - Arguments to update many AccessContents.
     * @example
     * // Update many AccessContents
     * const accessContent = await prisma.accessContent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessContents and only return the `id`
     * const accessContentWithIdOnly = await prisma.accessContent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessContentUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessContent.
     * @param {AccessContentUpsertArgs} args - Arguments to update or create a AccessContent.
     * @example
     * // Update or create a AccessContent
     * const accessContent = await prisma.accessContent.upsert({
     *   create: {
     *     // ... data to create a AccessContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessContent we want to update
     *   }
     * })
     */
    upsert<T extends AccessContentUpsertArgs>(args: SelectSubset<T, AccessContentUpsertArgs<ExtArgs>>): Prisma__AccessContentClient<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentCountArgs} args - Arguments to filter AccessContents to count.
     * @example
     * // Count the number of AccessContents
     * const count = await prisma.accessContent.count({
     *   where: {
     *     // ... the filter for the AccessContents we want to count
     *   }
     * })
    **/
    count<T extends AccessContentCountArgs>(
      args?: Subset<T, AccessContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessContentAggregateArgs>(args: Subset<T, AccessContentAggregateArgs>): Prisma.PrismaPromise<GetAccessContentAggregateType<T>>

    /**
     * Group by AccessContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessContentGroupByArgs['orderBy'] }
        : { orderBy?: AccessContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessContent model
   */
  readonly fields: AccessContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends AccessContent$ownerArgs<ExtArgs> = {}>(args?: Subset<T, AccessContent$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userAccesses<T extends AccessContent$userAccessesArgs<ExtArgs> = {}>(args?: Subset<T, AccessContent$userAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redemeers<T extends AccessContent$redemeersArgs<ExtArgs> = {}>(args?: Subset<T, AccessContent$redemeersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessContent model
   */
  interface AccessContentFieldRefs {
    readonly id: FieldRef<"AccessContent", 'String'>
    readonly expired: FieldRef<"AccessContent", 'DateTime'>
    readonly quota: FieldRef<"AccessContent", 'Int'>
    readonly currentQuota: FieldRef<"AccessContent", 'Int'>
    readonly ownerId: FieldRef<"AccessContent", 'String'>
    readonly zones: FieldRef<"AccessContent", 'String[]'>
    readonly createdAt: FieldRef<"AccessContent", 'DateTime'>
    readonly updatedAt: FieldRef<"AccessContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessContent findUnique
   */
  export type AccessContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * Filter, which AccessContent to fetch.
     */
    where: AccessContentWhereUniqueInput
  }

  /**
   * AccessContent findUniqueOrThrow
   */
  export type AccessContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * Filter, which AccessContent to fetch.
     */
    where: AccessContentWhereUniqueInput
  }

  /**
   * AccessContent findFirst
   */
  export type AccessContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * Filter, which AccessContent to fetch.
     */
    where?: AccessContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessContents to fetch.
     */
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessContents.
     */
    cursor?: AccessContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessContents.
     */
    distinct?: AccessContentScalarFieldEnum | AccessContentScalarFieldEnum[]
  }

  /**
   * AccessContent findFirstOrThrow
   */
  export type AccessContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * Filter, which AccessContent to fetch.
     */
    where?: AccessContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessContents to fetch.
     */
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessContents.
     */
    cursor?: AccessContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessContents.
     */
    distinct?: AccessContentScalarFieldEnum | AccessContentScalarFieldEnum[]
  }

  /**
   * AccessContent findMany
   */
  export type AccessContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * Filter, which AccessContents to fetch.
     */
    where?: AccessContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessContents to fetch.
     */
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessContents.
     */
    cursor?: AccessContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessContents.
     */
    skip?: number
    distinct?: AccessContentScalarFieldEnum | AccessContentScalarFieldEnum[]
  }

  /**
   * AccessContent create
   */
  export type AccessContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessContent.
     */
    data: XOR<AccessContentCreateInput, AccessContentUncheckedCreateInput>
  }

  /**
   * AccessContent createMany
   */
  export type AccessContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessContents.
     */
    data: AccessContentCreateManyInput | AccessContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessContent createManyAndReturn
   */
  export type AccessContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * The data used to create many AccessContents.
     */
    data: AccessContentCreateManyInput | AccessContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessContent update
   */
  export type AccessContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessContent.
     */
    data: XOR<AccessContentUpdateInput, AccessContentUncheckedUpdateInput>
    /**
     * Choose, which AccessContent to update.
     */
    where: AccessContentWhereUniqueInput
  }

  /**
   * AccessContent updateMany
   */
  export type AccessContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessContents.
     */
    data: XOR<AccessContentUpdateManyMutationInput, AccessContentUncheckedUpdateManyInput>
    /**
     * Filter which AccessContents to update
     */
    where?: AccessContentWhereInput
    /**
     * Limit how many AccessContents to update.
     */
    limit?: number
  }

  /**
   * AccessContent updateManyAndReturn
   */
  export type AccessContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * The data used to update AccessContents.
     */
    data: XOR<AccessContentUpdateManyMutationInput, AccessContentUncheckedUpdateManyInput>
    /**
     * Filter which AccessContents to update
     */
    where?: AccessContentWhereInput
    /**
     * Limit how many AccessContents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessContent upsert
   */
  export type AccessContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessContent to update in case it exists.
     */
    where: AccessContentWhereUniqueInput
    /**
     * In case the AccessContent found by the `where` argument doesn't exist, create a new AccessContent with this data.
     */
    create: XOR<AccessContentCreateInput, AccessContentUncheckedCreateInput>
    /**
     * In case the AccessContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessContentUpdateInput, AccessContentUncheckedUpdateInput>
  }

  /**
   * AccessContent delete
   */
  export type AccessContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    /**
     * Filter which AccessContent to delete.
     */
    where: AccessContentWhereUniqueInput
  }

  /**
   * AccessContent deleteMany
   */
  export type AccessContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessContents to delete
     */
    where?: AccessContentWhereInput
    /**
     * Limit how many AccessContents to delete.
     */
    limit?: number
  }

  /**
   * AccessContent.owner
   */
  export type AccessContent$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AccessContent.userAccesses
   */
  export type AccessContent$userAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * AccessContent.redemeers
   */
  export type AccessContent$redemeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * AccessContent without action
   */
  export type AccessContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    grade: number | null
    playTime: number | null
    characterUsed: number | null
    inventory: number | null
  }

  export type UserSumAggregateOutputType = {
    grade: number | null
    playTime: number | null
    characterUsed: number | null
    inventory: number[]
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    role: $Enums.Role | null
    suspend: boolean | null
    accountType: $Enums.AccountType | null
    firstTest: boolean | null
    fullname: string | null
    birthDate: Date | null
    grade: number | null
    lastGradeUpdateAt: Date | null
    schoolIdentity: string | null
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number | null
    characterUsed: number | null
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    storageId: string | null
    lastIdZoneUnlocked: string | null
    lastIdZonePosition: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    role: $Enums.Role | null
    suspend: boolean | null
    accountType: $Enums.AccountType | null
    firstTest: boolean | null
    fullname: string | null
    birthDate: Date | null
    grade: number | null
    lastGradeUpdateAt: Date | null
    schoolIdentity: string | null
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number | null
    characterUsed: number | null
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    storageId: string | null
    lastIdZoneUnlocked: string | null
    lastIdZonePosition: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    authId: number
    email: number
    role: number
    suspend: number
    accountType: number
    firstTest: number
    fullname: number
    birthDate: number
    grade: number
    lastGradeUpdateAt: number
    schoolIdentity: number
    loginAt: number
    logoutAt: number
    playTime: number
    characterUsed: number
    inventory: number
    schoolId: number
    cityId: number
    provinceId: number
    adminId: number
    createdAt: number
    updatedAt: number
    username: number
    storageId: number
    lastIdZoneUnlocked: number
    lastIdZonePosition: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    grade?: true
    playTime?: true
    characterUsed?: true
    inventory?: true
  }

  export type UserSumAggregateInputType = {
    grade?: true
    playTime?: true
    characterUsed?: true
    inventory?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    storageId?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    storageId?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    inventory?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    storageId?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    authId: string
    email: string
    role: $Enums.Role
    suspend: boolean
    accountType: $Enums.AccountType
    firstTest: boolean
    fullname: string
    birthDate: Date | null
    grade: number
    lastGradeUpdateAt: Date | null
    schoolIdentity: string
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number
    characterUsed: number
    inventory: number[]
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    adminId: string | null
    createdAt: Date
    updatedAt: Date
    username: string
    storageId: string | null
    lastIdZoneUnlocked: string
    lastIdZonePosition: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    storageId?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    device?: boolean | User$deviceArgs<ExtArgs>
    ownedAccesses?: boolean | User$ownedAccessesArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    userAccesses?: boolean | User$userAccessesArgs<ExtArgs>
    zones?: boolean | User$zonesArgs<ExtArgs>
    redeemedAccesses?: boolean | User$redeemedAccessesArgs<ExtArgs>
    UserLogin?: boolean | User$UserLoginArgs<ExtArgs>
    bannerVisitor?: boolean | User$bannerVisitorArgs<ExtArgs>
    testParticipant?: boolean | User$testParticipantArgs<ExtArgs>
    voucherRedemeer?: boolean | User$voucherRedemeerArgs<ExtArgs>
    userTransactionArchive?: boolean | User$userTransactionArchiveArgs<ExtArgs>
    userTransaction?: boolean | User$userTransactionArgs<ExtArgs>
    multiPlayerMember?: boolean | User$multiPlayerMemberArgs<ExtArgs>
    testRecords?: boolean | User$testRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    storageId?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    storageId?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    storageId?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "email" | "role" | "suspend" | "accountType" | "firstTest" | "fullname" | "birthDate" | "grade" | "lastGradeUpdateAt" | "schoolIdentity" | "loginAt" | "logoutAt" | "playTime" | "characterUsed" | "inventory" | "schoolId" | "cityId" | "provinceId" | "adminId" | "createdAt" | "updatedAt" | "username" | "storageId" | "lastIdZoneUnlocked" | "lastIdZonePosition", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | User$deviceArgs<ExtArgs>
    ownedAccesses?: boolean | User$ownedAccessesArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    userAccesses?: boolean | User$userAccessesArgs<ExtArgs>
    zones?: boolean | User$zonesArgs<ExtArgs>
    redeemedAccesses?: boolean | User$redeemedAccessesArgs<ExtArgs>
    UserLogin?: boolean | User$UserLoginArgs<ExtArgs>
    bannerVisitor?: boolean | User$bannerVisitorArgs<ExtArgs>
    testParticipant?: boolean | User$testParticipantArgs<ExtArgs>
    voucherRedemeer?: boolean | User$voucherRedemeerArgs<ExtArgs>
    userTransactionArchive?: boolean | User$userTransactionArchiveArgs<ExtArgs>
    userTransaction?: boolean | User$userTransactionArgs<ExtArgs>
    multiPlayerMember?: boolean | User$multiPlayerMemberArgs<ExtArgs>
    testRecords?: boolean | User$testRecordsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      device: Prisma.$DevicePayload<ExtArgs> | null
      ownedAccesses: Prisma.$AccessContentPayload<ExtArgs>[]
      city: Prisma.$CityPayload<ExtArgs> | null
      province: Prisma.$ProvincePayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      userAccesses: Prisma.$AccessContentPayload<ExtArgs>[]
      zones: Prisma.$ZonePayload<ExtArgs>[]
      redeemedAccesses: Prisma.$AccessContentPayload<ExtArgs>[]
      UserLogin: Prisma.$UserLoginPayload<ExtArgs>[]
      bannerVisitor: Prisma.$BannerVisitorPayload<ExtArgs>[]
      testParticipant: Prisma.$TestParticipantPayload<ExtArgs>[]
      voucherRedemeer: Prisma.$VoucherRedemeerPayload<ExtArgs>[]
      userTransactionArchive: Prisma.$UserTransactionArchivePayload<ExtArgs>[]
      userTransaction: Prisma.$UserTransactionPayload<ExtArgs>[]
      multiPlayerMember: Prisma.$MultiPlayerMemberPayload<ExtArgs>[]
      testRecords: Prisma.$TestParticipantRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      email: string
      role: $Enums.Role
      suspend: boolean
      accountType: $Enums.AccountType
      firstTest: boolean
      fullname: string
      birthDate: Date | null
      grade: number
      lastGradeUpdateAt: Date | null
      schoolIdentity: string
      loginAt: Date | null
      logoutAt: Date | null
      playTime: number
      characterUsed: number
      inventory: number[]
      schoolId: string | null
      cityId: string | null
      provinceId: string | null
      adminId: string | null
      createdAt: Date
      updatedAt: Date
      username: string
      storageId: string | null
      lastIdZoneUnlocked: string
      lastIdZonePosition: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    device<T extends User$deviceArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ownedAccesses<T extends User$ownedAccessesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    city<T extends User$cityArgs<ExtArgs> = {}>(args?: Subset<T, User$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    province<T extends User$provinceArgs<ExtArgs> = {}>(args?: Subset<T, User$provinceArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userAccesses<T extends User$userAccessesArgs<ExtArgs> = {}>(args?: Subset<T, User$userAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zones<T extends User$zonesArgs<ExtArgs> = {}>(args?: Subset<T, User$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redeemedAccesses<T extends User$redeemedAccessesArgs<ExtArgs> = {}>(args?: Subset<T, User$redeemedAccessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserLogin<T extends User$UserLoginArgs<ExtArgs> = {}>(args?: Subset<T, User$UserLoginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bannerVisitor<T extends User$bannerVisitorArgs<ExtArgs> = {}>(args?: Subset<T, User$bannerVisitorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testParticipant<T extends User$testParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$testParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherRedemeer<T extends User$voucherRedemeerArgs<ExtArgs> = {}>(args?: Subset<T, User$voucherRedemeerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userTransactionArchive<T extends User$userTransactionArchiveArgs<ExtArgs> = {}>(args?: Subset<T, User$userTransactionArchiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userTransaction<T extends User$userTransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$userTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    multiPlayerMember<T extends User$multiPlayerMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$multiPlayerMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testRecords<T extends User$testRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$testRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly authId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly suspend: FieldRef<"User", 'Boolean'>
    readonly accountType: FieldRef<"User", 'AccountType'>
    readonly firstTest: FieldRef<"User", 'Boolean'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly grade: FieldRef<"User", 'Int'>
    readonly lastGradeUpdateAt: FieldRef<"User", 'DateTime'>
    readonly schoolIdentity: FieldRef<"User", 'String'>
    readonly loginAt: FieldRef<"User", 'DateTime'>
    readonly logoutAt: FieldRef<"User", 'DateTime'>
    readonly playTime: FieldRef<"User", 'Int'>
    readonly characterUsed: FieldRef<"User", 'Int'>
    readonly inventory: FieldRef<"User", 'Int[]'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly provinceId: FieldRef<"User", 'String'>
    readonly adminId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly storageId: FieldRef<"User", 'String'>
    readonly lastIdZoneUnlocked: FieldRef<"User", 'String'>
    readonly lastIdZonePosition: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.device
   */
  export type User$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * User.ownedAccesses
   */
  export type User$ownedAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    where?: AccessContentWhereInput
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    cursor?: AccessContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessContentScalarFieldEnum | AccessContentScalarFieldEnum[]
  }

  /**
   * User.city
   */
  export type User$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * User.province
   */
  export type User$provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.userAccesses
   */
  export type User$userAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    where?: AccessContentWhereInput
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    cursor?: AccessContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessContentScalarFieldEnum | AccessContentScalarFieldEnum[]
  }

  /**
   * User.zones
   */
  export type User$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * User.redeemedAccesses
   */
  export type User$redeemedAccessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessContent
     */
    select?: AccessContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessContent
     */
    omit?: AccessContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessContentInclude<ExtArgs> | null
    where?: AccessContentWhereInput
    orderBy?: AccessContentOrderByWithRelationInput | AccessContentOrderByWithRelationInput[]
    cursor?: AccessContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessContentScalarFieldEnum | AccessContentScalarFieldEnum[]
  }

  /**
   * User.UserLogin
   */
  export type User$UserLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    where?: UserLoginWhereInput
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    cursor?: UserLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * User.bannerVisitor
   */
  export type User$bannerVisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    cursor?: BannerVisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * User.testParticipant
   */
  export type User$testParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    cursor?: TestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * User.voucherRedemeer
   */
  export type User$voucherRedemeerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    where?: VoucherRedemeerWhereInput
    orderBy?: VoucherRedemeerOrderByWithRelationInput | VoucherRedemeerOrderByWithRelationInput[]
    cursor?: VoucherRedemeerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherRedemeerScalarFieldEnum | VoucherRedemeerScalarFieldEnum[]
  }

  /**
   * User.userTransactionArchive
   */
  export type User$userTransactionArchiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    where?: UserTransactionArchiveWhereInput
    orderBy?: UserTransactionArchiveOrderByWithRelationInput | UserTransactionArchiveOrderByWithRelationInput[]
    cursor?: UserTransactionArchiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTransactionArchiveScalarFieldEnum | UserTransactionArchiveScalarFieldEnum[]
  }

  /**
   * User.userTransaction
   */
  export type User$userTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    where?: UserTransactionWhereInput
    orderBy?: UserTransactionOrderByWithRelationInput | UserTransactionOrderByWithRelationInput[]
    cursor?: UserTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTransactionScalarFieldEnum | UserTransactionScalarFieldEnum[]
  }

  /**
   * User.multiPlayerMember
   */
  export type User$multiPlayerMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    where?: MultiPlayerMemberWhereInput
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    cursor?: MultiPlayerMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * User.testRecords
   */
  export type User$testRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    cursor?: TestParticipantRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    ramSize: number | null
    cpuCores: number | null
  }

  export type DeviceSumAggregateOutputType = {
    ramSize: number | null
    cpuCores: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    model: string | null
    manufactur: string | null
    os: string | null
    ramSize: number | null
    gpuName: string | null
    cpuType: string | null
    cpuCores: number | null
    userId: string | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    model: string | null
    manufactur: string | null
    os: string | null
    ramSize: number | null
    gpuName: string | null
    cpuType: string | null
    cpuCores: number | null
    userId: string | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    uuid: number
    model: number
    manufactur: number
    os: number
    ramSize: number
    gpuName: number
    cpuType: number
    cpuCores: number
    userId: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    ramSize?: true
    cpuCores?: true
  }

  export type DeviceSumAggregateInputType = {
    ramSize?: true
    cpuCores?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    uuid?: true
    model?: true
    manufactur?: true
    os?: true
    ramSize?: true
    gpuName?: true
    cpuType?: true
    cpuCores?: true
    userId?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    uuid?: true
    model?: true
    manufactur?: true
    os?: true
    ramSize?: true
    gpuName?: true
    cpuType?: true
    cpuCores?: true
    userId?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    uuid?: true
    model?: true
    manufactur?: true
    os?: true
    ramSize?: true
    gpuName?: true
    cpuType?: true
    cpuCores?: true
    userId?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    uuid: string
    model: string
    manufactur: string
    os: string
    ramSize: number
    gpuName: string
    cpuType: string
    cpuCores: number
    userId: string
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    model?: boolean
    manufactur?: boolean
    os?: boolean
    ramSize?: boolean
    gpuName?: boolean
    cpuType?: boolean
    cpuCores?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    model?: boolean
    manufactur?: boolean
    os?: boolean
    ramSize?: boolean
    gpuName?: boolean
    cpuType?: boolean
    cpuCores?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    model?: boolean
    manufactur?: boolean
    os?: boolean
    ramSize?: boolean
    gpuName?: boolean
    cpuType?: boolean
    cpuCores?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    uuid?: boolean
    model?: boolean
    manufactur?: boolean
    os?: boolean
    ramSize?: boolean
    gpuName?: boolean
    cpuType?: boolean
    cpuCores?: boolean
    userId?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "model" | "manufactur" | "os" | "ramSize" | "gpuName" | "cpuType" | "cpuCores" | "userId", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      model: string
      manufactur: string
      os: string
      ramSize: number
      gpuName: string
      cpuType: string
      cpuCores: number
      userId: string
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly uuid: FieldRef<"Device", 'String'>
    readonly model: FieldRef<"Device", 'String'>
    readonly manufactur: FieldRef<"Device", 'String'>
    readonly os: FieldRef<"Device", 'String'>
    readonly ramSize: FieldRef<"Device", 'Int'>
    readonly gpuName: FieldRef<"Device", 'String'>
    readonly cpuType: FieldRef<"Device", 'String'>
    readonly cpuCores: FieldRef<"Device", 'Int'>
    readonly userId: FieldRef<"Device", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    zoneId: string | null
    userId: string | null
    isComplete: boolean | null
    completedAt: Date | null
    lastLevelId: string | null
    lastSubLevelId: string | null
    lastInnerLevelId: string | null
    lastLevelUnlock: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    zoneId: string | null
    userId: string | null
    isComplete: boolean | null
    completedAt: Date | null
    lastLevelId: string | null
    lastSubLevelId: string | null
    lastInnerLevelId: string | null
    lastLevelUnlock: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    zoneId: number
    userId: number
    isComplete: number
    completedAt: number
    lastLevelId: number
    lastSubLevelId: number
    lastInnerLevelId: number
    lastLevelUnlock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    id?: true
    zoneId?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    zoneId?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    zoneId?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    zoneId: string
    userId: string
    isComplete: boolean
    completedAt: Date | null
    lastLevelId: string
    lastSubLevelId: string
    lastInnerLevelId: string
    lastLevelUnlock: string
    createdAt: Date
    updatedAt: Date
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    levels?: boolean | Zone$levelsArgs<ExtArgs>
    gempo?: boolean | Zone$gempoArgs<ExtArgs>
    championship?: boolean | Zone$championshipArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zoneId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    zoneId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "zoneId" | "userId" | "isComplete" | "completedAt" | "lastLevelId" | "lastSubLevelId" | "lastInnerLevelId" | "lastLevelUnlock" | "createdAt" | "updatedAt", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    levels?: boolean | Zone$levelsArgs<ExtArgs>
    gempo?: boolean | Zone$gempoArgs<ExtArgs>
    championship?: boolean | Zone$championshipArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      levels: Prisma.$LevelPayload<ExtArgs>[]
      gempo: Prisma.$GempoPayload<ExtArgs> | null
      championship: Prisma.$ChampionshipPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zoneId: string
      userId: string
      isComplete: boolean
      completedAt: Date | null
      lastLevelId: string
      lastSubLevelId: string
      lastInnerLevelId: string
      lastLevelUnlock: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    levels<T extends Zone$levelsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gempo<T extends Zone$gempoArgs<ExtArgs> = {}>(args?: Subset<T, Zone$gempoArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    championship<T extends Zone$championshipArgs<ExtArgs> = {}>(args?: Subset<T, Zone$championshipArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly zoneId: FieldRef<"Zone", 'String'>
    readonly userId: FieldRef<"Zone", 'String'>
    readonly isComplete: FieldRef<"Zone", 'Boolean'>
    readonly completedAt: FieldRef<"Zone", 'DateTime'>
    readonly lastLevelId: FieldRef<"Zone", 'String'>
    readonly lastSubLevelId: FieldRef<"Zone", 'String'>
    readonly lastInnerLevelId: FieldRef<"Zone", 'String'>
    readonly lastLevelUnlock: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone.levels
   */
  export type Zone$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Zone.gempo
   */
  export type Zone$gempoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    where?: GempoWhereInput
  }

  /**
   * Zone.championship
   */
  export type Zone$championshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    where?: ChampionshipWhereInput
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    levelId: string | null
    zoneId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    levelId: string | null
    zoneId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    levelId: number
    zoneId: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelMinAggregateInputType = {
    id?: true
    levelId?: true
    zoneId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    levelId?: true
    zoneId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    levelId?: true
    zoneId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    levelId: string
    zoneId: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    levelId?: boolean
    zoneId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    subLevels?: boolean | Level$subLevelsArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    levelId?: boolean
    zoneId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    levelId?: boolean
    zoneId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectScalar = {
    id?: boolean
    levelId?: boolean
    zoneId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "levelId" | "zoneId" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    subLevels?: boolean | Level$subLevelsArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type LevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
      subLevels: Prisma.$SubLevelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      levelId: string
      zoneId: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {LevelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LevelUpdateManyAndReturnArgs>(args: SelectSubset<T, LevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subLevels<T extends Level$subLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Level$subLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly levelId: FieldRef<"Level", 'String'>
    readonly zoneId: FieldRef<"Level", 'String'>
    readonly isUnlock: FieldRef<"Level", 'Boolean'>
    readonly unlockedAt: FieldRef<"Level", 'DateTime'>
    readonly isComplete: FieldRef<"Level", 'Boolean'>
    readonly completedAt: FieldRef<"Level", 'DateTime'>
    readonly createdAt: FieldRef<"Level", 'DateTime'>
    readonly updatedAt: FieldRef<"Level", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level updateManyAndReturn
   */
  export type LevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level.subLevels
   */
  export type Level$subLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    where?: SubLevelWhereInput
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    cursor?: SubLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model SubLevel
   */

  export type AggregateSubLevel = {
    _count: SubLevelCountAggregateOutputType | null
    _min: SubLevelMinAggregateOutputType | null
    _max: SubLevelMaxAggregateOutputType | null
  }

  export type SubLevelMinAggregateOutputType = {
    id: string | null
    subLevelId: string | null
    levelId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubLevelMaxAggregateOutputType = {
    id: string | null
    subLevelId: string | null
    levelId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubLevelCountAggregateOutputType = {
    id: number
    subLevelId: number
    levelId: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubLevelMinAggregateInputType = {
    id?: true
    subLevelId?: true
    levelId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubLevelMaxAggregateInputType = {
    id?: true
    subLevelId?: true
    levelId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubLevelCountAggregateInputType = {
    id?: true
    subLevelId?: true
    levelId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubLevel to aggregate.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubLevels
    **/
    _count?: true | SubLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubLevelMaxAggregateInputType
  }

  export type GetSubLevelAggregateType<T extends SubLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateSubLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubLevel[P]>
      : GetScalarType<T[P], AggregateSubLevel[P]>
  }




  export type SubLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubLevelWhereInput
    orderBy?: SubLevelOrderByWithAggregationInput | SubLevelOrderByWithAggregationInput[]
    by: SubLevelScalarFieldEnum[] | SubLevelScalarFieldEnum
    having?: SubLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubLevelCountAggregateInputType | true
    _min?: SubLevelMinAggregateInputType
    _max?: SubLevelMaxAggregateInputType
  }

  export type SubLevelGroupByOutputType = {
    id: string
    subLevelId: string
    levelId: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubLevelCountAggregateOutputType | null
    _min: SubLevelMinAggregateOutputType | null
    _max: SubLevelMaxAggregateOutputType | null
  }

  type GetSubLevelGroupByPayload<T extends SubLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubLevelGroupByOutputType[P]>
            : GetScalarType<T[P], SubLevelGroupByOutputType[P]>
        }
      >
    >


  export type SubLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subLevelId?: boolean
    levelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | LevelDefaultArgs<ExtArgs>
    innerLevels?: boolean | SubLevel$innerLevelsArgs<ExtArgs>
    _count?: boolean | SubLevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subLevelId?: boolean
    levelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subLevelId?: boolean
    levelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectScalar = {
    id?: boolean
    subLevelId?: boolean
    levelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subLevelId" | "levelId" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["subLevel"]>
  export type SubLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | LevelDefaultArgs<ExtArgs>
    innerLevels?: boolean | SubLevel$innerLevelsArgs<ExtArgs>
    _count?: boolean | SubLevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }
  export type SubLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }

  export type $SubLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubLevel"
    objects: {
      level: Prisma.$LevelPayload<ExtArgs>
      innerLevels: Prisma.$InnerLevelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subLevelId: string
      levelId: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subLevel"]>
    composites: {}
  }

  type SubLevelGetPayload<S extends boolean | null | undefined | SubLevelDefaultArgs> = $Result.GetResult<Prisma.$SubLevelPayload, S>

  type SubLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubLevelCountAggregateInputType | true
    }

  export interface SubLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubLevel'], meta: { name: 'SubLevel' } }
    /**
     * Find zero or one SubLevel that matches the filter.
     * @param {SubLevelFindUniqueArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubLevelFindUniqueArgs>(args: SelectSubset<T, SubLevelFindUniqueArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubLevelFindUniqueOrThrowArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, SubLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindFirstArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubLevelFindFirstArgs>(args?: SelectSubset<T, SubLevelFindFirstArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindFirstOrThrowArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, SubLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubLevels
     * const subLevels = await prisma.subLevel.findMany()
     * 
     * // Get first 10 SubLevels
     * const subLevels = await prisma.subLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubLevelFindManyArgs>(args?: SelectSubset<T, SubLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubLevel.
     * @param {SubLevelCreateArgs} args - Arguments to create a SubLevel.
     * @example
     * // Create one SubLevel
     * const SubLevel = await prisma.subLevel.create({
     *   data: {
     *     // ... data to create a SubLevel
     *   }
     * })
     * 
     */
    create<T extends SubLevelCreateArgs>(args: SelectSubset<T, SubLevelCreateArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubLevels.
     * @param {SubLevelCreateManyArgs} args - Arguments to create many SubLevels.
     * @example
     * // Create many SubLevels
     * const subLevel = await prisma.subLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubLevelCreateManyArgs>(args?: SelectSubset<T, SubLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubLevels and returns the data saved in the database.
     * @param {SubLevelCreateManyAndReturnArgs} args - Arguments to create many SubLevels.
     * @example
     * // Create many SubLevels
     * const subLevel = await prisma.subLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubLevels and only return the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, SubLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubLevel.
     * @param {SubLevelDeleteArgs} args - Arguments to delete one SubLevel.
     * @example
     * // Delete one SubLevel
     * const SubLevel = await prisma.subLevel.delete({
     *   where: {
     *     // ... filter to delete one SubLevel
     *   }
     * })
     * 
     */
    delete<T extends SubLevelDeleteArgs>(args: SelectSubset<T, SubLevelDeleteArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubLevel.
     * @param {SubLevelUpdateArgs} args - Arguments to update one SubLevel.
     * @example
     * // Update one SubLevel
     * const subLevel = await prisma.subLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubLevelUpdateArgs>(args: SelectSubset<T, SubLevelUpdateArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubLevels.
     * @param {SubLevelDeleteManyArgs} args - Arguments to filter SubLevels to delete.
     * @example
     * // Delete a few SubLevels
     * const { count } = await prisma.subLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubLevelDeleteManyArgs>(args?: SelectSubset<T, SubLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubLevels
     * const subLevel = await prisma.subLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubLevelUpdateManyArgs>(args: SelectSubset<T, SubLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubLevels and returns the data updated in the database.
     * @param {SubLevelUpdateManyAndReturnArgs} args - Arguments to update many SubLevels.
     * @example
     * // Update many SubLevels
     * const subLevel = await prisma.subLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubLevels and only return the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, SubLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubLevel.
     * @param {SubLevelUpsertArgs} args - Arguments to update or create a SubLevel.
     * @example
     * // Update or create a SubLevel
     * const subLevel = await prisma.subLevel.upsert({
     *   create: {
     *     // ... data to create a SubLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubLevel we want to update
     *   }
     * })
     */
    upsert<T extends SubLevelUpsertArgs>(args: SelectSubset<T, SubLevelUpsertArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelCountArgs} args - Arguments to filter SubLevels to count.
     * @example
     * // Count the number of SubLevels
     * const count = await prisma.subLevel.count({
     *   where: {
     *     // ... the filter for the SubLevels we want to count
     *   }
     * })
    **/
    count<T extends SubLevelCountArgs>(
      args?: Subset<T, SubLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubLevelAggregateArgs>(args: Subset<T, SubLevelAggregateArgs>): Prisma.PrismaPromise<GetSubLevelAggregateType<T>>

    /**
     * Group by SubLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubLevelGroupByArgs['orderBy'] }
        : { orderBy?: SubLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubLevel model
   */
  readonly fields: SubLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    level<T extends LevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LevelDefaultArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    innerLevels<T extends SubLevel$innerLevelsArgs<ExtArgs> = {}>(args?: Subset<T, SubLevel$innerLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubLevel model
   */
  interface SubLevelFieldRefs {
    readonly id: FieldRef<"SubLevel", 'String'>
    readonly subLevelId: FieldRef<"SubLevel", 'String'>
    readonly levelId: FieldRef<"SubLevel", 'String'>
    readonly isUnlock: FieldRef<"SubLevel", 'Boolean'>
    readonly unlockedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly isComplete: FieldRef<"SubLevel", 'Boolean'>
    readonly completedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly createdAt: FieldRef<"SubLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"SubLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubLevel findUnique
   */
  export type SubLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel findUniqueOrThrow
   */
  export type SubLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel findFirst
   */
  export type SubLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubLevels.
     */
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel findFirstOrThrow
   */
  export type SubLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubLevels.
     */
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel findMany
   */
  export type SubLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevels to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel create
   */
  export type SubLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a SubLevel.
     */
    data: XOR<SubLevelCreateInput, SubLevelUncheckedCreateInput>
  }

  /**
   * SubLevel createMany
   */
  export type SubLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubLevels.
     */
    data: SubLevelCreateManyInput | SubLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubLevel createManyAndReturn
   */
  export type SubLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * The data used to create many SubLevels.
     */
    data: SubLevelCreateManyInput | SubLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubLevel update
   */
  export type SubLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a SubLevel.
     */
    data: XOR<SubLevelUpdateInput, SubLevelUncheckedUpdateInput>
    /**
     * Choose, which SubLevel to update.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel updateMany
   */
  export type SubLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubLevels.
     */
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyInput>
    /**
     * Filter which SubLevels to update
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to update.
     */
    limit?: number
  }

  /**
   * SubLevel updateManyAndReturn
   */
  export type SubLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * The data used to update SubLevels.
     */
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyInput>
    /**
     * Filter which SubLevels to update
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubLevel upsert
   */
  export type SubLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the SubLevel to update in case it exists.
     */
    where: SubLevelWhereUniqueInput
    /**
     * In case the SubLevel found by the `where` argument doesn't exist, create a new SubLevel with this data.
     */
    create: XOR<SubLevelCreateInput, SubLevelUncheckedCreateInput>
    /**
     * In case the SubLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubLevelUpdateInput, SubLevelUncheckedUpdateInput>
  }

  /**
   * SubLevel delete
   */
  export type SubLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter which SubLevel to delete.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel deleteMany
   */
  export type SubLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubLevels to delete
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to delete.
     */
    limit?: number
  }

  /**
   * SubLevel.innerLevels
   */
  export type SubLevel$innerLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    where?: InnerLevelWhereInput
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    cursor?: InnerLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * SubLevel without action
   */
  export type SubLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
  }


  /**
   * Model InnerLevel
   */

  export type AggregateInnerLevel = {
    _count: InnerLevelCountAggregateOutputType | null
    _avg: InnerLevelAvgAggregateOutputType | null
    _sum: InnerLevelSumAggregateOutputType | null
    _min: InnerLevelMinAggregateOutputType | null
    _max: InnerLevelMaxAggregateOutputType | null
  }

  export type InnerLevelAvgAggregateOutputType = {
    point: number | null
    played: number | null
  }

  export type InnerLevelSumAggregateOutputType = {
    point: number | null
    played: number | null
  }

  export type InnerLevelMinAggregateOutputType = {
    id: string | null
    innerLevelId: string | null
    subLevelId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    point: number | null
    played: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InnerLevelMaxAggregateOutputType = {
    id: string | null
    innerLevelId: string | null
    subLevelId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    point: number | null
    played: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InnerLevelCountAggregateOutputType = {
    id: number
    innerLevelId: number
    subLevelId: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    point: number
    played: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InnerLevelAvgAggregateInputType = {
    point?: true
    played?: true
  }

  export type InnerLevelSumAggregateInputType = {
    point?: true
    played?: true
  }

  export type InnerLevelMinAggregateInputType = {
    id?: true
    innerLevelId?: true
    subLevelId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InnerLevelMaxAggregateInputType = {
    id?: true
    innerLevelId?: true
    subLevelId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InnerLevelCountAggregateInputType = {
    id?: true
    innerLevelId?: true
    subLevelId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InnerLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnerLevel to aggregate.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InnerLevels
    **/
    _count?: true | InnerLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InnerLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InnerLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InnerLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InnerLevelMaxAggregateInputType
  }

  export type GetInnerLevelAggregateType<T extends InnerLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateInnerLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInnerLevel[P]>
      : GetScalarType<T[P], AggregateInnerLevel[P]>
  }




  export type InnerLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InnerLevelWhereInput
    orderBy?: InnerLevelOrderByWithAggregationInput | InnerLevelOrderByWithAggregationInput[]
    by: InnerLevelScalarFieldEnum[] | InnerLevelScalarFieldEnum
    having?: InnerLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InnerLevelCountAggregateInputType | true
    _avg?: InnerLevelAvgAggregateInputType
    _sum?: InnerLevelSumAggregateInputType
    _min?: InnerLevelMinAggregateInputType
    _max?: InnerLevelMaxAggregateInputType
  }

  export type InnerLevelGroupByOutputType = {
    id: string
    innerLevelId: string
    subLevelId: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    point: number
    played: number
    createdAt: Date
    updatedAt: Date
    _count: InnerLevelCountAggregateOutputType | null
    _avg: InnerLevelAvgAggregateOutputType | null
    _sum: InnerLevelSumAggregateOutputType | null
    _min: InnerLevelMinAggregateOutputType | null
    _max: InnerLevelMaxAggregateOutputType | null
  }

  type GetInnerLevelGroupByPayload<T extends InnerLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InnerLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InnerLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InnerLevelGroupByOutputType[P]>
            : GetScalarType<T[P], InnerLevelGroupByOutputType[P]>
        }
      >
    >


  export type InnerLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    innerLevelId?: boolean
    subLevelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subLevel?: boolean | SubLevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    innerLevelId?: boolean
    subLevelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subLevel?: boolean | SubLevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    innerLevelId?: boolean
    subLevelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subLevel?: boolean | SubLevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectScalar = {
    id?: boolean
    innerLevelId?: boolean
    subLevelId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InnerLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "innerLevelId" | "subLevelId" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "point" | "played" | "createdAt" | "updatedAt", ExtArgs["result"]["innerLevel"]>
  export type InnerLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subLevel?: boolean | SubLevelDefaultArgs<ExtArgs>
  }
  export type InnerLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subLevel?: boolean | SubLevelDefaultArgs<ExtArgs>
  }
  export type InnerLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subLevel?: boolean | SubLevelDefaultArgs<ExtArgs>
  }

  export type $InnerLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InnerLevel"
    objects: {
      subLevel: Prisma.$SubLevelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      innerLevelId: string
      subLevelId: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      point: number
      played: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["innerLevel"]>
    composites: {}
  }

  type InnerLevelGetPayload<S extends boolean | null | undefined | InnerLevelDefaultArgs> = $Result.GetResult<Prisma.$InnerLevelPayload, S>

  type InnerLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InnerLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InnerLevelCountAggregateInputType | true
    }

  export interface InnerLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InnerLevel'], meta: { name: 'InnerLevel' } }
    /**
     * Find zero or one InnerLevel that matches the filter.
     * @param {InnerLevelFindUniqueArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InnerLevelFindUniqueArgs>(args: SelectSubset<T, InnerLevelFindUniqueArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InnerLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InnerLevelFindUniqueOrThrowArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InnerLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, InnerLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InnerLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindFirstArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InnerLevelFindFirstArgs>(args?: SelectSubset<T, InnerLevelFindFirstArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InnerLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindFirstOrThrowArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InnerLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, InnerLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InnerLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InnerLevels
     * const innerLevels = await prisma.innerLevel.findMany()
     * 
     * // Get first 10 InnerLevels
     * const innerLevels = await prisma.innerLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InnerLevelFindManyArgs>(args?: SelectSubset<T, InnerLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InnerLevel.
     * @param {InnerLevelCreateArgs} args - Arguments to create a InnerLevel.
     * @example
     * // Create one InnerLevel
     * const InnerLevel = await prisma.innerLevel.create({
     *   data: {
     *     // ... data to create a InnerLevel
     *   }
     * })
     * 
     */
    create<T extends InnerLevelCreateArgs>(args: SelectSubset<T, InnerLevelCreateArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InnerLevels.
     * @param {InnerLevelCreateManyArgs} args - Arguments to create many InnerLevels.
     * @example
     * // Create many InnerLevels
     * const innerLevel = await prisma.innerLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InnerLevelCreateManyArgs>(args?: SelectSubset<T, InnerLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InnerLevels and returns the data saved in the database.
     * @param {InnerLevelCreateManyAndReturnArgs} args - Arguments to create many InnerLevels.
     * @example
     * // Create many InnerLevels
     * const innerLevel = await prisma.innerLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InnerLevels and only return the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InnerLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, InnerLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InnerLevel.
     * @param {InnerLevelDeleteArgs} args - Arguments to delete one InnerLevel.
     * @example
     * // Delete one InnerLevel
     * const InnerLevel = await prisma.innerLevel.delete({
     *   where: {
     *     // ... filter to delete one InnerLevel
     *   }
     * })
     * 
     */
    delete<T extends InnerLevelDeleteArgs>(args: SelectSubset<T, InnerLevelDeleteArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InnerLevel.
     * @param {InnerLevelUpdateArgs} args - Arguments to update one InnerLevel.
     * @example
     * // Update one InnerLevel
     * const innerLevel = await prisma.innerLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InnerLevelUpdateArgs>(args: SelectSubset<T, InnerLevelUpdateArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InnerLevels.
     * @param {InnerLevelDeleteManyArgs} args - Arguments to filter InnerLevels to delete.
     * @example
     * // Delete a few InnerLevels
     * const { count } = await prisma.innerLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InnerLevelDeleteManyArgs>(args?: SelectSubset<T, InnerLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnerLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InnerLevels
     * const innerLevel = await prisma.innerLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InnerLevelUpdateManyArgs>(args: SelectSubset<T, InnerLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnerLevels and returns the data updated in the database.
     * @param {InnerLevelUpdateManyAndReturnArgs} args - Arguments to update many InnerLevels.
     * @example
     * // Update many InnerLevels
     * const innerLevel = await prisma.innerLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InnerLevels and only return the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InnerLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, InnerLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InnerLevel.
     * @param {InnerLevelUpsertArgs} args - Arguments to update or create a InnerLevel.
     * @example
     * // Update or create a InnerLevel
     * const innerLevel = await prisma.innerLevel.upsert({
     *   create: {
     *     // ... data to create a InnerLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InnerLevel we want to update
     *   }
     * })
     */
    upsert<T extends InnerLevelUpsertArgs>(args: SelectSubset<T, InnerLevelUpsertArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InnerLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelCountArgs} args - Arguments to filter InnerLevels to count.
     * @example
     * // Count the number of InnerLevels
     * const count = await prisma.innerLevel.count({
     *   where: {
     *     // ... the filter for the InnerLevels we want to count
     *   }
     * })
    **/
    count<T extends InnerLevelCountArgs>(
      args?: Subset<T, InnerLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InnerLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InnerLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InnerLevelAggregateArgs>(args: Subset<T, InnerLevelAggregateArgs>): Prisma.PrismaPromise<GetInnerLevelAggregateType<T>>

    /**
     * Group by InnerLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InnerLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InnerLevelGroupByArgs['orderBy'] }
        : { orderBy?: InnerLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InnerLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInnerLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InnerLevel model
   */
  readonly fields: InnerLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InnerLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InnerLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subLevel<T extends SubLevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubLevelDefaultArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InnerLevel model
   */
  interface InnerLevelFieldRefs {
    readonly id: FieldRef<"InnerLevel", 'String'>
    readonly innerLevelId: FieldRef<"InnerLevel", 'String'>
    readonly subLevelId: FieldRef<"InnerLevel", 'String'>
    readonly isUnlock: FieldRef<"InnerLevel", 'Boolean'>
    readonly unlockedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly isComplete: FieldRef<"InnerLevel", 'Boolean'>
    readonly completedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly point: FieldRef<"InnerLevel", 'Int'>
    readonly played: FieldRef<"InnerLevel", 'Int'>
    readonly createdAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"InnerLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InnerLevel findUnique
   */
  export type InnerLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel findUniqueOrThrow
   */
  export type InnerLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel findFirst
   */
  export type InnerLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnerLevels.
     */
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel findFirstOrThrow
   */
  export type InnerLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnerLevels.
     */
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel findMany
   */
  export type InnerLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevels to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel create
   */
  export type InnerLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a InnerLevel.
     */
    data: XOR<InnerLevelCreateInput, InnerLevelUncheckedCreateInput>
  }

  /**
   * InnerLevel createMany
   */
  export type InnerLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InnerLevels.
     */
    data: InnerLevelCreateManyInput | InnerLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InnerLevel createManyAndReturn
   */
  export type InnerLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * The data used to create many InnerLevels.
     */
    data: InnerLevelCreateManyInput | InnerLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InnerLevel update
   */
  export type InnerLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a InnerLevel.
     */
    data: XOR<InnerLevelUpdateInput, InnerLevelUncheckedUpdateInput>
    /**
     * Choose, which InnerLevel to update.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel updateMany
   */
  export type InnerLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InnerLevels.
     */
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyInput>
    /**
     * Filter which InnerLevels to update
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to update.
     */
    limit?: number
  }

  /**
   * InnerLevel updateManyAndReturn
   */
  export type InnerLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * The data used to update InnerLevels.
     */
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyInput>
    /**
     * Filter which InnerLevels to update
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InnerLevel upsert
   */
  export type InnerLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the InnerLevel to update in case it exists.
     */
    where: InnerLevelWhereUniqueInput
    /**
     * In case the InnerLevel found by the `where` argument doesn't exist, create a new InnerLevel with this data.
     */
    create: XOR<InnerLevelCreateInput, InnerLevelUncheckedCreateInput>
    /**
     * In case the InnerLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InnerLevelUpdateInput, InnerLevelUncheckedUpdateInput>
  }

  /**
   * InnerLevel delete
   */
  export type InnerLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter which InnerLevel to delete.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel deleteMany
   */
  export type InnerLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnerLevels to delete
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to delete.
     */
    limit?: number
  }

  /**
   * InnerLevel without action
   */
  export type InnerLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
  }


  /**
   * Model Gempo
   */

  export type AggregateGempo = {
    _count: GempoCountAggregateOutputType | null
    _min: GempoMinAggregateOutputType | null
    _max: GempoMaxAggregateOutputType | null
  }

  export type GempoMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    gempoId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GempoMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    gempoId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GempoCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    gempoId: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GempoMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    gempoId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GempoMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    gempoId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GempoCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    gempoId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GempoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gempo to aggregate.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gempos
    **/
    _count?: true | GempoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GempoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GempoMaxAggregateInputType
  }

  export type GetGempoAggregateType<T extends GempoAggregateArgs> = {
        [P in keyof T & keyof AggregateGempo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGempo[P]>
      : GetScalarType<T[P], AggregateGempo[P]>
  }




  export type GempoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoWhereInput
    orderBy?: GempoOrderByWithAggregationInput | GempoOrderByWithAggregationInput[]
    by: GempoScalarFieldEnum[] | GempoScalarFieldEnum
    having?: GempoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GempoCountAggregateInputType | true
    _min?: GempoMinAggregateInputType
    _max?: GempoMaxAggregateInputType
  }

  export type GempoGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    gempoId: string
    zoneId: string
    createdAt: Date
    updatedAt: Date
    _count: GempoCountAggregateOutputType | null
    _min: GempoMinAggregateOutputType | null
    _max: GempoMaxAggregateOutputType | null
  }

  type GetGempoGroupByPayload<T extends GempoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GempoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GempoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GempoGroupByOutputType[P]>
            : GetScalarType<T[P], GempoGroupByOutputType[P]>
        }
      >
    >


  export type GempoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    gempoId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    records?: boolean | Gempo$recordsArgs<ExtArgs>
    _count?: boolean | GempoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    gempoId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    gempoId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    gempoId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GempoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "gempoId" | "zoneId" | "createdAt" | "updatedAt", ExtArgs["result"]["gempo"]>
  export type GempoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    records?: boolean | Gempo$recordsArgs<ExtArgs>
    _count?: boolean | GempoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GempoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type GempoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $GempoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gempo"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
      records: Prisma.$GempoRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      gempoId: string
      zoneId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gempo"]>
    composites: {}
  }

  type GempoGetPayload<S extends boolean | null | undefined | GempoDefaultArgs> = $Result.GetResult<Prisma.$GempoPayload, S>

  type GempoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GempoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GempoCountAggregateInputType | true
    }

  export interface GempoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gempo'], meta: { name: 'Gempo' } }
    /**
     * Find zero or one Gempo that matches the filter.
     * @param {GempoFindUniqueArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GempoFindUniqueArgs>(args: SelectSubset<T, GempoFindUniqueArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gempo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GempoFindUniqueOrThrowArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GempoFindUniqueOrThrowArgs>(args: SelectSubset<T, GempoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gempo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindFirstArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GempoFindFirstArgs>(args?: SelectSubset<T, GempoFindFirstArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gempo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindFirstOrThrowArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GempoFindFirstOrThrowArgs>(args?: SelectSubset<T, GempoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gempos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gempos
     * const gempos = await prisma.gempo.findMany()
     * 
     * // Get first 10 Gempos
     * const gempos = await prisma.gempo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gempoWithIdOnly = await prisma.gempo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GempoFindManyArgs>(args?: SelectSubset<T, GempoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gempo.
     * @param {GempoCreateArgs} args - Arguments to create a Gempo.
     * @example
     * // Create one Gempo
     * const Gempo = await prisma.gempo.create({
     *   data: {
     *     // ... data to create a Gempo
     *   }
     * })
     * 
     */
    create<T extends GempoCreateArgs>(args: SelectSubset<T, GempoCreateArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gempos.
     * @param {GempoCreateManyArgs} args - Arguments to create many Gempos.
     * @example
     * // Create many Gempos
     * const gempo = await prisma.gempo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GempoCreateManyArgs>(args?: SelectSubset<T, GempoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gempos and returns the data saved in the database.
     * @param {GempoCreateManyAndReturnArgs} args - Arguments to create many Gempos.
     * @example
     * // Create many Gempos
     * const gempo = await prisma.gempo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gempos and only return the `id`
     * const gempoWithIdOnly = await prisma.gempo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GempoCreateManyAndReturnArgs>(args?: SelectSubset<T, GempoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gempo.
     * @param {GempoDeleteArgs} args - Arguments to delete one Gempo.
     * @example
     * // Delete one Gempo
     * const Gempo = await prisma.gempo.delete({
     *   where: {
     *     // ... filter to delete one Gempo
     *   }
     * })
     * 
     */
    delete<T extends GempoDeleteArgs>(args: SelectSubset<T, GempoDeleteArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gempo.
     * @param {GempoUpdateArgs} args - Arguments to update one Gempo.
     * @example
     * // Update one Gempo
     * const gempo = await prisma.gempo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GempoUpdateArgs>(args: SelectSubset<T, GempoUpdateArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gempos.
     * @param {GempoDeleteManyArgs} args - Arguments to filter Gempos to delete.
     * @example
     * // Delete a few Gempos
     * const { count } = await prisma.gempo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GempoDeleteManyArgs>(args?: SelectSubset<T, GempoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gempos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gempos
     * const gempo = await prisma.gempo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GempoUpdateManyArgs>(args: SelectSubset<T, GempoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gempos and returns the data updated in the database.
     * @param {GempoUpdateManyAndReturnArgs} args - Arguments to update many Gempos.
     * @example
     * // Update many Gempos
     * const gempo = await prisma.gempo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gempos and only return the `id`
     * const gempoWithIdOnly = await prisma.gempo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GempoUpdateManyAndReturnArgs>(args: SelectSubset<T, GempoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gempo.
     * @param {GempoUpsertArgs} args - Arguments to update or create a Gempo.
     * @example
     * // Update or create a Gempo
     * const gempo = await prisma.gempo.upsert({
     *   create: {
     *     // ... data to create a Gempo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gempo we want to update
     *   }
     * })
     */
    upsert<T extends GempoUpsertArgs>(args: SelectSubset<T, GempoUpsertArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gempos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoCountArgs} args - Arguments to filter Gempos to count.
     * @example
     * // Count the number of Gempos
     * const count = await prisma.gempo.count({
     *   where: {
     *     // ... the filter for the Gempos we want to count
     *   }
     * })
    **/
    count<T extends GempoCountArgs>(
      args?: Subset<T, GempoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GempoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gempo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GempoAggregateArgs>(args: Subset<T, GempoAggregateArgs>): Prisma.PrismaPromise<GetGempoAggregateType<T>>

    /**
     * Group by Gempo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GempoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GempoGroupByArgs['orderBy'] }
        : { orderBy?: GempoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GempoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGempoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gempo model
   */
  readonly fields: GempoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gempo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GempoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    records<T extends Gempo$recordsArgs<ExtArgs> = {}>(args?: Subset<T, Gempo$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gempo model
   */
  interface GempoFieldRefs {
    readonly id: FieldRef<"Gempo", 'String'>
    readonly isUnlock: FieldRef<"Gempo", 'Boolean'>
    readonly unlockedAt: FieldRef<"Gempo", 'DateTime'>
    readonly gempoId: FieldRef<"Gempo", 'String'>
    readonly zoneId: FieldRef<"Gempo", 'String'>
    readonly createdAt: FieldRef<"Gempo", 'DateTime'>
    readonly updatedAt: FieldRef<"Gempo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gempo findUnique
   */
  export type GempoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo findUniqueOrThrow
   */
  export type GempoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo findFirst
   */
  export type GempoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gempos.
     */
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo findFirstOrThrow
   */
  export type GempoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gempos.
     */
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo findMany
   */
  export type GempoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempos to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo create
   */
  export type GempoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The data needed to create a Gempo.
     */
    data: XOR<GempoCreateInput, GempoUncheckedCreateInput>
  }

  /**
   * Gempo createMany
   */
  export type GempoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gempos.
     */
    data: GempoCreateManyInput | GempoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gempo createManyAndReturn
   */
  export type GempoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * The data used to create many Gempos.
     */
    data: GempoCreateManyInput | GempoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gempo update
   */
  export type GempoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The data needed to update a Gempo.
     */
    data: XOR<GempoUpdateInput, GempoUncheckedUpdateInput>
    /**
     * Choose, which Gempo to update.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo updateMany
   */
  export type GempoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gempos.
     */
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyInput>
    /**
     * Filter which Gempos to update
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to update.
     */
    limit?: number
  }

  /**
   * Gempo updateManyAndReturn
   */
  export type GempoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * The data used to update Gempos.
     */
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyInput>
    /**
     * Filter which Gempos to update
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gempo upsert
   */
  export type GempoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The filter to search for the Gempo to update in case it exists.
     */
    where: GempoWhereUniqueInput
    /**
     * In case the Gempo found by the `where` argument doesn't exist, create a new Gempo with this data.
     */
    create: XOR<GempoCreateInput, GempoUncheckedCreateInput>
    /**
     * In case the Gempo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GempoUpdateInput, GempoUncheckedUpdateInput>
  }

  /**
   * Gempo delete
   */
  export type GempoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter which Gempo to delete.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo deleteMany
   */
  export type GempoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gempos to delete
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to delete.
     */
    limit?: number
  }

  /**
   * Gempo.records
   */
  export type Gempo$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    where?: GempoRecordWhereInput
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    cursor?: GempoRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * Gempo without action
   */
  export type GempoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
  }


  /**
   * Model Championship
   */

  export type AggregateChampionship = {
    _count: ChampionshipCountAggregateOutputType | null
    _min: ChampionshipMinAggregateOutputType | null
    _max: ChampionshipMaxAggregateOutputType | null
  }

  export type ChampionshipMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    championshipId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChampionshipMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    championshipId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChampionshipCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    championshipId: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChampionshipMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    championshipId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChampionshipMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    championshipId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChampionshipCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    championshipId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChampionshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Championship to aggregate.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Championships
    **/
    _count?: true | ChampionshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipMaxAggregateInputType
  }

  export type GetChampionshipAggregateType<T extends ChampionshipAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionship[P]>
      : GetScalarType<T[P], AggregateChampionship[P]>
  }




  export type ChampionshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipWhereInput
    orderBy?: ChampionshipOrderByWithAggregationInput | ChampionshipOrderByWithAggregationInput[]
    by: ChampionshipScalarFieldEnum[] | ChampionshipScalarFieldEnum
    having?: ChampionshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipCountAggregateInputType | true
    _min?: ChampionshipMinAggregateInputType
    _max?: ChampionshipMaxAggregateInputType
  }

  export type ChampionshipGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    championshipId: string
    zoneId: string
    createdAt: Date
    updatedAt: Date
    _count: ChampionshipCountAggregateOutputType | null
    _min: ChampionshipMinAggregateOutputType | null
    _max: ChampionshipMaxAggregateOutputType | null
  }

  type GetChampionshipGroupByPayload<T extends ChampionshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    championshipId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    records?: boolean | Championship$recordsArgs<ExtArgs>
    _count?: boolean | ChampionshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    championshipId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    championshipId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    championshipId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChampionshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "championshipId" | "zoneId" | "createdAt" | "updatedAt", ExtArgs["result"]["championship"]>
  export type ChampionshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    records?: boolean | Championship$recordsArgs<ExtArgs>
    _count?: boolean | ChampionshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChampionshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type ChampionshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $ChampionshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Championship"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
      records: Prisma.$ChampionshipRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      championshipId: string
      zoneId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["championship"]>
    composites: {}
  }

  type ChampionshipGetPayload<S extends boolean | null | undefined | ChampionshipDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipPayload, S>

  type ChampionshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipCountAggregateInputType | true
    }

  export interface ChampionshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Championship'], meta: { name: 'Championship' } }
    /**
     * Find zero or one Championship that matches the filter.
     * @param {ChampionshipFindUniqueArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipFindUniqueArgs>(args: SelectSubset<T, ChampionshipFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Championship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipFindUniqueOrThrowArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Championship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindFirstArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipFindFirstArgs>(args?: SelectSubset<T, ChampionshipFindFirstArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Championship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindFirstOrThrowArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Championships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Championships
     * const championships = await prisma.championship.findMany()
     * 
     * // Get first 10 Championships
     * const championships = await prisma.championship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipWithIdOnly = await prisma.championship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipFindManyArgs>(args?: SelectSubset<T, ChampionshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Championship.
     * @param {ChampionshipCreateArgs} args - Arguments to create a Championship.
     * @example
     * // Create one Championship
     * const Championship = await prisma.championship.create({
     *   data: {
     *     // ... data to create a Championship
     *   }
     * })
     * 
     */
    create<T extends ChampionshipCreateArgs>(args: SelectSubset<T, ChampionshipCreateArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Championships.
     * @param {ChampionshipCreateManyArgs} args - Arguments to create many Championships.
     * @example
     * // Create many Championships
     * const championship = await prisma.championship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipCreateManyArgs>(args?: SelectSubset<T, ChampionshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Championships and returns the data saved in the database.
     * @param {ChampionshipCreateManyAndReturnArgs} args - Arguments to create many Championships.
     * @example
     * // Create many Championships
     * const championship = await prisma.championship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Championships and only return the `id`
     * const championshipWithIdOnly = await prisma.championship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Championship.
     * @param {ChampionshipDeleteArgs} args - Arguments to delete one Championship.
     * @example
     * // Delete one Championship
     * const Championship = await prisma.championship.delete({
     *   where: {
     *     // ... filter to delete one Championship
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipDeleteArgs>(args: SelectSubset<T, ChampionshipDeleteArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Championship.
     * @param {ChampionshipUpdateArgs} args - Arguments to update one Championship.
     * @example
     * // Update one Championship
     * const championship = await prisma.championship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipUpdateArgs>(args: SelectSubset<T, ChampionshipUpdateArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Championships.
     * @param {ChampionshipDeleteManyArgs} args - Arguments to filter Championships to delete.
     * @example
     * // Delete a few Championships
     * const { count } = await prisma.championship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipDeleteManyArgs>(args?: SelectSubset<T, ChampionshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Championships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Championships
     * const championship = await prisma.championship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipUpdateManyArgs>(args: SelectSubset<T, ChampionshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Championships and returns the data updated in the database.
     * @param {ChampionshipUpdateManyAndReturnArgs} args - Arguments to update many Championships.
     * @example
     * // Update many Championships
     * const championship = await prisma.championship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Championships and only return the `id`
     * const championshipWithIdOnly = await prisma.championship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Championship.
     * @param {ChampionshipUpsertArgs} args - Arguments to update or create a Championship.
     * @example
     * // Update or create a Championship
     * const championship = await prisma.championship.upsert({
     *   create: {
     *     // ... data to create a Championship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Championship we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipUpsertArgs>(args: SelectSubset<T, ChampionshipUpsertArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Championships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipCountArgs} args - Arguments to filter Championships to count.
     * @example
     * // Count the number of Championships
     * const count = await prisma.championship.count({
     *   where: {
     *     // ... the filter for the Championships we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipCountArgs>(
      args?: Subset<T, ChampionshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Championship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipAggregateArgs>(args: Subset<T, ChampionshipAggregateArgs>): Prisma.PrismaPromise<GetChampionshipAggregateType<T>>

    /**
     * Group by Championship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Championship model
   */
  readonly fields: ChampionshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Championship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    records<T extends Championship$recordsArgs<ExtArgs> = {}>(args?: Subset<T, Championship$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Championship model
   */
  interface ChampionshipFieldRefs {
    readonly id: FieldRef<"Championship", 'String'>
    readonly isUnlock: FieldRef<"Championship", 'Boolean'>
    readonly unlockedAt: FieldRef<"Championship", 'DateTime'>
    readonly championshipId: FieldRef<"Championship", 'String'>
    readonly zoneId: FieldRef<"Championship", 'String'>
    readonly createdAt: FieldRef<"Championship", 'DateTime'>
    readonly updatedAt: FieldRef<"Championship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Championship findUnique
   */
  export type ChampionshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship findUniqueOrThrow
   */
  export type ChampionshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship findFirst
   */
  export type ChampionshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Championships.
     */
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship findFirstOrThrow
   */
  export type ChampionshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Championships.
     */
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship findMany
   */
  export type ChampionshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championships to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship create
   */
  export type ChampionshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Championship.
     */
    data: XOR<ChampionshipCreateInput, ChampionshipUncheckedCreateInput>
  }

  /**
   * Championship createMany
   */
  export type ChampionshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Championships.
     */
    data: ChampionshipCreateManyInput | ChampionshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Championship createManyAndReturn
   */
  export type ChampionshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * The data used to create many Championships.
     */
    data: ChampionshipCreateManyInput | ChampionshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Championship update
   */
  export type ChampionshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Championship.
     */
    data: XOR<ChampionshipUpdateInput, ChampionshipUncheckedUpdateInput>
    /**
     * Choose, which Championship to update.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship updateMany
   */
  export type ChampionshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Championships.
     */
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyInput>
    /**
     * Filter which Championships to update
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to update.
     */
    limit?: number
  }

  /**
   * Championship updateManyAndReturn
   */
  export type ChampionshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * The data used to update Championships.
     */
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyInput>
    /**
     * Filter which Championships to update
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Championship upsert
   */
  export type ChampionshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Championship to update in case it exists.
     */
    where: ChampionshipWhereUniqueInput
    /**
     * In case the Championship found by the `where` argument doesn't exist, create a new Championship with this data.
     */
    create: XOR<ChampionshipCreateInput, ChampionshipUncheckedCreateInput>
    /**
     * In case the Championship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipUpdateInput, ChampionshipUncheckedUpdateInput>
  }

  /**
   * Championship delete
   */
  export type ChampionshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter which Championship to delete.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship deleteMany
   */
  export type ChampionshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Championships to delete
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to delete.
     */
    limit?: number
  }

  /**
   * Championship.records
   */
  export type Championship$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    where?: ChampionshipRecordWhereInput
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    cursor?: ChampionshipRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * Championship without action
   */
  export type ChampionshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
  }


  /**
   * Model GempoRecord
   */

  export type AggregateGempoRecord = {
    _count: GempoRecordCountAggregateOutputType | null
    _avg: GempoRecordAvgAggregateOutputType | null
    _sum: GempoRecordSumAggregateOutputType | null
    _min: GempoRecordMinAggregateOutputType | null
    _max: GempoRecordMaxAggregateOutputType | null
  }

  export type GempoRecordAvgAggregateOutputType = {
    played: number | null
    point: number | null
  }

  export type GempoRecordSumAggregateOutputType = {
    played: number | null
    point: number | null
  }

  export type GempoRecordMinAggregateOutputType = {
    id: string | null
    recordId: string | null
    gempoId: string | null
    played: number | null
    point: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GempoRecordMaxAggregateOutputType = {
    id: string | null
    recordId: string | null
    gempoId: string | null
    played: number | null
    point: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GempoRecordCountAggregateOutputType = {
    id: number
    recordId: number
    gempoId: number
    played: number
    point: number
    lastPlayedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GempoRecordAvgAggregateInputType = {
    played?: true
    point?: true
  }

  export type GempoRecordSumAggregateInputType = {
    played?: true
    point?: true
  }

  export type GempoRecordMinAggregateInputType = {
    id?: true
    recordId?: true
    gempoId?: true
    played?: true
    point?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GempoRecordMaxAggregateInputType = {
    id?: true
    recordId?: true
    gempoId?: true
    played?: true
    point?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GempoRecordCountAggregateInputType = {
    id?: true
    recordId?: true
    gempoId?: true
    played?: true
    point?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GempoRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GempoRecord to aggregate.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GempoRecords
    **/
    _count?: true | GempoRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GempoRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GempoRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GempoRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GempoRecordMaxAggregateInputType
  }

  export type GetGempoRecordAggregateType<T extends GempoRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateGempoRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGempoRecord[P]>
      : GetScalarType<T[P], AggregateGempoRecord[P]>
  }




  export type GempoRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoRecordWhereInput
    orderBy?: GempoRecordOrderByWithAggregationInput | GempoRecordOrderByWithAggregationInput[]
    by: GempoRecordScalarFieldEnum[] | GempoRecordScalarFieldEnum
    having?: GempoRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GempoRecordCountAggregateInputType | true
    _avg?: GempoRecordAvgAggregateInputType
    _sum?: GempoRecordSumAggregateInputType
    _min?: GempoRecordMinAggregateInputType
    _max?: GempoRecordMaxAggregateInputType
  }

  export type GempoRecordGroupByOutputType = {
    id: string
    recordId: string
    gempoId: string
    played: number
    point: number
    lastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: GempoRecordCountAggregateOutputType | null
    _avg: GempoRecordAvgAggregateOutputType | null
    _sum: GempoRecordSumAggregateOutputType | null
    _min: GempoRecordMinAggregateOutputType | null
    _max: GempoRecordMaxAggregateOutputType | null
  }

  type GetGempoRecordGroupByPayload<T extends GempoRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GempoRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GempoRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GempoRecordGroupByOutputType[P]>
            : GetScalarType<T[P], GempoRecordGroupByOutputType[P]>
        }
      >
    >


  export type GempoRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordId?: boolean
    gempoId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempo?: boolean | GempoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordId?: boolean
    gempoId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempo?: boolean | GempoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordId?: boolean
    gempoId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempo?: boolean | GempoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectScalar = {
    id?: boolean
    recordId?: boolean
    gempoId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GempoRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordId" | "gempoId" | "played" | "point" | "lastPlayedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["gempoRecord"]>
  export type GempoRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gempo?: boolean | GempoDefaultArgs<ExtArgs>
  }
  export type GempoRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gempo?: boolean | GempoDefaultArgs<ExtArgs>
  }
  export type GempoRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gempo?: boolean | GempoDefaultArgs<ExtArgs>
  }

  export type $GempoRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GempoRecord"
    objects: {
      gempo: Prisma.$GempoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordId: string
      gempoId: string
      played: number
      point: number
      lastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gempoRecord"]>
    composites: {}
  }

  type GempoRecordGetPayload<S extends boolean | null | undefined | GempoRecordDefaultArgs> = $Result.GetResult<Prisma.$GempoRecordPayload, S>

  type GempoRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GempoRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GempoRecordCountAggregateInputType | true
    }

  export interface GempoRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GempoRecord'], meta: { name: 'GempoRecord' } }
    /**
     * Find zero or one GempoRecord that matches the filter.
     * @param {GempoRecordFindUniqueArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GempoRecordFindUniqueArgs>(args: SelectSubset<T, GempoRecordFindUniqueArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GempoRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GempoRecordFindUniqueOrThrowArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GempoRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, GempoRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GempoRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindFirstArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GempoRecordFindFirstArgs>(args?: SelectSubset<T, GempoRecordFindFirstArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GempoRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindFirstOrThrowArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GempoRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, GempoRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GempoRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GempoRecords
     * const gempoRecords = await prisma.gempoRecord.findMany()
     * 
     * // Get first 10 GempoRecords
     * const gempoRecords = await prisma.gempoRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GempoRecordFindManyArgs>(args?: SelectSubset<T, GempoRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GempoRecord.
     * @param {GempoRecordCreateArgs} args - Arguments to create a GempoRecord.
     * @example
     * // Create one GempoRecord
     * const GempoRecord = await prisma.gempoRecord.create({
     *   data: {
     *     // ... data to create a GempoRecord
     *   }
     * })
     * 
     */
    create<T extends GempoRecordCreateArgs>(args: SelectSubset<T, GempoRecordCreateArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GempoRecords.
     * @param {GempoRecordCreateManyArgs} args - Arguments to create many GempoRecords.
     * @example
     * // Create many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GempoRecordCreateManyArgs>(args?: SelectSubset<T, GempoRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GempoRecords and returns the data saved in the database.
     * @param {GempoRecordCreateManyAndReturnArgs} args - Arguments to create many GempoRecords.
     * @example
     * // Create many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GempoRecords and only return the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GempoRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, GempoRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GempoRecord.
     * @param {GempoRecordDeleteArgs} args - Arguments to delete one GempoRecord.
     * @example
     * // Delete one GempoRecord
     * const GempoRecord = await prisma.gempoRecord.delete({
     *   where: {
     *     // ... filter to delete one GempoRecord
     *   }
     * })
     * 
     */
    delete<T extends GempoRecordDeleteArgs>(args: SelectSubset<T, GempoRecordDeleteArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GempoRecord.
     * @param {GempoRecordUpdateArgs} args - Arguments to update one GempoRecord.
     * @example
     * // Update one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GempoRecordUpdateArgs>(args: SelectSubset<T, GempoRecordUpdateArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GempoRecords.
     * @param {GempoRecordDeleteManyArgs} args - Arguments to filter GempoRecords to delete.
     * @example
     * // Delete a few GempoRecords
     * const { count } = await prisma.gempoRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GempoRecordDeleteManyArgs>(args?: SelectSubset<T, GempoRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GempoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GempoRecordUpdateManyArgs>(args: SelectSubset<T, GempoRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GempoRecords and returns the data updated in the database.
     * @param {GempoRecordUpdateManyAndReturnArgs} args - Arguments to update many GempoRecords.
     * @example
     * // Update many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GempoRecords and only return the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GempoRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, GempoRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GempoRecord.
     * @param {GempoRecordUpsertArgs} args - Arguments to update or create a GempoRecord.
     * @example
     * // Update or create a GempoRecord
     * const gempoRecord = await prisma.gempoRecord.upsert({
     *   create: {
     *     // ... data to create a GempoRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GempoRecord we want to update
     *   }
     * })
     */
    upsert<T extends GempoRecordUpsertArgs>(args: SelectSubset<T, GempoRecordUpsertArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GempoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordCountArgs} args - Arguments to filter GempoRecords to count.
     * @example
     * // Count the number of GempoRecords
     * const count = await prisma.gempoRecord.count({
     *   where: {
     *     // ... the filter for the GempoRecords we want to count
     *   }
     * })
    **/
    count<T extends GempoRecordCountArgs>(
      args?: Subset<T, GempoRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GempoRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GempoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GempoRecordAggregateArgs>(args: Subset<T, GempoRecordAggregateArgs>): Prisma.PrismaPromise<GetGempoRecordAggregateType<T>>

    /**
     * Group by GempoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GempoRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GempoRecordGroupByArgs['orderBy'] }
        : { orderBy?: GempoRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GempoRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGempoRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GempoRecord model
   */
  readonly fields: GempoRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GempoRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GempoRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gempo<T extends GempoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GempoDefaultArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GempoRecord model
   */
  interface GempoRecordFieldRefs {
    readonly id: FieldRef<"GempoRecord", 'String'>
    readonly recordId: FieldRef<"GempoRecord", 'String'>
    readonly gempoId: FieldRef<"GempoRecord", 'String'>
    readonly played: FieldRef<"GempoRecord", 'Int'>
    readonly point: FieldRef<"GempoRecord", 'Int'>
    readonly lastPlayedAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly createdAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"GempoRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GempoRecord findUnique
   */
  export type GempoRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord findUniqueOrThrow
   */
  export type GempoRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord findFirst
   */
  export type GempoRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GempoRecords.
     */
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord findFirstOrThrow
   */
  export type GempoRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GempoRecords.
     */
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord findMany
   */
  export type GempoRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecords to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord create
   */
  export type GempoRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a GempoRecord.
     */
    data: XOR<GempoRecordCreateInput, GempoRecordUncheckedCreateInput>
  }

  /**
   * GempoRecord createMany
   */
  export type GempoRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GempoRecords.
     */
    data: GempoRecordCreateManyInput | GempoRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GempoRecord createManyAndReturn
   */
  export type GempoRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * The data used to create many GempoRecords.
     */
    data: GempoRecordCreateManyInput | GempoRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GempoRecord update
   */
  export type GempoRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a GempoRecord.
     */
    data: XOR<GempoRecordUpdateInput, GempoRecordUncheckedUpdateInput>
    /**
     * Choose, which GempoRecord to update.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord updateMany
   */
  export type GempoRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GempoRecords.
     */
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyInput>
    /**
     * Filter which GempoRecords to update
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to update.
     */
    limit?: number
  }

  /**
   * GempoRecord updateManyAndReturn
   */
  export type GempoRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * The data used to update GempoRecords.
     */
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyInput>
    /**
     * Filter which GempoRecords to update
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GempoRecord upsert
   */
  export type GempoRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the GempoRecord to update in case it exists.
     */
    where: GempoRecordWhereUniqueInput
    /**
     * In case the GempoRecord found by the `where` argument doesn't exist, create a new GempoRecord with this data.
     */
    create: XOR<GempoRecordCreateInput, GempoRecordUncheckedCreateInput>
    /**
     * In case the GempoRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GempoRecordUpdateInput, GempoRecordUncheckedUpdateInput>
  }

  /**
   * GempoRecord delete
   */
  export type GempoRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter which GempoRecord to delete.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord deleteMany
   */
  export type GempoRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GempoRecords to delete
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to delete.
     */
    limit?: number
  }

  /**
   * GempoRecord without action
   */
  export type GempoRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
  }


  /**
   * Model ChampionshipRecord
   */

  export type AggregateChampionshipRecord = {
    _count: ChampionshipRecordCountAggregateOutputType | null
    _avg: ChampionshipRecordAvgAggregateOutputType | null
    _sum: ChampionshipRecordSumAggregateOutputType | null
    _min: ChampionshipRecordMinAggregateOutputType | null
    _max: ChampionshipRecordMaxAggregateOutputType | null
  }

  export type ChampionshipRecordAvgAggregateOutputType = {
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
  }

  export type ChampionshipRecordSumAggregateOutputType = {
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
  }

  export type ChampionshipRecordMinAggregateOutputType = {
    id: string | null
    recordId: string | null
    championshipId: string | null
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    teamLastPlayedAt: Date | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
    soloLastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChampionshipRecordMaxAggregateOutputType = {
    id: string | null
    recordId: string | null
    championshipId: string | null
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    teamLastPlayedAt: Date | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
    soloLastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChampionshipRecordCountAggregateOutputType = {
    id: number
    recordId: number
    championshipId: number
    teamWin: number
    teamLose: number
    teamPlayed: number
    teamPoint: number
    teamLastPlayedAt: number
    soloWin: number
    soloLose: number
    soloPlayed: number
    soloPoint: number
    soloLastPlayedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChampionshipRecordAvgAggregateInputType = {
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
  }

  export type ChampionshipRecordSumAggregateInputType = {
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
  }

  export type ChampionshipRecordMinAggregateInputType = {
    id?: true
    recordId?: true
    championshipId?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChampionshipRecordMaxAggregateInputType = {
    id?: true
    recordId?: true
    championshipId?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChampionshipRecordCountAggregateInputType = {
    id?: true
    recordId?: true
    championshipId?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChampionshipRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipRecord to aggregate.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChampionshipRecords
    **/
    _count?: true | ChampionshipRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChampionshipRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChampionshipRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipRecordMaxAggregateInputType
  }

  export type GetChampionshipRecordAggregateType<T extends ChampionshipRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionshipRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionshipRecord[P]>
      : GetScalarType<T[P], AggregateChampionshipRecord[P]>
  }




  export type ChampionshipRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipRecordWhereInput
    orderBy?: ChampionshipRecordOrderByWithAggregationInput | ChampionshipRecordOrderByWithAggregationInput[]
    by: ChampionshipRecordScalarFieldEnum[] | ChampionshipRecordScalarFieldEnum
    having?: ChampionshipRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipRecordCountAggregateInputType | true
    _avg?: ChampionshipRecordAvgAggregateInputType
    _sum?: ChampionshipRecordSumAggregateInputType
    _min?: ChampionshipRecordMinAggregateInputType
    _max?: ChampionshipRecordMaxAggregateInputType
  }

  export type ChampionshipRecordGroupByOutputType = {
    id: string
    recordId: string
    championshipId: string
    teamWin: number
    teamLose: number
    teamPlayed: number
    teamPoint: number
    teamLastPlayedAt: Date | null
    soloWin: number
    soloLose: number
    soloPlayed: number
    soloPoint: number
    soloLastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ChampionshipRecordCountAggregateOutputType | null
    _avg: ChampionshipRecordAvgAggregateOutputType | null
    _sum: ChampionshipRecordSumAggregateOutputType | null
    _min: ChampionshipRecordMinAggregateOutputType | null
    _max: ChampionshipRecordMaxAggregateOutputType | null
  }

  type GetChampionshipRecordGroupByPayload<T extends ChampionshipRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipRecordGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordId?: boolean
    championshipId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championship?: boolean | ChampionshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordId?: boolean
    championshipId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championship?: boolean | ChampionshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordId?: boolean
    championshipId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championship?: boolean | ChampionshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectScalar = {
    id?: boolean
    recordId?: boolean
    championshipId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChampionshipRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recordId" | "championshipId" | "teamWin" | "teamLose" | "teamPlayed" | "teamPoint" | "teamLastPlayedAt" | "soloWin" | "soloLose" | "soloPlayed" | "soloPoint" | "soloLastPlayedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["championshipRecord"]>
  export type ChampionshipRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    championship?: boolean | ChampionshipDefaultArgs<ExtArgs>
  }
  export type ChampionshipRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    championship?: boolean | ChampionshipDefaultArgs<ExtArgs>
  }
  export type ChampionshipRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    championship?: boolean | ChampionshipDefaultArgs<ExtArgs>
  }

  export type $ChampionshipRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChampionshipRecord"
    objects: {
      championship: Prisma.$ChampionshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordId: string
      championshipId: string
      teamWin: number
      teamLose: number
      teamPlayed: number
      teamPoint: number
      teamLastPlayedAt: Date | null
      soloWin: number
      soloLose: number
      soloPlayed: number
      soloPoint: number
      soloLastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["championshipRecord"]>
    composites: {}
  }

  type ChampionshipRecordGetPayload<S extends boolean | null | undefined | ChampionshipRecordDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipRecordPayload, S>

  type ChampionshipRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipRecordCountAggregateInputType | true
    }

  export interface ChampionshipRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChampionshipRecord'], meta: { name: 'ChampionshipRecord' } }
    /**
     * Find zero or one ChampionshipRecord that matches the filter.
     * @param {ChampionshipRecordFindUniqueArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipRecordFindUniqueArgs>(args: SelectSubset<T, ChampionshipRecordFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChampionshipRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipRecordFindUniqueOrThrowArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindFirstArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipRecordFindFirstArgs>(args?: SelectSubset<T, ChampionshipRecordFindFirstArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindFirstOrThrowArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChampionshipRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChampionshipRecords
     * const championshipRecords = await prisma.championshipRecord.findMany()
     * 
     * // Get first 10 ChampionshipRecords
     * const championshipRecords = await prisma.championshipRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipRecordFindManyArgs>(args?: SelectSubset<T, ChampionshipRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChampionshipRecord.
     * @param {ChampionshipRecordCreateArgs} args - Arguments to create a ChampionshipRecord.
     * @example
     * // Create one ChampionshipRecord
     * const ChampionshipRecord = await prisma.championshipRecord.create({
     *   data: {
     *     // ... data to create a ChampionshipRecord
     *   }
     * })
     * 
     */
    create<T extends ChampionshipRecordCreateArgs>(args: SelectSubset<T, ChampionshipRecordCreateArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChampionshipRecords.
     * @param {ChampionshipRecordCreateManyArgs} args - Arguments to create many ChampionshipRecords.
     * @example
     * // Create many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipRecordCreateManyArgs>(args?: SelectSubset<T, ChampionshipRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChampionshipRecords and returns the data saved in the database.
     * @param {ChampionshipRecordCreateManyAndReturnArgs} args - Arguments to create many ChampionshipRecords.
     * @example
     * // Create many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChampionshipRecords and only return the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChampionshipRecord.
     * @param {ChampionshipRecordDeleteArgs} args - Arguments to delete one ChampionshipRecord.
     * @example
     * // Delete one ChampionshipRecord
     * const ChampionshipRecord = await prisma.championshipRecord.delete({
     *   where: {
     *     // ... filter to delete one ChampionshipRecord
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipRecordDeleteArgs>(args: SelectSubset<T, ChampionshipRecordDeleteArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChampionshipRecord.
     * @param {ChampionshipRecordUpdateArgs} args - Arguments to update one ChampionshipRecord.
     * @example
     * // Update one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipRecordUpdateArgs>(args: SelectSubset<T, ChampionshipRecordUpdateArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChampionshipRecords.
     * @param {ChampionshipRecordDeleteManyArgs} args - Arguments to filter ChampionshipRecords to delete.
     * @example
     * // Delete a few ChampionshipRecords
     * const { count } = await prisma.championshipRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipRecordDeleteManyArgs>(args?: SelectSubset<T, ChampionshipRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipRecordUpdateManyArgs>(args: SelectSubset<T, ChampionshipRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipRecords and returns the data updated in the database.
     * @param {ChampionshipRecordUpdateManyAndReturnArgs} args - Arguments to update many ChampionshipRecords.
     * @example
     * // Update many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChampionshipRecords and only return the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChampionshipRecord.
     * @param {ChampionshipRecordUpsertArgs} args - Arguments to update or create a ChampionshipRecord.
     * @example
     * // Update or create a ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.upsert({
     *   create: {
     *     // ... data to create a ChampionshipRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChampionshipRecord we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipRecordUpsertArgs>(args: SelectSubset<T, ChampionshipRecordUpsertArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChampionshipRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordCountArgs} args - Arguments to filter ChampionshipRecords to count.
     * @example
     * // Count the number of ChampionshipRecords
     * const count = await prisma.championshipRecord.count({
     *   where: {
     *     // ... the filter for the ChampionshipRecords we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipRecordCountArgs>(
      args?: Subset<T, ChampionshipRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChampionshipRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipRecordAggregateArgs>(args: Subset<T, ChampionshipRecordAggregateArgs>): Prisma.PrismaPromise<GetChampionshipRecordAggregateType<T>>

    /**
     * Group by ChampionshipRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipRecordGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChampionshipRecord model
   */
  readonly fields: ChampionshipRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChampionshipRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    championship<T extends ChampionshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChampionshipDefaultArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChampionshipRecord model
   */
  interface ChampionshipRecordFieldRefs {
    readonly id: FieldRef<"ChampionshipRecord", 'String'>
    readonly recordId: FieldRef<"ChampionshipRecord", 'String'>
    readonly championshipId: FieldRef<"ChampionshipRecord", 'String'>
    readonly teamWin: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamLose: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamPlayed: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamPoint: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamLastPlayedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly soloWin: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloLose: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloPlayed: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloPoint: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloLastPlayedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChampionshipRecord findUnique
   */
  export type ChampionshipRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord findUniqueOrThrow
   */
  export type ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord findFirst
   */
  export type ChampionshipRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipRecords.
     */
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord findFirstOrThrow
   */
  export type ChampionshipRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipRecords.
     */
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord findMany
   */
  export type ChampionshipRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecords to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord create
   */
  export type ChampionshipRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ChampionshipRecord.
     */
    data: XOR<ChampionshipRecordCreateInput, ChampionshipRecordUncheckedCreateInput>
  }

  /**
   * ChampionshipRecord createMany
   */
  export type ChampionshipRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChampionshipRecords.
     */
    data: ChampionshipRecordCreateManyInput | ChampionshipRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipRecord createManyAndReturn
   */
  export type ChampionshipRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ChampionshipRecords.
     */
    data: ChampionshipRecordCreateManyInput | ChampionshipRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChampionshipRecord update
   */
  export type ChampionshipRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ChampionshipRecord.
     */
    data: XOR<ChampionshipRecordUpdateInput, ChampionshipRecordUncheckedUpdateInput>
    /**
     * Choose, which ChampionshipRecord to update.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord updateMany
   */
  export type ChampionshipRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChampionshipRecords.
     */
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipRecords to update
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to update.
     */
    limit?: number
  }

  /**
   * ChampionshipRecord updateManyAndReturn
   */
  export type ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * The data used to update ChampionshipRecords.
     */
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipRecords to update
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChampionshipRecord upsert
   */
  export type ChampionshipRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ChampionshipRecord to update in case it exists.
     */
    where: ChampionshipRecordWhereUniqueInput
    /**
     * In case the ChampionshipRecord found by the `where` argument doesn't exist, create a new ChampionshipRecord with this data.
     */
    create: XOR<ChampionshipRecordCreateInput, ChampionshipRecordUncheckedCreateInput>
    /**
     * In case the ChampionshipRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipRecordUpdateInput, ChampionshipRecordUncheckedUpdateInput>
  }

  /**
   * ChampionshipRecord delete
   */
  export type ChampionshipRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter which ChampionshipRecord to delete.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord deleteMany
   */
  export type ChampionshipRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipRecords to delete
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to delete.
     */
    limit?: number
  }

  /**
   * ChampionshipRecord without action
   */
  export type ChampionshipRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
  }


  /**
   * Model UserLogin
   */

  export type AggregateUserLogin = {
    _count: UserLoginCountAggregateOutputType | null
    _min: UserLoginMinAggregateOutputType | null
    _max: UserLoginMaxAggregateOutputType | null
  }

  export type UserLoginMinAggregateOutputType = {
    id: string | null
    userId: string | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type UserLoginMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type UserLoginCountAggregateOutputType = {
    id: number
    userId: number
    loginDate: number
    logoutDate: number
    _all: number
  }


  export type UserLoginMinAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
  }

  export type UserLoginMaxAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
  }

  export type UserLoginCountAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
    _all?: true
  }

  export type UserLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogin to aggregate.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLogins
    **/
    _count?: true | UserLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLoginMaxAggregateInputType
  }

  export type GetUserLoginAggregateType<T extends UserLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLogin[P]>
      : GetScalarType<T[P], AggregateUserLogin[P]>
  }




  export type UserLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginWhereInput
    orderBy?: UserLoginOrderByWithAggregationInput | UserLoginOrderByWithAggregationInput[]
    by: UserLoginScalarFieldEnum[] | UserLoginScalarFieldEnum
    having?: UserLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLoginCountAggregateInputType | true
    _min?: UserLoginMinAggregateInputType
    _max?: UserLoginMaxAggregateInputType
  }

  export type UserLoginGroupByOutputType = {
    id: string
    userId: string
    loginDate: Date
    logoutDate: Date | null
    _count: UserLoginCountAggregateOutputType | null
    _min: UserLoginMinAggregateOutputType | null
    _max: UserLoginMaxAggregateOutputType | null
  }

  type GetUserLoginGroupByPayload<T extends UserLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLoginGroupByOutputType[P]>
            : GetScalarType<T[P], UserLoginGroupByOutputType[P]>
        }
      >
    >


  export type UserLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectScalar = {
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
  }

  export type UserLoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "loginDate" | "logoutDate", ExtArgs["result"]["userLogin"]>
  export type UserLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLogin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      loginDate: Date
      logoutDate: Date | null
    }, ExtArgs["result"]["userLogin"]>
    composites: {}
  }

  type UserLoginGetPayload<S extends boolean | null | undefined | UserLoginDefaultArgs> = $Result.GetResult<Prisma.$UserLoginPayload, S>

  type UserLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLoginCountAggregateInputType | true
    }

  export interface UserLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLogin'], meta: { name: 'UserLogin' } }
    /**
     * Find zero or one UserLogin that matches the filter.
     * @param {UserLoginFindUniqueArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLoginFindUniqueArgs>(args: SelectSubset<T, UserLoginFindUniqueArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLogin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLoginFindUniqueOrThrowArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindFirstArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLoginFindFirstArgs>(args?: SelectSubset<T, UserLoginFindFirstArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindFirstOrThrowArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLogins
     * const userLogins = await prisma.userLogin.findMany()
     * 
     * // Get first 10 UserLogins
     * const userLogins = await prisma.userLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLoginFindManyArgs>(args?: SelectSubset<T, UserLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLogin.
     * @param {UserLoginCreateArgs} args - Arguments to create a UserLogin.
     * @example
     * // Create one UserLogin
     * const UserLogin = await prisma.userLogin.create({
     *   data: {
     *     // ... data to create a UserLogin
     *   }
     * })
     * 
     */
    create<T extends UserLoginCreateArgs>(args: SelectSubset<T, UserLoginCreateArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLogins.
     * @param {UserLoginCreateManyArgs} args - Arguments to create many UserLogins.
     * @example
     * // Create many UserLogins
     * const userLogin = await prisma.userLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLoginCreateManyArgs>(args?: SelectSubset<T, UserLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLogins and returns the data saved in the database.
     * @param {UserLoginCreateManyAndReturnArgs} args - Arguments to create many UserLogins.
     * @example
     * // Create many UserLogins
     * const userLogin = await prisma.userLogin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLogins and only return the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLoginCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLoginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLogin.
     * @param {UserLoginDeleteArgs} args - Arguments to delete one UserLogin.
     * @example
     * // Delete one UserLogin
     * const UserLogin = await prisma.userLogin.delete({
     *   where: {
     *     // ... filter to delete one UserLogin
     *   }
     * })
     * 
     */
    delete<T extends UserLoginDeleteArgs>(args: SelectSubset<T, UserLoginDeleteArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLogin.
     * @param {UserLoginUpdateArgs} args - Arguments to update one UserLogin.
     * @example
     * // Update one UserLogin
     * const userLogin = await prisma.userLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLoginUpdateArgs>(args: SelectSubset<T, UserLoginUpdateArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLogins.
     * @param {UserLoginDeleteManyArgs} args - Arguments to filter UserLogins to delete.
     * @example
     * // Delete a few UserLogins
     * const { count } = await prisma.userLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLoginDeleteManyArgs>(args?: SelectSubset<T, UserLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLogins
     * const userLogin = await prisma.userLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLoginUpdateManyArgs>(args: SelectSubset<T, UserLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogins and returns the data updated in the database.
     * @param {UserLoginUpdateManyAndReturnArgs} args - Arguments to update many UserLogins.
     * @example
     * // Update many UserLogins
     * const userLogin = await prisma.userLogin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLogins and only return the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLoginUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLoginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLogin.
     * @param {UserLoginUpsertArgs} args - Arguments to update or create a UserLogin.
     * @example
     * // Update or create a UserLogin
     * const userLogin = await prisma.userLogin.upsert({
     *   create: {
     *     // ... data to create a UserLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLogin we want to update
     *   }
     * })
     */
    upsert<T extends UserLoginUpsertArgs>(args: SelectSubset<T, UserLoginUpsertArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginCountArgs} args - Arguments to filter UserLogins to count.
     * @example
     * // Count the number of UserLogins
     * const count = await prisma.userLogin.count({
     *   where: {
     *     // ... the filter for the UserLogins we want to count
     *   }
     * })
    **/
    count<T extends UserLoginCountArgs>(
      args?: Subset<T, UserLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLoginAggregateArgs>(args: Subset<T, UserLoginAggregateArgs>): Prisma.PrismaPromise<GetUserLoginAggregateType<T>>

    /**
     * Group by UserLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLoginGroupByArgs['orderBy'] }
        : { orderBy?: UserLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLogin model
   */
  readonly fields: UserLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLogin model
   */
  interface UserLoginFieldRefs {
    readonly id: FieldRef<"UserLogin", 'String'>
    readonly userId: FieldRef<"UserLogin", 'String'>
    readonly loginDate: FieldRef<"UserLogin", 'DateTime'>
    readonly logoutDate: FieldRef<"UserLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLogin findUnique
   */
  export type UserLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin findUniqueOrThrow
   */
  export type UserLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin findFirst
   */
  export type UserLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogins.
     */
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin findFirstOrThrow
   */
  export type UserLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogins.
     */
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin findMany
   */
  export type UserLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogins to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin create
   */
  export type UserLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLogin.
     */
    data: XOR<UserLoginCreateInput, UserLoginUncheckedCreateInput>
  }

  /**
   * UserLogin createMany
   */
  export type UserLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLogins.
     */
    data: UserLoginCreateManyInput | UserLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLogin createManyAndReturn
   */
  export type UserLoginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * The data used to create many UserLogins.
     */
    data: UserLoginCreateManyInput | UserLoginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLogin update
   */
  export type UserLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLogin.
     */
    data: XOR<UserLoginUpdateInput, UserLoginUncheckedUpdateInput>
    /**
     * Choose, which UserLogin to update.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin updateMany
   */
  export type UserLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLogins.
     */
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyInput>
    /**
     * Filter which UserLogins to update
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to update.
     */
    limit?: number
  }

  /**
   * UserLogin updateManyAndReturn
   */
  export type UserLoginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * The data used to update UserLogins.
     */
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyInput>
    /**
     * Filter which UserLogins to update
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLogin upsert
   */
  export type UserLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLogin to update in case it exists.
     */
    where: UserLoginWhereUniqueInput
    /**
     * In case the UserLogin found by the `where` argument doesn't exist, create a new UserLogin with this data.
     */
    create: XOR<UserLoginCreateInput, UserLoginUncheckedCreateInput>
    /**
     * In case the UserLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLoginUpdateInput, UserLoginUncheckedUpdateInput>
  }

  /**
   * UserLogin delete
   */
  export type UserLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter which UserLogin to delete.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin deleteMany
   */
  export type UserLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogins to delete
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to delete.
     */
    limit?: number
  }

  /**
   * UserLogin without action
   */
  export type UserLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    authId: number
    email: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    authId: string
    email: string
    name: string
    role: $Enums.Role | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Admin$userArgs<ExtArgs>
    authority?: boolean | Admin$authorityArgs<ExtArgs>
    operationHistories?: boolean | Admin$operationHistoriesArgs<ExtArgs>
    operations?: boolean | Admin$operationsArgs<ExtArgs>
    banner?: boolean | Admin$bannerArgs<ExtArgs>
    adminTransaction?: boolean | Admin$adminTransactionArgs<ExtArgs>
    adminTransactionArchive?: boolean | Admin$adminTransactionArchiveArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "email" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Admin$userArgs<ExtArgs>
    authority?: boolean | Admin$authorityArgs<ExtArgs>
    operationHistories?: boolean | Admin$operationHistoriesArgs<ExtArgs>
    operations?: boolean | Admin$operationsArgs<ExtArgs>
    banner?: boolean | Admin$bannerArgs<ExtArgs>
    adminTransaction?: boolean | Admin$adminTransactionArgs<ExtArgs>
    adminTransactionArchive?: boolean | Admin$adminTransactionArchiveArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      authority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      operationHistories: Prisma.$AdminOperationHistoryPayload<ExtArgs>[]
      operations: Prisma.$AdminOperationHistoryPayload<ExtArgs>[]
      banner: Prisma.$BannerPayload<ExtArgs>[]
      adminTransaction: Prisma.$AdminTransactionPayload<ExtArgs>[]
      adminTransactionArchive: Prisma.$AdminTransactionArchivePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      email: string
      name: string
      role: $Enums.Role | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Admin$userArgs<ExtArgs> = {}>(args?: Subset<T, Admin$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    authority<T extends Admin$authorityArgs<ExtArgs> = {}>(args?: Subset<T, Admin$authorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operationHistories<T extends Admin$operationHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$operationHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operations<T extends Admin$operationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banner<T extends Admin$bannerArgs<ExtArgs> = {}>(args?: Subset<T, Admin$bannerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminTransaction<T extends Admin$adminTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Admin$adminTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminTransactionArchive<T extends Admin$adminTransactionArchiveArgs<ExtArgs> = {}>(args?: Subset<T, Admin$adminTransactionArchiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly authId: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'Role'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.user
   */
  export type Admin$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Admin.authority
   */
  export type Admin$authorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Admin.operationHistories
   */
  export type Admin$operationHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    cursor?: AdminOperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * Admin.operations
   */
  export type Admin$operationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    cursor?: AdminOperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * Admin.banner
   */
  export type Admin$bannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    cursor?: BannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Admin.adminTransaction
   */
  export type Admin$adminTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    cursor?: AdminTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * Admin.adminTransactionArchive
   */
  export type Admin$adminTransactionArchiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    where?: AdminTransactionArchiveWhereInput
    orderBy?: AdminTransactionArchiveOrderByWithRelationInput | AdminTransactionArchiveOrderByWithRelationInput[]
    cursor?: AdminTransactionArchiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminTransactionArchiveScalarFieldEnum | AdminTransactionArchiveScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model AdminOperationHistory
   */

  export type AggregateAdminOperationHistory = {
    _count: AdminOperationHistoryCountAggregateOutputType | null
    _min: AdminOperationHistoryMinAggregateOutputType | null
    _max: AdminOperationHistoryMaxAggregateOutputType | null
  }

  export type AdminOperationHistoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    adminId: string | null
    opAdminId: string | null
    operation: $Enums.Operation | null
  }

  export type AdminOperationHistoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    adminId: string | null
    opAdminId: string | null
    operation: $Enums.Operation | null
  }

  export type AdminOperationHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    adminId: number
    opAdminId: number
    operation: number
    _all: number
  }


  export type AdminOperationHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
  }

  export type AdminOperationHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
  }

  export type AdminOperationHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
    _all?: true
  }

  export type AdminOperationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminOperationHistory to aggregate.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminOperationHistories
    **/
    _count?: true | AdminOperationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminOperationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminOperationHistoryMaxAggregateInputType
  }

  export type GetAdminOperationHistoryAggregateType<T extends AdminOperationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminOperationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminOperationHistory[P]>
      : GetScalarType<T[P], AggregateAdminOperationHistory[P]>
  }




  export type AdminOperationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithAggregationInput | AdminOperationHistoryOrderByWithAggregationInput[]
    by: AdminOperationHistoryScalarFieldEnum[] | AdminOperationHistoryScalarFieldEnum
    having?: AdminOperationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminOperationHistoryCountAggregateInputType | true
    _min?: AdminOperationHistoryMinAggregateInputType
    _max?: AdminOperationHistoryMaxAggregateInputType
  }

  export type AdminOperationHistoryGroupByOutputType = {
    id: string
    createdAt: Date
    adminId: string
    opAdminId: string
    operation: $Enums.Operation
    _count: AdminOperationHistoryCountAggregateOutputType | null
    _min: AdminOperationHistoryMinAggregateOutputType | null
    _max: AdminOperationHistoryMaxAggregateOutputType | null
  }

  type GetAdminOperationHistoryGroupByPayload<T extends AdminOperationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminOperationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminOperationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminOperationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AdminOperationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AdminOperationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
  }

  export type AdminOperationHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "adminId" | "opAdminId" | "operation", ExtArgs["result"]["adminOperationHistory"]>
  export type AdminOperationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminOperationHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminOperationHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminOperationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminOperationHistory"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      opAdmin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      adminId: string
      opAdminId: string
      operation: $Enums.Operation
    }, ExtArgs["result"]["adminOperationHistory"]>
    composites: {}
  }

  type AdminOperationHistoryGetPayload<S extends boolean | null | undefined | AdminOperationHistoryDefaultArgs> = $Result.GetResult<Prisma.$AdminOperationHistoryPayload, S>

  type AdminOperationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminOperationHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminOperationHistoryCountAggregateInputType | true
    }

  export interface AdminOperationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminOperationHistory'], meta: { name: 'AdminOperationHistory' } }
    /**
     * Find zero or one AdminOperationHistory that matches the filter.
     * @param {AdminOperationHistoryFindUniqueArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminOperationHistoryFindUniqueArgs>(args: SelectSubset<T, AdminOperationHistoryFindUniqueArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminOperationHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminOperationHistoryFindUniqueOrThrowArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminOperationHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminOperationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindFirstArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminOperationHistoryFindFirstArgs>(args?: SelectSubset<T, AdminOperationHistoryFindFirstArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminOperationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindFirstOrThrowArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminOperationHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminOperationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminOperationHistories
     * const adminOperationHistories = await prisma.adminOperationHistory.findMany()
     * 
     * // Get first 10 AdminOperationHistories
     * const adminOperationHistories = await prisma.adminOperationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminOperationHistoryFindManyArgs>(args?: SelectSubset<T, AdminOperationHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminOperationHistory.
     * @param {AdminOperationHistoryCreateArgs} args - Arguments to create a AdminOperationHistory.
     * @example
     * // Create one AdminOperationHistory
     * const AdminOperationHistory = await prisma.adminOperationHistory.create({
     *   data: {
     *     // ... data to create a AdminOperationHistory
     *   }
     * })
     * 
     */
    create<T extends AdminOperationHistoryCreateArgs>(args: SelectSubset<T, AdminOperationHistoryCreateArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminOperationHistories.
     * @param {AdminOperationHistoryCreateManyArgs} args - Arguments to create many AdminOperationHistories.
     * @example
     * // Create many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminOperationHistoryCreateManyArgs>(args?: SelectSubset<T, AdminOperationHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminOperationHistories and returns the data saved in the database.
     * @param {AdminOperationHistoryCreateManyAndReturnArgs} args - Arguments to create many AdminOperationHistories.
     * @example
     * // Create many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminOperationHistories and only return the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminOperationHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminOperationHistory.
     * @param {AdminOperationHistoryDeleteArgs} args - Arguments to delete one AdminOperationHistory.
     * @example
     * // Delete one AdminOperationHistory
     * const AdminOperationHistory = await prisma.adminOperationHistory.delete({
     *   where: {
     *     // ... filter to delete one AdminOperationHistory
     *   }
     * })
     * 
     */
    delete<T extends AdminOperationHistoryDeleteArgs>(args: SelectSubset<T, AdminOperationHistoryDeleteArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminOperationHistory.
     * @param {AdminOperationHistoryUpdateArgs} args - Arguments to update one AdminOperationHistory.
     * @example
     * // Update one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminOperationHistoryUpdateArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminOperationHistories.
     * @param {AdminOperationHistoryDeleteManyArgs} args - Arguments to filter AdminOperationHistories to delete.
     * @example
     * // Delete a few AdminOperationHistories
     * const { count } = await prisma.adminOperationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminOperationHistoryDeleteManyArgs>(args?: SelectSubset<T, AdminOperationHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminOperationHistoryUpdateManyArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOperationHistories and returns the data updated in the database.
     * @param {AdminOperationHistoryUpdateManyAndReturnArgs} args - Arguments to update many AdminOperationHistories.
     * @example
     * // Update many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminOperationHistories and only return the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminOperationHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminOperationHistory.
     * @param {AdminOperationHistoryUpsertArgs} args - Arguments to update or create a AdminOperationHistory.
     * @example
     * // Update or create a AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.upsert({
     *   create: {
     *     // ... data to create a AdminOperationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminOperationHistory we want to update
     *   }
     * })
     */
    upsert<T extends AdminOperationHistoryUpsertArgs>(args: SelectSubset<T, AdminOperationHistoryUpsertArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminOperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryCountArgs} args - Arguments to filter AdminOperationHistories to count.
     * @example
     * // Count the number of AdminOperationHistories
     * const count = await prisma.adminOperationHistory.count({
     *   where: {
     *     // ... the filter for the AdminOperationHistories we want to count
     *   }
     * })
    **/
    count<T extends AdminOperationHistoryCountArgs>(
      args?: Subset<T, AdminOperationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminOperationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminOperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminOperationHistoryAggregateArgs>(args: Subset<T, AdminOperationHistoryAggregateArgs>): Prisma.PrismaPromise<GetAdminOperationHistoryAggregateType<T>>

    /**
     * Group by AdminOperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminOperationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminOperationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AdminOperationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminOperationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminOperationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminOperationHistory model
   */
  readonly fields: AdminOperationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminOperationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminOperationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminOperationHistory model
   */
  interface AdminOperationHistoryFieldRefs {
    readonly id: FieldRef<"AdminOperationHistory", 'String'>
    readonly createdAt: FieldRef<"AdminOperationHistory", 'DateTime'>
    readonly adminId: FieldRef<"AdminOperationHistory", 'String'>
    readonly opAdminId: FieldRef<"AdminOperationHistory", 'String'>
    readonly operation: FieldRef<"AdminOperationHistory", 'Operation'>
  }
    

  // Custom InputTypes
  /**
   * AdminOperationHistory findUnique
   */
  export type AdminOperationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory findUniqueOrThrow
   */
  export type AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory findFirst
   */
  export type AdminOperationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOperationHistories.
     */
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory findFirstOrThrow
   */
  export type AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOperationHistories.
     */
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory findMany
   */
  export type AdminOperationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistories to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory create
   */
  export type AdminOperationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminOperationHistory.
     */
    data: XOR<AdminOperationHistoryCreateInput, AdminOperationHistoryUncheckedCreateInput>
  }

  /**
   * AdminOperationHistory createMany
   */
  export type AdminOperationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminOperationHistories.
     */
    data: AdminOperationHistoryCreateManyInput | AdminOperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminOperationHistory createManyAndReturn
   */
  export type AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many AdminOperationHistories.
     */
    data: AdminOperationHistoryCreateManyInput | AdminOperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminOperationHistory update
   */
  export type AdminOperationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminOperationHistory.
     */
    data: XOR<AdminOperationHistoryUpdateInput, AdminOperationHistoryUncheckedUpdateInput>
    /**
     * Choose, which AdminOperationHistory to update.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory updateMany
   */
  export type AdminOperationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminOperationHistories.
     */
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AdminOperationHistories to update
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to update.
     */
    limit?: number
  }

  /**
   * AdminOperationHistory updateManyAndReturn
   */
  export type AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * The data used to update AdminOperationHistories.
     */
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AdminOperationHistories to update
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminOperationHistory upsert
   */
  export type AdminOperationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminOperationHistory to update in case it exists.
     */
    where: AdminOperationHistoryWhereUniqueInput
    /**
     * In case the AdminOperationHistory found by the `where` argument doesn't exist, create a new AdminOperationHistory with this data.
     */
    create: XOR<AdminOperationHistoryCreateInput, AdminOperationHistoryUncheckedCreateInput>
    /**
     * In case the AdminOperationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminOperationHistoryUpdateInput, AdminOperationHistoryUncheckedUpdateInput>
  }

  /**
   * AdminOperationHistory delete
   */
  export type AdminOperationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter which AdminOperationHistory to delete.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory deleteMany
   */
  export type AdminOperationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminOperationHistories to delete
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to delete.
     */
    limit?: number
  }

  /**
   * AdminOperationHistory without action
   */
  export type AdminOperationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuthority
   */

  export type AggregateAdminAuthority = {
    _count: AdminAuthorityCountAggregateOutputType | null
    _avg: AdminAuthorityAvgAggregateOutputType | null
    _sum: AdminAuthoritySumAggregateOutputType | null
    _min: AdminAuthorityMinAggregateOutputType | null
    _max: AdminAuthorityMaxAggregateOutputType | null
  }

  export type AdminAuthorityAvgAggregateOutputType = {
    grades: number | null
  }

  export type AdminAuthoritySumAggregateOutputType = {
    grades: number[]
  }

  export type AdminAuthorityMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    provinceId: string | null
  }

  export type AdminAuthorityMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    provinceId: string | null
  }

  export type AdminAuthorityCountAggregateOutputType = {
    id: number
    adminId: number
    provinceId: number
    grades: number
    _all: number
  }


  export type AdminAuthorityAvgAggregateInputType = {
    grades?: true
  }

  export type AdminAuthoritySumAggregateInputType = {
    grades?: true
  }

  export type AdminAuthorityMinAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
  }

  export type AdminAuthorityMaxAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
  }

  export type AdminAuthorityCountAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
    grades?: true
    _all?: true
  }

  export type AdminAuthorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuthority to aggregate.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuthorities
    **/
    _count?: true | AdminAuthorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAuthorityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAuthoritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuthorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuthorityMaxAggregateInputType
  }

  export type GetAdminAuthorityAggregateType<T extends AdminAuthorityAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuthority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuthority[P]>
      : GetScalarType<T[P], AggregateAdminAuthority[P]>
  }




  export type AdminAuthorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithAggregationInput | AdminAuthorityOrderByWithAggregationInput[]
    by: AdminAuthorityScalarFieldEnum[] | AdminAuthorityScalarFieldEnum
    having?: AdminAuthorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuthorityCountAggregateInputType | true
    _avg?: AdminAuthorityAvgAggregateInputType
    _sum?: AdminAuthoritySumAggregateInputType
    _min?: AdminAuthorityMinAggregateInputType
    _max?: AdminAuthorityMaxAggregateInputType
  }

  export type AdminAuthorityGroupByOutputType = {
    id: string
    adminId: string
    provinceId: string
    grades: number[]
    _count: AdminAuthorityCountAggregateOutputType | null
    _avg: AdminAuthorityAvgAggregateOutputType | null
    _sum: AdminAuthoritySumAggregateOutputType | null
    _min: AdminAuthorityMinAggregateOutputType | null
    _max: AdminAuthorityMaxAggregateOutputType | null
  }

  type GetAdminAuthorityGroupByPayload<T extends AdminAuthorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuthorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuthorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuthorityGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuthorityGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuthoritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | AdminAuthority$citiesArgs<ExtArgs>
    schools?: boolean | AdminAuthority$schoolsArgs<ExtArgs>
    _count?: boolean | AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectScalar = {
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
  }

  export type AdminAuthorityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "provinceId" | "grades", ExtArgs["result"]["adminAuthority"]>
  export type AdminAuthorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | AdminAuthority$citiesArgs<ExtArgs>
    schools?: boolean | AdminAuthority$schoolsArgs<ExtArgs>
    _count?: boolean | AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminAuthorityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type AdminAuthorityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $AdminAuthorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuthority"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
      schools: Prisma.$SchoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      provinceId: string
      grades: number[]
    }, ExtArgs["result"]["adminAuthority"]>
    composites: {}
  }

  type AdminAuthorityGetPayload<S extends boolean | null | undefined | AdminAuthorityDefaultArgs> = $Result.GetResult<Prisma.$AdminAuthorityPayload, S>

  type AdminAuthorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuthorityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuthorityCountAggregateInputType | true
    }

  export interface AdminAuthorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuthority'], meta: { name: 'AdminAuthority' } }
    /**
     * Find zero or one AdminAuthority that matches the filter.
     * @param {AdminAuthorityFindUniqueArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuthorityFindUniqueArgs>(args: SelectSubset<T, AdminAuthorityFindUniqueArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuthority that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuthorityFindUniqueOrThrowArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuthorityFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuthorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuthority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindFirstArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuthorityFindFirstArgs>(args?: SelectSubset<T, AdminAuthorityFindFirstArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuthority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindFirstOrThrowArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuthorityFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuthorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuthorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuthorities
     * const adminAuthorities = await prisma.adminAuthority.findMany()
     * 
     * // Get first 10 AdminAuthorities
     * const adminAuthorities = await prisma.adminAuthority.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuthorityFindManyArgs>(args?: SelectSubset<T, AdminAuthorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuthority.
     * @param {AdminAuthorityCreateArgs} args - Arguments to create a AdminAuthority.
     * @example
     * // Create one AdminAuthority
     * const AdminAuthority = await prisma.adminAuthority.create({
     *   data: {
     *     // ... data to create a AdminAuthority
     *   }
     * })
     * 
     */
    create<T extends AdminAuthorityCreateArgs>(args: SelectSubset<T, AdminAuthorityCreateArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuthorities.
     * @param {AdminAuthorityCreateManyArgs} args - Arguments to create many AdminAuthorities.
     * @example
     * // Create many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuthorityCreateManyArgs>(args?: SelectSubset<T, AdminAuthorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuthorities and returns the data saved in the database.
     * @param {AdminAuthorityCreateManyAndReturnArgs} args - Arguments to create many AdminAuthorities.
     * @example
     * // Create many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuthorities and only return the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuthorityCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuthorityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuthority.
     * @param {AdminAuthorityDeleteArgs} args - Arguments to delete one AdminAuthority.
     * @example
     * // Delete one AdminAuthority
     * const AdminAuthority = await prisma.adminAuthority.delete({
     *   where: {
     *     // ... filter to delete one AdminAuthority
     *   }
     * })
     * 
     */
    delete<T extends AdminAuthorityDeleteArgs>(args: SelectSubset<T, AdminAuthorityDeleteArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuthority.
     * @param {AdminAuthorityUpdateArgs} args - Arguments to update one AdminAuthority.
     * @example
     * // Update one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuthorityUpdateArgs>(args: SelectSubset<T, AdminAuthorityUpdateArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuthorities.
     * @param {AdminAuthorityDeleteManyArgs} args - Arguments to filter AdminAuthorities to delete.
     * @example
     * // Delete a few AdminAuthorities
     * const { count } = await prisma.adminAuthority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuthorityDeleteManyArgs>(args?: SelectSubset<T, AdminAuthorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuthorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuthorityUpdateManyArgs>(args: SelectSubset<T, AdminAuthorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuthorities and returns the data updated in the database.
     * @param {AdminAuthorityUpdateManyAndReturnArgs} args - Arguments to update many AdminAuthorities.
     * @example
     * // Update many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuthorities and only return the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuthorityUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuthorityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuthority.
     * @param {AdminAuthorityUpsertArgs} args - Arguments to update or create a AdminAuthority.
     * @example
     * // Update or create a AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.upsert({
     *   create: {
     *     // ... data to create a AdminAuthority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuthority we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuthorityUpsertArgs>(args: SelectSubset<T, AdminAuthorityUpsertArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuthorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityCountArgs} args - Arguments to filter AdminAuthorities to count.
     * @example
     * // Count the number of AdminAuthorities
     * const count = await prisma.adminAuthority.count({
     *   where: {
     *     // ... the filter for the AdminAuthorities we want to count
     *   }
     * })
    **/
    count<T extends AdminAuthorityCountArgs>(
      args?: Subset<T, AdminAuthorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuthorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuthority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuthorityAggregateArgs>(args: Subset<T, AdminAuthorityAggregateArgs>): Prisma.PrismaPromise<GetAdminAuthorityAggregateType<T>>

    /**
     * Group by AdminAuthority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuthorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuthorityGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuthorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuthorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuthorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuthority model
   */
  readonly fields: AdminAuthorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuthority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuthorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cities<T extends AdminAuthority$citiesArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends AdminAuthority$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuthority model
   */
  interface AdminAuthorityFieldRefs {
    readonly id: FieldRef<"AdminAuthority", 'String'>
    readonly adminId: FieldRef<"AdminAuthority", 'String'>
    readonly provinceId: FieldRef<"AdminAuthority", 'String'>
    readonly grades: FieldRef<"AdminAuthority", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuthority findUnique
   */
  export type AdminAuthorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority findUniqueOrThrow
   */
  export type AdminAuthorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority findFirst
   */
  export type AdminAuthorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuthorities.
     */
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority findFirstOrThrow
   */
  export type AdminAuthorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuthorities.
     */
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority findMany
   */
  export type AdminAuthorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthorities to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority create
   */
  export type AdminAuthorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuthority.
     */
    data: XOR<AdminAuthorityCreateInput, AdminAuthorityUncheckedCreateInput>
  }

  /**
   * AdminAuthority createMany
   */
  export type AdminAuthorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuthorities.
     */
    data: AdminAuthorityCreateManyInput | AdminAuthorityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuthority createManyAndReturn
   */
  export type AdminAuthorityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuthorities.
     */
    data: AdminAuthorityCreateManyInput | AdminAuthorityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuthority update
   */
  export type AdminAuthorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuthority.
     */
    data: XOR<AdminAuthorityUpdateInput, AdminAuthorityUncheckedUpdateInput>
    /**
     * Choose, which AdminAuthority to update.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority updateMany
   */
  export type AdminAuthorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuthorities.
     */
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuthorities to update
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to update.
     */
    limit?: number
  }

  /**
   * AdminAuthority updateManyAndReturn
   */
  export type AdminAuthorityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuthorities.
     */
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuthorities to update
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuthority upsert
   */
  export type AdminAuthorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuthority to update in case it exists.
     */
    where: AdminAuthorityWhereUniqueInput
    /**
     * In case the AdminAuthority found by the `where` argument doesn't exist, create a new AdminAuthority with this data.
     */
    create: XOR<AdminAuthorityCreateInput, AdminAuthorityUncheckedCreateInput>
    /**
     * In case the AdminAuthority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuthorityUpdateInput, AdminAuthorityUncheckedUpdateInput>
  }

  /**
   * AdminAuthority delete
   */
  export type AdminAuthorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter which AdminAuthority to delete.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority deleteMany
   */
  export type AdminAuthorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuthorities to delete
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to delete.
     */
    limit?: number
  }

  /**
   * AdminAuthority.cities
   */
  export type AdminAuthority$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * AdminAuthority.schools
   */
  export type AdminAuthority$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * AdminAuthority without action
   */
  export type AdminAuthorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    thumbnail: string | null
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean | null
    adminId: string | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    thumbnail: string | null
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean | null
    adminId: string | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    thumbnail: number
    link: number
    startedAt: number
    endedAt: number
    isHide: number
    adminId: number
    _all: number
  }


  export type BannerMinAggregateInputType = {
    id?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    adminId?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    adminId?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    adminId?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    thumbnail: string
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean
    adminId: string
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
    visitors?: boolean | Banner$visitorsArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    bannerLocation?: boolean | Banner$bannerLocationArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "thumbnail" | "link" | "startedAt" | "endedAt" | "isHide" | "adminId", ExtArgs["result"]["banner"]>
  export type BannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | Banner$visitorsArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    bannerLocation?: boolean | Banner$bannerLocationArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type BannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {
      visitors: Prisma.$BannerVisitorPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>
      bannerLocation: Prisma.$BannerLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      thumbnail: string
      link: string | null
      startedAt: Date | null
      endedAt: Date | null
      isHide: boolean
      adminId: string
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {BannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners and returns the data updated in the database.
     * @param {BannerUpdateManyAndReturnArgs} args - Arguments to update many Banners.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visitors<T extends Banner$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Banner$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bannerLocation<T extends Banner$bannerLocationArgs<ExtArgs> = {}>(args?: Subset<T, Banner$bannerLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly thumbnail: FieldRef<"Banner", 'String'>
    readonly link: FieldRef<"Banner", 'String'>
    readonly startedAt: FieldRef<"Banner", 'DateTime'>
    readonly endedAt: FieldRef<"Banner", 'DateTime'>
    readonly isHide: FieldRef<"Banner", 'Boolean'>
    readonly adminId: FieldRef<"Banner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner createManyAndReturn
   */
  export type BannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner updateManyAndReturn
   */
  export type BannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner.visitors
   */
  export type Banner$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    cursor?: BannerVisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * Banner.bannerLocation
   */
  export type Banner$bannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    cursor?: BannerLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
  }


  /**
   * Model BannerLocation
   */

  export type AggregateBannerLocation = {
    _count: BannerLocationCountAggregateOutputType | null
    _min: BannerLocationMinAggregateOutputType | null
    _max: BannerLocationMaxAggregateOutputType | null
  }

  export type BannerLocationMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    provinceId: string | null
  }

  export type BannerLocationMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    provinceId: string | null
  }

  export type BannerLocationCountAggregateOutputType = {
    id: number
    bannerId: number
    provinceId: number
    _all: number
  }


  export type BannerLocationMinAggregateInputType = {
    id?: true
    bannerId?: true
    provinceId?: true
  }

  export type BannerLocationMaxAggregateInputType = {
    id?: true
    bannerId?: true
    provinceId?: true
  }

  export type BannerLocationCountAggregateInputType = {
    id?: true
    bannerId?: true
    provinceId?: true
    _all?: true
  }

  export type BannerLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerLocation to aggregate.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerLocations
    **/
    _count?: true | BannerLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerLocationMaxAggregateInputType
  }

  export type GetBannerLocationAggregateType<T extends BannerLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerLocation[P]>
      : GetScalarType<T[P], AggregateBannerLocation[P]>
  }




  export type BannerLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithAggregationInput | BannerLocationOrderByWithAggregationInput[]
    by: BannerLocationScalarFieldEnum[] | BannerLocationScalarFieldEnum
    having?: BannerLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerLocationCountAggregateInputType | true
    _min?: BannerLocationMinAggregateInputType
    _max?: BannerLocationMaxAggregateInputType
  }

  export type BannerLocationGroupByOutputType = {
    id: string
    bannerId: string
    provinceId: string
    _count: BannerLocationCountAggregateOutputType | null
    _min: BannerLocationMinAggregateOutputType | null
    _max: BannerLocationMaxAggregateOutputType | null
  }

  type GetBannerLocationGroupByPayload<T extends BannerLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerLocationGroupByOutputType[P]>
            : GetScalarType<T[P], BannerLocationGroupByOutputType[P]>
        }
      >
    >


  export type BannerLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | BannerLocation$citiesArgs<ExtArgs>
    _count?: boolean | BannerLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerLocation"]>

  export type BannerLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerLocation"]>

  export type BannerLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerLocation"]>

  export type BannerLocationSelectScalar = {
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
  }

  export type BannerLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "provinceId", ExtArgs["result"]["bannerLocation"]>
  export type BannerLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | BannerLocation$citiesArgs<ExtArgs>
    _count?: boolean | BannerLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BannerLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type BannerLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $BannerLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerLocation"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      provinceId: string
    }, ExtArgs["result"]["bannerLocation"]>
    composites: {}
  }

  type BannerLocationGetPayload<S extends boolean | null | undefined | BannerLocationDefaultArgs> = $Result.GetResult<Prisma.$BannerLocationPayload, S>

  type BannerLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerLocationCountAggregateInputType | true
    }

  export interface BannerLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerLocation'], meta: { name: 'BannerLocation' } }
    /**
     * Find zero or one BannerLocation that matches the filter.
     * @param {BannerLocationFindUniqueArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerLocationFindUniqueArgs>(args: SelectSubset<T, BannerLocationFindUniqueArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerLocationFindUniqueOrThrowArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationFindFirstArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerLocationFindFirstArgs>(args?: SelectSubset<T, BannerLocationFindFirstArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationFindFirstOrThrowArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerLocations
     * const bannerLocations = await prisma.bannerLocation.findMany()
     * 
     * // Get first 10 BannerLocations
     * const bannerLocations = await prisma.bannerLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerLocationWithIdOnly = await prisma.bannerLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerLocationFindManyArgs>(args?: SelectSubset<T, BannerLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerLocation.
     * @param {BannerLocationCreateArgs} args - Arguments to create a BannerLocation.
     * @example
     * // Create one BannerLocation
     * const BannerLocation = await prisma.bannerLocation.create({
     *   data: {
     *     // ... data to create a BannerLocation
     *   }
     * })
     * 
     */
    create<T extends BannerLocationCreateArgs>(args: SelectSubset<T, BannerLocationCreateArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerLocations.
     * @param {BannerLocationCreateManyArgs} args - Arguments to create many BannerLocations.
     * @example
     * // Create many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerLocationCreateManyArgs>(args?: SelectSubset<T, BannerLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BannerLocations and returns the data saved in the database.
     * @param {BannerLocationCreateManyAndReturnArgs} args - Arguments to create many BannerLocations.
     * @example
     * // Create many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BannerLocations and only return the `id`
     * const bannerLocationWithIdOnly = await prisma.bannerLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BannerLocation.
     * @param {BannerLocationDeleteArgs} args - Arguments to delete one BannerLocation.
     * @example
     * // Delete one BannerLocation
     * const BannerLocation = await prisma.bannerLocation.delete({
     *   where: {
     *     // ... filter to delete one BannerLocation
     *   }
     * })
     * 
     */
    delete<T extends BannerLocationDeleteArgs>(args: SelectSubset<T, BannerLocationDeleteArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerLocation.
     * @param {BannerLocationUpdateArgs} args - Arguments to update one BannerLocation.
     * @example
     * // Update one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerLocationUpdateArgs>(args: SelectSubset<T, BannerLocationUpdateArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerLocations.
     * @param {BannerLocationDeleteManyArgs} args - Arguments to filter BannerLocations to delete.
     * @example
     * // Delete a few BannerLocations
     * const { count } = await prisma.bannerLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerLocationDeleteManyArgs>(args?: SelectSubset<T, BannerLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerLocationUpdateManyArgs>(args: SelectSubset<T, BannerLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerLocations and returns the data updated in the database.
     * @param {BannerLocationUpdateManyAndReturnArgs} args - Arguments to update many BannerLocations.
     * @example
     * // Update many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BannerLocations and only return the `id`
     * const bannerLocationWithIdOnly = await prisma.bannerLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BannerLocation.
     * @param {BannerLocationUpsertArgs} args - Arguments to update or create a BannerLocation.
     * @example
     * // Update or create a BannerLocation
     * const bannerLocation = await prisma.bannerLocation.upsert({
     *   create: {
     *     // ... data to create a BannerLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerLocation we want to update
     *   }
     * })
     */
    upsert<T extends BannerLocationUpsertArgs>(args: SelectSubset<T, BannerLocationUpsertArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationCountArgs} args - Arguments to filter BannerLocations to count.
     * @example
     * // Count the number of BannerLocations
     * const count = await prisma.bannerLocation.count({
     *   where: {
     *     // ... the filter for the BannerLocations we want to count
     *   }
     * })
    **/
    count<T extends BannerLocationCountArgs>(
      args?: Subset<T, BannerLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerLocationAggregateArgs>(args: Subset<T, BannerLocationAggregateArgs>): Prisma.PrismaPromise<GetBannerLocationAggregateType<T>>

    /**
     * Group by BannerLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerLocationGroupByArgs['orderBy'] }
        : { orderBy?: BannerLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerLocation model
   */
  readonly fields: BannerLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cities<T extends BannerLocation$citiesArgs<ExtArgs> = {}>(args?: Subset<T, BannerLocation$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerLocation model
   */
  interface BannerLocationFieldRefs {
    readonly id: FieldRef<"BannerLocation", 'String'>
    readonly bannerId: FieldRef<"BannerLocation", 'String'>
    readonly provinceId: FieldRef<"BannerLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BannerLocation findUnique
   */
  export type BannerLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation findUniqueOrThrow
   */
  export type BannerLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation findFirst
   */
  export type BannerLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerLocations.
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerLocations.
     */
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * BannerLocation findFirstOrThrow
   */
  export type BannerLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerLocations.
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerLocations.
     */
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * BannerLocation findMany
   */
  export type BannerLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocations to fetch.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerLocations.
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * BannerLocation create
   */
  export type BannerLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerLocation.
     */
    data: XOR<BannerLocationCreateInput, BannerLocationUncheckedCreateInput>
  }

  /**
   * BannerLocation createMany
   */
  export type BannerLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerLocations.
     */
    data: BannerLocationCreateManyInput | BannerLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerLocation createManyAndReturn
   */
  export type BannerLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * The data used to create many BannerLocations.
     */
    data: BannerLocationCreateManyInput | BannerLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerLocation update
   */
  export type BannerLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerLocation.
     */
    data: XOR<BannerLocationUpdateInput, BannerLocationUncheckedUpdateInput>
    /**
     * Choose, which BannerLocation to update.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation updateMany
   */
  export type BannerLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerLocations.
     */
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyInput>
    /**
     * Filter which BannerLocations to update
     */
    where?: BannerLocationWhereInput
    /**
     * Limit how many BannerLocations to update.
     */
    limit?: number
  }

  /**
   * BannerLocation updateManyAndReturn
   */
  export type BannerLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * The data used to update BannerLocations.
     */
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyInput>
    /**
     * Filter which BannerLocations to update
     */
    where?: BannerLocationWhereInput
    /**
     * Limit how many BannerLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerLocation upsert
   */
  export type BannerLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerLocation to update in case it exists.
     */
    where: BannerLocationWhereUniqueInput
    /**
     * In case the BannerLocation found by the `where` argument doesn't exist, create a new BannerLocation with this data.
     */
    create: XOR<BannerLocationCreateInput, BannerLocationUncheckedCreateInput>
    /**
     * In case the BannerLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerLocationUpdateInput, BannerLocationUncheckedUpdateInput>
  }

  /**
   * BannerLocation delete
   */
  export type BannerLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter which BannerLocation to delete.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation deleteMany
   */
  export type BannerLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerLocations to delete
     */
    where?: BannerLocationWhereInput
    /**
     * Limit how many BannerLocations to delete.
     */
    limit?: number
  }

  /**
   * BannerLocation.cities
   */
  export type BannerLocation$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * BannerLocation without action
   */
  export type BannerLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
  }


  /**
   * Model BannerVisitor
   */

  export type AggregateBannerVisitor = {
    _count: BannerVisitorCountAggregateOutputType | null
    _avg: BannerVisitorAvgAggregateOutputType | null
    _sum: BannerVisitorSumAggregateOutputType | null
    _min: BannerVisitorMinAggregateOutputType | null
    _max: BannerVisitorMaxAggregateOutputType | null
  }

  export type BannerVisitorAvgAggregateOutputType = {
    traffic: number | null
  }

  export type BannerVisitorSumAggregateOutputType = {
    traffic: number | null
  }

  export type BannerVisitorMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    traffic: number | null
  }

  export type BannerVisitorMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    traffic: number | null
  }

  export type BannerVisitorCountAggregateOutputType = {
    id: number
    bannerId: number
    userId: number
    createdAt: number
    updatedAt: number
    traffic: number
    _all: number
  }


  export type BannerVisitorAvgAggregateInputType = {
    traffic?: true
  }

  export type BannerVisitorSumAggregateInputType = {
    traffic?: true
  }

  export type BannerVisitorMinAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
  }

  export type BannerVisitorMaxAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
  }

  export type BannerVisitorCountAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
    _all?: true
  }

  export type BannerVisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerVisitor to aggregate.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerVisitors
    **/
    _count?: true | BannerVisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerVisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerVisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerVisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerVisitorMaxAggregateInputType
  }

  export type GetBannerVisitorAggregateType<T extends BannerVisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerVisitor[P]>
      : GetScalarType<T[P], AggregateBannerVisitor[P]>
  }




  export type BannerVisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithAggregationInput | BannerVisitorOrderByWithAggregationInput[]
    by: BannerVisitorScalarFieldEnum[] | BannerVisitorScalarFieldEnum
    having?: BannerVisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerVisitorCountAggregateInputType | true
    _avg?: BannerVisitorAvgAggregateInputType
    _sum?: BannerVisitorSumAggregateInputType
    _min?: BannerVisitorMinAggregateInputType
    _max?: BannerVisitorMaxAggregateInputType
  }

  export type BannerVisitorGroupByOutputType = {
    id: string
    bannerId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    traffic: number
    _count: BannerVisitorCountAggregateOutputType | null
    _avg: BannerVisitorAvgAggregateOutputType | null
    _sum: BannerVisitorSumAggregateOutputType | null
    _min: BannerVisitorMinAggregateOutputType | null
    _max: BannerVisitorMaxAggregateOutputType | null
  }

  type GetBannerVisitorGroupByPayload<T extends BannerVisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerVisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerVisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerVisitorGroupByOutputType[P]>
            : GetScalarType<T[P], BannerVisitorGroupByOutputType[P]>
        }
      >
    >


  export type BannerVisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectScalar = {
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
  }

  export type BannerVisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "userId" | "createdAt" | "updatedAt" | "traffic", ExtArgs["result"]["bannerVisitor"]>
  export type BannerVisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BannerVisitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BannerVisitorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BannerVisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerVisitor"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      userId: string
      createdAt: Date
      updatedAt: Date
      traffic: number
    }, ExtArgs["result"]["bannerVisitor"]>
    composites: {}
  }

  type BannerVisitorGetPayload<S extends boolean | null | undefined | BannerVisitorDefaultArgs> = $Result.GetResult<Prisma.$BannerVisitorPayload, S>

  type BannerVisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerVisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerVisitorCountAggregateInputType | true
    }

  export interface BannerVisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerVisitor'], meta: { name: 'BannerVisitor' } }
    /**
     * Find zero or one BannerVisitor that matches the filter.
     * @param {BannerVisitorFindUniqueArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerVisitorFindUniqueArgs>(args: SelectSubset<T, BannerVisitorFindUniqueArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerVisitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerVisitorFindUniqueOrThrowArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerVisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerVisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerVisitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindFirstArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerVisitorFindFirstArgs>(args?: SelectSubset<T, BannerVisitorFindFirstArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerVisitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindFirstOrThrowArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerVisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerVisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerVisitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerVisitors
     * const bannerVisitors = await prisma.bannerVisitor.findMany()
     * 
     * // Get first 10 BannerVisitors
     * const bannerVisitors = await prisma.bannerVisitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerVisitorFindManyArgs>(args?: SelectSubset<T, BannerVisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerVisitor.
     * @param {BannerVisitorCreateArgs} args - Arguments to create a BannerVisitor.
     * @example
     * // Create one BannerVisitor
     * const BannerVisitor = await prisma.bannerVisitor.create({
     *   data: {
     *     // ... data to create a BannerVisitor
     *   }
     * })
     * 
     */
    create<T extends BannerVisitorCreateArgs>(args: SelectSubset<T, BannerVisitorCreateArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerVisitors.
     * @param {BannerVisitorCreateManyArgs} args - Arguments to create many BannerVisitors.
     * @example
     * // Create many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerVisitorCreateManyArgs>(args?: SelectSubset<T, BannerVisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BannerVisitors and returns the data saved in the database.
     * @param {BannerVisitorCreateManyAndReturnArgs} args - Arguments to create many BannerVisitors.
     * @example
     * // Create many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BannerVisitors and only return the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerVisitorCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerVisitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BannerVisitor.
     * @param {BannerVisitorDeleteArgs} args - Arguments to delete one BannerVisitor.
     * @example
     * // Delete one BannerVisitor
     * const BannerVisitor = await prisma.bannerVisitor.delete({
     *   where: {
     *     // ... filter to delete one BannerVisitor
     *   }
     * })
     * 
     */
    delete<T extends BannerVisitorDeleteArgs>(args: SelectSubset<T, BannerVisitorDeleteArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerVisitor.
     * @param {BannerVisitorUpdateArgs} args - Arguments to update one BannerVisitor.
     * @example
     * // Update one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerVisitorUpdateArgs>(args: SelectSubset<T, BannerVisitorUpdateArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerVisitors.
     * @param {BannerVisitorDeleteManyArgs} args - Arguments to filter BannerVisitors to delete.
     * @example
     * // Delete a few BannerVisitors
     * const { count } = await prisma.bannerVisitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerVisitorDeleteManyArgs>(args?: SelectSubset<T, BannerVisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerVisitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerVisitorUpdateManyArgs>(args: SelectSubset<T, BannerVisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerVisitors and returns the data updated in the database.
     * @param {BannerVisitorUpdateManyAndReturnArgs} args - Arguments to update many BannerVisitors.
     * @example
     * // Update many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BannerVisitors and only return the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerVisitorUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerVisitorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BannerVisitor.
     * @param {BannerVisitorUpsertArgs} args - Arguments to update or create a BannerVisitor.
     * @example
     * // Update or create a BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.upsert({
     *   create: {
     *     // ... data to create a BannerVisitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerVisitor we want to update
     *   }
     * })
     */
    upsert<T extends BannerVisitorUpsertArgs>(args: SelectSubset<T, BannerVisitorUpsertArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerVisitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorCountArgs} args - Arguments to filter BannerVisitors to count.
     * @example
     * // Count the number of BannerVisitors
     * const count = await prisma.bannerVisitor.count({
     *   where: {
     *     // ... the filter for the BannerVisitors we want to count
     *   }
     * })
    **/
    count<T extends BannerVisitorCountArgs>(
      args?: Subset<T, BannerVisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerVisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerVisitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerVisitorAggregateArgs>(args: Subset<T, BannerVisitorAggregateArgs>): Prisma.PrismaPromise<GetBannerVisitorAggregateType<T>>

    /**
     * Group by BannerVisitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerVisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerVisitorGroupByArgs['orderBy'] }
        : { orderBy?: BannerVisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerVisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerVisitor model
   */
  readonly fields: BannerVisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerVisitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerVisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerVisitor model
   */
  interface BannerVisitorFieldRefs {
    readonly id: FieldRef<"BannerVisitor", 'String'>
    readonly bannerId: FieldRef<"BannerVisitor", 'String'>
    readonly userId: FieldRef<"BannerVisitor", 'String'>
    readonly createdAt: FieldRef<"BannerVisitor", 'DateTime'>
    readonly updatedAt: FieldRef<"BannerVisitor", 'DateTime'>
    readonly traffic: FieldRef<"BannerVisitor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BannerVisitor findUnique
   */
  export type BannerVisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor findUniqueOrThrow
   */
  export type BannerVisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor findFirst
   */
  export type BannerVisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerVisitors.
     */
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor findFirstOrThrow
   */
  export type BannerVisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerVisitors.
     */
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor findMany
   */
  export type BannerVisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitors to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor create
   */
  export type BannerVisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerVisitor.
     */
    data: XOR<BannerVisitorCreateInput, BannerVisitorUncheckedCreateInput>
  }

  /**
   * BannerVisitor createMany
   */
  export type BannerVisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerVisitors.
     */
    data: BannerVisitorCreateManyInput | BannerVisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerVisitor createManyAndReturn
   */
  export type BannerVisitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * The data used to create many BannerVisitors.
     */
    data: BannerVisitorCreateManyInput | BannerVisitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerVisitor update
   */
  export type BannerVisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerVisitor.
     */
    data: XOR<BannerVisitorUpdateInput, BannerVisitorUncheckedUpdateInput>
    /**
     * Choose, which BannerVisitor to update.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor updateMany
   */
  export type BannerVisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerVisitors.
     */
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyInput>
    /**
     * Filter which BannerVisitors to update
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to update.
     */
    limit?: number
  }

  /**
   * BannerVisitor updateManyAndReturn
   */
  export type BannerVisitorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * The data used to update BannerVisitors.
     */
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyInput>
    /**
     * Filter which BannerVisitors to update
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerVisitor upsert
   */
  export type BannerVisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerVisitor to update in case it exists.
     */
    where: BannerVisitorWhereUniqueInput
    /**
     * In case the BannerVisitor found by the `where` argument doesn't exist, create a new BannerVisitor with this data.
     */
    create: XOR<BannerVisitorCreateInput, BannerVisitorUncheckedCreateInput>
    /**
     * In case the BannerVisitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerVisitorUpdateInput, BannerVisitorUncheckedUpdateInput>
  }

  /**
   * BannerVisitor delete
   */
  export type BannerVisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter which BannerVisitor to delete.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor deleteMany
   */
  export type BannerVisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerVisitors to delete
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to delete.
     */
    limit?: number
  }

  /**
   * BannerVisitor without action
   */
  export type BannerVisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
  }


  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type TestSumAggregateOutputType = {
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type TestMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.TestCategory | null
    question: $Enums.QuestionType | null
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    type: $Enums.TestType | null
    quota: number | null
    currentQuota: number | null
    code: string | null
    zoneId: string | null
    startedAt: Date | null
    endedAt: Date | null
    description: string | null
  }

  export type TestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.TestCategory | null
    question: $Enums.QuestionType | null
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    type: $Enums.TestType | null
    quota: number | null
    currentQuota: number | null
    code: string | null
    zoneId: string | null
    startedAt: Date | null
    endedAt: Date | null
    description: string | null
  }

  export type TestCountAggregateOutputType = {
    id: number
    name: number
    category: number
    question: number
    duration: number
    passedPoint: number
    remidialCount: number
    type: number
    quota: number
    currentQuota: number
    code: number
    zoneId: number
    startedAt: number
    endedAt: number
    description: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    duration?: true
    passedPoint?: true
    remidialCount?: true
    quota?: true
    currentQuota?: true
  }

  export type TestSumAggregateInputType = {
    duration?: true
    passedPoint?: true
    remidialCount?: true
    quota?: true
    currentQuota?: true
  }

  export type TestMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
  }

  export type TestMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
  }

  export type TestCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    id: string
    name: string
    category: $Enums.TestCategory
    question: $Enums.QuestionType
    duration: number
    passedPoint: number
    remidialCount: number
    type: $Enums.TestType
    quota: number
    currentQuota: number
    code: string | null
    zoneId: string | null
    startedAt: Date
    endedAt: Date | null
    description: string | null
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    participants?: boolean | Test$participantsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>

  export type TestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
  }, ExtArgs["result"]["test"]>

  export type TestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
  }, ExtArgs["result"]["test"]>

  export type TestSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
  }

  export type TestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "question" | "duration" | "passedPoint" | "remidialCount" | "type" | "quota" | "currentQuota" | "code" | "zoneId" | "startedAt" | "endedAt" | "description", ExtArgs["result"]["test"]>
  export type TestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Test$participantsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {
      participants: Prisma.$TestParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.TestCategory
      question: $Enums.QuestionType
      duration: number
      passedPoint: number
      remidialCount: number
      type: $Enums.TestType
      quota: number
      currentQuota: number
      code: string | null
      zoneId: string | null
      startedAt: Date
      endedAt: Date | null
      description: string | null
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestFindUniqueArgs>(args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs>(args: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestFindFirstArgs>(args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs>(args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testWithIdOnly = await prisma.test.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestFindManyArgs>(args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends TestCreateArgs>(args: SelectSubset<T, TestCreateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tests.
     * @param {TestCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCreateManyArgs>(args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tests and returns the data saved in the database.
     * @param {TestCreateManyAndReturnArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tests and only return the `id`
     * const testWithIdOnly = await prisma.test.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestCreateManyAndReturnArgs>(args?: SelectSubset<T, TestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends TestDeleteArgs>(args: SelectSubset<T, TestDeleteArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestUpdateArgs>(args: SelectSubset<T, TestUpdateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDeleteManyArgs>(args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestUpdateManyArgs>(args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests and returns the data updated in the database.
     * @param {TestUpdateManyAndReturnArgs} args - Arguments to update many Tests.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tests and only return the `id`
     * const testWithIdOnly = await prisma.test.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestUpdateManyAndReturnArgs>(args: SelectSubset<T, TestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends TestUpsertArgs>(args: SelectSubset<T, TestUpsertArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Test$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Test$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Test model
   */
  interface TestFieldRefs {
    readonly id: FieldRef<"Test", 'String'>
    readonly name: FieldRef<"Test", 'String'>
    readonly category: FieldRef<"Test", 'TestCategory'>
    readonly question: FieldRef<"Test", 'QuestionType'>
    readonly duration: FieldRef<"Test", 'Int'>
    readonly passedPoint: FieldRef<"Test", 'Int'>
    readonly remidialCount: FieldRef<"Test", 'Int'>
    readonly type: FieldRef<"Test", 'TestType'>
    readonly quota: FieldRef<"Test", 'Int'>
    readonly currentQuota: FieldRef<"Test", 'Int'>
    readonly code: FieldRef<"Test", 'String'>
    readonly zoneId: FieldRef<"Test", 'String'>
    readonly startedAt: FieldRef<"Test", 'DateTime'>
    readonly endedAt: FieldRef<"Test", 'DateTime'>
    readonly description: FieldRef<"Test", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }

  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Test createManyAndReturn
   */
  export type TestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test updateManyAndReturn
   */
  export type TestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }

  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to delete.
     */
    limit?: number
  }

  /**
   * Test.participants
   */
  export type Test$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    cursor?: TestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
  }


  /**
   * Model TestParticipant
   */

  export type AggregateTestParticipant = {
    _count: TestParticipantCountAggregateOutputType | null
    _avg: TestParticipantAvgAggregateOutputType | null
    _sum: TestParticipantSumAggregateOutputType | null
    _min: TestParticipantMinAggregateOutputType | null
    _max: TestParticipantMaxAggregateOutputType | null
  }

  export type TestParticipantAvgAggregateOutputType = {
    highscore: number | null
    average: number | null
    lowscore: number | null
  }

  export type TestParticipantSumAggregateOutputType = {
    highscore: number | null
    average: number | null
    lowscore: number | null
  }

  export type TestParticipantMinAggregateOutputType = {
    id: string | null
    testId: string | null
    userId: string | null
    firstTimeAt: Date | null
    lastTestAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    highscore: number | null
    average: number | null
    lowscore: number | null
  }

  export type TestParticipantMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    userId: string | null
    firstTimeAt: Date | null
    lastTestAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    highscore: number | null
    average: number | null
    lowscore: number | null
  }

  export type TestParticipantCountAggregateOutputType = {
    id: number
    testId: number
    userId: number
    firstTimeAt: number
    lastTestAt: number
    createdAt: number
    updatedAt: number
    highscore: number
    average: number
    lowscore: number
    _all: number
  }


  export type TestParticipantAvgAggregateInputType = {
    highscore?: true
    average?: true
    lowscore?: true
  }

  export type TestParticipantSumAggregateInputType = {
    highscore?: true
    average?: true
    lowscore?: true
  }

  export type TestParticipantMinAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    firstTimeAt?: true
    lastTestAt?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
    average?: true
    lowscore?: true
  }

  export type TestParticipantMaxAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    firstTimeAt?: true
    lastTestAt?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
    average?: true
    lowscore?: true
  }

  export type TestParticipantCountAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    firstTimeAt?: true
    lastTestAt?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
    average?: true
    lowscore?: true
    _all?: true
  }

  export type TestParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipant to aggregate.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParticipants
    **/
    _count?: true | TestParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParticipantMaxAggregateInputType
  }

  export type GetTestParticipantAggregateType<T extends TestParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParticipant[P]>
      : GetScalarType<T[P], AggregateTestParticipant[P]>
  }




  export type TestParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithAggregationInput | TestParticipantOrderByWithAggregationInput[]
    by: TestParticipantScalarFieldEnum[] | TestParticipantScalarFieldEnum
    having?: TestParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParticipantCountAggregateInputType | true
    _avg?: TestParticipantAvgAggregateInputType
    _sum?: TestParticipantSumAggregateInputType
    _min?: TestParticipantMinAggregateInputType
    _max?: TestParticipantMaxAggregateInputType
  }

  export type TestParticipantGroupByOutputType = {
    id: string
    testId: string
    userId: string
    firstTimeAt: Date | null
    lastTestAt: Date | null
    createdAt: Date
    updatedAt: Date
    highscore: number
    average: number
    lowscore: number
    _count: TestParticipantCountAggregateOutputType | null
    _avg: TestParticipantAvgAggregateOutputType | null
    _sum: TestParticipantSumAggregateOutputType | null
    _min: TestParticipantMinAggregateOutputType | null
    _max: TestParticipantMaxAggregateOutputType | null
  }

  type GetTestParticipantGroupByPayload<T extends TestParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TestParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TestParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    average?: boolean
    lowscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    records?: boolean | TestParticipant$recordsArgs<ExtArgs>
    _count?: boolean | TestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    average?: boolean
    lowscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    average?: boolean
    lowscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectScalar = {
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    average?: boolean
    lowscore?: boolean
  }

  export type TestParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "userId" | "firstTimeAt" | "lastTestAt" | "createdAt" | "updatedAt" | "highscore" | "average" | "lowscore", ExtArgs["result"]["testParticipant"]>
  export type TestParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    records?: boolean | TestParticipant$recordsArgs<ExtArgs>
    _count?: boolean | TestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParticipant"
    objects: {
      test: Prisma.$TestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      records: Prisma.$TestParticipantRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      userId: string
      firstTimeAt: Date | null
      lastTestAt: Date | null
      createdAt: Date
      updatedAt: Date
      highscore: number
      average: number
      lowscore: number
    }, ExtArgs["result"]["testParticipant"]>
    composites: {}
  }

  type TestParticipantGetPayload<S extends boolean | null | undefined | TestParticipantDefaultArgs> = $Result.GetResult<Prisma.$TestParticipantPayload, S>

  type TestParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParticipantCountAggregateInputType | true
    }

  export interface TestParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParticipant'], meta: { name: 'TestParticipant' } }
    /**
     * Find zero or one TestParticipant that matches the filter.
     * @param {TestParticipantFindUniqueArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParticipantFindUniqueArgs>(args: SelectSubset<T, TestParticipantFindUniqueArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParticipantFindUniqueOrThrowArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindFirstArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParticipantFindFirstArgs>(args?: SelectSubset<T, TestParticipantFindFirstArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindFirstOrThrowArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParticipants
     * const testParticipants = await prisma.testParticipant.findMany()
     * 
     * // Get first 10 TestParticipants
     * const testParticipants = await prisma.testParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParticipantFindManyArgs>(args?: SelectSubset<T, TestParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParticipant.
     * @param {TestParticipantCreateArgs} args - Arguments to create a TestParticipant.
     * @example
     * // Create one TestParticipant
     * const TestParticipant = await prisma.testParticipant.create({
     *   data: {
     *     // ... data to create a TestParticipant
     *   }
     * })
     * 
     */
    create<T extends TestParticipantCreateArgs>(args: SelectSubset<T, TestParticipantCreateArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParticipants.
     * @param {TestParticipantCreateManyArgs} args - Arguments to create many TestParticipants.
     * @example
     * // Create many TestParticipants
     * const testParticipant = await prisma.testParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParticipantCreateManyArgs>(args?: SelectSubset<T, TestParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParticipants and returns the data saved in the database.
     * @param {TestParticipantCreateManyAndReturnArgs} args - Arguments to create many TestParticipants.
     * @example
     * // Create many TestParticipants
     * const testParticipant = await prisma.testParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParticipants and only return the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParticipant.
     * @param {TestParticipantDeleteArgs} args - Arguments to delete one TestParticipant.
     * @example
     * // Delete one TestParticipant
     * const TestParticipant = await prisma.testParticipant.delete({
     *   where: {
     *     // ... filter to delete one TestParticipant
     *   }
     * })
     * 
     */
    delete<T extends TestParticipantDeleteArgs>(args: SelectSubset<T, TestParticipantDeleteArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParticipant.
     * @param {TestParticipantUpdateArgs} args - Arguments to update one TestParticipant.
     * @example
     * // Update one TestParticipant
     * const testParticipant = await prisma.testParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParticipantUpdateArgs>(args: SelectSubset<T, TestParticipantUpdateArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParticipants.
     * @param {TestParticipantDeleteManyArgs} args - Arguments to filter TestParticipants to delete.
     * @example
     * // Delete a few TestParticipants
     * const { count } = await prisma.testParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParticipantDeleteManyArgs>(args?: SelectSubset<T, TestParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParticipants
     * const testParticipant = await prisma.testParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParticipantUpdateManyArgs>(args: SelectSubset<T, TestParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipants and returns the data updated in the database.
     * @param {TestParticipantUpdateManyAndReturnArgs} args - Arguments to update many TestParticipants.
     * @example
     * // Update many TestParticipants
     * const testParticipant = await prisma.testParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParticipants and only return the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParticipant.
     * @param {TestParticipantUpsertArgs} args - Arguments to update or create a TestParticipant.
     * @example
     * // Update or create a TestParticipant
     * const testParticipant = await prisma.testParticipant.upsert({
     *   create: {
     *     // ... data to create a TestParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TestParticipantUpsertArgs>(args: SelectSubset<T, TestParticipantUpsertArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantCountArgs} args - Arguments to filter TestParticipants to count.
     * @example
     * // Count the number of TestParticipants
     * const count = await prisma.testParticipant.count({
     *   where: {
     *     // ... the filter for the TestParticipants we want to count
     *   }
     * })
    **/
    count<T extends TestParticipantCountArgs>(
      args?: Subset<T, TestParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParticipantAggregateArgs>(args: Subset<T, TestParticipantAggregateArgs>): Prisma.PrismaPromise<GetTestParticipantAggregateType<T>>

    /**
     * Group by TestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TestParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParticipant model
   */
  readonly fields: TestParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends TestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestDefaultArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    records<T extends TestParticipant$recordsArgs<ExtArgs> = {}>(args?: Subset<T, TestParticipant$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParticipant model
   */
  interface TestParticipantFieldRefs {
    readonly id: FieldRef<"TestParticipant", 'String'>
    readonly testId: FieldRef<"TestParticipant", 'String'>
    readonly userId: FieldRef<"TestParticipant", 'String'>
    readonly firstTimeAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly lastTestAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly createdAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly highscore: FieldRef<"TestParticipant", 'Float'>
    readonly average: FieldRef<"TestParticipant", 'Float'>
    readonly lowscore: FieldRef<"TestParticipant", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TestParticipant findUnique
   */
  export type TestParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant findUniqueOrThrow
   */
  export type TestParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant findFirst
   */
  export type TestParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipants.
     */
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant findFirstOrThrow
   */
  export type TestParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipants.
     */
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant findMany
   */
  export type TestParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipants to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant create
   */
  export type TestParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParticipant.
     */
    data: XOR<TestParticipantCreateInput, TestParticipantUncheckedCreateInput>
  }

  /**
   * TestParticipant createMany
   */
  export type TestParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParticipants.
     */
    data: TestParticipantCreateManyInput | TestParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParticipant createManyAndReturn
   */
  export type TestParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many TestParticipants.
     */
    data: TestParticipantCreateManyInput | TestParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipant update
   */
  export type TestParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParticipant.
     */
    data: XOR<TestParticipantUpdateInput, TestParticipantUncheckedUpdateInput>
    /**
     * Choose, which TestParticipant to update.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant updateMany
   */
  export type TestParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParticipants.
     */
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipants to update
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to update.
     */
    limit?: number
  }

  /**
   * TestParticipant updateManyAndReturn
   */
  export type TestParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * The data used to update TestParticipants.
     */
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipants to update
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipant upsert
   */
  export type TestParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParticipant to update in case it exists.
     */
    where: TestParticipantWhereUniqueInput
    /**
     * In case the TestParticipant found by the `where` argument doesn't exist, create a new TestParticipant with this data.
     */
    create: XOR<TestParticipantCreateInput, TestParticipantUncheckedCreateInput>
    /**
     * In case the TestParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParticipantUpdateInput, TestParticipantUncheckedUpdateInput>
  }

  /**
   * TestParticipant delete
   */
  export type TestParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter which TestParticipant to delete.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant deleteMany
   */
  export type TestParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipants to delete
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to delete.
     */
    limit?: number
  }

  /**
   * TestParticipant.records
   */
  export type TestParticipant$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    cursor?: TestParticipantRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipant without action
   */
  export type TestParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
  }


  /**
   * Model TestParticipantRecord
   */

  export type AggregateTestParticipantRecord = {
    _count: TestParticipantRecordCountAggregateOutputType | null
    _avg: TestParticipantRecordAvgAggregateOutputType | null
    _sum: TestParticipantRecordSumAggregateOutputType | null
    _min: TestParticipantRecordMinAggregateOutputType | null
    _max: TestParticipantRecordMaxAggregateOutputType | null
  }

  export type TestParticipantRecordAvgAggregateOutputType = {
    score: number | null
  }

  export type TestParticipantRecordSumAggregateOutputType = {
    score: number | null
  }

  export type TestParticipantRecordMinAggregateOutputType = {
    id: string | null
    participantId: string | null
    startedAt: Date | null
    endedAt: Date | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type TestParticipantRecordMaxAggregateOutputType = {
    id: string | null
    participantId: string | null
    startedAt: Date | null
    endedAt: Date | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type TestParticipantRecordCountAggregateOutputType = {
    id: number
    participantId: number
    startedAt: number
    endedAt: number
    score: number
    createdAt: number
    updatedAt: number
    userId: number
    answers: number
    _all: number
  }


  export type TestParticipantRecordAvgAggregateInputType = {
    score?: true
  }

  export type TestParticipantRecordSumAggregateInputType = {
    score?: true
  }

  export type TestParticipantRecordMinAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type TestParticipantRecordMaxAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type TestParticipantRecordCountAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    answers?: true
    _all?: true
  }

  export type TestParticipantRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipantRecord to aggregate.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParticipantRecords
    **/
    _count?: true | TestParticipantRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestParticipantRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestParticipantRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParticipantRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParticipantRecordMaxAggregateInputType
  }

  export type GetTestParticipantRecordAggregateType<T extends TestParticipantRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParticipantRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParticipantRecord[P]>
      : GetScalarType<T[P], AggregateTestParticipantRecord[P]>
  }




  export type TestParticipantRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithAggregationInput | TestParticipantRecordOrderByWithAggregationInput[]
    by: TestParticipantRecordScalarFieldEnum[] | TestParticipantRecordScalarFieldEnum
    having?: TestParticipantRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParticipantRecordCountAggregateInputType | true
    _avg?: TestParticipantRecordAvgAggregateInputType
    _sum?: TestParticipantRecordSumAggregateInputType
    _min?: TestParticipantRecordMinAggregateInputType
    _max?: TestParticipantRecordMaxAggregateInputType
  }

  export type TestParticipantRecordGroupByOutputType = {
    id: string
    participantId: string
    startedAt: Date | null
    endedAt: Date | null
    score: number
    createdAt: Date
    updatedAt: Date
    userId: string
    answers: JsonValue
    _count: TestParticipantRecordCountAggregateOutputType | null
    _avg: TestParticipantRecordAvgAggregateOutputType | null
    _sum: TestParticipantRecordSumAggregateOutputType | null
    _min: TestParticipantRecordMinAggregateOutputType | null
    _max: TestParticipantRecordMaxAggregateOutputType | null
  }

  type GetTestParticipantRecordGroupByPayload<T extends TestParticipantRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParticipantRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParticipantRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParticipantRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TestParticipantRecordGroupByOutputType[P]>
        }
      >
    >


  export type TestParticipantRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectScalar = {
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    answers?: boolean
  }

  export type TestParticipantRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participantId" | "startedAt" | "endedAt" | "score" | "createdAt" | "updatedAt" | "userId" | "answers", ExtArgs["result"]["testParticipantRecord"]>
  export type TestParticipantRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestParticipantRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestParticipantRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestParticipantRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParticipantRecord"
    objects: {
      participant: Prisma.$TestParticipantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participantId: string
      startedAt: Date | null
      endedAt: Date | null
      score: number
      createdAt: Date
      updatedAt: Date
      userId: string
      answers: Prisma.JsonValue
    }, ExtArgs["result"]["testParticipantRecord"]>
    composites: {}
  }

  type TestParticipantRecordGetPayload<S extends boolean | null | undefined | TestParticipantRecordDefaultArgs> = $Result.GetResult<Prisma.$TestParticipantRecordPayload, S>

  type TestParticipantRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParticipantRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParticipantRecordCountAggregateInputType | true
    }

  export interface TestParticipantRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParticipantRecord'], meta: { name: 'TestParticipantRecord' } }
    /**
     * Find zero or one TestParticipantRecord that matches the filter.
     * @param {TestParticipantRecordFindUniqueArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParticipantRecordFindUniqueArgs>(args: SelectSubset<T, TestParticipantRecordFindUniqueArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParticipantRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParticipantRecordFindUniqueOrThrowArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParticipantRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipantRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindFirstArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParticipantRecordFindFirstArgs>(args?: SelectSubset<T, TestParticipantRecordFindFirstArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipantRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindFirstOrThrowArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParticipantRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParticipantRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParticipantRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParticipantRecords
     * const testParticipantRecords = await prisma.testParticipantRecord.findMany()
     * 
     * // Get first 10 TestParticipantRecords
     * const testParticipantRecords = await prisma.testParticipantRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParticipantRecordFindManyArgs>(args?: SelectSubset<T, TestParticipantRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParticipantRecord.
     * @param {TestParticipantRecordCreateArgs} args - Arguments to create a TestParticipantRecord.
     * @example
     * // Create one TestParticipantRecord
     * const TestParticipantRecord = await prisma.testParticipantRecord.create({
     *   data: {
     *     // ... data to create a TestParticipantRecord
     *   }
     * })
     * 
     */
    create<T extends TestParticipantRecordCreateArgs>(args: SelectSubset<T, TestParticipantRecordCreateArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParticipantRecords.
     * @param {TestParticipantRecordCreateManyArgs} args - Arguments to create many TestParticipantRecords.
     * @example
     * // Create many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParticipantRecordCreateManyArgs>(args?: SelectSubset<T, TestParticipantRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParticipantRecords and returns the data saved in the database.
     * @param {TestParticipantRecordCreateManyAndReturnArgs} args - Arguments to create many TestParticipantRecords.
     * @example
     * // Create many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParticipantRecords and only return the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParticipantRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParticipantRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParticipantRecord.
     * @param {TestParticipantRecordDeleteArgs} args - Arguments to delete one TestParticipantRecord.
     * @example
     * // Delete one TestParticipantRecord
     * const TestParticipantRecord = await prisma.testParticipantRecord.delete({
     *   where: {
     *     // ... filter to delete one TestParticipantRecord
     *   }
     * })
     * 
     */
    delete<T extends TestParticipantRecordDeleteArgs>(args: SelectSubset<T, TestParticipantRecordDeleteArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParticipantRecord.
     * @param {TestParticipantRecordUpdateArgs} args - Arguments to update one TestParticipantRecord.
     * @example
     * // Update one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParticipantRecordUpdateArgs>(args: SelectSubset<T, TestParticipantRecordUpdateArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParticipantRecords.
     * @param {TestParticipantRecordDeleteManyArgs} args - Arguments to filter TestParticipantRecords to delete.
     * @example
     * // Delete a few TestParticipantRecords
     * const { count } = await prisma.testParticipantRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParticipantRecordDeleteManyArgs>(args?: SelectSubset<T, TestParticipantRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipantRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParticipantRecordUpdateManyArgs>(args: SelectSubset<T, TestParticipantRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipantRecords and returns the data updated in the database.
     * @param {TestParticipantRecordUpdateManyAndReturnArgs} args - Arguments to update many TestParticipantRecords.
     * @example
     * // Update many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParticipantRecords and only return the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParticipantRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParticipantRecord.
     * @param {TestParticipantRecordUpsertArgs} args - Arguments to update or create a TestParticipantRecord.
     * @example
     * // Update or create a TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.upsert({
     *   create: {
     *     // ... data to create a TestParticipantRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParticipantRecord we want to update
     *   }
     * })
     */
    upsert<T extends TestParticipantRecordUpsertArgs>(args: SelectSubset<T, TestParticipantRecordUpsertArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParticipantRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordCountArgs} args - Arguments to filter TestParticipantRecords to count.
     * @example
     * // Count the number of TestParticipantRecords
     * const count = await prisma.testParticipantRecord.count({
     *   where: {
     *     // ... the filter for the TestParticipantRecords we want to count
     *   }
     * })
    **/
    count<T extends TestParticipantRecordCountArgs>(
      args?: Subset<T, TestParticipantRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParticipantRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParticipantRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParticipantRecordAggregateArgs>(args: Subset<T, TestParticipantRecordAggregateArgs>): Prisma.PrismaPromise<GetTestParticipantRecordAggregateType<T>>

    /**
     * Group by TestParticipantRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParticipantRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParticipantRecordGroupByArgs['orderBy'] }
        : { orderBy?: TestParticipantRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParticipantRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParticipantRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParticipantRecord model
   */
  readonly fields: TestParticipantRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParticipantRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParticipantRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends TestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParticipantDefaultArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParticipantRecord model
   */
  interface TestParticipantRecordFieldRefs {
    readonly id: FieldRef<"TestParticipantRecord", 'String'>
    readonly participantId: FieldRef<"TestParticipantRecord", 'String'>
    readonly startedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly endedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly score: FieldRef<"TestParticipantRecord", 'Float'>
    readonly createdAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly userId: FieldRef<"TestParticipantRecord", 'String'>
    readonly answers: FieldRef<"TestParticipantRecord", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TestParticipantRecord findUnique
   */
  export type TestParticipantRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord findUniqueOrThrow
   */
  export type TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord findFirst
   */
  export type TestParticipantRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipantRecords.
     */
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord findFirstOrThrow
   */
  export type TestParticipantRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipantRecords.
     */
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord findMany
   */
  export type TestParticipantRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecords to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord create
   */
  export type TestParticipantRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParticipantRecord.
     */
    data: XOR<TestParticipantRecordCreateInput, TestParticipantRecordUncheckedCreateInput>
  }

  /**
   * TestParticipantRecord createMany
   */
  export type TestParticipantRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParticipantRecords.
     */
    data: TestParticipantRecordCreateManyInput | TestParticipantRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParticipantRecord createManyAndReturn
   */
  export type TestParticipantRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TestParticipantRecords.
     */
    data: TestParticipantRecordCreateManyInput | TestParticipantRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipantRecord update
   */
  export type TestParticipantRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParticipantRecord.
     */
    data: XOR<TestParticipantRecordUpdateInput, TestParticipantRecordUncheckedUpdateInput>
    /**
     * Choose, which TestParticipantRecord to update.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord updateMany
   */
  export type TestParticipantRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParticipantRecords.
     */
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipantRecords to update
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to update.
     */
    limit?: number
  }

  /**
   * TestParticipantRecord updateManyAndReturn
   */
  export type TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * The data used to update TestParticipantRecords.
     */
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipantRecords to update
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipantRecord upsert
   */
  export type TestParticipantRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParticipantRecord to update in case it exists.
     */
    where: TestParticipantRecordWhereUniqueInput
    /**
     * In case the TestParticipantRecord found by the `where` argument doesn't exist, create a new TestParticipantRecord with this data.
     */
    create: XOR<TestParticipantRecordCreateInput, TestParticipantRecordUncheckedCreateInput>
    /**
     * In case the TestParticipantRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParticipantRecordUpdateInput, TestParticipantRecordUncheckedUpdateInput>
  }

  /**
   * TestParticipantRecord delete
   */
  export type TestParticipantRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter which TestParticipantRecord to delete.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord deleteMany
   */
  export type TestParticipantRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipantRecords to delete
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to delete.
     */
    limit?: number
  }

  /**
   * TestParticipantRecord without action
   */
  export type TestParticipantRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
  }


  /**
   * Model Background
   */

  export type AggregateBackground = {
    _count: BackgroundCountAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  export type BackgroundMinAggregateOutputType = {
    id: string | null
    name: string | null
    thumbnail: string | null
    isUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackgroundMaxAggregateOutputType = {
    id: string | null
    name: string | null
    thumbnail: string | null
    isUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackgroundCountAggregateOutputType = {
    id: number
    name: number
    thumbnail: number
    isUse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BackgroundMinAggregateInputType = {
    id?: true
    name?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackgroundMaxAggregateInputType = {
    id?: true
    name?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackgroundCountAggregateInputType = {
    id?: true
    name?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BackgroundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Background to aggregate.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backgrounds
    **/
    _count?: true | BackgroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackgroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackgroundMaxAggregateInputType
  }

  export type GetBackgroundAggregateType<T extends BackgroundAggregateArgs> = {
        [P in keyof T & keyof AggregateBackground]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackground[P]>
      : GetScalarType<T[P], AggregateBackground[P]>
  }




  export type BackgroundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackgroundWhereInput
    orderBy?: BackgroundOrderByWithAggregationInput | BackgroundOrderByWithAggregationInput[]
    by: BackgroundScalarFieldEnum[] | BackgroundScalarFieldEnum
    having?: BackgroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackgroundCountAggregateInputType | true
    _min?: BackgroundMinAggregateInputType
    _max?: BackgroundMaxAggregateInputType
  }

  export type BackgroundGroupByOutputType = {
    id: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt: Date
    updatedAt: Date
    _count: BackgroundCountAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  type GetBackgroundGroupByPayload<T extends BackgroundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackgroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackgroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
            : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
        }
      >
    >


  export type BackgroundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectScalar = {
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BackgroundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "thumbnail" | "isUse" | "createdAt" | "updatedAt", ExtArgs["result"]["background"]>

  export type $BackgroundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Background"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      thumbnail: string
      isUse: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["background"]>
    composites: {}
  }

  type BackgroundGetPayload<S extends boolean | null | undefined | BackgroundDefaultArgs> = $Result.GetResult<Prisma.$BackgroundPayload, S>

  type BackgroundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BackgroundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BackgroundCountAggregateInputType | true
    }

  export interface BackgroundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Background'], meta: { name: 'Background' } }
    /**
     * Find zero or one Background that matches the filter.
     * @param {BackgroundFindUniqueArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackgroundFindUniqueArgs>(args: SelectSubset<T, BackgroundFindUniqueArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Background that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BackgroundFindUniqueOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackgroundFindUniqueOrThrowArgs>(args: SelectSubset<T, BackgroundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackgroundFindFirstArgs>(args?: SelectSubset<T, BackgroundFindFirstArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackgroundFindFirstOrThrowArgs>(args?: SelectSubset<T, BackgroundFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Backgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backgrounds
     * const backgrounds = await prisma.background.findMany()
     * 
     * // Get first 10 Backgrounds
     * const backgrounds = await prisma.background.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backgroundWithIdOnly = await prisma.background.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackgroundFindManyArgs>(args?: SelectSubset<T, BackgroundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Background.
     * @param {BackgroundCreateArgs} args - Arguments to create a Background.
     * @example
     * // Create one Background
     * const Background = await prisma.background.create({
     *   data: {
     *     // ... data to create a Background
     *   }
     * })
     * 
     */
    create<T extends BackgroundCreateArgs>(args: SelectSubset<T, BackgroundCreateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Backgrounds.
     * @param {BackgroundCreateManyArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackgroundCreateManyArgs>(args?: SelectSubset<T, BackgroundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Backgrounds and returns the data saved in the database.
     * @param {BackgroundCreateManyAndReturnArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Backgrounds and only return the `id`
     * const backgroundWithIdOnly = await prisma.background.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackgroundCreateManyAndReturnArgs>(args?: SelectSubset<T, BackgroundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Background.
     * @param {BackgroundDeleteArgs} args - Arguments to delete one Background.
     * @example
     * // Delete one Background
     * const Background = await prisma.background.delete({
     *   where: {
     *     // ... filter to delete one Background
     *   }
     * })
     * 
     */
    delete<T extends BackgroundDeleteArgs>(args: SelectSubset<T, BackgroundDeleteArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Background.
     * @param {BackgroundUpdateArgs} args - Arguments to update one Background.
     * @example
     * // Update one Background
     * const background = await prisma.background.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackgroundUpdateArgs>(args: SelectSubset<T, BackgroundUpdateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Backgrounds.
     * @param {BackgroundDeleteManyArgs} args - Arguments to filter Backgrounds to delete.
     * @example
     * // Delete a few Backgrounds
     * const { count } = await prisma.background.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackgroundDeleteManyArgs>(args?: SelectSubset<T, BackgroundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackgroundUpdateManyArgs>(args: SelectSubset<T, BackgroundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds and returns the data updated in the database.
     * @param {BackgroundUpdateManyAndReturnArgs} args - Arguments to update many Backgrounds.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Backgrounds and only return the `id`
     * const backgroundWithIdOnly = await prisma.background.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BackgroundUpdateManyAndReturnArgs>(args: SelectSubset<T, BackgroundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Background.
     * @param {BackgroundUpsertArgs} args - Arguments to update or create a Background.
     * @example
     * // Update or create a Background
     * const background = await prisma.background.upsert({
     *   create: {
     *     // ... data to create a Background
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Background we want to update
     *   }
     * })
     */
    upsert<T extends BackgroundUpsertArgs>(args: SelectSubset<T, BackgroundUpsertArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundCountArgs} args - Arguments to filter Backgrounds to count.
     * @example
     * // Count the number of Backgrounds
     * const count = await prisma.background.count({
     *   where: {
     *     // ... the filter for the Backgrounds we want to count
     *   }
     * })
    **/
    count<T extends BackgroundCountArgs>(
      args?: Subset<T, BackgroundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackgroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackgroundAggregateArgs>(args: Subset<T, BackgroundAggregateArgs>): Prisma.PrismaPromise<GetBackgroundAggregateType<T>>

    /**
     * Group by Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackgroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackgroundGroupByArgs['orderBy'] }
        : { orderBy?: BackgroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackgroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackgroundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Background model
   */
  readonly fields: BackgroundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Background.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackgroundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Background model
   */
  interface BackgroundFieldRefs {
    readonly id: FieldRef<"Background", 'String'>
    readonly name: FieldRef<"Background", 'String'>
    readonly thumbnail: FieldRef<"Background", 'String'>
    readonly isUse: FieldRef<"Background", 'Boolean'>
    readonly createdAt: FieldRef<"Background", 'DateTime'>
    readonly updatedAt: FieldRef<"Background", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Background findUnique
   */
  export type BackgroundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findUniqueOrThrow
   */
  export type BackgroundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findFirst
   */
  export type BackgroundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findFirstOrThrow
   */
  export type BackgroundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findMany
   */
  export type BackgroundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Backgrounds to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background create
   */
  export type BackgroundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data needed to create a Background.
     */
    data: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
  }

  /**
   * Background createMany
   */
  export type BackgroundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background createManyAndReturn
   */
  export type BackgroundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background update
   */
  export type BackgroundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data needed to update a Background.
     */
    data: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
    /**
     * Choose, which Background to update.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background updateMany
   */
  export type BackgroundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background updateManyAndReturn
   */
  export type BackgroundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background upsert
   */
  export type BackgroundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The filter to search for the Background to update in case it exists.
     */
    where: BackgroundWhereUniqueInput
    /**
     * In case the Background found by the `where` argument doesn't exist, create a new Background with this data.
     */
    create: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
    /**
     * In case the Background was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
  }

  /**
   * Background delete
   */
  export type BackgroundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter which Background to delete.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background deleteMany
   */
  export type BackgroundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backgrounds to delete
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to delete.
     */
    limit?: number
  }

  /**
   * Background without action
   */
  export type BackgroundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    name: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    name: string
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "title" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly name: FieldRef<"Setting", 'String'>
    readonly title: FieldRef<"Setting", 'String'>
    readonly content: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    id: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type VoucherSumAggregateOutputType = {
    id: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: number | null
    code: string | null
    quota: number | null
    currentQuota: number | null
    startedAt: Date | null
    endedAt: Date | null
    type: $Enums.VoucherType | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: number | null
    code: string | null
    quota: number | null
    currentQuota: number | null
    startedAt: Date | null
    endedAt: Date | null
    type: $Enums.VoucherType | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    code: number
    quota: number
    currentQuota: number
    startedAt: number
    endedAt: number
    type: number
    zones: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    id?: true
    quota?: true
    currentQuota?: true
  }

  export type VoucherSumAggregateInputType = {
    id?: true
    quota?: true
    currentQuota?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    code?: true
    quota?: true
    currentQuota?: true
    startedAt?: true
    endedAt?: true
    type?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    code?: true
    quota?: true
    currentQuota?: true
    startedAt?: true
    endedAt?: true
    type?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    code?: true
    quota?: true
    currentQuota?: true
    startedAt?: true
    endedAt?: true
    type?: true
    zones?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: number
    code: string
    quota: number
    currentQuota: number
    startedAt: Date
    endedAt: Date | null
    type: $Enums.VoucherType
    zones: string[]
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    quota?: boolean
    currentQuota?: boolean
    startedAt?: boolean
    endedAt?: boolean
    type?: boolean
    zones?: boolean
    redemeers?: boolean | Voucher$redemeersArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    quota?: boolean
    currentQuota?: boolean
    startedAt?: boolean
    endedAt?: boolean
    type?: boolean
    zones?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    quota?: boolean
    currentQuota?: boolean
    startedAt?: boolean
    endedAt?: boolean
    type?: boolean
    zones?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    code?: boolean
    quota?: boolean
    currentQuota?: boolean
    startedAt?: boolean
    endedAt?: boolean
    type?: boolean
    zones?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "quota" | "currentQuota" | "startedAt" | "endedAt" | "type" | "zones", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemeers?: boolean | Voucher$redemeersArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      redemeers: Prisma.$VoucherRedemeerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      quota: number
      currentQuota: number
      startedAt: Date
      endedAt: Date | null
      type: $Enums.VoucherType
      zones: string[]
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redemeers<T extends Voucher$redemeersArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$redemeersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'Int'>
    readonly code: FieldRef<"Voucher", 'String'>
    readonly quota: FieldRef<"Voucher", 'Int'>
    readonly currentQuota: FieldRef<"Voucher", 'Int'>
    readonly startedAt: FieldRef<"Voucher", 'DateTime'>
    readonly endedAt: FieldRef<"Voucher", 'DateTime'>
    readonly type: FieldRef<"Voucher", 'VoucherType'>
    readonly zones: FieldRef<"Voucher", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.redemeers
   */
  export type Voucher$redemeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    where?: VoucherRedemeerWhereInput
    orderBy?: VoucherRedemeerOrderByWithRelationInput | VoucherRedemeerOrderByWithRelationInput[]
    cursor?: VoucherRedemeerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherRedemeerScalarFieldEnum | VoucherRedemeerScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model VoucherRedemeer
   */

  export type AggregateVoucherRedemeer = {
    _count: VoucherRedemeerCountAggregateOutputType | null
    _avg: VoucherRedemeerAvgAggregateOutputType | null
    _sum: VoucherRedemeerSumAggregateOutputType | null
    _min: VoucherRedemeerMinAggregateOutputType | null
    _max: VoucherRedemeerMaxAggregateOutputType | null
  }

  export type VoucherRedemeerAvgAggregateOutputType = {
    id: number | null
    voucherId: number | null
  }

  export type VoucherRedemeerSumAggregateOutputType = {
    id: number | null
    voucherId: number | null
  }

  export type VoucherRedemeerMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    voucherId: number | null
    userId: string | null
  }

  export type VoucherRedemeerMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    voucherId: number | null
    userId: string | null
  }

  export type VoucherRedemeerCountAggregateOutputType = {
    id: number
    createdAt: number
    voucherId: number
    userId: number
    _all: number
  }


  export type VoucherRedemeerAvgAggregateInputType = {
    id?: true
    voucherId?: true
  }

  export type VoucherRedemeerSumAggregateInputType = {
    id?: true
    voucherId?: true
  }

  export type VoucherRedemeerMinAggregateInputType = {
    id?: true
    createdAt?: true
    voucherId?: true
    userId?: true
  }

  export type VoucherRedemeerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    voucherId?: true
    userId?: true
  }

  export type VoucherRedemeerCountAggregateInputType = {
    id?: true
    createdAt?: true
    voucherId?: true
    userId?: true
    _all?: true
  }

  export type VoucherRedemeerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherRedemeer to aggregate.
     */
    where?: VoucherRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherRedemeers to fetch.
     */
    orderBy?: VoucherRedemeerOrderByWithRelationInput | VoucherRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherRedemeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherRedemeers
    **/
    _count?: true | VoucherRedemeerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherRedemeerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherRedemeerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherRedemeerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherRedemeerMaxAggregateInputType
  }

  export type GetVoucherRedemeerAggregateType<T extends VoucherRedemeerAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherRedemeer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherRedemeer[P]>
      : GetScalarType<T[P], AggregateVoucherRedemeer[P]>
  }




  export type VoucherRedemeerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherRedemeerWhereInput
    orderBy?: VoucherRedemeerOrderByWithAggregationInput | VoucherRedemeerOrderByWithAggregationInput[]
    by: VoucherRedemeerScalarFieldEnum[] | VoucherRedemeerScalarFieldEnum
    having?: VoucherRedemeerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherRedemeerCountAggregateInputType | true
    _avg?: VoucherRedemeerAvgAggregateInputType
    _sum?: VoucherRedemeerSumAggregateInputType
    _min?: VoucherRedemeerMinAggregateInputType
    _max?: VoucherRedemeerMaxAggregateInputType
  }

  export type VoucherRedemeerGroupByOutputType = {
    id: number
    createdAt: Date
    voucherId: number
    userId: string
    _count: VoucherRedemeerCountAggregateOutputType | null
    _avg: VoucherRedemeerAvgAggregateOutputType | null
    _sum: VoucherRedemeerSumAggregateOutputType | null
    _min: VoucherRedemeerMinAggregateOutputType | null
    _max: VoucherRedemeerMaxAggregateOutputType | null
  }

  type GetVoucherRedemeerGroupByPayload<T extends VoucherRedemeerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherRedemeerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherRedemeerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherRedemeerGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherRedemeerGroupByOutputType[P]>
        }
      >
    >


  export type VoucherRedemeerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    voucherId?: boolean
    userId?: boolean
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherRedemeer"]>

  export type VoucherRedemeerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    voucherId?: boolean
    userId?: boolean
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherRedemeer"]>

  export type VoucherRedemeerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    voucherId?: boolean
    userId?: boolean
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherRedemeer"]>

  export type VoucherRedemeerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    voucherId?: boolean
    userId?: boolean
  }

  export type VoucherRedemeerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "voucherId" | "userId", ExtArgs["result"]["voucherRedemeer"]>
  export type VoucherRedemeerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoucherRedemeerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoucherRedemeerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VoucherRedemeerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherRedemeer"
    objects: {
      voucher: Prisma.$VoucherPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      voucherId: number
      userId: string
    }, ExtArgs["result"]["voucherRedemeer"]>
    composites: {}
  }

  type VoucherRedemeerGetPayload<S extends boolean | null | undefined | VoucherRedemeerDefaultArgs> = $Result.GetResult<Prisma.$VoucherRedemeerPayload, S>

  type VoucherRedemeerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherRedemeerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherRedemeerCountAggregateInputType | true
    }

  export interface VoucherRedemeerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherRedemeer'], meta: { name: 'VoucherRedemeer' } }
    /**
     * Find zero or one VoucherRedemeer that matches the filter.
     * @param {VoucherRedemeerFindUniqueArgs} args - Arguments to find a VoucherRedemeer
     * @example
     * // Get one VoucherRedemeer
     * const voucherRedemeer = await prisma.voucherRedemeer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherRedemeerFindUniqueArgs>(args: SelectSubset<T, VoucherRedemeerFindUniqueArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoucherRedemeer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherRedemeerFindUniqueOrThrowArgs} args - Arguments to find a VoucherRedemeer
     * @example
     * // Get one VoucherRedemeer
     * const voucherRedemeer = await prisma.voucherRedemeer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherRedemeerFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherRedemeerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherRedemeer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerFindFirstArgs} args - Arguments to find a VoucherRedemeer
     * @example
     * // Get one VoucherRedemeer
     * const voucherRedemeer = await prisma.voucherRedemeer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherRedemeerFindFirstArgs>(args?: SelectSubset<T, VoucherRedemeerFindFirstArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherRedemeer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerFindFirstOrThrowArgs} args - Arguments to find a VoucherRedemeer
     * @example
     * // Get one VoucherRedemeer
     * const voucherRedemeer = await prisma.voucherRedemeer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherRedemeerFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherRedemeerFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoucherRedemeers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherRedemeers
     * const voucherRedemeers = await prisma.voucherRedemeer.findMany()
     * 
     * // Get first 10 VoucherRedemeers
     * const voucherRedemeers = await prisma.voucherRedemeer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherRedemeerWithIdOnly = await prisma.voucherRedemeer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherRedemeerFindManyArgs>(args?: SelectSubset<T, VoucherRedemeerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoucherRedemeer.
     * @param {VoucherRedemeerCreateArgs} args - Arguments to create a VoucherRedemeer.
     * @example
     * // Create one VoucherRedemeer
     * const VoucherRedemeer = await prisma.voucherRedemeer.create({
     *   data: {
     *     // ... data to create a VoucherRedemeer
     *   }
     * })
     * 
     */
    create<T extends VoucherRedemeerCreateArgs>(args: SelectSubset<T, VoucherRedemeerCreateArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoucherRedemeers.
     * @param {VoucherRedemeerCreateManyArgs} args - Arguments to create many VoucherRedemeers.
     * @example
     * // Create many VoucherRedemeers
     * const voucherRedemeer = await prisma.voucherRedemeer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherRedemeerCreateManyArgs>(args?: SelectSubset<T, VoucherRedemeerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherRedemeers and returns the data saved in the database.
     * @param {VoucherRedemeerCreateManyAndReturnArgs} args - Arguments to create many VoucherRedemeers.
     * @example
     * // Create many VoucherRedemeers
     * const voucherRedemeer = await prisma.voucherRedemeer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherRedemeers and only return the `id`
     * const voucherRedemeerWithIdOnly = await prisma.voucherRedemeer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherRedemeerCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherRedemeerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoucherRedemeer.
     * @param {VoucherRedemeerDeleteArgs} args - Arguments to delete one VoucherRedemeer.
     * @example
     * // Delete one VoucherRedemeer
     * const VoucherRedemeer = await prisma.voucherRedemeer.delete({
     *   where: {
     *     // ... filter to delete one VoucherRedemeer
     *   }
     * })
     * 
     */
    delete<T extends VoucherRedemeerDeleteArgs>(args: SelectSubset<T, VoucherRedemeerDeleteArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoucherRedemeer.
     * @param {VoucherRedemeerUpdateArgs} args - Arguments to update one VoucherRedemeer.
     * @example
     * // Update one VoucherRedemeer
     * const voucherRedemeer = await prisma.voucherRedemeer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherRedemeerUpdateArgs>(args: SelectSubset<T, VoucherRedemeerUpdateArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoucherRedemeers.
     * @param {VoucherRedemeerDeleteManyArgs} args - Arguments to filter VoucherRedemeers to delete.
     * @example
     * // Delete a few VoucherRedemeers
     * const { count } = await prisma.voucherRedemeer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherRedemeerDeleteManyArgs>(args?: SelectSubset<T, VoucherRedemeerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherRedemeers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherRedemeers
     * const voucherRedemeer = await prisma.voucherRedemeer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherRedemeerUpdateManyArgs>(args: SelectSubset<T, VoucherRedemeerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherRedemeers and returns the data updated in the database.
     * @param {VoucherRedemeerUpdateManyAndReturnArgs} args - Arguments to update many VoucherRedemeers.
     * @example
     * // Update many VoucherRedemeers
     * const voucherRedemeer = await prisma.voucherRedemeer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoucherRedemeers and only return the `id`
     * const voucherRedemeerWithIdOnly = await prisma.voucherRedemeer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherRedemeerUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherRedemeerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoucherRedemeer.
     * @param {VoucherRedemeerUpsertArgs} args - Arguments to update or create a VoucherRedemeer.
     * @example
     * // Update or create a VoucherRedemeer
     * const voucherRedemeer = await prisma.voucherRedemeer.upsert({
     *   create: {
     *     // ... data to create a VoucherRedemeer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherRedemeer we want to update
     *   }
     * })
     */
    upsert<T extends VoucherRedemeerUpsertArgs>(args: SelectSubset<T, VoucherRedemeerUpsertArgs<ExtArgs>>): Prisma__VoucherRedemeerClient<$Result.GetResult<Prisma.$VoucherRedemeerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoucherRedemeers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerCountArgs} args - Arguments to filter VoucherRedemeers to count.
     * @example
     * // Count the number of VoucherRedemeers
     * const count = await prisma.voucherRedemeer.count({
     *   where: {
     *     // ... the filter for the VoucherRedemeers we want to count
     *   }
     * })
    **/
    count<T extends VoucherRedemeerCountArgs>(
      args?: Subset<T, VoucherRedemeerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherRedemeerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherRedemeer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherRedemeerAggregateArgs>(args: Subset<T, VoucherRedemeerAggregateArgs>): Prisma.PrismaPromise<GetVoucherRedemeerAggregateType<T>>

    /**
     * Group by VoucherRedemeer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherRedemeerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherRedemeerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherRedemeerGroupByArgs['orderBy'] }
        : { orderBy?: VoucherRedemeerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherRedemeerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherRedemeerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherRedemeer model
   */
  readonly fields: VoucherRedemeerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherRedemeer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherRedemeerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherRedemeer model
   */
  interface VoucherRedemeerFieldRefs {
    readonly id: FieldRef<"VoucherRedemeer", 'Int'>
    readonly createdAt: FieldRef<"VoucherRedemeer", 'DateTime'>
    readonly voucherId: FieldRef<"VoucherRedemeer", 'Int'>
    readonly userId: FieldRef<"VoucherRedemeer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VoucherRedemeer findUnique
   */
  export type VoucherRedemeerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which VoucherRedemeer to fetch.
     */
    where: VoucherRedemeerWhereUniqueInput
  }

  /**
   * VoucherRedemeer findUniqueOrThrow
   */
  export type VoucherRedemeerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which VoucherRedemeer to fetch.
     */
    where: VoucherRedemeerWhereUniqueInput
  }

  /**
   * VoucherRedemeer findFirst
   */
  export type VoucherRedemeerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which VoucherRedemeer to fetch.
     */
    where?: VoucherRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherRedemeers to fetch.
     */
    orderBy?: VoucherRedemeerOrderByWithRelationInput | VoucherRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherRedemeers.
     */
    cursor?: VoucherRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherRedemeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherRedemeers.
     */
    distinct?: VoucherRedemeerScalarFieldEnum | VoucherRedemeerScalarFieldEnum[]
  }

  /**
   * VoucherRedemeer findFirstOrThrow
   */
  export type VoucherRedemeerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which VoucherRedemeer to fetch.
     */
    where?: VoucherRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherRedemeers to fetch.
     */
    orderBy?: VoucherRedemeerOrderByWithRelationInput | VoucherRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherRedemeers.
     */
    cursor?: VoucherRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherRedemeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherRedemeers.
     */
    distinct?: VoucherRedemeerScalarFieldEnum | VoucherRedemeerScalarFieldEnum[]
  }

  /**
   * VoucherRedemeer findMany
   */
  export type VoucherRedemeerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which VoucherRedemeers to fetch.
     */
    where?: VoucherRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherRedemeers to fetch.
     */
    orderBy?: VoucherRedemeerOrderByWithRelationInput | VoucherRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherRedemeers.
     */
    cursor?: VoucherRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherRedemeers.
     */
    skip?: number
    distinct?: VoucherRedemeerScalarFieldEnum | VoucherRedemeerScalarFieldEnum[]
  }

  /**
   * VoucherRedemeer create
   */
  export type VoucherRedemeerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherRedemeer.
     */
    data: XOR<VoucherRedemeerCreateInput, VoucherRedemeerUncheckedCreateInput>
  }

  /**
   * VoucherRedemeer createMany
   */
  export type VoucherRedemeerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherRedemeers.
     */
    data: VoucherRedemeerCreateManyInput | VoucherRedemeerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherRedemeer createManyAndReturn
   */
  export type VoucherRedemeerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * The data used to create many VoucherRedemeers.
     */
    data: VoucherRedemeerCreateManyInput | VoucherRedemeerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherRedemeer update
   */
  export type VoucherRedemeerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherRedemeer.
     */
    data: XOR<VoucherRedemeerUpdateInput, VoucherRedemeerUncheckedUpdateInput>
    /**
     * Choose, which VoucherRedemeer to update.
     */
    where: VoucherRedemeerWhereUniqueInput
  }

  /**
   * VoucherRedemeer updateMany
   */
  export type VoucherRedemeerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherRedemeers.
     */
    data: XOR<VoucherRedemeerUpdateManyMutationInput, VoucherRedemeerUncheckedUpdateManyInput>
    /**
     * Filter which VoucherRedemeers to update
     */
    where?: VoucherRedemeerWhereInput
    /**
     * Limit how many VoucherRedemeers to update.
     */
    limit?: number
  }

  /**
   * VoucherRedemeer updateManyAndReturn
   */
  export type VoucherRedemeerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * The data used to update VoucherRedemeers.
     */
    data: XOR<VoucherRedemeerUpdateManyMutationInput, VoucherRedemeerUncheckedUpdateManyInput>
    /**
     * Filter which VoucherRedemeers to update
     */
    where?: VoucherRedemeerWhereInput
    /**
     * Limit how many VoucherRedemeers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherRedemeer upsert
   */
  export type VoucherRedemeerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherRedemeer to update in case it exists.
     */
    where: VoucherRedemeerWhereUniqueInput
    /**
     * In case the VoucherRedemeer found by the `where` argument doesn't exist, create a new VoucherRedemeer with this data.
     */
    create: XOR<VoucherRedemeerCreateInput, VoucherRedemeerUncheckedCreateInput>
    /**
     * In case the VoucherRedemeer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherRedemeerUpdateInput, VoucherRedemeerUncheckedUpdateInput>
  }

  /**
   * VoucherRedemeer delete
   */
  export type VoucherRedemeerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
    /**
     * Filter which VoucherRedemeer to delete.
     */
    where: VoucherRedemeerWhereUniqueInput
  }

  /**
   * VoucherRedemeer deleteMany
   */
  export type VoucherRedemeerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherRedemeers to delete
     */
    where?: VoucherRedemeerWhereInput
    /**
     * Limit how many VoucherRedemeers to delete.
     */
    limit?: number
  }

  /**
   * VoucherRedemeer without action
   */
  export type VoucherRedemeerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherRedemeer
     */
    select?: VoucherRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherRedemeer
     */
    omit?: VoucherRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherRedemeerInclude<ExtArgs> | null
  }


  /**
   * Model AdminTransaction
   */

  export type AggregateAdminTransaction = {
    _count: AdminTransactionCountAggregateOutputType | null
    _avg: AdminTransactionAvgAggregateOutputType | null
    _sum: AdminTransactionSumAggregateOutputType | null
    _min: AdminTransactionMinAggregateOutputType | null
    _max: AdminTransactionMaxAggregateOutputType | null
  }

  export type AdminTransactionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type AdminTransactionSumAggregateOutputType = {
    quantity: number | null
  }

  export type AdminTransactionMinAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type AdminTransactionMaxAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type AdminTransactionCountAggregateOutputType = {
    id: number
    transactionName: number
    status: number
    createdAt: number
    expiredAt: number
    updatedAt: number
    customerEmail: number
    customerName: number
    customerId: number
    quantity: number
    zones: number
    _all: number
  }


  export type AdminTransactionAvgAggregateInputType = {
    quantity?: true
  }

  export type AdminTransactionSumAggregateInputType = {
    quantity?: true
  }

  export type AdminTransactionMinAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type AdminTransactionMaxAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type AdminTransactionCountAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
    zones?: true
    _all?: true
  }

  export type AdminTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransaction to aggregate.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminTransactions
    **/
    _count?: true | AdminTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminTransactionMaxAggregateInputType
  }

  export type GetAdminTransactionAggregateType<T extends AdminTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminTransaction[P]>
      : GetScalarType<T[P], AggregateAdminTransaction[P]>
  }




  export type AdminTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithAggregationInput | AdminTransactionOrderByWithAggregationInput[]
    by: AdminTransactionScalarFieldEnum[] | AdminTransactionScalarFieldEnum
    having?: AdminTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminTransactionCountAggregateInputType | true
    _avg?: AdminTransactionAvgAggregateInputType
    _sum?: AdminTransactionSumAggregateInputType
    _min?: AdminTransactionMinAggregateInputType
    _max?: AdminTransactionMaxAggregateInputType
  }

  export type AdminTransactionGroupByOutputType = {
    id: string
    transactionName: string
    status: string
    createdAt: Date
    expiredAt: Date
    updatedAt: Date
    customerEmail: string
    customerName: string
    customerId: string
    quantity: number
    zones: string[]
    _count: AdminTransactionCountAggregateOutputType | null
    _avg: AdminTransactionAvgAggregateOutputType | null
    _sum: AdminTransactionSumAggregateOutputType | null
    _min: AdminTransactionMinAggregateOutputType | null
    _max: AdminTransactionMaxAggregateOutputType | null
  }

  type GetAdminTransactionGroupByPayload<T extends AdminTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminTransactionGroupByOutputType[P]>
        }
      >
    >


  export type AdminTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectScalar = {
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
  }

  export type AdminTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionName" | "status" | "createdAt" | "expiredAt" | "updatedAt" | "customerEmail" | "customerName" | "customerId" | "quantity" | "zones", ExtArgs["result"]["adminTransaction"]>
  export type AdminTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminTransaction"
    objects: {
      customer: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionName: string
      status: string
      createdAt: Date
      expiredAt: Date
      updatedAt: Date
      customerEmail: string
      customerName: string
      customerId: string
      quantity: number
      zones: string[]
    }, ExtArgs["result"]["adminTransaction"]>
    composites: {}
  }

  type AdminTransactionGetPayload<S extends boolean | null | undefined | AdminTransactionDefaultArgs> = $Result.GetResult<Prisma.$AdminTransactionPayload, S>

  type AdminTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminTransactionCountAggregateInputType | true
    }

  export interface AdminTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminTransaction'], meta: { name: 'AdminTransaction' } }
    /**
     * Find zero or one AdminTransaction that matches the filter.
     * @param {AdminTransactionFindUniqueArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminTransactionFindUniqueArgs>(args: SelectSubset<T, AdminTransactionFindUniqueArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminTransactionFindUniqueOrThrowArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindFirstArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminTransactionFindFirstArgs>(args?: SelectSubset<T, AdminTransactionFindFirstArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindFirstOrThrowArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminTransactions
     * const adminTransactions = await prisma.adminTransaction.findMany()
     * 
     * // Get first 10 AdminTransactions
     * const adminTransactions = await prisma.adminTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminTransactionFindManyArgs>(args?: SelectSubset<T, AdminTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminTransaction.
     * @param {AdminTransactionCreateArgs} args - Arguments to create a AdminTransaction.
     * @example
     * // Create one AdminTransaction
     * const AdminTransaction = await prisma.adminTransaction.create({
     *   data: {
     *     // ... data to create a AdminTransaction
     *   }
     * })
     * 
     */
    create<T extends AdminTransactionCreateArgs>(args: SelectSubset<T, AdminTransactionCreateArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminTransactions.
     * @param {AdminTransactionCreateManyArgs} args - Arguments to create many AdminTransactions.
     * @example
     * // Create many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminTransactionCreateManyArgs>(args?: SelectSubset<T, AdminTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminTransactions and returns the data saved in the database.
     * @param {AdminTransactionCreateManyAndReturnArgs} args - Arguments to create many AdminTransactions.
     * @example
     * // Create many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminTransactions and only return the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminTransaction.
     * @param {AdminTransactionDeleteArgs} args - Arguments to delete one AdminTransaction.
     * @example
     * // Delete one AdminTransaction
     * const AdminTransaction = await prisma.adminTransaction.delete({
     *   where: {
     *     // ... filter to delete one AdminTransaction
     *   }
     * })
     * 
     */
    delete<T extends AdminTransactionDeleteArgs>(args: SelectSubset<T, AdminTransactionDeleteArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminTransaction.
     * @param {AdminTransactionUpdateArgs} args - Arguments to update one AdminTransaction.
     * @example
     * // Update one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminTransactionUpdateArgs>(args: SelectSubset<T, AdminTransactionUpdateArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminTransactions.
     * @param {AdminTransactionDeleteManyArgs} args - Arguments to filter AdminTransactions to delete.
     * @example
     * // Delete a few AdminTransactions
     * const { count } = await prisma.adminTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminTransactionDeleteManyArgs>(args?: SelectSubset<T, AdminTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminTransactionUpdateManyArgs>(args: SelectSubset<T, AdminTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactions and returns the data updated in the database.
     * @param {AdminTransactionUpdateManyAndReturnArgs} args - Arguments to update many AdminTransactions.
     * @example
     * // Update many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminTransactions and only return the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminTransaction.
     * @param {AdminTransactionUpsertArgs} args - Arguments to update or create a AdminTransaction.
     * @example
     * // Update or create a AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.upsert({
     *   create: {
     *     // ... data to create a AdminTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminTransaction we want to update
     *   }
     * })
     */
    upsert<T extends AdminTransactionUpsertArgs>(args: SelectSubset<T, AdminTransactionUpsertArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionCountArgs} args - Arguments to filter AdminTransactions to count.
     * @example
     * // Count the number of AdminTransactions
     * const count = await prisma.adminTransaction.count({
     *   where: {
     *     // ... the filter for the AdminTransactions we want to count
     *   }
     * })
    **/
    count<T extends AdminTransactionCountArgs>(
      args?: Subset<T, AdminTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminTransactionAggregateArgs>(args: Subset<T, AdminTransactionAggregateArgs>): Prisma.PrismaPromise<GetAdminTransactionAggregateType<T>>

    /**
     * Group by AdminTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminTransactionGroupByArgs['orderBy'] }
        : { orderBy?: AdminTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminTransaction model
   */
  readonly fields: AdminTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminTransaction model
   */
  interface AdminTransactionFieldRefs {
    readonly id: FieldRef<"AdminTransaction", 'String'>
    readonly transactionName: FieldRef<"AdminTransaction", 'String'>
    readonly status: FieldRef<"AdminTransaction", 'String'>
    readonly createdAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly expiredAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly customerEmail: FieldRef<"AdminTransaction", 'String'>
    readonly customerName: FieldRef<"AdminTransaction", 'String'>
    readonly customerId: FieldRef<"AdminTransaction", 'String'>
    readonly quantity: FieldRef<"AdminTransaction", 'Int'>
    readonly zones: FieldRef<"AdminTransaction", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * AdminTransaction findUnique
   */
  export type AdminTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction findUniqueOrThrow
   */
  export type AdminTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction findFirst
   */
  export type AdminTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactions.
     */
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction findFirstOrThrow
   */
  export type AdminTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactions.
     */
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction findMany
   */
  export type AdminTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactions to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction create
   */
  export type AdminTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminTransaction.
     */
    data: XOR<AdminTransactionCreateInput, AdminTransactionUncheckedCreateInput>
  }

  /**
   * AdminTransaction createMany
   */
  export type AdminTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminTransactions.
     */
    data: AdminTransactionCreateManyInput | AdminTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminTransaction createManyAndReturn
   */
  export type AdminTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminTransactions.
     */
    data: AdminTransactionCreateManyInput | AdminTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransaction update
   */
  export type AdminTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminTransaction.
     */
    data: XOR<AdminTransactionUpdateInput, AdminTransactionUncheckedUpdateInput>
    /**
     * Choose, which AdminTransaction to update.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction updateMany
   */
  export type AdminTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminTransactions.
     */
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactions to update
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to update.
     */
    limit?: number
  }

  /**
   * AdminTransaction updateManyAndReturn
   */
  export type AdminTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * The data used to update AdminTransactions.
     */
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactions to update
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransaction upsert
   */
  export type AdminTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminTransaction to update in case it exists.
     */
    where: AdminTransactionWhereUniqueInput
    /**
     * In case the AdminTransaction found by the `where` argument doesn't exist, create a new AdminTransaction with this data.
     */
    create: XOR<AdminTransactionCreateInput, AdminTransactionUncheckedCreateInput>
    /**
     * In case the AdminTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminTransactionUpdateInput, AdminTransactionUncheckedUpdateInput>
  }

  /**
   * AdminTransaction delete
   */
  export type AdminTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter which AdminTransaction to delete.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction deleteMany
   */
  export type AdminTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransactions to delete
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to delete.
     */
    limit?: number
  }

  /**
   * AdminTransaction without action
   */
  export type AdminTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
  }


  /**
   * Model AdminTransactionArchive
   */

  export type AggregateAdminTransactionArchive = {
    _count: AdminTransactionArchiveCountAggregateOutputType | null
    _avg: AdminTransactionArchiveAvgAggregateOutputType | null
    _sum: AdminTransactionArchiveSumAggregateOutputType | null
    _min: AdminTransactionArchiveMinAggregateOutputType | null
    _max: AdminTransactionArchiveMaxAggregateOutputType | null
  }

  export type AdminTransactionArchiveAvgAggregateOutputType = {
    quantity: number | null
  }

  export type AdminTransactionArchiveSumAggregateOutputType = {
    quantity: number | null
  }

  export type AdminTransactionArchiveMinAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type AdminTransactionArchiveMaxAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type AdminTransactionArchiveCountAggregateOutputType = {
    id: number
    transactionName: number
    status: number
    createdAt: number
    expiredAt: number
    updatedAt: number
    customerEmail: number
    customerName: number
    customerId: number
    quantity: number
    zones: number
    _all: number
  }


  export type AdminTransactionArchiveAvgAggregateInputType = {
    quantity?: true
  }

  export type AdminTransactionArchiveSumAggregateInputType = {
    quantity?: true
  }

  export type AdminTransactionArchiveMinAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type AdminTransactionArchiveMaxAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type AdminTransactionArchiveCountAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
    zones?: true
    _all?: true
  }

  export type AdminTransactionArchiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransactionArchive to aggregate.
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactionArchives to fetch.
     */
    orderBy?: AdminTransactionArchiveOrderByWithRelationInput | AdminTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminTransactionArchives
    **/
    _count?: true | AdminTransactionArchiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminTransactionArchiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminTransactionArchiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminTransactionArchiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminTransactionArchiveMaxAggregateInputType
  }

  export type GetAdminTransactionArchiveAggregateType<T extends AdminTransactionArchiveAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminTransactionArchive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminTransactionArchive[P]>
      : GetScalarType<T[P], AggregateAdminTransactionArchive[P]>
  }




  export type AdminTransactionArchiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionArchiveWhereInput
    orderBy?: AdminTransactionArchiveOrderByWithAggregationInput | AdminTransactionArchiveOrderByWithAggregationInput[]
    by: AdminTransactionArchiveScalarFieldEnum[] | AdminTransactionArchiveScalarFieldEnum
    having?: AdminTransactionArchiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminTransactionArchiveCountAggregateInputType | true
    _avg?: AdminTransactionArchiveAvgAggregateInputType
    _sum?: AdminTransactionArchiveSumAggregateInputType
    _min?: AdminTransactionArchiveMinAggregateInputType
    _max?: AdminTransactionArchiveMaxAggregateInputType
  }

  export type AdminTransactionArchiveGroupByOutputType = {
    id: string
    transactionName: string
    status: string
    createdAt: Date
    expiredAt: Date
    updatedAt: Date
    customerEmail: string
    customerName: string
    customerId: string
    quantity: number
    zones: string[]
    _count: AdminTransactionArchiveCountAggregateOutputType | null
    _avg: AdminTransactionArchiveAvgAggregateOutputType | null
    _sum: AdminTransactionArchiveSumAggregateOutputType | null
    _min: AdminTransactionArchiveMinAggregateOutputType | null
    _max: AdminTransactionArchiveMaxAggregateOutputType | null
  }

  type GetAdminTransactionArchiveGroupByPayload<T extends AdminTransactionArchiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminTransactionArchiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminTransactionArchiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminTransactionArchiveGroupByOutputType[P]>
            : GetScalarType<T[P], AdminTransactionArchiveGroupByOutputType[P]>
        }
      >
    >


  export type AdminTransactionArchiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransactionArchive"]>

  export type AdminTransactionArchiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransactionArchive"]>

  export type AdminTransactionArchiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransactionArchive"]>

  export type AdminTransactionArchiveSelectScalar = {
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
  }

  export type AdminTransactionArchiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionName" | "status" | "createdAt" | "expiredAt" | "updatedAt" | "customerEmail" | "customerName" | "customerId" | "quantity" | "zones", ExtArgs["result"]["adminTransactionArchive"]>
  export type AdminTransactionArchiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminTransactionArchiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminTransactionArchiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminTransactionArchivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminTransactionArchive"
    objects: {
      customer: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionName: string
      status: string
      createdAt: Date
      expiredAt: Date
      updatedAt: Date
      customerEmail: string
      customerName: string
      customerId: string
      quantity: number
      zones: string[]
    }, ExtArgs["result"]["adminTransactionArchive"]>
    composites: {}
  }

  type AdminTransactionArchiveGetPayload<S extends boolean | null | undefined | AdminTransactionArchiveDefaultArgs> = $Result.GetResult<Prisma.$AdminTransactionArchivePayload, S>

  type AdminTransactionArchiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminTransactionArchiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminTransactionArchiveCountAggregateInputType | true
    }

  export interface AdminTransactionArchiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminTransactionArchive'], meta: { name: 'AdminTransactionArchive' } }
    /**
     * Find zero or one AdminTransactionArchive that matches the filter.
     * @param {AdminTransactionArchiveFindUniqueArgs} args - Arguments to find a AdminTransactionArchive
     * @example
     * // Get one AdminTransactionArchive
     * const adminTransactionArchive = await prisma.adminTransactionArchive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminTransactionArchiveFindUniqueArgs>(args: SelectSubset<T, AdminTransactionArchiveFindUniqueArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminTransactionArchive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminTransactionArchiveFindUniqueOrThrowArgs} args - Arguments to find a AdminTransactionArchive
     * @example
     * // Get one AdminTransactionArchive
     * const adminTransactionArchive = await prisma.adminTransactionArchive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminTransactionArchiveFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminTransactionArchiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransactionArchive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveFindFirstArgs} args - Arguments to find a AdminTransactionArchive
     * @example
     * // Get one AdminTransactionArchive
     * const adminTransactionArchive = await prisma.adminTransactionArchive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminTransactionArchiveFindFirstArgs>(args?: SelectSubset<T, AdminTransactionArchiveFindFirstArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransactionArchive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveFindFirstOrThrowArgs} args - Arguments to find a AdminTransactionArchive
     * @example
     * // Get one AdminTransactionArchive
     * const adminTransactionArchive = await prisma.adminTransactionArchive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminTransactionArchiveFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminTransactionArchiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminTransactionArchives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminTransactionArchives
     * const adminTransactionArchives = await prisma.adminTransactionArchive.findMany()
     * 
     * // Get first 10 AdminTransactionArchives
     * const adminTransactionArchives = await prisma.adminTransactionArchive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminTransactionArchiveWithIdOnly = await prisma.adminTransactionArchive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminTransactionArchiveFindManyArgs>(args?: SelectSubset<T, AdminTransactionArchiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminTransactionArchive.
     * @param {AdminTransactionArchiveCreateArgs} args - Arguments to create a AdminTransactionArchive.
     * @example
     * // Create one AdminTransactionArchive
     * const AdminTransactionArchive = await prisma.adminTransactionArchive.create({
     *   data: {
     *     // ... data to create a AdminTransactionArchive
     *   }
     * })
     * 
     */
    create<T extends AdminTransactionArchiveCreateArgs>(args: SelectSubset<T, AdminTransactionArchiveCreateArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminTransactionArchives.
     * @param {AdminTransactionArchiveCreateManyArgs} args - Arguments to create many AdminTransactionArchives.
     * @example
     * // Create many AdminTransactionArchives
     * const adminTransactionArchive = await prisma.adminTransactionArchive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminTransactionArchiveCreateManyArgs>(args?: SelectSubset<T, AdminTransactionArchiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminTransactionArchives and returns the data saved in the database.
     * @param {AdminTransactionArchiveCreateManyAndReturnArgs} args - Arguments to create many AdminTransactionArchives.
     * @example
     * // Create many AdminTransactionArchives
     * const adminTransactionArchive = await prisma.adminTransactionArchive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminTransactionArchives and only return the `id`
     * const adminTransactionArchiveWithIdOnly = await prisma.adminTransactionArchive.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminTransactionArchiveCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminTransactionArchiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminTransactionArchive.
     * @param {AdminTransactionArchiveDeleteArgs} args - Arguments to delete one AdminTransactionArchive.
     * @example
     * // Delete one AdminTransactionArchive
     * const AdminTransactionArchive = await prisma.adminTransactionArchive.delete({
     *   where: {
     *     // ... filter to delete one AdminTransactionArchive
     *   }
     * })
     * 
     */
    delete<T extends AdminTransactionArchiveDeleteArgs>(args: SelectSubset<T, AdminTransactionArchiveDeleteArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminTransactionArchive.
     * @param {AdminTransactionArchiveUpdateArgs} args - Arguments to update one AdminTransactionArchive.
     * @example
     * // Update one AdminTransactionArchive
     * const adminTransactionArchive = await prisma.adminTransactionArchive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminTransactionArchiveUpdateArgs>(args: SelectSubset<T, AdminTransactionArchiveUpdateArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminTransactionArchives.
     * @param {AdminTransactionArchiveDeleteManyArgs} args - Arguments to filter AdminTransactionArchives to delete.
     * @example
     * // Delete a few AdminTransactionArchives
     * const { count } = await prisma.adminTransactionArchive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminTransactionArchiveDeleteManyArgs>(args?: SelectSubset<T, AdminTransactionArchiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactionArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminTransactionArchives
     * const adminTransactionArchive = await prisma.adminTransactionArchive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminTransactionArchiveUpdateManyArgs>(args: SelectSubset<T, AdminTransactionArchiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactionArchives and returns the data updated in the database.
     * @param {AdminTransactionArchiveUpdateManyAndReturnArgs} args - Arguments to update many AdminTransactionArchives.
     * @example
     * // Update many AdminTransactionArchives
     * const adminTransactionArchive = await prisma.adminTransactionArchive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminTransactionArchives and only return the `id`
     * const adminTransactionArchiveWithIdOnly = await prisma.adminTransactionArchive.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminTransactionArchiveUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminTransactionArchiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminTransactionArchive.
     * @param {AdminTransactionArchiveUpsertArgs} args - Arguments to update or create a AdminTransactionArchive.
     * @example
     * // Update or create a AdminTransactionArchive
     * const adminTransactionArchive = await prisma.adminTransactionArchive.upsert({
     *   create: {
     *     // ... data to create a AdminTransactionArchive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminTransactionArchive we want to update
     *   }
     * })
     */
    upsert<T extends AdminTransactionArchiveUpsertArgs>(args: SelectSubset<T, AdminTransactionArchiveUpsertArgs<ExtArgs>>): Prisma__AdminTransactionArchiveClient<$Result.GetResult<Prisma.$AdminTransactionArchivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminTransactionArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveCountArgs} args - Arguments to filter AdminTransactionArchives to count.
     * @example
     * // Count the number of AdminTransactionArchives
     * const count = await prisma.adminTransactionArchive.count({
     *   where: {
     *     // ... the filter for the AdminTransactionArchives we want to count
     *   }
     * })
    **/
    count<T extends AdminTransactionArchiveCountArgs>(
      args?: Subset<T, AdminTransactionArchiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminTransactionArchiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminTransactionArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminTransactionArchiveAggregateArgs>(args: Subset<T, AdminTransactionArchiveAggregateArgs>): Prisma.PrismaPromise<GetAdminTransactionArchiveAggregateType<T>>

    /**
     * Group by AdminTransactionArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionArchiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminTransactionArchiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminTransactionArchiveGroupByArgs['orderBy'] }
        : { orderBy?: AdminTransactionArchiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminTransactionArchiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminTransactionArchiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminTransactionArchive model
   */
  readonly fields: AdminTransactionArchiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminTransactionArchive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminTransactionArchiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminTransactionArchive model
   */
  interface AdminTransactionArchiveFieldRefs {
    readonly id: FieldRef<"AdminTransactionArchive", 'String'>
    readonly transactionName: FieldRef<"AdminTransactionArchive", 'String'>
    readonly status: FieldRef<"AdminTransactionArchive", 'String'>
    readonly createdAt: FieldRef<"AdminTransactionArchive", 'DateTime'>
    readonly expiredAt: FieldRef<"AdminTransactionArchive", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminTransactionArchive", 'DateTime'>
    readonly customerEmail: FieldRef<"AdminTransactionArchive", 'String'>
    readonly customerName: FieldRef<"AdminTransactionArchive", 'String'>
    readonly customerId: FieldRef<"AdminTransactionArchive", 'String'>
    readonly quantity: FieldRef<"AdminTransactionArchive", 'Int'>
    readonly zones: FieldRef<"AdminTransactionArchive", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * AdminTransactionArchive findUnique
   */
  export type AdminTransactionArchiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactionArchive to fetch.
     */
    where: AdminTransactionArchiveWhereUniqueInput
  }

  /**
   * AdminTransactionArchive findUniqueOrThrow
   */
  export type AdminTransactionArchiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactionArchive to fetch.
     */
    where: AdminTransactionArchiveWhereUniqueInput
  }

  /**
   * AdminTransactionArchive findFirst
   */
  export type AdminTransactionArchiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactionArchive to fetch.
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactionArchives to fetch.
     */
    orderBy?: AdminTransactionArchiveOrderByWithRelationInput | AdminTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactionArchives.
     */
    cursor?: AdminTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactionArchives.
     */
    distinct?: AdminTransactionArchiveScalarFieldEnum | AdminTransactionArchiveScalarFieldEnum[]
  }

  /**
   * AdminTransactionArchive findFirstOrThrow
   */
  export type AdminTransactionArchiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactionArchive to fetch.
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactionArchives to fetch.
     */
    orderBy?: AdminTransactionArchiveOrderByWithRelationInput | AdminTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactionArchives.
     */
    cursor?: AdminTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactionArchives.
     */
    distinct?: AdminTransactionArchiveScalarFieldEnum | AdminTransactionArchiveScalarFieldEnum[]
  }

  /**
   * AdminTransactionArchive findMany
   */
  export type AdminTransactionArchiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactionArchives to fetch.
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactionArchives to fetch.
     */
    orderBy?: AdminTransactionArchiveOrderByWithRelationInput | AdminTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminTransactionArchives.
     */
    cursor?: AdminTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactionArchives.
     */
    skip?: number
    distinct?: AdminTransactionArchiveScalarFieldEnum | AdminTransactionArchiveScalarFieldEnum[]
  }

  /**
   * AdminTransactionArchive create
   */
  export type AdminTransactionArchiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminTransactionArchive.
     */
    data: XOR<AdminTransactionArchiveCreateInput, AdminTransactionArchiveUncheckedCreateInput>
  }

  /**
   * AdminTransactionArchive createMany
   */
  export type AdminTransactionArchiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminTransactionArchives.
     */
    data: AdminTransactionArchiveCreateManyInput | AdminTransactionArchiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminTransactionArchive createManyAndReturn
   */
  export type AdminTransactionArchiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * The data used to create many AdminTransactionArchives.
     */
    data: AdminTransactionArchiveCreateManyInput | AdminTransactionArchiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransactionArchive update
   */
  export type AdminTransactionArchiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminTransactionArchive.
     */
    data: XOR<AdminTransactionArchiveUpdateInput, AdminTransactionArchiveUncheckedUpdateInput>
    /**
     * Choose, which AdminTransactionArchive to update.
     */
    where: AdminTransactionArchiveWhereUniqueInput
  }

  /**
   * AdminTransactionArchive updateMany
   */
  export type AdminTransactionArchiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminTransactionArchives.
     */
    data: XOR<AdminTransactionArchiveUpdateManyMutationInput, AdminTransactionArchiveUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactionArchives to update
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * Limit how many AdminTransactionArchives to update.
     */
    limit?: number
  }

  /**
   * AdminTransactionArchive updateManyAndReturn
   */
  export type AdminTransactionArchiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * The data used to update AdminTransactionArchives.
     */
    data: XOR<AdminTransactionArchiveUpdateManyMutationInput, AdminTransactionArchiveUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactionArchives to update
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * Limit how many AdminTransactionArchives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransactionArchive upsert
   */
  export type AdminTransactionArchiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminTransactionArchive to update in case it exists.
     */
    where: AdminTransactionArchiveWhereUniqueInput
    /**
     * In case the AdminTransactionArchive found by the `where` argument doesn't exist, create a new AdminTransactionArchive with this data.
     */
    create: XOR<AdminTransactionArchiveCreateInput, AdminTransactionArchiveUncheckedCreateInput>
    /**
     * In case the AdminTransactionArchive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminTransactionArchiveUpdateInput, AdminTransactionArchiveUncheckedUpdateInput>
  }

  /**
   * AdminTransactionArchive delete
   */
  export type AdminTransactionArchiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter which AdminTransactionArchive to delete.
     */
    where: AdminTransactionArchiveWhereUniqueInput
  }

  /**
   * AdminTransactionArchive deleteMany
   */
  export type AdminTransactionArchiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransactionArchives to delete
     */
    where?: AdminTransactionArchiveWhereInput
    /**
     * Limit how many AdminTransactionArchives to delete.
     */
    limit?: number
  }

  /**
   * AdminTransactionArchive without action
   */
  export type AdminTransactionArchiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransactionArchive
     */
    select?: AdminTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransactionArchive
     */
    omit?: AdminTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionArchiveInclude<ExtArgs> | null
  }


  /**
   * Model UserTransaction
   */

  export type AggregateUserTransaction = {
    _count: UserTransactionCountAggregateOutputType | null
    _avg: UserTransactionAvgAggregateOutputType | null
    _sum: UserTransactionSumAggregateOutputType | null
    _min: UserTransactionMinAggregateOutputType | null
    _max: UserTransactionMaxAggregateOutputType | null
  }

  export type UserTransactionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UserTransactionSumAggregateOutputType = {
    quantity: number | null
  }

  export type UserTransactionMinAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type UserTransactionMaxAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type UserTransactionCountAggregateOutputType = {
    id: number
    transactionName: number
    status: number
    createdAt: number
    expiredAt: number
    updatedAt: number
    customerEmail: number
    customerName: number
    customerId: number
    quantity: number
    zones: number
    _all: number
  }


  export type UserTransactionAvgAggregateInputType = {
    quantity?: true
  }

  export type UserTransactionSumAggregateInputType = {
    quantity?: true
  }

  export type UserTransactionMinAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type UserTransactionMaxAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type UserTransactionCountAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
    zones?: true
    _all?: true
  }

  export type UserTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTransaction to aggregate.
     */
    where?: UserTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactions to fetch.
     */
    orderBy?: UserTransactionOrderByWithRelationInput | UserTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTransactions
    **/
    _count?: true | UserTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTransactionMaxAggregateInputType
  }

  export type GetUserTransactionAggregateType<T extends UserTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTransaction[P]>
      : GetScalarType<T[P], AggregateUserTransaction[P]>
  }




  export type UserTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTransactionWhereInput
    orderBy?: UserTransactionOrderByWithAggregationInput | UserTransactionOrderByWithAggregationInput[]
    by: UserTransactionScalarFieldEnum[] | UserTransactionScalarFieldEnum
    having?: UserTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTransactionCountAggregateInputType | true
    _avg?: UserTransactionAvgAggregateInputType
    _sum?: UserTransactionSumAggregateInputType
    _min?: UserTransactionMinAggregateInputType
    _max?: UserTransactionMaxAggregateInputType
  }

  export type UserTransactionGroupByOutputType = {
    id: string
    transactionName: string
    status: string
    createdAt: Date
    expiredAt: Date
    updatedAt: Date
    customerEmail: string
    customerName: string
    customerId: string
    quantity: number
    zones: string[]
    _count: UserTransactionCountAggregateOutputType | null
    _avg: UserTransactionAvgAggregateOutputType | null
    _sum: UserTransactionSumAggregateOutputType | null
    _min: UserTransactionMinAggregateOutputType | null
    _max: UserTransactionMaxAggregateOutputType | null
  }

  type GetUserTransactionGroupByPayload<T extends UserTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], UserTransactionGroupByOutputType[P]>
        }
      >
    >


  export type UserTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTransaction"]>

  export type UserTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTransaction"]>

  export type UserTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTransaction"]>

  export type UserTransactionSelectScalar = {
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
  }

  export type UserTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionName" | "status" | "createdAt" | "expiredAt" | "updatedAt" | "customerEmail" | "customerName" | "customerId" | "quantity" | "zones", ExtArgs["result"]["userTransaction"]>
  export type UserTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTransaction"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionName: string
      status: string
      createdAt: Date
      expiredAt: Date
      updatedAt: Date
      customerEmail: string
      customerName: string
      customerId: string
      quantity: number
      zones: string[]
    }, ExtArgs["result"]["userTransaction"]>
    composites: {}
  }

  type UserTransactionGetPayload<S extends boolean | null | undefined | UserTransactionDefaultArgs> = $Result.GetResult<Prisma.$UserTransactionPayload, S>

  type UserTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTransactionCountAggregateInputType | true
    }

  export interface UserTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTransaction'], meta: { name: 'UserTransaction' } }
    /**
     * Find zero or one UserTransaction that matches the filter.
     * @param {UserTransactionFindUniqueArgs} args - Arguments to find a UserTransaction
     * @example
     * // Get one UserTransaction
     * const userTransaction = await prisma.userTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTransactionFindUniqueArgs>(args: SelectSubset<T, UserTransactionFindUniqueArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTransactionFindUniqueOrThrowArgs} args - Arguments to find a UserTransaction
     * @example
     * // Get one UserTransaction
     * const userTransaction = await prisma.userTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionFindFirstArgs} args - Arguments to find a UserTransaction
     * @example
     * // Get one UserTransaction
     * const userTransaction = await prisma.userTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTransactionFindFirstArgs>(args?: SelectSubset<T, UserTransactionFindFirstArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionFindFirstOrThrowArgs} args - Arguments to find a UserTransaction
     * @example
     * // Get one UserTransaction
     * const userTransaction = await prisma.userTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTransactions
     * const userTransactions = await prisma.userTransaction.findMany()
     * 
     * // Get first 10 UserTransactions
     * const userTransactions = await prisma.userTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTransactionWithIdOnly = await prisma.userTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTransactionFindManyArgs>(args?: SelectSubset<T, UserTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTransaction.
     * @param {UserTransactionCreateArgs} args - Arguments to create a UserTransaction.
     * @example
     * // Create one UserTransaction
     * const UserTransaction = await prisma.userTransaction.create({
     *   data: {
     *     // ... data to create a UserTransaction
     *   }
     * })
     * 
     */
    create<T extends UserTransactionCreateArgs>(args: SelectSubset<T, UserTransactionCreateArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTransactions.
     * @param {UserTransactionCreateManyArgs} args - Arguments to create many UserTransactions.
     * @example
     * // Create many UserTransactions
     * const userTransaction = await prisma.userTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTransactionCreateManyArgs>(args?: SelectSubset<T, UserTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTransactions and returns the data saved in the database.
     * @param {UserTransactionCreateManyAndReturnArgs} args - Arguments to create many UserTransactions.
     * @example
     * // Create many UserTransactions
     * const userTransaction = await prisma.userTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTransactions and only return the `id`
     * const userTransactionWithIdOnly = await prisma.userTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTransaction.
     * @param {UserTransactionDeleteArgs} args - Arguments to delete one UserTransaction.
     * @example
     * // Delete one UserTransaction
     * const UserTransaction = await prisma.userTransaction.delete({
     *   where: {
     *     // ... filter to delete one UserTransaction
     *   }
     * })
     * 
     */
    delete<T extends UserTransactionDeleteArgs>(args: SelectSubset<T, UserTransactionDeleteArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTransaction.
     * @param {UserTransactionUpdateArgs} args - Arguments to update one UserTransaction.
     * @example
     * // Update one UserTransaction
     * const userTransaction = await prisma.userTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTransactionUpdateArgs>(args: SelectSubset<T, UserTransactionUpdateArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTransactions.
     * @param {UserTransactionDeleteManyArgs} args - Arguments to filter UserTransactions to delete.
     * @example
     * // Delete a few UserTransactions
     * const { count } = await prisma.userTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTransactionDeleteManyArgs>(args?: SelectSubset<T, UserTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTransactions
     * const userTransaction = await prisma.userTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTransactionUpdateManyArgs>(args: SelectSubset<T, UserTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTransactions and returns the data updated in the database.
     * @param {UserTransactionUpdateManyAndReturnArgs} args - Arguments to update many UserTransactions.
     * @example
     * // Update many UserTransactions
     * const userTransaction = await prisma.userTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTransactions and only return the `id`
     * const userTransactionWithIdOnly = await prisma.userTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTransaction.
     * @param {UserTransactionUpsertArgs} args - Arguments to update or create a UserTransaction.
     * @example
     * // Update or create a UserTransaction
     * const userTransaction = await prisma.userTransaction.upsert({
     *   create: {
     *     // ... data to create a UserTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTransaction we want to update
     *   }
     * })
     */
    upsert<T extends UserTransactionUpsertArgs>(args: SelectSubset<T, UserTransactionUpsertArgs<ExtArgs>>): Prisma__UserTransactionClient<$Result.GetResult<Prisma.$UserTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionCountArgs} args - Arguments to filter UserTransactions to count.
     * @example
     * // Count the number of UserTransactions
     * const count = await prisma.userTransaction.count({
     *   where: {
     *     // ... the filter for the UserTransactions we want to count
     *   }
     * })
    **/
    count<T extends UserTransactionCountArgs>(
      args?: Subset<T, UserTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTransactionAggregateArgs>(args: Subset<T, UserTransactionAggregateArgs>): Prisma.PrismaPromise<GetUserTransactionAggregateType<T>>

    /**
     * Group by UserTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTransactionGroupByArgs['orderBy'] }
        : { orderBy?: UserTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTransaction model
   */
  readonly fields: UserTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTransaction model
   */
  interface UserTransactionFieldRefs {
    readonly id: FieldRef<"UserTransaction", 'String'>
    readonly transactionName: FieldRef<"UserTransaction", 'String'>
    readonly status: FieldRef<"UserTransaction", 'String'>
    readonly createdAt: FieldRef<"UserTransaction", 'DateTime'>
    readonly expiredAt: FieldRef<"UserTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTransaction", 'DateTime'>
    readonly customerEmail: FieldRef<"UserTransaction", 'String'>
    readonly customerName: FieldRef<"UserTransaction", 'String'>
    readonly customerId: FieldRef<"UserTransaction", 'String'>
    readonly quantity: FieldRef<"UserTransaction", 'Int'>
    readonly zones: FieldRef<"UserTransaction", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * UserTransaction findUnique
   */
  export type UserTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * Filter, which UserTransaction to fetch.
     */
    where: UserTransactionWhereUniqueInput
  }

  /**
   * UserTransaction findUniqueOrThrow
   */
  export type UserTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * Filter, which UserTransaction to fetch.
     */
    where: UserTransactionWhereUniqueInput
  }

  /**
   * UserTransaction findFirst
   */
  export type UserTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * Filter, which UserTransaction to fetch.
     */
    where?: UserTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactions to fetch.
     */
    orderBy?: UserTransactionOrderByWithRelationInput | UserTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTransactions.
     */
    cursor?: UserTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTransactions.
     */
    distinct?: UserTransactionScalarFieldEnum | UserTransactionScalarFieldEnum[]
  }

  /**
   * UserTransaction findFirstOrThrow
   */
  export type UserTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * Filter, which UserTransaction to fetch.
     */
    where?: UserTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactions to fetch.
     */
    orderBy?: UserTransactionOrderByWithRelationInput | UserTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTransactions.
     */
    cursor?: UserTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTransactions.
     */
    distinct?: UserTransactionScalarFieldEnum | UserTransactionScalarFieldEnum[]
  }

  /**
   * UserTransaction findMany
   */
  export type UserTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * Filter, which UserTransactions to fetch.
     */
    where?: UserTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactions to fetch.
     */
    orderBy?: UserTransactionOrderByWithRelationInput | UserTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTransactions.
     */
    cursor?: UserTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactions.
     */
    skip?: number
    distinct?: UserTransactionScalarFieldEnum | UserTransactionScalarFieldEnum[]
  }

  /**
   * UserTransaction create
   */
  export type UserTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTransaction.
     */
    data: XOR<UserTransactionCreateInput, UserTransactionUncheckedCreateInput>
  }

  /**
   * UserTransaction createMany
   */
  export type UserTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTransactions.
     */
    data: UserTransactionCreateManyInput | UserTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTransaction createManyAndReturn
   */
  export type UserTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many UserTransactions.
     */
    data: UserTransactionCreateManyInput | UserTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTransaction update
   */
  export type UserTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTransaction.
     */
    data: XOR<UserTransactionUpdateInput, UserTransactionUncheckedUpdateInput>
    /**
     * Choose, which UserTransaction to update.
     */
    where: UserTransactionWhereUniqueInput
  }

  /**
   * UserTransaction updateMany
   */
  export type UserTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTransactions.
     */
    data: XOR<UserTransactionUpdateManyMutationInput, UserTransactionUncheckedUpdateManyInput>
    /**
     * Filter which UserTransactions to update
     */
    where?: UserTransactionWhereInput
    /**
     * Limit how many UserTransactions to update.
     */
    limit?: number
  }

  /**
   * UserTransaction updateManyAndReturn
   */
  export type UserTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * The data used to update UserTransactions.
     */
    data: XOR<UserTransactionUpdateManyMutationInput, UserTransactionUncheckedUpdateManyInput>
    /**
     * Filter which UserTransactions to update
     */
    where?: UserTransactionWhereInput
    /**
     * Limit how many UserTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTransaction upsert
   */
  export type UserTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTransaction to update in case it exists.
     */
    where: UserTransactionWhereUniqueInput
    /**
     * In case the UserTransaction found by the `where` argument doesn't exist, create a new UserTransaction with this data.
     */
    create: XOR<UserTransactionCreateInput, UserTransactionUncheckedCreateInput>
    /**
     * In case the UserTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTransactionUpdateInput, UserTransactionUncheckedUpdateInput>
  }

  /**
   * UserTransaction delete
   */
  export type UserTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
    /**
     * Filter which UserTransaction to delete.
     */
    where: UserTransactionWhereUniqueInput
  }

  /**
   * UserTransaction deleteMany
   */
  export type UserTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTransactions to delete
     */
    where?: UserTransactionWhereInput
    /**
     * Limit how many UserTransactions to delete.
     */
    limit?: number
  }

  /**
   * UserTransaction without action
   */
  export type UserTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransaction
     */
    select?: UserTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransaction
     */
    omit?: UserTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionInclude<ExtArgs> | null
  }


  /**
   * Model UserTransactionArchive
   */

  export type AggregateUserTransactionArchive = {
    _count: UserTransactionArchiveCountAggregateOutputType | null
    _avg: UserTransactionArchiveAvgAggregateOutputType | null
    _sum: UserTransactionArchiveSumAggregateOutputType | null
    _min: UserTransactionArchiveMinAggregateOutputType | null
    _max: UserTransactionArchiveMaxAggregateOutputType | null
  }

  export type UserTransactionArchiveAvgAggregateOutputType = {
    quantity: number | null
  }

  export type UserTransactionArchiveSumAggregateOutputType = {
    quantity: number | null
  }

  export type UserTransactionArchiveMinAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type UserTransactionArchiveMaxAggregateOutputType = {
    id: string | null
    transactionName: string | null
    status: string | null
    createdAt: Date | null
    expiredAt: Date | null
    updatedAt: Date | null
    customerEmail: string | null
    customerName: string | null
    customerId: string | null
    quantity: number | null
  }

  export type UserTransactionArchiveCountAggregateOutputType = {
    id: number
    transactionName: number
    status: number
    createdAt: number
    expiredAt: number
    updatedAt: number
    customerEmail: number
    customerName: number
    customerId: number
    quantity: number
    zones: number
    _all: number
  }


  export type UserTransactionArchiveAvgAggregateInputType = {
    quantity?: true
  }

  export type UserTransactionArchiveSumAggregateInputType = {
    quantity?: true
  }

  export type UserTransactionArchiveMinAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type UserTransactionArchiveMaxAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
  }

  export type UserTransactionArchiveCountAggregateInputType = {
    id?: true
    transactionName?: true
    status?: true
    createdAt?: true
    expiredAt?: true
    updatedAt?: true
    customerEmail?: true
    customerName?: true
    customerId?: true
    quantity?: true
    zones?: true
    _all?: true
  }

  export type UserTransactionArchiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTransactionArchive to aggregate.
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactionArchives to fetch.
     */
    orderBy?: UserTransactionArchiveOrderByWithRelationInput | UserTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTransactionArchives
    **/
    _count?: true | UserTransactionArchiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTransactionArchiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTransactionArchiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTransactionArchiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTransactionArchiveMaxAggregateInputType
  }

  export type GetUserTransactionArchiveAggregateType<T extends UserTransactionArchiveAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTransactionArchive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTransactionArchive[P]>
      : GetScalarType<T[P], AggregateUserTransactionArchive[P]>
  }




  export type UserTransactionArchiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTransactionArchiveWhereInput
    orderBy?: UserTransactionArchiveOrderByWithAggregationInput | UserTransactionArchiveOrderByWithAggregationInput[]
    by: UserTransactionArchiveScalarFieldEnum[] | UserTransactionArchiveScalarFieldEnum
    having?: UserTransactionArchiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTransactionArchiveCountAggregateInputType | true
    _avg?: UserTransactionArchiveAvgAggregateInputType
    _sum?: UserTransactionArchiveSumAggregateInputType
    _min?: UserTransactionArchiveMinAggregateInputType
    _max?: UserTransactionArchiveMaxAggregateInputType
  }

  export type UserTransactionArchiveGroupByOutputType = {
    id: string
    transactionName: string
    status: string
    createdAt: Date
    expiredAt: Date
    updatedAt: Date
    customerEmail: string
    customerName: string
    customerId: string
    quantity: number
    zones: string[]
    _count: UserTransactionArchiveCountAggregateOutputType | null
    _avg: UserTransactionArchiveAvgAggregateOutputType | null
    _sum: UserTransactionArchiveSumAggregateOutputType | null
    _min: UserTransactionArchiveMinAggregateOutputType | null
    _max: UserTransactionArchiveMaxAggregateOutputType | null
  }

  type GetUserTransactionArchiveGroupByPayload<T extends UserTransactionArchiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTransactionArchiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTransactionArchiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTransactionArchiveGroupByOutputType[P]>
            : GetScalarType<T[P], UserTransactionArchiveGroupByOutputType[P]>
        }
      >
    >


  export type UserTransactionArchiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTransactionArchive"]>

  export type UserTransactionArchiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTransactionArchive"]>

  export type UserTransactionArchiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTransactionArchive"]>

  export type UserTransactionArchiveSelectScalar = {
    id?: boolean
    transactionName?: boolean
    status?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    updatedAt?: boolean
    customerEmail?: boolean
    customerName?: boolean
    customerId?: boolean
    quantity?: boolean
    zones?: boolean
  }

  export type UserTransactionArchiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionName" | "status" | "createdAt" | "expiredAt" | "updatedAt" | "customerEmail" | "customerName" | "customerId" | "quantity" | "zones", ExtArgs["result"]["userTransactionArchive"]>
  export type UserTransactionArchiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTransactionArchiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTransactionArchiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTransactionArchivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTransactionArchive"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionName: string
      status: string
      createdAt: Date
      expiredAt: Date
      updatedAt: Date
      customerEmail: string
      customerName: string
      customerId: string
      quantity: number
      zones: string[]
    }, ExtArgs["result"]["userTransactionArchive"]>
    composites: {}
  }

  type UserTransactionArchiveGetPayload<S extends boolean | null | undefined | UserTransactionArchiveDefaultArgs> = $Result.GetResult<Prisma.$UserTransactionArchivePayload, S>

  type UserTransactionArchiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTransactionArchiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTransactionArchiveCountAggregateInputType | true
    }

  export interface UserTransactionArchiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTransactionArchive'], meta: { name: 'UserTransactionArchive' } }
    /**
     * Find zero or one UserTransactionArchive that matches the filter.
     * @param {UserTransactionArchiveFindUniqueArgs} args - Arguments to find a UserTransactionArchive
     * @example
     * // Get one UserTransactionArchive
     * const userTransactionArchive = await prisma.userTransactionArchive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTransactionArchiveFindUniqueArgs>(args: SelectSubset<T, UserTransactionArchiveFindUniqueArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTransactionArchive that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTransactionArchiveFindUniqueOrThrowArgs} args - Arguments to find a UserTransactionArchive
     * @example
     * // Get one UserTransactionArchive
     * const userTransactionArchive = await prisma.userTransactionArchive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTransactionArchiveFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTransactionArchiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTransactionArchive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveFindFirstArgs} args - Arguments to find a UserTransactionArchive
     * @example
     * // Get one UserTransactionArchive
     * const userTransactionArchive = await prisma.userTransactionArchive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTransactionArchiveFindFirstArgs>(args?: SelectSubset<T, UserTransactionArchiveFindFirstArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTransactionArchive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveFindFirstOrThrowArgs} args - Arguments to find a UserTransactionArchive
     * @example
     * // Get one UserTransactionArchive
     * const userTransactionArchive = await prisma.userTransactionArchive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTransactionArchiveFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTransactionArchiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTransactionArchives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTransactionArchives
     * const userTransactionArchives = await prisma.userTransactionArchive.findMany()
     * 
     * // Get first 10 UserTransactionArchives
     * const userTransactionArchives = await prisma.userTransactionArchive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTransactionArchiveWithIdOnly = await prisma.userTransactionArchive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTransactionArchiveFindManyArgs>(args?: SelectSubset<T, UserTransactionArchiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTransactionArchive.
     * @param {UserTransactionArchiveCreateArgs} args - Arguments to create a UserTransactionArchive.
     * @example
     * // Create one UserTransactionArchive
     * const UserTransactionArchive = await prisma.userTransactionArchive.create({
     *   data: {
     *     // ... data to create a UserTransactionArchive
     *   }
     * })
     * 
     */
    create<T extends UserTransactionArchiveCreateArgs>(args: SelectSubset<T, UserTransactionArchiveCreateArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTransactionArchives.
     * @param {UserTransactionArchiveCreateManyArgs} args - Arguments to create many UserTransactionArchives.
     * @example
     * // Create many UserTransactionArchives
     * const userTransactionArchive = await prisma.userTransactionArchive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTransactionArchiveCreateManyArgs>(args?: SelectSubset<T, UserTransactionArchiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTransactionArchives and returns the data saved in the database.
     * @param {UserTransactionArchiveCreateManyAndReturnArgs} args - Arguments to create many UserTransactionArchives.
     * @example
     * // Create many UserTransactionArchives
     * const userTransactionArchive = await prisma.userTransactionArchive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTransactionArchives and only return the `id`
     * const userTransactionArchiveWithIdOnly = await prisma.userTransactionArchive.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTransactionArchiveCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTransactionArchiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTransactionArchive.
     * @param {UserTransactionArchiveDeleteArgs} args - Arguments to delete one UserTransactionArchive.
     * @example
     * // Delete one UserTransactionArchive
     * const UserTransactionArchive = await prisma.userTransactionArchive.delete({
     *   where: {
     *     // ... filter to delete one UserTransactionArchive
     *   }
     * })
     * 
     */
    delete<T extends UserTransactionArchiveDeleteArgs>(args: SelectSubset<T, UserTransactionArchiveDeleteArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTransactionArchive.
     * @param {UserTransactionArchiveUpdateArgs} args - Arguments to update one UserTransactionArchive.
     * @example
     * // Update one UserTransactionArchive
     * const userTransactionArchive = await prisma.userTransactionArchive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTransactionArchiveUpdateArgs>(args: SelectSubset<T, UserTransactionArchiveUpdateArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTransactionArchives.
     * @param {UserTransactionArchiveDeleteManyArgs} args - Arguments to filter UserTransactionArchives to delete.
     * @example
     * // Delete a few UserTransactionArchives
     * const { count } = await prisma.userTransactionArchive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTransactionArchiveDeleteManyArgs>(args?: SelectSubset<T, UserTransactionArchiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTransactionArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTransactionArchives
     * const userTransactionArchive = await prisma.userTransactionArchive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTransactionArchiveUpdateManyArgs>(args: SelectSubset<T, UserTransactionArchiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTransactionArchives and returns the data updated in the database.
     * @param {UserTransactionArchiveUpdateManyAndReturnArgs} args - Arguments to update many UserTransactionArchives.
     * @example
     * // Update many UserTransactionArchives
     * const userTransactionArchive = await prisma.userTransactionArchive.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTransactionArchives and only return the `id`
     * const userTransactionArchiveWithIdOnly = await prisma.userTransactionArchive.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTransactionArchiveUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTransactionArchiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTransactionArchive.
     * @param {UserTransactionArchiveUpsertArgs} args - Arguments to update or create a UserTransactionArchive.
     * @example
     * // Update or create a UserTransactionArchive
     * const userTransactionArchive = await prisma.userTransactionArchive.upsert({
     *   create: {
     *     // ... data to create a UserTransactionArchive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTransactionArchive we want to update
     *   }
     * })
     */
    upsert<T extends UserTransactionArchiveUpsertArgs>(args: SelectSubset<T, UserTransactionArchiveUpsertArgs<ExtArgs>>): Prisma__UserTransactionArchiveClient<$Result.GetResult<Prisma.$UserTransactionArchivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTransactionArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveCountArgs} args - Arguments to filter UserTransactionArchives to count.
     * @example
     * // Count the number of UserTransactionArchives
     * const count = await prisma.userTransactionArchive.count({
     *   where: {
     *     // ... the filter for the UserTransactionArchives we want to count
     *   }
     * })
    **/
    count<T extends UserTransactionArchiveCountArgs>(
      args?: Subset<T, UserTransactionArchiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTransactionArchiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTransactionArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTransactionArchiveAggregateArgs>(args: Subset<T, UserTransactionArchiveAggregateArgs>): Prisma.PrismaPromise<GetUserTransactionArchiveAggregateType<T>>

    /**
     * Group by UserTransactionArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTransactionArchiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTransactionArchiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTransactionArchiveGroupByArgs['orderBy'] }
        : { orderBy?: UserTransactionArchiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTransactionArchiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTransactionArchiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTransactionArchive model
   */
  readonly fields: UserTransactionArchiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTransactionArchive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTransactionArchiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTransactionArchive model
   */
  interface UserTransactionArchiveFieldRefs {
    readonly id: FieldRef<"UserTransactionArchive", 'String'>
    readonly transactionName: FieldRef<"UserTransactionArchive", 'String'>
    readonly status: FieldRef<"UserTransactionArchive", 'String'>
    readonly createdAt: FieldRef<"UserTransactionArchive", 'DateTime'>
    readonly expiredAt: FieldRef<"UserTransactionArchive", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTransactionArchive", 'DateTime'>
    readonly customerEmail: FieldRef<"UserTransactionArchive", 'String'>
    readonly customerName: FieldRef<"UserTransactionArchive", 'String'>
    readonly customerId: FieldRef<"UserTransactionArchive", 'String'>
    readonly quantity: FieldRef<"UserTransactionArchive", 'Int'>
    readonly zones: FieldRef<"UserTransactionArchive", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * UserTransactionArchive findUnique
   */
  export type UserTransactionArchiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which UserTransactionArchive to fetch.
     */
    where: UserTransactionArchiveWhereUniqueInput
  }

  /**
   * UserTransactionArchive findUniqueOrThrow
   */
  export type UserTransactionArchiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which UserTransactionArchive to fetch.
     */
    where: UserTransactionArchiveWhereUniqueInput
  }

  /**
   * UserTransactionArchive findFirst
   */
  export type UserTransactionArchiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which UserTransactionArchive to fetch.
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactionArchives to fetch.
     */
    orderBy?: UserTransactionArchiveOrderByWithRelationInput | UserTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTransactionArchives.
     */
    cursor?: UserTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTransactionArchives.
     */
    distinct?: UserTransactionArchiveScalarFieldEnum | UserTransactionArchiveScalarFieldEnum[]
  }

  /**
   * UserTransactionArchive findFirstOrThrow
   */
  export type UserTransactionArchiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which UserTransactionArchive to fetch.
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactionArchives to fetch.
     */
    orderBy?: UserTransactionArchiveOrderByWithRelationInput | UserTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTransactionArchives.
     */
    cursor?: UserTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTransactionArchives.
     */
    distinct?: UserTransactionArchiveScalarFieldEnum | UserTransactionArchiveScalarFieldEnum[]
  }

  /**
   * UserTransactionArchive findMany
   */
  export type UserTransactionArchiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which UserTransactionArchives to fetch.
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTransactionArchives to fetch.
     */
    orderBy?: UserTransactionArchiveOrderByWithRelationInput | UserTransactionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTransactionArchives.
     */
    cursor?: UserTransactionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTransactionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTransactionArchives.
     */
    skip?: number
    distinct?: UserTransactionArchiveScalarFieldEnum | UserTransactionArchiveScalarFieldEnum[]
  }

  /**
   * UserTransactionArchive create
   */
  export type UserTransactionArchiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTransactionArchive.
     */
    data: XOR<UserTransactionArchiveCreateInput, UserTransactionArchiveUncheckedCreateInput>
  }

  /**
   * UserTransactionArchive createMany
   */
  export type UserTransactionArchiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTransactionArchives.
     */
    data: UserTransactionArchiveCreateManyInput | UserTransactionArchiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTransactionArchive createManyAndReturn
   */
  export type UserTransactionArchiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * The data used to create many UserTransactionArchives.
     */
    data: UserTransactionArchiveCreateManyInput | UserTransactionArchiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTransactionArchive update
   */
  export type UserTransactionArchiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTransactionArchive.
     */
    data: XOR<UserTransactionArchiveUpdateInput, UserTransactionArchiveUncheckedUpdateInput>
    /**
     * Choose, which UserTransactionArchive to update.
     */
    where: UserTransactionArchiveWhereUniqueInput
  }

  /**
   * UserTransactionArchive updateMany
   */
  export type UserTransactionArchiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTransactionArchives.
     */
    data: XOR<UserTransactionArchiveUpdateManyMutationInput, UserTransactionArchiveUncheckedUpdateManyInput>
    /**
     * Filter which UserTransactionArchives to update
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * Limit how many UserTransactionArchives to update.
     */
    limit?: number
  }

  /**
   * UserTransactionArchive updateManyAndReturn
   */
  export type UserTransactionArchiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * The data used to update UserTransactionArchives.
     */
    data: XOR<UserTransactionArchiveUpdateManyMutationInput, UserTransactionArchiveUncheckedUpdateManyInput>
    /**
     * Filter which UserTransactionArchives to update
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * Limit how many UserTransactionArchives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTransactionArchive upsert
   */
  export type UserTransactionArchiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTransactionArchive to update in case it exists.
     */
    where: UserTransactionArchiveWhereUniqueInput
    /**
     * In case the UserTransactionArchive found by the `where` argument doesn't exist, create a new UserTransactionArchive with this data.
     */
    create: XOR<UserTransactionArchiveCreateInput, UserTransactionArchiveUncheckedCreateInput>
    /**
     * In case the UserTransactionArchive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTransactionArchiveUpdateInput, UserTransactionArchiveUncheckedUpdateInput>
  }

  /**
   * UserTransactionArchive delete
   */
  export type UserTransactionArchiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
    /**
     * Filter which UserTransactionArchive to delete.
     */
    where: UserTransactionArchiveWhereUniqueInput
  }

  /**
   * UserTransactionArchive deleteMany
   */
  export type UserTransactionArchiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTransactionArchives to delete
     */
    where?: UserTransactionArchiveWhereInput
    /**
     * Limit how many UserTransactionArchives to delete.
     */
    limit?: number
  }

  /**
   * UserTransactionArchive without action
   */
  export type UserTransactionArchiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTransactionArchive
     */
    select?: UserTransactionArchiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTransactionArchive
     */
    omit?: UserTransactionArchiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTransactionArchiveInclude<ExtArgs> | null
  }


  /**
   * Model MultiplayerRoom
   */

  export type AggregateMultiplayerRoom = {
    _count: MultiplayerRoomCountAggregateOutputType | null
    _avg: MultiplayerRoomAvgAggregateOutputType | null
    _sum: MultiplayerRoomSumAggregateOutputType | null
    _min: MultiplayerRoomMinAggregateOutputType | null
    _max: MultiplayerRoomMaxAggregateOutputType | null
  }

  export type MultiplayerRoomAvgAggregateOutputType = {
    max: number | null
  }

  export type MultiplayerRoomSumAggregateOutputType = {
    max: number | null
  }

  export type MultiplayerRoomMinAggregateOutputType = {
    id: string | null
    max: number | null
    gameplayId: string | null
    botOwner: string | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MultiplayerRoomMaxAggregateOutputType = {
    id: string | null
    max: number | null
    gameplayId: string | null
    botOwner: string | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MultiplayerRoomCountAggregateOutputType = {
    id: number
    max: number
    gameplayId: number
    botOwner: number
    startedAt: number
    endedAt: number
    expiredAt: number
    isStarted: number
    isEnded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MultiplayerRoomAvgAggregateInputType = {
    max?: true
  }

  export type MultiplayerRoomSumAggregateInputType = {
    max?: true
  }

  export type MultiplayerRoomMinAggregateInputType = {
    id?: true
    max?: true
    gameplayId?: true
    botOwner?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MultiplayerRoomMaxAggregateInputType = {
    id?: true
    max?: true
    gameplayId?: true
    botOwner?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MultiplayerRoomCountAggregateInputType = {
    id?: true
    max?: true
    gameplayId?: true
    botOwner?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MultiplayerRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiplayerRoom to aggregate.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiplayerRooms
    **/
    _count?: true | MultiplayerRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultiplayerRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultiplayerRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiplayerRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiplayerRoomMaxAggregateInputType
  }

  export type GetMultiplayerRoomAggregateType<T extends MultiplayerRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiplayerRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiplayerRoom[P]>
      : GetScalarType<T[P], AggregateMultiplayerRoom[P]>
  }




  export type MultiplayerRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiplayerRoomWhereInput
    orderBy?: MultiplayerRoomOrderByWithAggregationInput | MultiplayerRoomOrderByWithAggregationInput[]
    by: MultiplayerRoomScalarFieldEnum[] | MultiplayerRoomScalarFieldEnum
    having?: MultiplayerRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiplayerRoomCountAggregateInputType | true
    _avg?: MultiplayerRoomAvgAggregateInputType
    _sum?: MultiplayerRoomSumAggregateInputType
    _min?: MultiplayerRoomMinAggregateInputType
    _max?: MultiplayerRoomMaxAggregateInputType
  }

  export type MultiplayerRoomGroupByOutputType = {
    id: string
    max: number
    gameplayId: string
    botOwner: string
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean
    isEnded: boolean
    createdAt: Date
    updatedAt: Date
    _count: MultiplayerRoomCountAggregateOutputType | null
    _avg: MultiplayerRoomAvgAggregateOutputType | null
    _sum: MultiplayerRoomSumAggregateOutputType | null
    _min: MultiplayerRoomMinAggregateOutputType | null
    _max: MultiplayerRoomMaxAggregateOutputType | null
  }

  type GetMultiplayerRoomGroupByPayload<T extends MultiplayerRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiplayerRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiplayerRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiplayerRoomGroupByOutputType[P]>
            : GetScalarType<T[P], MultiplayerRoomGroupByOutputType[P]>
        }
      >
    >


  export type MultiplayerRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | MultiplayerRoom$membersArgs<ExtArgs>
    _count?: boolean | MultiplayerRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiplayerRoom"]>

  export type MultiplayerRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["multiplayerRoom"]>

  export type MultiplayerRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["multiplayerRoom"]>

  export type MultiplayerRoomSelectScalar = {
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MultiplayerRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "max" | "gameplayId" | "botOwner" | "startedAt" | "endedAt" | "expiredAt" | "isStarted" | "isEnded" | "createdAt" | "updatedAt", ExtArgs["result"]["multiplayerRoom"]>
  export type MultiplayerRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MultiplayerRoom$membersArgs<ExtArgs>
    _count?: boolean | MultiplayerRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MultiplayerRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MultiplayerRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MultiplayerRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiplayerRoom"
    objects: {
      members: Prisma.$MultiPlayerMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      gameplayId: string
      botOwner: string
      startedAt: Date | null
      endedAt: Date | null
      expiredAt: Date | null
      isStarted: boolean
      isEnded: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["multiplayerRoom"]>
    composites: {}
  }

  type MultiplayerRoomGetPayload<S extends boolean | null | undefined | MultiplayerRoomDefaultArgs> = $Result.GetResult<Prisma.$MultiplayerRoomPayload, S>

  type MultiplayerRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultiplayerRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultiplayerRoomCountAggregateInputType | true
    }

  export interface MultiplayerRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiplayerRoom'], meta: { name: 'MultiplayerRoom' } }
    /**
     * Find zero or one MultiplayerRoom that matches the filter.
     * @param {MultiplayerRoomFindUniqueArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultiplayerRoomFindUniqueArgs>(args: SelectSubset<T, MultiplayerRoomFindUniqueArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultiplayerRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultiplayerRoomFindUniqueOrThrowArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultiplayerRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, MultiplayerRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiplayerRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomFindFirstArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultiplayerRoomFindFirstArgs>(args?: SelectSubset<T, MultiplayerRoomFindFirstArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiplayerRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomFindFirstOrThrowArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultiplayerRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, MultiplayerRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultiplayerRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiplayerRooms
     * const multiplayerRooms = await prisma.multiplayerRoom.findMany()
     * 
     * // Get first 10 MultiplayerRooms
     * const multiplayerRooms = await prisma.multiplayerRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiplayerRoomWithIdOnly = await prisma.multiplayerRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultiplayerRoomFindManyArgs>(args?: SelectSubset<T, MultiplayerRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultiplayerRoom.
     * @param {MultiplayerRoomCreateArgs} args - Arguments to create a MultiplayerRoom.
     * @example
     * // Create one MultiplayerRoom
     * const MultiplayerRoom = await prisma.multiplayerRoom.create({
     *   data: {
     *     // ... data to create a MultiplayerRoom
     *   }
     * })
     * 
     */
    create<T extends MultiplayerRoomCreateArgs>(args: SelectSubset<T, MultiplayerRoomCreateArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultiplayerRooms.
     * @param {MultiplayerRoomCreateManyArgs} args - Arguments to create many MultiplayerRooms.
     * @example
     * // Create many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultiplayerRoomCreateManyArgs>(args?: SelectSubset<T, MultiplayerRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultiplayerRooms and returns the data saved in the database.
     * @param {MultiplayerRoomCreateManyAndReturnArgs} args - Arguments to create many MultiplayerRooms.
     * @example
     * // Create many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultiplayerRooms and only return the `id`
     * const multiplayerRoomWithIdOnly = await prisma.multiplayerRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultiplayerRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, MultiplayerRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultiplayerRoom.
     * @param {MultiplayerRoomDeleteArgs} args - Arguments to delete one MultiplayerRoom.
     * @example
     * // Delete one MultiplayerRoom
     * const MultiplayerRoom = await prisma.multiplayerRoom.delete({
     *   where: {
     *     // ... filter to delete one MultiplayerRoom
     *   }
     * })
     * 
     */
    delete<T extends MultiplayerRoomDeleteArgs>(args: SelectSubset<T, MultiplayerRoomDeleteArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultiplayerRoom.
     * @param {MultiplayerRoomUpdateArgs} args - Arguments to update one MultiplayerRoom.
     * @example
     * // Update one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultiplayerRoomUpdateArgs>(args: SelectSubset<T, MultiplayerRoomUpdateArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultiplayerRooms.
     * @param {MultiplayerRoomDeleteManyArgs} args - Arguments to filter MultiplayerRooms to delete.
     * @example
     * // Delete a few MultiplayerRooms
     * const { count } = await prisma.multiplayerRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultiplayerRoomDeleteManyArgs>(args?: SelectSubset<T, MultiplayerRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiplayerRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultiplayerRoomUpdateManyArgs>(args: SelectSubset<T, MultiplayerRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiplayerRooms and returns the data updated in the database.
     * @param {MultiplayerRoomUpdateManyAndReturnArgs} args - Arguments to update many MultiplayerRooms.
     * @example
     * // Update many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultiplayerRooms and only return the `id`
     * const multiplayerRoomWithIdOnly = await prisma.multiplayerRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultiplayerRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, MultiplayerRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultiplayerRoom.
     * @param {MultiplayerRoomUpsertArgs} args - Arguments to update or create a MultiplayerRoom.
     * @example
     * // Update or create a MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.upsert({
     *   create: {
     *     // ... data to create a MultiplayerRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiplayerRoom we want to update
     *   }
     * })
     */
    upsert<T extends MultiplayerRoomUpsertArgs>(args: SelectSubset<T, MultiplayerRoomUpsertArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultiplayerRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomCountArgs} args - Arguments to filter MultiplayerRooms to count.
     * @example
     * // Count the number of MultiplayerRooms
     * const count = await prisma.multiplayerRoom.count({
     *   where: {
     *     // ... the filter for the MultiplayerRooms we want to count
     *   }
     * })
    **/
    count<T extends MultiplayerRoomCountArgs>(
      args?: Subset<T, MultiplayerRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiplayerRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiplayerRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiplayerRoomAggregateArgs>(args: Subset<T, MultiplayerRoomAggregateArgs>): Prisma.PrismaPromise<GetMultiplayerRoomAggregateType<T>>

    /**
     * Group by MultiplayerRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiplayerRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiplayerRoomGroupByArgs['orderBy'] }
        : { orderBy?: MultiplayerRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiplayerRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiplayerRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiplayerRoom model
   */
  readonly fields: MultiplayerRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiplayerRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiplayerRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends MultiplayerRoom$membersArgs<ExtArgs> = {}>(args?: Subset<T, MultiplayerRoom$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultiplayerRoom model
   */
  interface MultiplayerRoomFieldRefs {
    readonly id: FieldRef<"MultiplayerRoom", 'String'>
    readonly max: FieldRef<"MultiplayerRoom", 'Int'>
    readonly gameplayId: FieldRef<"MultiplayerRoom", 'String'>
    readonly botOwner: FieldRef<"MultiplayerRoom", 'String'>
    readonly startedAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly endedAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly expiredAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly isStarted: FieldRef<"MultiplayerRoom", 'Boolean'>
    readonly isEnded: FieldRef<"MultiplayerRoom", 'Boolean'>
    readonly createdAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"MultiplayerRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultiplayerRoom findUnique
   */
  export type MultiplayerRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom findUniqueOrThrow
   */
  export type MultiplayerRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom findFirst
   */
  export type MultiplayerRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiplayerRooms.
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiplayerRooms.
     */
    distinct?: MultiplayerRoomScalarFieldEnum | MultiplayerRoomScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom findFirstOrThrow
   */
  export type MultiplayerRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiplayerRooms.
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiplayerRooms.
     */
    distinct?: MultiplayerRoomScalarFieldEnum | MultiplayerRoomScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom findMany
   */
  export type MultiplayerRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRooms to fetch.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiplayerRooms.
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    distinct?: MultiplayerRoomScalarFieldEnum | MultiplayerRoomScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom create
   */
  export type MultiplayerRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiplayerRoom.
     */
    data: XOR<MultiplayerRoomCreateInput, MultiplayerRoomUncheckedCreateInput>
  }

  /**
   * MultiplayerRoom createMany
   */
  export type MultiplayerRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiplayerRooms.
     */
    data: MultiplayerRoomCreateManyInput | MultiplayerRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiplayerRoom createManyAndReturn
   */
  export type MultiplayerRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * The data used to create many MultiplayerRooms.
     */
    data: MultiplayerRoomCreateManyInput | MultiplayerRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiplayerRoom update
   */
  export type MultiplayerRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiplayerRoom.
     */
    data: XOR<MultiplayerRoomUpdateInput, MultiplayerRoomUncheckedUpdateInput>
    /**
     * Choose, which MultiplayerRoom to update.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom updateMany
   */
  export type MultiplayerRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiplayerRooms.
     */
    data: XOR<MultiplayerRoomUpdateManyMutationInput, MultiplayerRoomUncheckedUpdateManyInput>
    /**
     * Filter which MultiplayerRooms to update
     */
    where?: MultiplayerRoomWhereInput
    /**
     * Limit how many MultiplayerRooms to update.
     */
    limit?: number
  }

  /**
   * MultiplayerRoom updateManyAndReturn
   */
  export type MultiplayerRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * The data used to update MultiplayerRooms.
     */
    data: XOR<MultiplayerRoomUpdateManyMutationInput, MultiplayerRoomUncheckedUpdateManyInput>
    /**
     * Filter which MultiplayerRooms to update
     */
    where?: MultiplayerRoomWhereInput
    /**
     * Limit how many MultiplayerRooms to update.
     */
    limit?: number
  }

  /**
   * MultiplayerRoom upsert
   */
  export type MultiplayerRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiplayerRoom to update in case it exists.
     */
    where: MultiplayerRoomWhereUniqueInput
    /**
     * In case the MultiplayerRoom found by the `where` argument doesn't exist, create a new MultiplayerRoom with this data.
     */
    create: XOR<MultiplayerRoomCreateInput, MultiplayerRoomUncheckedCreateInput>
    /**
     * In case the MultiplayerRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiplayerRoomUpdateInput, MultiplayerRoomUncheckedUpdateInput>
  }

  /**
   * MultiplayerRoom delete
   */
  export type MultiplayerRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter which MultiplayerRoom to delete.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom deleteMany
   */
  export type MultiplayerRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiplayerRooms to delete
     */
    where?: MultiplayerRoomWhereInput
    /**
     * Limit how many MultiplayerRooms to delete.
     */
    limit?: number
  }

  /**
   * MultiplayerRoom.members
   */
  export type MultiplayerRoom$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    where?: MultiPlayerMemberWhereInput
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    cursor?: MultiPlayerMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom without action
   */
  export type MultiplayerRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
  }


  /**
   * Model MultiPlayerMember
   */

  export type AggregateMultiPlayerMember = {
    _count: MultiPlayerMemberCountAggregateOutputType | null
    _avg: MultiPlayerMemberAvgAggregateOutputType | null
    _sum: MultiPlayerMemberSumAggregateOutputType | null
    _min: MultiPlayerMemberMinAggregateOutputType | null
    _max: MultiPlayerMemberMaxAggregateOutputType | null
  }

  export type MultiPlayerMemberAvgAggregateOutputType = {
    point: number | null
    bonusPoint: number | null
  }

  export type MultiPlayerMemberSumAggregateOutputType = {
    point: number | null
    bonusPoint: number | null
  }

  export type MultiPlayerMemberMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    point: number | null
    bonusPoint: number | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MultiPlayerMemberMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    point: number | null
    bonusPoint: number | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MultiPlayerMemberCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    point: number
    bonusPoint: number
    isReady: number
    isComplete: number
    isBot: number
    joinedAt: number
    finishedAt: number
    isDisconnect: number
    _all: number
  }


  export type MultiPlayerMemberAvgAggregateInputType = {
    point?: true
    bonusPoint?: true
  }

  export type MultiPlayerMemberSumAggregateInputType = {
    point?: true
    bonusPoint?: true
  }

  export type MultiPlayerMemberMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    point?: true
    bonusPoint?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MultiPlayerMemberMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    point?: true
    bonusPoint?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MultiPlayerMemberCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    point?: true
    bonusPoint?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
    _all?: true
  }

  export type MultiPlayerMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiPlayerMember to aggregate.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiPlayerMembers
    **/
    _count?: true | MultiPlayerMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultiPlayerMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultiPlayerMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiPlayerMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiPlayerMemberMaxAggregateInputType
  }

  export type GetMultiPlayerMemberAggregateType<T extends MultiPlayerMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiPlayerMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiPlayerMember[P]>
      : GetScalarType<T[P], AggregateMultiPlayerMember[P]>
  }




  export type MultiPlayerMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiPlayerMemberWhereInput
    orderBy?: MultiPlayerMemberOrderByWithAggregationInput | MultiPlayerMemberOrderByWithAggregationInput[]
    by: MultiPlayerMemberScalarFieldEnum[] | MultiPlayerMemberScalarFieldEnum
    having?: MultiPlayerMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiPlayerMemberCountAggregateInputType | true
    _avg?: MultiPlayerMemberAvgAggregateInputType
    _sum?: MultiPlayerMemberSumAggregateInputType
    _min?: MultiPlayerMemberMinAggregateInputType
    _max?: MultiPlayerMemberMaxAggregateInputType
  }

  export type MultiPlayerMemberGroupByOutputType = {
    id: string
    roomId: string
    userId: string | null
    point: number
    bonusPoint: number
    isReady: boolean
    isComplete: boolean
    isBot: boolean
    joinedAt: Date
    finishedAt: Date | null
    isDisconnect: boolean
    _count: MultiPlayerMemberCountAggregateOutputType | null
    _avg: MultiPlayerMemberAvgAggregateOutputType | null
    _sum: MultiPlayerMemberSumAggregateOutputType | null
    _min: MultiPlayerMemberMinAggregateOutputType | null
    _max: MultiPlayerMemberMaxAggregateOutputType | null
  }

  type GetMultiPlayerMemberGroupByPayload<T extends MultiPlayerMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiPlayerMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiPlayerMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiPlayerMemberGroupByOutputType[P]>
            : GetScalarType<T[P], MultiPlayerMemberGroupByOutputType[P]>
        }
      >
    >


  export type MultiPlayerMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    user?: boolean | MultiPlayerMember$userArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiPlayerMember"]>

  export type MultiPlayerMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    user?: boolean | MultiPlayerMember$userArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiPlayerMember"]>

  export type MultiPlayerMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    user?: boolean | MultiPlayerMember$userArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiPlayerMember"]>

  export type MultiPlayerMemberSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "point" | "bonusPoint" | "isReady" | "isComplete" | "isBot" | "joinedAt" | "finishedAt" | "isDisconnect", ExtArgs["result"]["multiPlayerMember"]>
  export type MultiPlayerMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MultiPlayerMember$userArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }
  export type MultiPlayerMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MultiPlayerMember$userArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }
  export type MultiPlayerMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MultiPlayerMember$userArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }

  export type $MultiPlayerMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiPlayerMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      room: Prisma.$MultiplayerRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string | null
      point: number
      bonusPoint: number
      isReady: boolean
      isComplete: boolean
      isBot: boolean
      joinedAt: Date
      finishedAt: Date | null
      isDisconnect: boolean
    }, ExtArgs["result"]["multiPlayerMember"]>
    composites: {}
  }

  type MultiPlayerMemberGetPayload<S extends boolean | null | undefined | MultiPlayerMemberDefaultArgs> = $Result.GetResult<Prisma.$MultiPlayerMemberPayload, S>

  type MultiPlayerMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultiPlayerMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultiPlayerMemberCountAggregateInputType | true
    }

  export interface MultiPlayerMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiPlayerMember'], meta: { name: 'MultiPlayerMember' } }
    /**
     * Find zero or one MultiPlayerMember that matches the filter.
     * @param {MultiPlayerMemberFindUniqueArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultiPlayerMemberFindUniqueArgs>(args: SelectSubset<T, MultiPlayerMemberFindUniqueArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultiPlayerMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultiPlayerMemberFindUniqueOrThrowArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultiPlayerMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MultiPlayerMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiPlayerMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberFindFirstArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultiPlayerMemberFindFirstArgs>(args?: SelectSubset<T, MultiPlayerMemberFindFirstArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiPlayerMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberFindFirstOrThrowArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultiPlayerMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MultiPlayerMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultiPlayerMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiPlayerMembers
     * const multiPlayerMembers = await prisma.multiPlayerMember.findMany()
     * 
     * // Get first 10 MultiPlayerMembers
     * const multiPlayerMembers = await prisma.multiPlayerMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiPlayerMemberWithIdOnly = await prisma.multiPlayerMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultiPlayerMemberFindManyArgs>(args?: SelectSubset<T, MultiPlayerMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultiPlayerMember.
     * @param {MultiPlayerMemberCreateArgs} args - Arguments to create a MultiPlayerMember.
     * @example
     * // Create one MultiPlayerMember
     * const MultiPlayerMember = await prisma.multiPlayerMember.create({
     *   data: {
     *     // ... data to create a MultiPlayerMember
     *   }
     * })
     * 
     */
    create<T extends MultiPlayerMemberCreateArgs>(args: SelectSubset<T, MultiPlayerMemberCreateArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultiPlayerMembers.
     * @param {MultiPlayerMemberCreateManyArgs} args - Arguments to create many MultiPlayerMembers.
     * @example
     * // Create many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultiPlayerMemberCreateManyArgs>(args?: SelectSubset<T, MultiPlayerMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultiPlayerMembers and returns the data saved in the database.
     * @param {MultiPlayerMemberCreateManyAndReturnArgs} args - Arguments to create many MultiPlayerMembers.
     * @example
     * // Create many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultiPlayerMembers and only return the `id`
     * const multiPlayerMemberWithIdOnly = await prisma.multiPlayerMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultiPlayerMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MultiPlayerMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultiPlayerMember.
     * @param {MultiPlayerMemberDeleteArgs} args - Arguments to delete one MultiPlayerMember.
     * @example
     * // Delete one MultiPlayerMember
     * const MultiPlayerMember = await prisma.multiPlayerMember.delete({
     *   where: {
     *     // ... filter to delete one MultiPlayerMember
     *   }
     * })
     * 
     */
    delete<T extends MultiPlayerMemberDeleteArgs>(args: SelectSubset<T, MultiPlayerMemberDeleteArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultiPlayerMember.
     * @param {MultiPlayerMemberUpdateArgs} args - Arguments to update one MultiPlayerMember.
     * @example
     * // Update one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultiPlayerMemberUpdateArgs>(args: SelectSubset<T, MultiPlayerMemberUpdateArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultiPlayerMembers.
     * @param {MultiPlayerMemberDeleteManyArgs} args - Arguments to filter MultiPlayerMembers to delete.
     * @example
     * // Delete a few MultiPlayerMembers
     * const { count } = await prisma.multiPlayerMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultiPlayerMemberDeleteManyArgs>(args?: SelectSubset<T, MultiPlayerMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiPlayerMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultiPlayerMemberUpdateManyArgs>(args: SelectSubset<T, MultiPlayerMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiPlayerMembers and returns the data updated in the database.
     * @param {MultiPlayerMemberUpdateManyAndReturnArgs} args - Arguments to update many MultiPlayerMembers.
     * @example
     * // Update many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultiPlayerMembers and only return the `id`
     * const multiPlayerMemberWithIdOnly = await prisma.multiPlayerMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultiPlayerMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MultiPlayerMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultiPlayerMember.
     * @param {MultiPlayerMemberUpsertArgs} args - Arguments to update or create a MultiPlayerMember.
     * @example
     * // Update or create a MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.upsert({
     *   create: {
     *     // ... data to create a MultiPlayerMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiPlayerMember we want to update
     *   }
     * })
     */
    upsert<T extends MultiPlayerMemberUpsertArgs>(args: SelectSubset<T, MultiPlayerMemberUpsertArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultiPlayerMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberCountArgs} args - Arguments to filter MultiPlayerMembers to count.
     * @example
     * // Count the number of MultiPlayerMembers
     * const count = await prisma.multiPlayerMember.count({
     *   where: {
     *     // ... the filter for the MultiPlayerMembers we want to count
     *   }
     * })
    **/
    count<T extends MultiPlayerMemberCountArgs>(
      args?: Subset<T, MultiPlayerMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiPlayerMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiPlayerMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiPlayerMemberAggregateArgs>(args: Subset<T, MultiPlayerMemberAggregateArgs>): Prisma.PrismaPromise<GetMultiPlayerMemberAggregateType<T>>

    /**
     * Group by MultiPlayerMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiPlayerMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiPlayerMemberGroupByArgs['orderBy'] }
        : { orderBy?: MultiPlayerMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiPlayerMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiPlayerMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiPlayerMember model
   */
  readonly fields: MultiPlayerMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiPlayerMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiPlayerMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends MultiPlayerMember$userArgs<ExtArgs> = {}>(args?: Subset<T, MultiPlayerMember$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    room<T extends MultiplayerRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MultiplayerRoomDefaultArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultiPlayerMember model
   */
  interface MultiPlayerMemberFieldRefs {
    readonly id: FieldRef<"MultiPlayerMember", 'String'>
    readonly roomId: FieldRef<"MultiPlayerMember", 'String'>
    readonly userId: FieldRef<"MultiPlayerMember", 'String'>
    readonly point: FieldRef<"MultiPlayerMember", 'Int'>
    readonly bonusPoint: FieldRef<"MultiPlayerMember", 'Int'>
    readonly isReady: FieldRef<"MultiPlayerMember", 'Boolean'>
    readonly isComplete: FieldRef<"MultiPlayerMember", 'Boolean'>
    readonly isBot: FieldRef<"MultiPlayerMember", 'Boolean'>
    readonly joinedAt: FieldRef<"MultiPlayerMember", 'DateTime'>
    readonly finishedAt: FieldRef<"MultiPlayerMember", 'DateTime'>
    readonly isDisconnect: FieldRef<"MultiPlayerMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MultiPlayerMember findUnique
   */
  export type MultiPlayerMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember findUniqueOrThrow
   */
  export type MultiPlayerMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember findFirst
   */
  export type MultiPlayerMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiPlayerMembers.
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiPlayerMembers.
     */
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiPlayerMember findFirstOrThrow
   */
  export type MultiPlayerMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiPlayerMembers.
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiPlayerMembers.
     */
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiPlayerMember findMany
   */
  export type MultiPlayerMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMembers to fetch.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiPlayerMembers.
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiPlayerMember create
   */
  export type MultiPlayerMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiPlayerMember.
     */
    data: XOR<MultiPlayerMemberCreateInput, MultiPlayerMemberUncheckedCreateInput>
  }

  /**
   * MultiPlayerMember createMany
   */
  export type MultiPlayerMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiPlayerMembers.
     */
    data: MultiPlayerMemberCreateManyInput | MultiPlayerMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiPlayerMember createManyAndReturn
   */
  export type MultiPlayerMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * The data used to create many MultiPlayerMembers.
     */
    data: MultiPlayerMemberCreateManyInput | MultiPlayerMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultiPlayerMember update
   */
  export type MultiPlayerMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiPlayerMember.
     */
    data: XOR<MultiPlayerMemberUpdateInput, MultiPlayerMemberUncheckedUpdateInput>
    /**
     * Choose, which MultiPlayerMember to update.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember updateMany
   */
  export type MultiPlayerMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiPlayerMembers.
     */
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyInput>
    /**
     * Filter which MultiPlayerMembers to update
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * Limit how many MultiPlayerMembers to update.
     */
    limit?: number
  }

  /**
   * MultiPlayerMember updateManyAndReturn
   */
  export type MultiPlayerMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * The data used to update MultiPlayerMembers.
     */
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyInput>
    /**
     * Filter which MultiPlayerMembers to update
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * Limit how many MultiPlayerMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultiPlayerMember upsert
   */
  export type MultiPlayerMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiPlayerMember to update in case it exists.
     */
    where: MultiPlayerMemberWhereUniqueInput
    /**
     * In case the MultiPlayerMember found by the `where` argument doesn't exist, create a new MultiPlayerMember with this data.
     */
    create: XOR<MultiPlayerMemberCreateInput, MultiPlayerMemberUncheckedCreateInput>
    /**
     * In case the MultiPlayerMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiPlayerMemberUpdateInput, MultiPlayerMemberUncheckedUpdateInput>
  }

  /**
   * MultiPlayerMember delete
   */
  export type MultiPlayerMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter which MultiPlayerMember to delete.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember deleteMany
   */
  export type MultiPlayerMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiPlayerMembers to delete
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * Limit how many MultiPlayerMembers to delete.
     */
    limit?: number
  }

  /**
   * MultiPlayerMember.user
   */
  export type MultiPlayerMember$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MultiPlayerMember without action
   */
  export type MultiPlayerMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProvinceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    provinceId: 'provinceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    identity: 'identity',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    cityId: 'cityId',
    provinceId: 'provinceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const AccessContentScalarFieldEnum: {
    id: 'id',
    expired: 'expired',
    quota: 'quota',
    currentQuota: 'currentQuota',
    ownerId: 'ownerId',
    zones: 'zones',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccessContentScalarFieldEnum = (typeof AccessContentScalarFieldEnum)[keyof typeof AccessContentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    email: 'email',
    role: 'role',
    suspend: 'suspend',
    accountType: 'accountType',
    firstTest: 'firstTest',
    fullname: 'fullname',
    birthDate: 'birthDate',
    grade: 'grade',
    lastGradeUpdateAt: 'lastGradeUpdateAt',
    schoolIdentity: 'schoolIdentity',
    loginAt: 'loginAt',
    logoutAt: 'logoutAt',
    playTime: 'playTime',
    characterUsed: 'characterUsed',
    inventory: 'inventory',
    schoolId: 'schoolId',
    cityId: 'cityId',
    provinceId: 'provinceId',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    storageId: 'storageId',
    lastIdZoneUnlocked: 'lastIdZoneUnlocked',
    lastIdZonePosition: 'lastIdZonePosition'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    model: 'model',
    manufactur: 'manufactur',
    os: 'os',
    ramSize: 'ramSize',
    gpuName: 'gpuName',
    cpuType: 'cpuType',
    cpuCores: 'cpuCores',
    userId: 'userId'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    zoneId: 'zoneId',
    userId: 'userId',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    lastLevelId: 'lastLevelId',
    lastSubLevelId: 'lastSubLevelId',
    lastInnerLevelId: 'lastInnerLevelId',
    lastLevelUnlock: 'lastLevelUnlock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    levelId: 'levelId',
    zoneId: 'zoneId',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const SubLevelScalarFieldEnum: {
    id: 'id',
    subLevelId: 'subLevelId',
    levelId: 'levelId',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubLevelScalarFieldEnum = (typeof SubLevelScalarFieldEnum)[keyof typeof SubLevelScalarFieldEnum]


  export const InnerLevelScalarFieldEnum: {
    id: 'id',
    innerLevelId: 'innerLevelId',
    subLevelId: 'subLevelId',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    point: 'point',
    played: 'played',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InnerLevelScalarFieldEnum = (typeof InnerLevelScalarFieldEnum)[keyof typeof InnerLevelScalarFieldEnum]


  export const GempoScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    gempoId: 'gempoId',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GempoScalarFieldEnum = (typeof GempoScalarFieldEnum)[keyof typeof GempoScalarFieldEnum]


  export const ChampionshipScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    championshipId: 'championshipId',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChampionshipScalarFieldEnum = (typeof ChampionshipScalarFieldEnum)[keyof typeof ChampionshipScalarFieldEnum]


  export const GempoRecordScalarFieldEnum: {
    id: 'id',
    recordId: 'recordId',
    gempoId: 'gempoId',
    played: 'played',
    point: 'point',
    lastPlayedAt: 'lastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GempoRecordScalarFieldEnum = (typeof GempoRecordScalarFieldEnum)[keyof typeof GempoRecordScalarFieldEnum]


  export const ChampionshipRecordScalarFieldEnum: {
    id: 'id',
    recordId: 'recordId',
    championshipId: 'championshipId',
    teamWin: 'teamWin',
    teamLose: 'teamLose',
    teamPlayed: 'teamPlayed',
    teamPoint: 'teamPoint',
    teamLastPlayedAt: 'teamLastPlayedAt',
    soloWin: 'soloWin',
    soloLose: 'soloLose',
    soloPlayed: 'soloPlayed',
    soloPoint: 'soloPoint',
    soloLastPlayedAt: 'soloLastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChampionshipRecordScalarFieldEnum = (typeof ChampionshipRecordScalarFieldEnum)[keyof typeof ChampionshipRecordScalarFieldEnum]


  export const UserLoginScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    loginDate: 'loginDate',
    logoutDate: 'logoutDate'
  };

  export type UserLoginScalarFieldEnum = (typeof UserLoginScalarFieldEnum)[keyof typeof UserLoginScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    email: 'email',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminOperationHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    adminId: 'adminId',
    opAdminId: 'opAdminId',
    operation: 'operation'
  };

  export type AdminOperationHistoryScalarFieldEnum = (typeof AdminOperationHistoryScalarFieldEnum)[keyof typeof AdminOperationHistoryScalarFieldEnum]


  export const AdminAuthorityScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    provinceId: 'provinceId',
    grades: 'grades'
  };

  export type AdminAuthorityScalarFieldEnum = (typeof AdminAuthorityScalarFieldEnum)[keyof typeof AdminAuthorityScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    thumbnail: 'thumbnail',
    link: 'link',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    isHide: 'isHide',
    adminId: 'adminId'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const BannerLocationScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    provinceId: 'provinceId'
  };

  export type BannerLocationScalarFieldEnum = (typeof BannerLocationScalarFieldEnum)[keyof typeof BannerLocationScalarFieldEnum]


  export const BannerVisitorScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    traffic: 'traffic'
  };

  export type BannerVisitorScalarFieldEnum = (typeof BannerVisitorScalarFieldEnum)[keyof typeof BannerVisitorScalarFieldEnum]


  export const TestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    question: 'question',
    duration: 'duration',
    passedPoint: 'passedPoint',
    remidialCount: 'remidialCount',
    type: 'type',
    quota: 'quota',
    currentQuota: 'currentQuota',
    code: 'code',
    zoneId: 'zoneId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    description: 'description'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const TestParticipantScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    userId: 'userId',
    firstTimeAt: 'firstTimeAt',
    lastTestAt: 'lastTestAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    highscore: 'highscore',
    average: 'average',
    lowscore: 'lowscore'
  };

  export type TestParticipantScalarFieldEnum = (typeof TestParticipantScalarFieldEnum)[keyof typeof TestParticipantScalarFieldEnum]


  export const TestParticipantRecordScalarFieldEnum: {
    id: 'id',
    participantId: 'participantId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    answers: 'answers'
  };

  export type TestParticipantRecordScalarFieldEnum = (typeof TestParticipantRecordScalarFieldEnum)[keyof typeof TestParticipantRecordScalarFieldEnum]


  export const BackgroundScalarFieldEnum: {
    id: 'id',
    name: 'name',
    thumbnail: 'thumbnail',
    isUse: 'isUse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BackgroundScalarFieldEnum = (typeof BackgroundScalarFieldEnum)[keyof typeof BackgroundScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    quota: 'quota',
    currentQuota: 'currentQuota',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    type: 'type',
    zones: 'zones'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherRedemeerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    voucherId: 'voucherId',
    userId: 'userId'
  };

  export type VoucherRedemeerScalarFieldEnum = (typeof VoucherRedemeerScalarFieldEnum)[keyof typeof VoucherRedemeerScalarFieldEnum]


  export const AdminTransactionScalarFieldEnum: {
    id: 'id',
    transactionName: 'transactionName',
    status: 'status',
    createdAt: 'createdAt',
    expiredAt: 'expiredAt',
    updatedAt: 'updatedAt',
    customerEmail: 'customerEmail',
    customerName: 'customerName',
    customerId: 'customerId',
    quantity: 'quantity',
    zones: 'zones'
  };

  export type AdminTransactionScalarFieldEnum = (typeof AdminTransactionScalarFieldEnum)[keyof typeof AdminTransactionScalarFieldEnum]


  export const AdminTransactionArchiveScalarFieldEnum: {
    id: 'id',
    transactionName: 'transactionName',
    status: 'status',
    createdAt: 'createdAt',
    expiredAt: 'expiredAt',
    updatedAt: 'updatedAt',
    customerEmail: 'customerEmail',
    customerName: 'customerName',
    customerId: 'customerId',
    quantity: 'quantity',
    zones: 'zones'
  };

  export type AdminTransactionArchiveScalarFieldEnum = (typeof AdminTransactionArchiveScalarFieldEnum)[keyof typeof AdminTransactionArchiveScalarFieldEnum]


  export const UserTransactionScalarFieldEnum: {
    id: 'id',
    transactionName: 'transactionName',
    status: 'status',
    createdAt: 'createdAt',
    expiredAt: 'expiredAt',
    updatedAt: 'updatedAt',
    customerEmail: 'customerEmail',
    customerName: 'customerName',
    customerId: 'customerId',
    quantity: 'quantity',
    zones: 'zones'
  };

  export type UserTransactionScalarFieldEnum = (typeof UserTransactionScalarFieldEnum)[keyof typeof UserTransactionScalarFieldEnum]


  export const UserTransactionArchiveScalarFieldEnum: {
    id: 'id',
    transactionName: 'transactionName',
    status: 'status',
    createdAt: 'createdAt',
    expiredAt: 'expiredAt',
    updatedAt: 'updatedAt',
    customerEmail: 'customerEmail',
    customerName: 'customerName',
    customerId: 'customerId',
    quantity: 'quantity',
    zones: 'zones'
  };

  export type UserTransactionArchiveScalarFieldEnum = (typeof UserTransactionArchiveScalarFieldEnum)[keyof typeof UserTransactionArchiveScalarFieldEnum]


  export const MultiplayerRoomScalarFieldEnum: {
    id: 'id',
    max: 'max',
    gameplayId: 'gameplayId',
    botOwner: 'botOwner',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    expiredAt: 'expiredAt',
    isStarted: 'isStarted',
    isEnded: 'isEnded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MultiplayerRoomScalarFieldEnum = (typeof MultiplayerRoomScalarFieldEnum)[keyof typeof MultiplayerRoomScalarFieldEnum]


  export const MultiPlayerMemberScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    point: 'point',
    bonusPoint: 'bonusPoint',
    isReady: 'isReady',
    isComplete: 'isComplete',
    isBot: 'isBot',
    joinedAt: 'joinedAt',
    finishedAt: 'finishedAt',
    isDisconnect: 'isDisconnect'
  };

  export type MultiPlayerMemberScalarFieldEnum = (typeof MultiPlayerMemberScalarFieldEnum)[keyof typeof MultiPlayerMemberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Operation'
   */
  export type EnumOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Operation'>
    


  /**
   * Reference to a field of type 'Operation[]'
   */
  export type ListEnumOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Operation[]'>
    


  /**
   * Reference to a field of type 'TestCategory'
   */
  export type EnumTestCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestCategory'>
    


  /**
   * Reference to a field of type 'TestCategory[]'
   */
  export type ListEnumTestCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestCategory[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'TestType'
   */
  export type EnumTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestType'>
    


  /**
   * Reference to a field of type 'TestType[]'
   */
  export type ListEnumTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'VoucherType'
   */
  export type EnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType'>
    


  /**
   * Reference to a field of type 'VoucherType[]'
   */
  export type ListEnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType[]'>
    
  /**
   * Deep Input Types
   */


  export type ProvinceWhereInput = {
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    id?: StringFilter<"Province"> | string
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
  }

  export type ProvinceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    schools?: SchoolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    bannerLocation?: BannerLocationOrderByRelationAggregateInput
  }

  export type ProvinceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
  }, "id">

  export type ProvinceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProvinceCountOrderByAggregateInput
    _avg?: ProvinceAvgOrderByAggregateInput
    _max?: ProvinceMaxOrderByAggregateInput
    _min?: ProvinceMinOrderByAggregateInput
    _sum?: ProvinceSumOrderByAggregateInput
  }

  export type ProvinceScalarWhereWithAggregatesInput = {
    AND?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    OR?: ProvinceScalarWhereWithAggregatesInput[]
    NOT?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Province"> | string
    name?: StringWithAggregatesFilter<"Province"> | string
    longitude?: FloatWithAggregatesFilter<"Province"> | number
    latitude?: FloatWithAggregatesFilter<"Province"> | number
    geoId?: StringWithAggregatesFilter<"Province"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Province"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Province"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    province?: ProvinceOrderByWithRelationInput
    schools?: SchoolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    bannerLocation?: BannerLocationOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    longitude?: FloatWithAggregatesFilter<"City"> | number
    latitude?: FloatWithAggregatesFilter<"City"> | number
    geoId?: StringWithAggregatesFilter<"City"> | string
    provinceId?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    identity?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringFilter<"School"> | string
    provinceId?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    identity?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringFilter<"School"> | string
    provinceId?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    identity?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    longitude?: FloatWithAggregatesFilter<"School"> | number
    latitude?: FloatWithAggregatesFilter<"School"> | number
    cityId?: StringWithAggregatesFilter<"School"> | string
    provinceId?: StringWithAggregatesFilter<"School"> | string
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type AccessContentWhereInput = {
    AND?: AccessContentWhereInput | AccessContentWhereInput[]
    OR?: AccessContentWhereInput[]
    NOT?: AccessContentWhereInput | AccessContentWhereInput[]
    id?: StringFilter<"AccessContent"> | string
    expired?: DateTimeFilter<"AccessContent"> | Date | string
    quota?: IntFilter<"AccessContent"> | number
    currentQuota?: IntFilter<"AccessContent"> | number
    ownerId?: StringNullableFilter<"AccessContent"> | string | null
    zones?: StringNullableListFilter<"AccessContent">
    createdAt?: DateTimeFilter<"AccessContent"> | Date | string
    updatedAt?: DateTimeFilter<"AccessContent"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    userAccesses?: UserListRelationFilter
    redemeers?: UserListRelationFilter
  }

  export type AccessContentOrderByWithRelationInput = {
    id?: SortOrder
    expired?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    zones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    userAccesses?: UserOrderByRelationAggregateInput
    redemeers?: UserOrderByRelationAggregateInput
  }

  export type AccessContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccessContentWhereInput | AccessContentWhereInput[]
    OR?: AccessContentWhereInput[]
    NOT?: AccessContentWhereInput | AccessContentWhereInput[]
    expired?: DateTimeFilter<"AccessContent"> | Date | string
    quota?: IntFilter<"AccessContent"> | number
    currentQuota?: IntFilter<"AccessContent"> | number
    ownerId?: StringNullableFilter<"AccessContent"> | string | null
    zones?: StringNullableListFilter<"AccessContent">
    createdAt?: DateTimeFilter<"AccessContent"> | Date | string
    updatedAt?: DateTimeFilter<"AccessContent"> | Date | string
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    userAccesses?: UserListRelationFilter
    redemeers?: UserListRelationFilter
  }, "id">

  export type AccessContentOrderByWithAggregationInput = {
    id?: SortOrder
    expired?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    zones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccessContentCountOrderByAggregateInput
    _avg?: AccessContentAvgOrderByAggregateInput
    _max?: AccessContentMaxOrderByAggregateInput
    _min?: AccessContentMinOrderByAggregateInput
    _sum?: AccessContentSumOrderByAggregateInput
  }

  export type AccessContentScalarWhereWithAggregatesInput = {
    AND?: AccessContentScalarWhereWithAggregatesInput | AccessContentScalarWhereWithAggregatesInput[]
    OR?: AccessContentScalarWhereWithAggregatesInput[]
    NOT?: AccessContentScalarWhereWithAggregatesInput | AccessContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccessContent"> | string
    expired?: DateTimeWithAggregatesFilter<"AccessContent"> | Date | string
    quota?: IntWithAggregatesFilter<"AccessContent"> | number
    currentQuota?: IntWithAggregatesFilter<"AccessContent"> | number
    ownerId?: StringNullableWithAggregatesFilter<"AccessContent"> | string | null
    zones?: StringNullableListFilter<"AccessContent">
    createdAt?: DateTimeWithAggregatesFilter<"AccessContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccessContent"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    authId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: IntFilter<"User"> | number
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    storageId?: StringNullableFilter<"User"> | string | null
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
    ownedAccesses?: AccessContentListRelationFilter
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    userAccesses?: AccessContentListRelationFilter
    zones?: ZoneListRelationFilter
    redeemedAccesses?: AccessContentListRelationFilter
    UserLogin?: UserLoginListRelationFilter
    bannerVisitor?: BannerVisitorListRelationFilter
    testParticipant?: TestParticipantListRelationFilter
    voucherRedemeer?: VoucherRedemeerListRelationFilter
    userTransactionArchive?: UserTransactionArchiveListRelationFilter
    userTransaction?: UserTransactionListRelationFilter
    multiPlayerMember?: MultiPlayerMemberListRelationFilter
    testRecords?: TestParticipantRecordListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrderInput | SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrderInput | SortOrder
    logoutAt?: SortOrderInput | SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    storageId?: SortOrderInput | SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
    device?: DeviceOrderByWithRelationInput
    ownedAccesses?: AccessContentOrderByRelationAggregateInput
    city?: CityOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    userAccesses?: AccessContentOrderByRelationAggregateInput
    zones?: ZoneOrderByRelationAggregateInput
    redeemedAccesses?: AccessContentOrderByRelationAggregateInput
    UserLogin?: UserLoginOrderByRelationAggregateInput
    bannerVisitor?: BannerVisitorOrderByRelationAggregateInput
    testParticipant?: TestParticipantOrderByRelationAggregateInput
    voucherRedemeer?: VoucherRedemeerOrderByRelationAggregateInput
    userTransactionArchive?: UserTransactionArchiveOrderByRelationAggregateInput
    userTransaction?: UserTransactionOrderByRelationAggregateInput
    multiPlayerMember?: MultiPlayerMemberOrderByRelationAggregateInput
    testRecords?: TestParticipantRecordOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    schoolId?: string
    cityId?: string
    provinceId?: string
    adminId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: IntFilter<"User"> | number
    inventory?: IntNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    storageId?: StringNullableFilter<"User"> | string | null
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
    ownedAccesses?: AccessContentListRelationFilter
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    userAccesses?: AccessContentListRelationFilter
    zones?: ZoneListRelationFilter
    redeemedAccesses?: AccessContentListRelationFilter
    UserLogin?: UserLoginListRelationFilter
    bannerVisitor?: BannerVisitorListRelationFilter
    testParticipant?: TestParticipantListRelationFilter
    voucherRedemeer?: VoucherRedemeerListRelationFilter
    userTransactionArchive?: UserTransactionArchiveListRelationFilter
    userTransaction?: UserTransactionListRelationFilter
    multiPlayerMember?: MultiPlayerMemberListRelationFilter
    testRecords?: TestParticipantRecordListRelationFilter
  }, "id" | "authId" | "email" | "schoolId" | "cityId" | "provinceId" | "adminId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrderInput | SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrderInput | SortOrder
    logoutAt?: SortOrderInput | SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    storageId?: SortOrderInput | SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    authId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    suspend?: BoolWithAggregatesFilter<"User"> | boolean
    accountType?: EnumAccountTypeWithAggregatesFilter<"User"> | $Enums.AccountType
    firstTest?: BoolWithAggregatesFilter<"User"> | boolean
    fullname?: StringWithAggregatesFilter<"User"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    grade?: IntWithAggregatesFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    schoolIdentity?: StringWithAggregatesFilter<"User"> | string
    loginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    playTime?: IntWithAggregatesFilter<"User"> | number
    characterUsed?: IntWithAggregatesFilter<"User"> | number
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    provinceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringWithAggregatesFilter<"User"> | string
    storageId?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastIdZoneUnlocked?: StringWithAggregatesFilter<"User"> | string
    lastIdZonePosition?: StringWithAggregatesFilter<"User"> | string
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    uuid?: StringFilter<"Device"> | string
    model?: StringFilter<"Device"> | string
    manufactur?: StringFilter<"Device"> | string
    os?: StringFilter<"Device"> | string
    ramSize?: IntFilter<"Device"> | number
    gpuName?: StringFilter<"Device"> | string
    cpuType?: StringFilter<"Device"> | string
    cpuCores?: IntFilter<"Device"> | number
    userId?: StringFilter<"Device"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufactur?: SortOrder
    os?: SortOrder
    ramSize?: SortOrder
    gpuName?: SortOrder
    cpuType?: SortOrder
    cpuCores?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    uuid?: StringFilter<"Device"> | string
    model?: StringFilter<"Device"> | string
    manufactur?: StringFilter<"Device"> | string
    os?: StringFilter<"Device"> | string
    ramSize?: IntFilter<"Device"> | number
    gpuName?: StringFilter<"Device"> | string
    cpuType?: StringFilter<"Device"> | string
    cpuCores?: IntFilter<"Device"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufactur?: SortOrder
    os?: SortOrder
    ramSize?: SortOrder
    gpuName?: SortOrder
    cpuType?: SortOrder
    cpuCores?: SortOrder
    userId?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    uuid?: StringWithAggregatesFilter<"Device"> | string
    model?: StringWithAggregatesFilter<"Device"> | string
    manufactur?: StringWithAggregatesFilter<"Device"> | string
    os?: StringWithAggregatesFilter<"Device"> | string
    ramSize?: IntWithAggregatesFilter<"Device"> | number
    gpuName?: StringWithAggregatesFilter<"Device"> | string
    cpuType?: StringWithAggregatesFilter<"Device"> | string
    cpuCores?: IntWithAggregatesFilter<"Device"> | number
    userId?: StringWithAggregatesFilter<"Device"> | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    zoneId?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    levels?: LevelListRelationFilter
    gempo?: XOR<GempoNullableScalarRelationFilter, GempoWhereInput> | null
    championship?: XOR<ChampionshipNullableScalarRelationFilter, ChampionshipWhereInput> | null
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    levels?: LevelOrderByRelationAggregateInput
    gempo?: GempoOrderByWithRelationInput
    championship?: ChampionshipOrderByWithRelationInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_zoneId?: ZoneUserIdZoneIdCompoundUniqueInput
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    zoneId?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    levels?: LevelListRelationFilter
    gempo?: XOR<GempoNullableScalarRelationFilter, GempoWhereInput> | null
    championship?: XOR<ChampionshipNullableScalarRelationFilter, ChampionshipWhereInput> | null
  }, "id" | "userId_zoneId">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    zoneId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    zoneId?: StringWithAggregatesFilter<"Zone"> | string
    userId?: StringWithAggregatesFilter<"Zone"> | string
    isComplete?: BoolWithAggregatesFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Zone"> | Date | string | null
    lastLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastSubLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastInnerLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastLevelUnlock?: StringWithAggregatesFilter<"Zone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    levelId?: StringFilter<"Level"> | string
    zoneId?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    subLevels?: SubLevelListRelationFilter
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    levelId?: SortOrder
    zoneId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    subLevels?: SubLevelOrderByRelationAggregateInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    zoneId_levelId?: LevelZoneIdLevelIdCompoundUniqueInput
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    levelId?: StringFilter<"Level"> | string
    zoneId?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    subLevels?: SubLevelListRelationFilter
  }, "id" | "zoneId_levelId">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    levelId?: SortOrder
    zoneId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    levelId?: StringWithAggregatesFilter<"Level"> | string
    zoneId?: StringWithAggregatesFilter<"Level"> | string
    isUnlock?: BoolWithAggregatesFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"Level"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
  }

  export type SubLevelWhereInput = {
    AND?: SubLevelWhereInput | SubLevelWhereInput[]
    OR?: SubLevelWhereInput[]
    NOT?: SubLevelWhereInput | SubLevelWhereInput[]
    id?: StringFilter<"SubLevel"> | string
    subLevelId?: StringFilter<"SubLevel"> | string
    levelId?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
    innerLevels?: InnerLevelListRelationFilter
  }

  export type SubLevelOrderByWithRelationInput = {
    id?: SortOrder
    subLevelId?: SortOrder
    levelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: LevelOrderByWithRelationInput
    innerLevels?: InnerLevelOrderByRelationAggregateInput
  }

  export type SubLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    levelId_subLevelId?: SubLevelLevelIdSubLevelIdCompoundUniqueInput
    AND?: SubLevelWhereInput | SubLevelWhereInput[]
    OR?: SubLevelWhereInput[]
    NOT?: SubLevelWhereInput | SubLevelWhereInput[]
    subLevelId?: StringFilter<"SubLevel"> | string
    levelId?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
    innerLevels?: InnerLevelListRelationFilter
  }, "id" | "levelId_subLevelId">

  export type SubLevelOrderByWithAggregationInput = {
    id?: SortOrder
    subLevelId?: SortOrder
    levelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubLevelCountOrderByAggregateInput
    _max?: SubLevelMaxOrderByAggregateInput
    _min?: SubLevelMinOrderByAggregateInput
  }

  export type SubLevelScalarWhereWithAggregatesInput = {
    AND?: SubLevelScalarWhereWithAggregatesInput | SubLevelScalarWhereWithAggregatesInput[]
    OR?: SubLevelScalarWhereWithAggregatesInput[]
    NOT?: SubLevelScalarWhereWithAggregatesInput | SubLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubLevel"> | string
    subLevelId?: StringWithAggregatesFilter<"SubLevel"> | string
    levelId?: StringWithAggregatesFilter<"SubLevel"> | string
    isUnlock?: BoolWithAggregatesFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubLevel"> | Date | string
  }

  export type InnerLevelWhereInput = {
    AND?: InnerLevelWhereInput | InnerLevelWhereInput[]
    OR?: InnerLevelWhereInput[]
    NOT?: InnerLevelWhereInput | InnerLevelWhereInput[]
    id?: StringFilter<"InnerLevel"> | string
    innerLevelId?: StringFilter<"InnerLevel"> | string
    subLevelId?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    subLevel?: XOR<SubLevelScalarRelationFilter, SubLevelWhereInput>
  }

  export type InnerLevelOrderByWithRelationInput = {
    id?: SortOrder
    innerLevelId?: SortOrder
    subLevelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subLevel?: SubLevelOrderByWithRelationInput
  }

  export type InnerLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subLevelId_innerLevelId?: InnerLevelSubLevelIdInnerLevelIdCompoundUniqueInput
    AND?: InnerLevelWhereInput | InnerLevelWhereInput[]
    OR?: InnerLevelWhereInput[]
    NOT?: InnerLevelWhereInput | InnerLevelWhereInput[]
    innerLevelId?: StringFilter<"InnerLevel"> | string
    subLevelId?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    subLevel?: XOR<SubLevelScalarRelationFilter, SubLevelWhereInput>
  }, "id" | "subLevelId_innerLevelId">

  export type InnerLevelOrderByWithAggregationInput = {
    id?: SortOrder
    innerLevelId?: SortOrder
    subLevelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InnerLevelCountOrderByAggregateInput
    _avg?: InnerLevelAvgOrderByAggregateInput
    _max?: InnerLevelMaxOrderByAggregateInput
    _min?: InnerLevelMinOrderByAggregateInput
    _sum?: InnerLevelSumOrderByAggregateInput
  }

  export type InnerLevelScalarWhereWithAggregatesInput = {
    AND?: InnerLevelScalarWhereWithAggregatesInput | InnerLevelScalarWhereWithAggregatesInput[]
    OR?: InnerLevelScalarWhereWithAggregatesInput[]
    NOT?: InnerLevelScalarWhereWithAggregatesInput | InnerLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InnerLevel"> | string
    innerLevelId?: StringWithAggregatesFilter<"InnerLevel"> | string
    subLevelId?: StringWithAggregatesFilter<"InnerLevel"> | string
    isUnlock?: BoolWithAggregatesFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"InnerLevel"> | Date | string | null
    point?: IntWithAggregatesFilter<"InnerLevel"> | number
    played?: IntWithAggregatesFilter<"InnerLevel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InnerLevel"> | Date | string
  }

  export type GempoWhereInput = {
    AND?: GempoWhereInput | GempoWhereInput[]
    OR?: GempoWhereInput[]
    NOT?: GempoWhereInput | GempoWhereInput[]
    id?: StringFilter<"Gempo"> | string
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    gempoId?: StringFilter<"Gempo"> | string
    zoneId?: StringFilter<"Gempo"> | string
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    records?: GempoRecordListRelationFilter
  }

  export type GempoOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    gempoId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    records?: GempoRecordOrderByRelationAggregateInput
  }

  export type GempoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    zoneId?: string
    zoneId_gempoId?: GempoZoneIdGempoIdCompoundUniqueInput
    AND?: GempoWhereInput | GempoWhereInput[]
    OR?: GempoWhereInput[]
    NOT?: GempoWhereInput | GempoWhereInput[]
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    gempoId?: StringFilter<"Gempo"> | string
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    records?: GempoRecordListRelationFilter
  }, "id" | "zoneId" | "zoneId_gempoId">

  export type GempoOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    gempoId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GempoCountOrderByAggregateInput
    _max?: GempoMaxOrderByAggregateInput
    _min?: GempoMinOrderByAggregateInput
  }

  export type GempoScalarWhereWithAggregatesInput = {
    AND?: GempoScalarWhereWithAggregatesInput | GempoScalarWhereWithAggregatesInput[]
    OR?: GempoScalarWhereWithAggregatesInput[]
    NOT?: GempoScalarWhereWithAggregatesInput | GempoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gempo"> | string
    isUnlock?: BoolWithAggregatesFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Gempo"> | Date | string | null
    gempoId?: StringWithAggregatesFilter<"Gempo"> | string
    zoneId?: StringWithAggregatesFilter<"Gempo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gempo"> | Date | string
  }

  export type ChampionshipWhereInput = {
    AND?: ChampionshipWhereInput | ChampionshipWhereInput[]
    OR?: ChampionshipWhereInput[]
    NOT?: ChampionshipWhereInput | ChampionshipWhereInput[]
    id?: StringFilter<"Championship"> | string
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    championshipId?: StringFilter<"Championship"> | string
    zoneId?: StringFilter<"Championship"> | string
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    records?: ChampionshipRecordListRelationFilter
  }

  export type ChampionshipOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    championshipId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    records?: ChampionshipRecordOrderByRelationAggregateInput
  }

  export type ChampionshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    zoneId?: string
    zoneId_championshipId?: ChampionshipZoneIdChampionshipIdCompoundUniqueInput
    AND?: ChampionshipWhereInput | ChampionshipWhereInput[]
    OR?: ChampionshipWhereInput[]
    NOT?: ChampionshipWhereInput | ChampionshipWhereInput[]
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    championshipId?: StringFilter<"Championship"> | string
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    records?: ChampionshipRecordListRelationFilter
  }, "id" | "zoneId" | "zoneId_championshipId">

  export type ChampionshipOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    championshipId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChampionshipCountOrderByAggregateInput
    _max?: ChampionshipMaxOrderByAggregateInput
    _min?: ChampionshipMinOrderByAggregateInput
  }

  export type ChampionshipScalarWhereWithAggregatesInput = {
    AND?: ChampionshipScalarWhereWithAggregatesInput | ChampionshipScalarWhereWithAggregatesInput[]
    OR?: ChampionshipScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipScalarWhereWithAggregatesInput | ChampionshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Championship"> | string
    isUnlock?: BoolWithAggregatesFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Championship"> | Date | string | null
    championshipId?: StringWithAggregatesFilter<"Championship"> | string
    zoneId?: StringWithAggregatesFilter<"Championship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Championship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Championship"> | Date | string
  }

  export type GempoRecordWhereInput = {
    AND?: GempoRecordWhereInput | GempoRecordWhereInput[]
    OR?: GempoRecordWhereInput[]
    NOT?: GempoRecordWhereInput | GempoRecordWhereInput[]
    id?: StringFilter<"GempoRecord"> | string
    recordId?: StringFilter<"GempoRecord"> | string
    gempoId?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    gempo?: XOR<GempoScalarRelationFilter, GempoWhereInput>
  }

  export type GempoRecordOrderByWithRelationInput = {
    id?: SortOrder
    recordId?: SortOrder
    gempoId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gempo?: GempoOrderByWithRelationInput
  }

  export type GempoRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gempoId_recordId?: GempoRecordGempoIdRecordIdCompoundUniqueInput
    AND?: GempoRecordWhereInput | GempoRecordWhereInput[]
    OR?: GempoRecordWhereInput[]
    NOT?: GempoRecordWhereInput | GempoRecordWhereInput[]
    recordId?: StringFilter<"GempoRecord"> | string
    gempoId?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    gempo?: XOR<GempoScalarRelationFilter, GempoWhereInput>
  }, "id" | "gempoId_recordId">

  export type GempoRecordOrderByWithAggregationInput = {
    id?: SortOrder
    recordId?: SortOrder
    gempoId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GempoRecordCountOrderByAggregateInput
    _avg?: GempoRecordAvgOrderByAggregateInput
    _max?: GempoRecordMaxOrderByAggregateInput
    _min?: GempoRecordMinOrderByAggregateInput
    _sum?: GempoRecordSumOrderByAggregateInput
  }

  export type GempoRecordScalarWhereWithAggregatesInput = {
    AND?: GempoRecordScalarWhereWithAggregatesInput | GempoRecordScalarWhereWithAggregatesInput[]
    OR?: GempoRecordScalarWhereWithAggregatesInput[]
    NOT?: GempoRecordScalarWhereWithAggregatesInput | GempoRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GempoRecord"> | string
    recordId?: StringWithAggregatesFilter<"GempoRecord"> | string
    gempoId?: StringWithAggregatesFilter<"GempoRecord"> | string
    played?: IntWithAggregatesFilter<"GempoRecord"> | number
    point?: IntWithAggregatesFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GempoRecord"> | Date | string
  }

  export type ChampionshipRecordWhereInput = {
    AND?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    OR?: ChampionshipRecordWhereInput[]
    NOT?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    id?: StringFilter<"ChampionshipRecord"> | string
    recordId?: StringFilter<"ChampionshipRecord"> | string
    championshipId?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    championship?: XOR<ChampionshipScalarRelationFilter, ChampionshipWhereInput>
  }

  export type ChampionshipRecordOrderByWithRelationInput = {
    id?: SortOrder
    recordId?: SortOrder
    championshipId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrderInput | SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    championship?: ChampionshipOrderByWithRelationInput
  }

  export type ChampionshipRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    championshipId_recordId?: ChampionshipRecordChampionshipIdRecordIdCompoundUniqueInput
    AND?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    OR?: ChampionshipRecordWhereInput[]
    NOT?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    recordId?: StringFilter<"ChampionshipRecord"> | string
    championshipId?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    championship?: XOR<ChampionshipScalarRelationFilter, ChampionshipWhereInput>
  }, "id" | "championshipId_recordId">

  export type ChampionshipRecordOrderByWithAggregationInput = {
    id?: SortOrder
    recordId?: SortOrder
    championshipId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrderInput | SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChampionshipRecordCountOrderByAggregateInput
    _avg?: ChampionshipRecordAvgOrderByAggregateInput
    _max?: ChampionshipRecordMaxOrderByAggregateInput
    _min?: ChampionshipRecordMinOrderByAggregateInput
    _sum?: ChampionshipRecordSumOrderByAggregateInput
  }

  export type ChampionshipRecordScalarWhereWithAggregatesInput = {
    AND?: ChampionshipRecordScalarWhereWithAggregatesInput | ChampionshipRecordScalarWhereWithAggregatesInput[]
    OR?: ChampionshipRecordScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipRecordScalarWhereWithAggregatesInput | ChampionshipRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    recordId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    championshipId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    teamWin?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamLose?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamPoint?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloLose?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloPoint?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChampionshipRecord"> | Date | string
  }

  export type UserLoginWhereInput = {
    AND?: UserLoginWhereInput | UserLoginWhereInput[]
    OR?: UserLoginWhereInput[]
    NOT?: UserLoginWhereInput | UserLoginWhereInput[]
    id?: StringFilter<"UserLogin"> | string
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLoginOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLoginWhereInput | UserLoginWhereInput[]
    OR?: UserLoginWhereInput[]
    NOT?: UserLoginWhereInput | UserLoginWhereInput[]
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserLoginOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrderInput | SortOrder
    _count?: UserLoginCountOrderByAggregateInput
    _max?: UserLoginMaxOrderByAggregateInput
    _min?: UserLoginMinOrderByAggregateInput
  }

  export type UserLoginScalarWhereWithAggregatesInput = {
    AND?: UserLoginScalarWhereWithAggregatesInput | UserLoginScalarWhereWithAggregatesInput[]
    OR?: UserLoginScalarWhereWithAggregatesInput[]
    NOT?: UserLoginScalarWhereWithAggregatesInput | UserLoginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLogin"> | string
    userId?: StringWithAggregatesFilter<"UserLogin"> | string
    loginDate?: DateTimeWithAggregatesFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableWithAggregatesFilter<"UserLogin"> | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    authId?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    authority?: AdminAuthorityListRelationFilter
    operationHistories?: AdminOperationHistoryListRelationFilter
    operations?: AdminOperationHistoryListRelationFilter
    banner?: BannerListRelationFilter
    adminTransaction?: AdminTransactionListRelationFilter
    adminTransactionArchive?: AdminTransactionArchiveListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    authority?: AdminAuthorityOrderByRelationAggregateInput
    operationHistories?: AdminOperationHistoryOrderByRelationAggregateInput
    operations?: AdminOperationHistoryOrderByRelationAggregateInput
    banner?: BannerOrderByRelationAggregateInput
    adminTransaction?: AdminTransactionOrderByRelationAggregateInput
    adminTransactionArchive?: AdminTransactionArchiveOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    authority?: AdminAuthorityListRelationFilter
    operationHistories?: AdminOperationHistoryListRelationFilter
    operations?: AdminOperationHistoryListRelationFilter
    banner?: BannerListRelationFilter
    adminTransaction?: AdminTransactionListRelationFilter
    adminTransactionArchive?: AdminTransactionArchiveListRelationFilter
  }, "id" | "authId" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    authId?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumRoleNullableWithAggregatesFilter<"Admin"> | $Enums.Role | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type AdminOperationHistoryWhereInput = {
    AND?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    OR?: AdminOperationHistoryWhereInput[]
    NOT?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    opAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminOperationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
    admin?: AdminOrderByWithRelationInput
    opAdmin?: AdminOrderByWithRelationInput
  }

  export type AdminOperationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    OR?: AdminOperationHistoryWhereInput[]
    NOT?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    opAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminOperationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
    _count?: AdminOperationHistoryCountOrderByAggregateInput
    _max?: AdminOperationHistoryMaxOrderByAggregateInput
    _min?: AdminOperationHistoryMinOrderByAggregateInput
  }

  export type AdminOperationHistoryScalarWhereWithAggregatesInput = {
    AND?: AdminOperationHistoryScalarWhereWithAggregatesInput | AdminOperationHistoryScalarWhereWithAggregatesInput[]
    OR?: AdminOperationHistoryScalarWhereWithAggregatesInput[]
    NOT?: AdminOperationHistoryScalarWhereWithAggregatesInput | AdminOperationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    opAdminId?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationWithAggregatesFilter<"AdminOperationHistory"> | $Enums.Operation
  }

  export type AdminAuthorityWhereInput = {
    AND?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    OR?: AdminAuthorityWhereInput[]
    NOT?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    id?: StringFilter<"AdminAuthority"> | string
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
  }

  export type AdminAuthorityOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
    admin?: AdminOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
    schools?: SchoolOrderByRelationAggregateInput
  }

  export type AdminAuthorityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    OR?: AdminAuthorityWhereInput[]
    NOT?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
  }, "id">

  export type AdminAuthorityOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
    _count?: AdminAuthorityCountOrderByAggregateInput
    _avg?: AdminAuthorityAvgOrderByAggregateInput
    _max?: AdminAuthorityMaxOrderByAggregateInput
    _min?: AdminAuthorityMinOrderByAggregateInput
    _sum?: AdminAuthoritySumOrderByAggregateInput
  }

  export type AdminAuthorityScalarWhereWithAggregatesInput = {
    AND?: AdminAuthorityScalarWhereWithAggregatesInput | AdminAuthorityScalarWhereWithAggregatesInput[]
    OR?: AdminAuthorityScalarWhereWithAggregatesInput[]
    NOT?: AdminAuthorityScalarWhereWithAggregatesInput | AdminAuthorityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuthority"> | string
    adminId?: StringWithAggregatesFilter<"AdminAuthority"> | string
    provinceId?: StringWithAggregatesFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    adminId?: StringFilter<"Banner"> | string
    visitors?: BannerVisitorListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    bannerLocation?: BannerLocationListRelationFilter
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
    visitors?: BannerVisitorOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    bannerLocation?: BannerLocationOrderByRelationAggregateInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    adminId?: StringFilter<"Banner"> | string
    visitors?: BannerVisitorListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    bannerLocation?: BannerLocationListRelationFilter
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    thumbnail?: StringWithAggregatesFilter<"Banner"> | string
    link?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    isHide?: BoolWithAggregatesFilter<"Banner"> | boolean
    adminId?: StringWithAggregatesFilter<"Banner"> | string
  }

  export type BannerLocationWhereInput = {
    AND?: BannerLocationWhereInput | BannerLocationWhereInput[]
    OR?: BannerLocationWhereInput[]
    NOT?: BannerLocationWhereInput | BannerLocationWhereInput[]
    id?: StringFilter<"BannerLocation"> | string
    bannerId?: StringFilter<"BannerLocation"> | string
    provinceId?: StringFilter<"BannerLocation"> | string
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
  }

  export type BannerLocationOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
    banner?: BannerOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
  }

  export type BannerLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerLocationWhereInput | BannerLocationWhereInput[]
    OR?: BannerLocationWhereInput[]
    NOT?: BannerLocationWhereInput | BannerLocationWhereInput[]
    bannerId?: StringFilter<"BannerLocation"> | string
    provinceId?: StringFilter<"BannerLocation"> | string
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
  }, "id">

  export type BannerLocationOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
    _count?: BannerLocationCountOrderByAggregateInput
    _max?: BannerLocationMaxOrderByAggregateInput
    _min?: BannerLocationMinOrderByAggregateInput
  }

  export type BannerLocationScalarWhereWithAggregatesInput = {
    AND?: BannerLocationScalarWhereWithAggregatesInput | BannerLocationScalarWhereWithAggregatesInput[]
    OR?: BannerLocationScalarWhereWithAggregatesInput[]
    NOT?: BannerLocationScalarWhereWithAggregatesInput | BannerLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerLocation"> | string
    bannerId?: StringWithAggregatesFilter<"BannerLocation"> | string
    provinceId?: StringWithAggregatesFilter<"BannerLocation"> | string
  }

  export type BannerVisitorWhereInput = {
    AND?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    OR?: BannerVisitorWhereInput[]
    NOT?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    id?: StringFilter<"BannerVisitor"> | string
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BannerVisitorOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
    banner?: BannerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BannerVisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bannerId?: string
    userId?: string
    AND?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    OR?: BannerVisitorWhereInput[]
    NOT?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bannerId" | "userId">

  export type BannerVisitorOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
    _count?: BannerVisitorCountOrderByAggregateInput
    _avg?: BannerVisitorAvgOrderByAggregateInput
    _max?: BannerVisitorMaxOrderByAggregateInput
    _min?: BannerVisitorMinOrderByAggregateInput
    _sum?: BannerVisitorSumOrderByAggregateInput
  }

  export type BannerVisitorScalarWhereWithAggregatesInput = {
    AND?: BannerVisitorScalarWhereWithAggregatesInput | BannerVisitorScalarWhereWithAggregatesInput[]
    OR?: BannerVisitorScalarWhereWithAggregatesInput[]
    NOT?: BannerVisitorScalarWhereWithAggregatesInput | BannerVisitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerVisitor"> | string
    bannerId?: StringWithAggregatesFilter<"BannerVisitor"> | string
    userId?: StringWithAggregatesFilter<"BannerVisitor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BannerVisitor"> | Date | string
    traffic?: IntWithAggregatesFilter<"BannerVisitor"> | number
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    id?: StringFilter<"Test"> | string
    name?: StringFilter<"Test"> | string
    category?: EnumTestCategoryFilter<"Test"> | $Enums.TestCategory
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    participants?: TestParticipantListRelationFilter
  }

  export type TestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    participants?: TestParticipantOrderByRelationAggregateInput
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    name?: StringFilter<"Test"> | string
    category?: EnumTestCategoryFilter<"Test"> | $Enums.TestCategory
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    participants?: TestParticipantListRelationFilter
  }, "id">

  export type TestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Test"> | string
    name?: StringWithAggregatesFilter<"Test"> | string
    category?: EnumTestCategoryWithAggregatesFilter<"Test"> | $Enums.TestCategory
    question?: EnumQuestionTypeWithAggregatesFilter<"Test"> | $Enums.QuestionType
    duration?: IntWithAggregatesFilter<"Test"> | number
    passedPoint?: IntWithAggregatesFilter<"Test"> | number
    remidialCount?: IntWithAggregatesFilter<"Test"> | number
    type?: EnumTestTypeWithAggregatesFilter<"Test"> | $Enums.TestType
    quota?: IntWithAggregatesFilter<"Test"> | number
    currentQuota?: IntWithAggregatesFilter<"Test"> | number
    code?: StringNullableWithAggregatesFilter<"Test"> | string | null
    zoneId?: StringNullableWithAggregatesFilter<"Test"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Test"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Test"> | string | null
  }

  export type TestParticipantWhereInput = {
    AND?: TestParticipantWhereInput | TestParticipantWhereInput[]
    OR?: TestParticipantWhereInput[]
    NOT?: TestParticipantWhereInput | TestParticipantWhereInput[]
    id?: StringFilter<"TestParticipant"> | string
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    average?: FloatFilter<"TestParticipant"> | number
    lowscore?: FloatFilter<"TestParticipant"> | number
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    records?: TestParticipantRecordListRelationFilter
  }

  export type TestParticipantOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrderInput | SortOrder
    lastTestAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
    test?: TestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    records?: TestParticipantRecordOrderByRelationAggregateInput
  }

  export type TestParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    testId_userId?: TestParticipantTestIdUserIdCompoundUniqueInput
    AND?: TestParticipantWhereInput | TestParticipantWhereInput[]
    OR?: TestParticipantWhereInput[]
    NOT?: TestParticipantWhereInput | TestParticipantWhereInput[]
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    average?: FloatFilter<"TestParticipant"> | number
    lowscore?: FloatFilter<"TestParticipant"> | number
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    records?: TestParticipantRecordListRelationFilter
  }, "id" | "testId_userId">

  export type TestParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrderInput | SortOrder
    lastTestAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
    _count?: TestParticipantCountOrderByAggregateInput
    _avg?: TestParticipantAvgOrderByAggregateInput
    _max?: TestParticipantMaxOrderByAggregateInput
    _min?: TestParticipantMinOrderByAggregateInput
    _sum?: TestParticipantSumOrderByAggregateInput
  }

  export type TestParticipantScalarWhereWithAggregatesInput = {
    AND?: TestParticipantScalarWhereWithAggregatesInput | TestParticipantScalarWhereWithAggregatesInput[]
    OR?: TestParticipantScalarWhereWithAggregatesInput[]
    NOT?: TestParticipantScalarWhereWithAggregatesInput | TestParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParticipant"> | string
    testId?: StringWithAggregatesFilter<"TestParticipant"> | string
    userId?: StringWithAggregatesFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableWithAggregatesFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableWithAggregatesFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParticipant"> | Date | string
    highscore?: FloatWithAggregatesFilter<"TestParticipant"> | number
    average?: FloatWithAggregatesFilter<"TestParticipant"> | number
    lowscore?: FloatWithAggregatesFilter<"TestParticipant"> | number
  }

  export type TestParticipantRecordWhereInput = {
    AND?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    OR?: TestParticipantRecordWhereInput[]
    NOT?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    id?: StringFilter<"TestParticipantRecord"> | string
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    userId?: StringFilter<"TestParticipantRecord"> | string
    answers?: JsonFilter<"TestParticipantRecord">
    participant?: XOR<TestParticipantScalarRelationFilter, TestParticipantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TestParticipantRecordOrderByWithRelationInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    participant?: TestParticipantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TestParticipantRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    OR?: TestParticipantRecordWhereInput[]
    NOT?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    userId?: StringFilter<"TestParticipantRecord"> | string
    answers?: JsonFilter<"TestParticipantRecord">
    participant?: XOR<TestParticipantScalarRelationFilter, TestParticipantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TestParticipantRecordOrderByWithAggregationInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
    _count?: TestParticipantRecordCountOrderByAggregateInput
    _avg?: TestParticipantRecordAvgOrderByAggregateInput
    _max?: TestParticipantRecordMaxOrderByAggregateInput
    _min?: TestParticipantRecordMinOrderByAggregateInput
    _sum?: TestParticipantRecordSumOrderByAggregateInput
  }

  export type TestParticipantRecordScalarWhereWithAggregatesInput = {
    AND?: TestParticipantRecordScalarWhereWithAggregatesInput | TestParticipantRecordScalarWhereWithAggregatesInput[]
    OR?: TestParticipantRecordScalarWhereWithAggregatesInput[]
    NOT?: TestParticipantRecordScalarWhereWithAggregatesInput | TestParticipantRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    participantId?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatWithAggregatesFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParticipantRecord"> | Date | string
    userId?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    answers?: JsonWithAggregatesFilter<"TestParticipantRecord">
  }

  export type BackgroundWhereInput = {
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    id?: StringFilter<"Background"> | string
    name?: StringFilter<"Background"> | string
    thumbnail?: StringFilter<"Background"> | string
    isUse?: BoolFilter<"Background"> | boolean
    createdAt?: DateTimeFilter<"Background"> | Date | string
    updatedAt?: DateTimeFilter<"Background"> | Date | string
  }

  export type BackgroundOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackgroundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    name?: StringFilter<"Background"> | string
    thumbnail?: StringFilter<"Background"> | string
    isUse?: BoolFilter<"Background"> | boolean
    createdAt?: DateTimeFilter<"Background"> | Date | string
    updatedAt?: DateTimeFilter<"Background"> | Date | string
  }, "id">

  export type BackgroundOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BackgroundCountOrderByAggregateInput
    _max?: BackgroundMaxOrderByAggregateInput
    _min?: BackgroundMinOrderByAggregateInput
  }

  export type BackgroundScalarWhereWithAggregatesInput = {
    AND?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    OR?: BackgroundScalarWhereWithAggregatesInput[]
    NOT?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Background"> | string
    name?: StringWithAggregatesFilter<"Background"> | string
    thumbnail?: StringWithAggregatesFilter<"Background"> | string
    isUse?: BoolWithAggregatesFilter<"Background"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Background"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Background"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    name?: StringFilter<"Setting"> | string
    title?: StringFilter<"Setting"> | string
    content?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    name?: StringFilter<"Setting"> | string
    title?: StringFilter<"Setting"> | string
    content?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    name?: StringWithAggregatesFilter<"Setting"> | string
    title?: StringWithAggregatesFilter<"Setting"> | string
    content?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: IntFilter<"Voucher"> | number
    code?: StringFilter<"Voucher"> | string
    quota?: IntFilter<"Voucher"> | number
    currentQuota?: IntFilter<"Voucher"> | number
    startedAt?: DateTimeFilter<"Voucher"> | Date | string
    endedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    type?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    zones?: StringNullableListFilter<"Voucher">
    redemeers?: VoucherRedemeerListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    type?: SortOrder
    zones?: SortOrder
    redemeers?: VoucherRedemeerOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    quota?: IntFilter<"Voucher"> | number
    currentQuota?: IntFilter<"Voucher"> | number
    startedAt?: DateTimeFilter<"Voucher"> | Date | string
    endedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    type?: EnumVoucherTypeFilter<"Voucher"> | $Enums.VoucherType
    zones?: StringNullableListFilter<"Voucher">
    redemeers?: VoucherRedemeerListRelationFilter
  }, "id" | "code">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    type?: SortOrder
    zones?: SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Voucher"> | number
    code?: StringWithAggregatesFilter<"Voucher"> | string
    quota?: IntWithAggregatesFilter<"Voucher"> | number
    currentQuota?: IntWithAggregatesFilter<"Voucher"> | number
    startedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    type?: EnumVoucherTypeWithAggregatesFilter<"Voucher"> | $Enums.VoucherType
    zones?: StringNullableListFilter<"Voucher">
  }

  export type VoucherRedemeerWhereInput = {
    AND?: VoucherRedemeerWhereInput | VoucherRedemeerWhereInput[]
    OR?: VoucherRedemeerWhereInput[]
    NOT?: VoucherRedemeerWhereInput | VoucherRedemeerWhereInput[]
    id?: IntFilter<"VoucherRedemeer"> | number
    createdAt?: DateTimeFilter<"VoucherRedemeer"> | Date | string
    voucherId?: IntFilter<"VoucherRedemeer"> | number
    userId?: StringFilter<"VoucherRedemeer"> | string
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VoucherRedemeerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    voucher?: VoucherOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type VoucherRedemeerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VoucherRedemeerWhereInput | VoucherRedemeerWhereInput[]
    OR?: VoucherRedemeerWhereInput[]
    NOT?: VoucherRedemeerWhereInput | VoucherRedemeerWhereInput[]
    createdAt?: DateTimeFilter<"VoucherRedemeer"> | Date | string
    voucherId?: IntFilter<"VoucherRedemeer"> | number
    userId?: StringFilter<"VoucherRedemeer"> | string
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VoucherRedemeerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    _count?: VoucherRedemeerCountOrderByAggregateInput
    _avg?: VoucherRedemeerAvgOrderByAggregateInput
    _max?: VoucherRedemeerMaxOrderByAggregateInput
    _min?: VoucherRedemeerMinOrderByAggregateInput
    _sum?: VoucherRedemeerSumOrderByAggregateInput
  }

  export type VoucherRedemeerScalarWhereWithAggregatesInput = {
    AND?: VoucherRedemeerScalarWhereWithAggregatesInput | VoucherRedemeerScalarWhereWithAggregatesInput[]
    OR?: VoucherRedemeerScalarWhereWithAggregatesInput[]
    NOT?: VoucherRedemeerScalarWhereWithAggregatesInput | VoucherRedemeerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VoucherRedemeer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VoucherRedemeer"> | Date | string
    voucherId?: IntWithAggregatesFilter<"VoucherRedemeer"> | number
    userId?: StringWithAggregatesFilter<"VoucherRedemeer"> | string
  }

  export type AdminTransactionWhereInput = {
    AND?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    OR?: AdminTransactionWhereInput[]
    NOT?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    id?: StringFilter<"AdminTransaction"> | string
    transactionName?: StringFilter<"AdminTransaction"> | string
    status?: StringFilter<"AdminTransaction"> | string
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    expiredAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    customerEmail?: StringFilter<"AdminTransaction"> | string
    customerName?: StringFilter<"AdminTransaction"> | string
    customerId?: StringFilter<"AdminTransaction"> | string
    quantity?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    customer?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminTransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    customer?: AdminOrderByWithRelationInput
  }

  export type AdminTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    OR?: AdminTransactionWhereInput[]
    NOT?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    transactionName?: StringFilter<"AdminTransaction"> | string
    status?: StringFilter<"AdminTransaction"> | string
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    expiredAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    customerEmail?: StringFilter<"AdminTransaction"> | string
    customerName?: StringFilter<"AdminTransaction"> | string
    customerId?: StringFilter<"AdminTransaction"> | string
    quantity?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    customer?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    _count?: AdminTransactionCountOrderByAggregateInput
    _avg?: AdminTransactionAvgOrderByAggregateInput
    _max?: AdminTransactionMaxOrderByAggregateInput
    _min?: AdminTransactionMinOrderByAggregateInput
    _sum?: AdminTransactionSumOrderByAggregateInput
  }

  export type AdminTransactionScalarWhereWithAggregatesInput = {
    AND?: AdminTransactionScalarWhereWithAggregatesInput | AdminTransactionScalarWhereWithAggregatesInput[]
    OR?: AdminTransactionScalarWhereWithAggregatesInput[]
    NOT?: AdminTransactionScalarWhereWithAggregatesInput | AdminTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminTransaction"> | string
    transactionName?: StringWithAggregatesFilter<"AdminTransaction"> | string
    status?: StringWithAggregatesFilter<"AdminTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    expiredAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    customerEmail?: StringWithAggregatesFilter<"AdminTransaction"> | string
    customerName?: StringWithAggregatesFilter<"AdminTransaction"> | string
    customerId?: StringWithAggregatesFilter<"AdminTransaction"> | string
    quantity?: IntWithAggregatesFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
  }

  export type AdminTransactionArchiveWhereInput = {
    AND?: AdminTransactionArchiveWhereInput | AdminTransactionArchiveWhereInput[]
    OR?: AdminTransactionArchiveWhereInput[]
    NOT?: AdminTransactionArchiveWhereInput | AdminTransactionArchiveWhereInput[]
    id?: StringFilter<"AdminTransactionArchive"> | string
    transactionName?: StringFilter<"AdminTransactionArchive"> | string
    status?: StringFilter<"AdminTransactionArchive"> | string
    createdAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    expiredAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    customerEmail?: StringFilter<"AdminTransactionArchive"> | string
    customerName?: StringFilter<"AdminTransactionArchive"> | string
    customerId?: StringFilter<"AdminTransactionArchive"> | string
    quantity?: IntFilter<"AdminTransactionArchive"> | number
    zones?: StringNullableListFilter<"AdminTransactionArchive">
    customer?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminTransactionArchiveOrderByWithRelationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    customer?: AdminOrderByWithRelationInput
  }

  export type AdminTransactionArchiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminTransactionArchiveWhereInput | AdminTransactionArchiveWhereInput[]
    OR?: AdminTransactionArchiveWhereInput[]
    NOT?: AdminTransactionArchiveWhereInput | AdminTransactionArchiveWhereInput[]
    transactionName?: StringFilter<"AdminTransactionArchive"> | string
    status?: StringFilter<"AdminTransactionArchive"> | string
    createdAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    expiredAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    customerEmail?: StringFilter<"AdminTransactionArchive"> | string
    customerName?: StringFilter<"AdminTransactionArchive"> | string
    customerId?: StringFilter<"AdminTransactionArchive"> | string
    quantity?: IntFilter<"AdminTransactionArchive"> | number
    zones?: StringNullableListFilter<"AdminTransactionArchive">
    customer?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminTransactionArchiveOrderByWithAggregationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    _count?: AdminTransactionArchiveCountOrderByAggregateInput
    _avg?: AdminTransactionArchiveAvgOrderByAggregateInput
    _max?: AdminTransactionArchiveMaxOrderByAggregateInput
    _min?: AdminTransactionArchiveMinOrderByAggregateInput
    _sum?: AdminTransactionArchiveSumOrderByAggregateInput
  }

  export type AdminTransactionArchiveScalarWhereWithAggregatesInput = {
    AND?: AdminTransactionArchiveScalarWhereWithAggregatesInput | AdminTransactionArchiveScalarWhereWithAggregatesInput[]
    OR?: AdminTransactionArchiveScalarWhereWithAggregatesInput[]
    NOT?: AdminTransactionArchiveScalarWhereWithAggregatesInput | AdminTransactionArchiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminTransactionArchive"> | string
    transactionName?: StringWithAggregatesFilter<"AdminTransactionArchive"> | string
    status?: StringWithAggregatesFilter<"AdminTransactionArchive"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminTransactionArchive"> | Date | string
    expiredAt?: DateTimeWithAggregatesFilter<"AdminTransactionArchive"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminTransactionArchive"> | Date | string
    customerEmail?: StringWithAggregatesFilter<"AdminTransactionArchive"> | string
    customerName?: StringWithAggregatesFilter<"AdminTransactionArchive"> | string
    customerId?: StringWithAggregatesFilter<"AdminTransactionArchive"> | string
    quantity?: IntWithAggregatesFilter<"AdminTransactionArchive"> | number
    zones?: StringNullableListFilter<"AdminTransactionArchive">
  }

  export type UserTransactionWhereInput = {
    AND?: UserTransactionWhereInput | UserTransactionWhereInput[]
    OR?: UserTransactionWhereInput[]
    NOT?: UserTransactionWhereInput | UserTransactionWhereInput[]
    id?: StringFilter<"UserTransaction"> | string
    transactionName?: StringFilter<"UserTransaction"> | string
    status?: StringFilter<"UserTransaction"> | string
    createdAt?: DateTimeFilter<"UserTransaction"> | Date | string
    expiredAt?: DateTimeFilter<"UserTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"UserTransaction"> | Date | string
    customerEmail?: StringFilter<"UserTransaction"> | string
    customerName?: StringFilter<"UserTransaction"> | string
    customerId?: StringFilter<"UserTransaction"> | string
    quantity?: IntFilter<"UserTransaction"> | number
    zones?: StringNullableListFilter<"UserTransaction">
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserTransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    customer?: UserOrderByWithRelationInput
  }

  export type UserTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserTransactionWhereInput | UserTransactionWhereInput[]
    OR?: UserTransactionWhereInput[]
    NOT?: UserTransactionWhereInput | UserTransactionWhereInput[]
    transactionName?: StringFilter<"UserTransaction"> | string
    status?: StringFilter<"UserTransaction"> | string
    createdAt?: DateTimeFilter<"UserTransaction"> | Date | string
    expiredAt?: DateTimeFilter<"UserTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"UserTransaction"> | Date | string
    customerEmail?: StringFilter<"UserTransaction"> | string
    customerName?: StringFilter<"UserTransaction"> | string
    customerId?: StringFilter<"UserTransaction"> | string
    quantity?: IntFilter<"UserTransaction"> | number
    zones?: StringNullableListFilter<"UserTransaction">
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    _count?: UserTransactionCountOrderByAggregateInput
    _avg?: UserTransactionAvgOrderByAggregateInput
    _max?: UserTransactionMaxOrderByAggregateInput
    _min?: UserTransactionMinOrderByAggregateInput
    _sum?: UserTransactionSumOrderByAggregateInput
  }

  export type UserTransactionScalarWhereWithAggregatesInput = {
    AND?: UserTransactionScalarWhereWithAggregatesInput | UserTransactionScalarWhereWithAggregatesInput[]
    OR?: UserTransactionScalarWhereWithAggregatesInput[]
    NOT?: UserTransactionScalarWhereWithAggregatesInput | UserTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTransaction"> | string
    transactionName?: StringWithAggregatesFilter<"UserTransaction"> | string
    status?: StringWithAggregatesFilter<"UserTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTransaction"> | Date | string
    expiredAt?: DateTimeWithAggregatesFilter<"UserTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTransaction"> | Date | string
    customerEmail?: StringWithAggregatesFilter<"UserTransaction"> | string
    customerName?: StringWithAggregatesFilter<"UserTransaction"> | string
    customerId?: StringWithAggregatesFilter<"UserTransaction"> | string
    quantity?: IntWithAggregatesFilter<"UserTransaction"> | number
    zones?: StringNullableListFilter<"UserTransaction">
  }

  export type UserTransactionArchiveWhereInput = {
    AND?: UserTransactionArchiveWhereInput | UserTransactionArchiveWhereInput[]
    OR?: UserTransactionArchiveWhereInput[]
    NOT?: UserTransactionArchiveWhereInput | UserTransactionArchiveWhereInput[]
    id?: StringFilter<"UserTransactionArchive"> | string
    transactionName?: StringFilter<"UserTransactionArchive"> | string
    status?: StringFilter<"UserTransactionArchive"> | string
    createdAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    expiredAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    updatedAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    customerEmail?: StringFilter<"UserTransactionArchive"> | string
    customerName?: StringFilter<"UserTransactionArchive"> | string
    customerId?: StringFilter<"UserTransactionArchive"> | string
    quantity?: IntFilter<"UserTransactionArchive"> | number
    zones?: StringNullableListFilter<"UserTransactionArchive">
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserTransactionArchiveOrderByWithRelationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    customer?: UserOrderByWithRelationInput
  }

  export type UserTransactionArchiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserTransactionArchiveWhereInput | UserTransactionArchiveWhereInput[]
    OR?: UserTransactionArchiveWhereInput[]
    NOT?: UserTransactionArchiveWhereInput | UserTransactionArchiveWhereInput[]
    transactionName?: StringFilter<"UserTransactionArchive"> | string
    status?: StringFilter<"UserTransactionArchive"> | string
    createdAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    expiredAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    updatedAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    customerEmail?: StringFilter<"UserTransactionArchive"> | string
    customerName?: StringFilter<"UserTransactionArchive"> | string
    customerId?: StringFilter<"UserTransactionArchive"> | string
    quantity?: IntFilter<"UserTransactionArchive"> | number
    zones?: StringNullableListFilter<"UserTransactionArchive">
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserTransactionArchiveOrderByWithAggregationInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    _count?: UserTransactionArchiveCountOrderByAggregateInput
    _avg?: UserTransactionArchiveAvgOrderByAggregateInput
    _max?: UserTransactionArchiveMaxOrderByAggregateInput
    _min?: UserTransactionArchiveMinOrderByAggregateInput
    _sum?: UserTransactionArchiveSumOrderByAggregateInput
  }

  export type UserTransactionArchiveScalarWhereWithAggregatesInput = {
    AND?: UserTransactionArchiveScalarWhereWithAggregatesInput | UserTransactionArchiveScalarWhereWithAggregatesInput[]
    OR?: UserTransactionArchiveScalarWhereWithAggregatesInput[]
    NOT?: UserTransactionArchiveScalarWhereWithAggregatesInput | UserTransactionArchiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTransactionArchive"> | string
    transactionName?: StringWithAggregatesFilter<"UserTransactionArchive"> | string
    status?: StringWithAggregatesFilter<"UserTransactionArchive"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTransactionArchive"> | Date | string
    expiredAt?: DateTimeWithAggregatesFilter<"UserTransactionArchive"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTransactionArchive"> | Date | string
    customerEmail?: StringWithAggregatesFilter<"UserTransactionArchive"> | string
    customerName?: StringWithAggregatesFilter<"UserTransactionArchive"> | string
    customerId?: StringWithAggregatesFilter<"UserTransactionArchive"> | string
    quantity?: IntWithAggregatesFilter<"UserTransactionArchive"> | number
    zones?: StringNullableListFilter<"UserTransactionArchive">
  }

  export type MultiplayerRoomWhereInput = {
    AND?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    OR?: MultiplayerRoomWhereInput[]
    NOT?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    id?: StringFilter<"MultiplayerRoom"> | string
    max?: IntFilter<"MultiplayerRoom"> | number
    gameplayId?: StringFilter<"MultiplayerRoom"> | string
    botOwner?: StringFilter<"MultiplayerRoom"> | string
    startedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    isStarted?: BoolFilter<"MultiplayerRoom"> | boolean
    isEnded?: BoolFilter<"MultiplayerRoom"> | boolean
    createdAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    updatedAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    members?: MultiPlayerMemberListRelationFilter
  }

  export type MultiplayerRoomOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: MultiPlayerMemberOrderByRelationAggregateInput
  }

  export type MultiplayerRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameplayId?: string
    AND?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    OR?: MultiplayerRoomWhereInput[]
    NOT?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    max?: IntFilter<"MultiplayerRoom"> | number
    botOwner?: StringFilter<"MultiplayerRoom"> | string
    startedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    isStarted?: BoolFilter<"MultiplayerRoom"> | boolean
    isEnded?: BoolFilter<"MultiplayerRoom"> | boolean
    createdAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    updatedAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    members?: MultiPlayerMemberListRelationFilter
  }, "id" | "gameplayId">

  export type MultiplayerRoomOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MultiplayerRoomCountOrderByAggregateInput
    _avg?: MultiplayerRoomAvgOrderByAggregateInput
    _max?: MultiplayerRoomMaxOrderByAggregateInput
    _min?: MultiplayerRoomMinOrderByAggregateInput
    _sum?: MultiplayerRoomSumOrderByAggregateInput
  }

  export type MultiplayerRoomScalarWhereWithAggregatesInput = {
    AND?: MultiplayerRoomScalarWhereWithAggregatesInput | MultiplayerRoomScalarWhereWithAggregatesInput[]
    OR?: MultiplayerRoomScalarWhereWithAggregatesInput[]
    NOT?: MultiplayerRoomScalarWhereWithAggregatesInput | MultiplayerRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultiplayerRoom"> | string
    max?: IntWithAggregatesFilter<"MultiplayerRoom"> | number
    gameplayId?: StringWithAggregatesFilter<"MultiplayerRoom"> | string
    botOwner?: StringWithAggregatesFilter<"MultiplayerRoom"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"MultiplayerRoom"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"MultiplayerRoom"> | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter<"MultiplayerRoom"> | Date | string | null
    isStarted?: BoolWithAggregatesFilter<"MultiplayerRoom"> | boolean
    isEnded?: BoolWithAggregatesFilter<"MultiplayerRoom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MultiplayerRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MultiplayerRoom"> | Date | string
  }

  export type MultiPlayerMemberWhereInput = {
    AND?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    OR?: MultiPlayerMemberWhereInput[]
    NOT?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    id?: StringFilter<"MultiPlayerMember"> | string
    roomId?: StringFilter<"MultiPlayerMember"> | string
    userId?: StringNullableFilter<"MultiPlayerMember"> | string | null
    point?: IntFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntFilter<"MultiPlayerMember"> | number
    isReady?: BoolFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MultiPlayerMember"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    room?: XOR<MultiplayerRoomScalarRelationFilter, MultiplayerRoomWhereInput>
  }

  export type MultiPlayerMemberOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrderInput | SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    user?: UserOrderByWithRelationInput
    room?: MultiplayerRoomOrderByWithRelationInput
  }

  export type MultiPlayerMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    OR?: MultiPlayerMemberWhereInput[]
    NOT?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    roomId?: StringFilter<"MultiPlayerMember"> | string
    userId?: StringNullableFilter<"MultiPlayerMember"> | string | null
    point?: IntFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntFilter<"MultiPlayerMember"> | number
    isReady?: BoolFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MultiPlayerMember"> | boolean
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    room?: XOR<MultiplayerRoomScalarRelationFilter, MultiplayerRoomWhereInput>
  }, "id">

  export type MultiPlayerMemberOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrderInput | SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    _count?: MultiPlayerMemberCountOrderByAggregateInput
    _avg?: MultiPlayerMemberAvgOrderByAggregateInput
    _max?: MultiPlayerMemberMaxOrderByAggregateInput
    _min?: MultiPlayerMemberMinOrderByAggregateInput
    _sum?: MultiPlayerMemberSumOrderByAggregateInput
  }

  export type MultiPlayerMemberScalarWhereWithAggregatesInput = {
    AND?: MultiPlayerMemberScalarWhereWithAggregatesInput | MultiPlayerMemberScalarWhereWithAggregatesInput[]
    OR?: MultiPlayerMemberScalarWhereWithAggregatesInput[]
    NOT?: MultiPlayerMemberScalarWhereWithAggregatesInput | MultiPlayerMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultiPlayerMember"> | string
    roomId?: StringWithAggregatesFilter<"MultiPlayerMember"> | string
    userId?: StringNullableWithAggregatesFilter<"MultiPlayerMember"> | string | null
    point?: IntWithAggregatesFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntWithAggregatesFilter<"MultiPlayerMember"> | number
    isReady?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
  }

  export type ProvinceCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProvinceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProvinceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessContentCreateInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedAccessesInput
    userAccesses?: UserCreateNestedManyWithoutUserAccessesInput
    redemeers?: UserCreateNestedManyWithoutRedeemedAccessesInput
  }

  export type AccessContentUncheckedCreateInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    ownerId?: string | null
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userAccesses?: UserUncheckedCreateNestedManyWithoutUserAccessesInput
    redemeers?: UserUncheckedCreateNestedManyWithoutRedeemedAccessesInput
  }

  export type AccessContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedAccessesNestedInput
    userAccesses?: UserUpdateManyWithoutUserAccessesNestedInput
    redemeers?: UserUpdateManyWithoutRedeemedAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAccesses?: UserUncheckedUpdateManyWithoutUserAccessesNestedInput
    redemeers?: UserUncheckedUpdateManyWithoutRedeemedAccessesNestedInput
  }

  export type AccessContentCreateManyInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    ownerId?: string | null
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCreateInput = {
    id?: string
    uuid: string
    model: string
    manufactur: string
    os: string
    ramSize: number
    gpuName: string
    cpuType: string
    cpuCores: number
    user: UserCreateNestedOneWithoutDeviceInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    uuid: string
    model: string
    manufactur: string
    os: string
    ramSize: number
    gpuName: string
    cpuType: string
    cpuCores: number
    userId: string
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufactur?: StringFieldUpdateOperationsInput | string
    os?: StringFieldUpdateOperationsInput | string
    ramSize?: IntFieldUpdateOperationsInput | number
    gpuName?: StringFieldUpdateOperationsInput | string
    cpuType?: StringFieldUpdateOperationsInput | string
    cpuCores?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufactur?: StringFieldUpdateOperationsInput | string
    os?: StringFieldUpdateOperationsInput | string
    ramSize?: IntFieldUpdateOperationsInput | number
    gpuName?: StringFieldUpdateOperationsInput | string
    cpuType?: StringFieldUpdateOperationsInput | string
    cpuCores?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCreateManyInput = {
    id?: string
    uuid: string
    model: string
    manufactur: string
    os: string
    ramSize: number
    gpuName: string
    cpuType: string
    cpuCores: number
    userId: string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufactur?: StringFieldUpdateOperationsInput | string
    os?: StringFieldUpdateOperationsInput | string
    ramSize?: IntFieldUpdateOperationsInput | number
    gpuName?: StringFieldUpdateOperationsInput | string
    cpuType?: StringFieldUpdateOperationsInput | string
    cpuCores?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufactur?: StringFieldUpdateOperationsInput | string
    os?: StringFieldUpdateOperationsInput | string
    ramSize?: IntFieldUpdateOperationsInput | number
    gpuName?: StringFieldUpdateOperationsInput | string
    cpuType?: StringFieldUpdateOperationsInput | string
    cpuCores?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ZoneCreateInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZonesInput
    levels?: LevelCreateNestedManyWithoutZoneInput
    gempo?: GempoCreateNestedOneWithoutZoneInput
    championship?: ChampionshipCreateNestedOneWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    zoneId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    levels?: LevelUncheckedCreateNestedManyWithoutZoneInput
    gempo?: GempoUncheckedCreateNestedOneWithoutZoneInput
    championship?: ChampionshipUncheckedCreateNestedOneWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZonesNestedInput
    levels?: LevelUpdateManyWithoutZoneNestedInput
    gempo?: GempoUpdateOneWithoutZoneNestedInput
    championship?: ChampionshipUpdateOneWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    levels?: LevelUncheckedUpdateManyWithoutZoneNestedInput
    gempo?: GempoUncheckedUpdateOneWithoutZoneNestedInput
    championship?: ChampionshipUncheckedUpdateOneWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    zoneId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelCreateInput = {
    id?: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutLevelsInput
    subLevels?: SubLevelCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    levelId: string
    zoneId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutLevelsNestedInput
    subLevels?: SubLevelUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subLevels?: SubLevelUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelCreateManyInput = {
    id?: string
    levelId: string
    zoneId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubLevelCreateInput = {
    id?: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level: LevelCreateNestedOneWithoutSubLevelsInput
    innerLevels?: InnerLevelCreateNestedManyWithoutSubLevelInput
  }

  export type SubLevelUncheckedCreateInput = {
    id?: string
    subLevelId: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutSubLevelInput
  }

  export type SubLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: LevelUpdateOneRequiredWithoutSubLevelsNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutSubLevelNestedInput
  }

  export type SubLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutSubLevelNestedInput
  }

  export type SubLevelCreateManyInput = {
    id?: string
    subLevelId: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelCreateInput = {
    id?: string
    innerLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subLevel: SubLevelCreateNestedOneWithoutInnerLevelsInput
  }

  export type InnerLevelUncheckedCreateInput = {
    id?: string
    innerLevelId: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subLevel?: SubLevelUpdateOneRequiredWithoutInnerLevelsNestedInput
  }

  export type InnerLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelCreateManyInput = {
    id?: string
    innerLevelId: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutGempoInput
    records?: GempoRecordCreateNestedManyWithoutGempoInput
  }

  export type GempoUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: GempoRecordUncheckedCreateNestedManyWithoutGempoInput
  }

  export type GempoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutGempoNestedInput
    records?: GempoRecordUpdateManyWithoutGempoNestedInput
  }

  export type GempoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: GempoRecordUncheckedUpdateManyWithoutGempoNestedInput
  }

  export type GempoCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutChampionshipInput
    records?: ChampionshipRecordCreateNestedManyWithoutChampionshipInput
  }

  export type ChampionshipUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: ChampionshipRecordUncheckedCreateNestedManyWithoutChampionshipInput
  }

  export type ChampionshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutChampionshipNestedInput
    records?: ChampionshipRecordUpdateManyWithoutChampionshipNestedInput
  }

  export type ChampionshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: ChampionshipRecordUncheckedUpdateManyWithoutChampionshipNestedInput
  }

  export type ChampionshipCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordCreateInput = {
    id?: string
    recordId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempo: GempoCreateNestedOneWithoutRecordsInput
  }

  export type GempoRecordUncheckedCreateInput = {
    id?: string
    recordId: string
    gempoId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempo?: GempoUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type GempoRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    gempoId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordCreateManyInput = {
    id?: string
    recordId: string
    gempoId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    gempoId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordCreateInput = {
    id?: string
    recordId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championship: ChampionshipCreateNestedOneWithoutRecordsInput
  }

  export type ChampionshipRecordUncheckedCreateInput = {
    id?: string
    recordId: string
    championshipId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championship?: ChampionshipUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type ChampionshipRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    championshipId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordCreateManyInput = {
    id?: string
    recordId: string
    championshipId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    championshipId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginCreateInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
    user: UserCreateNestedOneWithoutUserLoginInput
  }

  export type UserLoginUncheckedCreateInput = {
    id?: string
    userId: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserLoginNestedInput
  }

  export type UserLoginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginCreateManyInput = {
    id?: string
    userId: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOperationHistoryCreateInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    admin: AdminCreateNestedOneWithoutOperationHistoriesInput
    opAdmin: AdminCreateNestedOneWithoutOperationsInput
  }

  export type AdminOperationHistoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    admin?: AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput
    opAdmin?: AdminUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminAuthorityCreateInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityCreateManyInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type AdminAuthorityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminAuthorityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerCreateInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
    admin: AdminCreateNestedOneWithoutBannerInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerCreateManyInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerLocationCreateInput = {
    id?: string
    banner: BannerCreateNestedOneWithoutBannerLocationInput
    province: ProvinceCreateNestedOneWithoutBannerLocationInput
    cities?: CityCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateInput = {
    id?: string
    bannerId: string
    provinceId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: BannerUpdateOneRequiredWithoutBannerLocationNestedInput
    province?: ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput
    cities?: CityUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationCreateManyInput = {
    id?: string
    bannerId: string
    provinceId: string
  }

  export type BannerLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BannerLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerVisitorCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    banner: BannerCreateNestedOneWithoutVisitorsInput
    user: UserCreateNestedOneWithoutBannerVisitorInput
  }

  export type BannerVisitorUncheckedCreateInput = {
    id?: string
    bannerId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    banner?: BannerUpdateOneRequiredWithoutVisitorsNestedInput
    user?: UserUpdateOneRequiredWithoutBannerVisitorNestedInput
  }

  export type BannerVisitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorCreateManyInput = {
    id?: string
    bannerId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateInput = {
    id?: string
    name?: string
    category: $Enums.TestCategory
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    participants?: TestParticipantCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateInput = {
    id?: string
    name?: string
    category: $Enums.TestCategory
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    participants?: TestParticipantUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumTestCategoryFieldUpdateOperationsInput | $Enums.TestCategory
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: TestParticipantUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumTestCategoryFieldUpdateOperationsInput | $Enums.TestCategory
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: TestParticipantUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCreateManyInput = {
    id?: string
    name?: string
    category: $Enums.TestCategory
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
  }

  export type TestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumTestCategoryFieldUpdateOperationsInput | $Enums.TestCategory
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumTestCategoryFieldUpdateOperationsInput | $Enums.TestCategory
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestParticipantCreateInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTestParticipantInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateInput = {
    id?: string
    testId: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantCreateManyInput = {
    id?: string
    testId: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
  }

  export type TestParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantRecordCreateInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    participant: TestParticipantCreateNestedOneWithoutRecordsInput
    user: UserCreateNestedOneWithoutTestRecordsInput
  }

  export type TestParticipantRecordUncheckedCreateInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    participant?: TestParticipantUpdateOneRequiredWithoutRecordsNestedInput
    user?: UserUpdateOneRequiredWithoutTestRecordsNestedInput
  }

  export type TestParticipantRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateManyInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type BackgroundCreateInput = {
    id?: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackgroundUncheckedCreateInput = {
    id?: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackgroundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackgroundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackgroundCreateManyInput = {
    id?: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackgroundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackgroundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherCreateInput = {
    code: string
    quota?: number
    currentQuota?: number
    startedAt: Date | string
    endedAt?: Date | string | null
    type?: $Enums.VoucherType
    zones?: VoucherCreatezonesInput | string[]
    redemeers?: VoucherRedemeerCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: number
    code: string
    quota?: number
    currentQuota?: number
    startedAt: Date | string
    endedAt?: Date | string | null
    type?: $Enums.VoucherType
    zones?: VoucherCreatezonesInput | string[]
    redemeers?: VoucherRedemeerUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    zones?: VoucherUpdatezonesInput | string[]
    redemeers?: VoucherRedemeerUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    zones?: VoucherUpdatezonesInput | string[]
    redemeers?: VoucherRedemeerUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: number
    code: string
    quota?: number
    currentQuota?: number
    startedAt: Date | string
    endedAt?: Date | string | null
    type?: $Enums.VoucherType
    zones?: VoucherCreatezonesInput | string[]
  }

  export type VoucherUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    zones?: VoucherUpdatezonesInput | string[]
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    zones?: VoucherUpdatezonesInput | string[]
  }

  export type VoucherRedemeerCreateInput = {
    createdAt?: Date | string
    voucher: VoucherCreateNestedOneWithoutRedemeersInput
    user: UserCreateNestedOneWithoutVoucherRedemeerInput
  }

  export type VoucherRedemeerUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    voucherId: number
    userId: string
  }

  export type VoucherRedemeerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucher?: VoucherUpdateOneRequiredWithoutRedemeersNestedInput
    user?: UserUpdateOneRequiredWithoutVoucherRedemeerNestedInput
  }

  export type VoucherRedemeerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherRedemeerCreateManyInput = {
    id?: number
    createdAt?: Date | string
    voucherId: number
    userId: string
  }

  export type VoucherRedemeerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherRedemeerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminTransactionCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    customer: AdminCreateNestedOneWithoutAdminTransactionInput
  }

  export type AdminTransactionUncheckedCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
  }

  export type AdminTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    customer?: AdminUpdateOneRequiredWithoutAdminTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
  }

  export type AdminTransactionCreateManyInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
  }

  export type AdminTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
  }

  export type AdminTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
  }

  export type AdminTransactionArchiveCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionArchiveCreatezonesInput | string[]
    customer: AdminCreateNestedOneWithoutAdminTransactionArchiveInput
  }

  export type AdminTransactionArchiveUncheckedCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: AdminTransactionArchiveCreatezonesInput | string[]
  }

  export type AdminTransactionArchiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
    customer?: AdminUpdateOneRequiredWithoutAdminTransactionArchiveNestedInput
  }

  export type AdminTransactionArchiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
  }

  export type AdminTransactionArchiveCreateManyInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: AdminTransactionArchiveCreatezonesInput | string[]
  }

  export type AdminTransactionArchiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
  }

  export type AdminTransactionArchiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
  }

  export type UserTransactionCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionCreatezonesInput | string[]
    customer: UserCreateNestedOneWithoutUserTransactionInput
  }

  export type UserTransactionUncheckedCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: UserTransactionCreatezonesInput | string[]
  }

  export type UserTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
    customer?: UserUpdateOneRequiredWithoutUserTransactionNestedInput
  }

  export type UserTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
  }

  export type UserTransactionCreateManyInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: UserTransactionCreatezonesInput | string[]
  }

  export type UserTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
  }

  export type UserTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
  }

  export type UserTransactionArchiveCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionArchiveCreatezonesInput | string[]
    customer: UserCreateNestedOneWithoutUserTransactionArchiveInput
  }

  export type UserTransactionArchiveUncheckedCreateInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: UserTransactionArchiveCreatezonesInput | string[]
  }

  export type UserTransactionArchiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
    customer?: UserUpdateOneRequiredWithoutUserTransactionArchiveNestedInput
  }

  export type UserTransactionArchiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
  }

  export type UserTransactionArchiveCreateManyInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    customerId: string
    quantity?: number
    zones?: UserTransactionArchiveCreatezonesInput | string[]
  }

  export type UserTransactionArchiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
  }

  export type UserTransactionArchiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
  }

  export type MultiplayerRoomCreateInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MultiPlayerMemberCreateNestedManyWithoutRoomInput
  }

  export type MultiplayerRoomUncheckedCreateInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: MultiPlayerMemberUncheckedCreateNestedManyWithoutRoomInput
  }

  export type MultiplayerRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MultiPlayerMemberUpdateManyWithoutRoomNestedInput
  }

  export type MultiplayerRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MultiPlayerMemberUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type MultiplayerRoomCreateManyInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultiplayerRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiplayerRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiPlayerMemberCreateInput = {
    id?: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    user?: UserCreateNestedOneWithoutMultiPlayerMemberInput
    room: MultiplayerRoomCreateNestedOneWithoutMembersInput
  }

  export type MultiPlayerMemberUncheckedCreateInput = {
    id?: string
    roomId: string
    userId?: string | null
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutMultiPlayerMemberNestedInput
    room?: MultiplayerRoomUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MultiPlayerMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberCreateManyInput = {
    id?: string
    roomId: string
    userId?: string | null
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AdminAuthorityListRelationFilter = {
    every?: AdminAuthorityWhereInput
    some?: AdminAuthorityWhereInput
    none?: AdminAuthorityWhereInput
  }

  export type BannerLocationListRelationFilter = {
    every?: BannerLocationWhereInput
    some?: BannerLocationWhereInput
    none?: BannerLocationWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuthorityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type ProvinceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProvinceScalarRelationFilter = {
    is?: ProvinceWhereInput
    isNot?: ProvinceWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccessContentCountOrderByAggregateInput = {
    id?: SortOrder
    expired?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    ownerId?: SortOrder
    zones?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessContentAvgOrderByAggregateInput = {
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type AccessContentMaxOrderByAggregateInput = {
    id?: SortOrder
    expired?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessContentMinOrderByAggregateInput = {
    id?: SortOrder
    expired?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccessContentSumOrderByAggregateInput = {
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type AccessContentListRelationFilter = {
    every?: AccessContentWhereInput
    some?: AccessContentWhereInput
    none?: AccessContentWhereInput
  }

  export type CityNullableScalarRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type ProvinceNullableScalarRelationFilter = {
    is?: ProvinceWhereInput | null
    isNot?: ProvinceWhereInput | null
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type UserLoginListRelationFilter = {
    every?: UserLoginWhereInput
    some?: UserLoginWhereInput
    none?: UserLoginWhereInput
  }

  export type BannerVisitorListRelationFilter = {
    every?: BannerVisitorWhereInput
    some?: BannerVisitorWhereInput
    none?: BannerVisitorWhereInput
  }

  export type TestParticipantListRelationFilter = {
    every?: TestParticipantWhereInput
    some?: TestParticipantWhereInput
    none?: TestParticipantWhereInput
  }

  export type VoucherRedemeerListRelationFilter = {
    every?: VoucherRedemeerWhereInput
    some?: VoucherRedemeerWhereInput
    none?: VoucherRedemeerWhereInput
  }

  export type UserTransactionArchiveListRelationFilter = {
    every?: UserTransactionArchiveWhereInput
    some?: UserTransactionArchiveWhereInput
    none?: UserTransactionArchiveWhereInput
  }

  export type UserTransactionListRelationFilter = {
    every?: UserTransactionWhereInput
    some?: UserTransactionWhereInput
    none?: UserTransactionWhereInput
  }

  export type MultiPlayerMemberListRelationFilter = {
    every?: MultiPlayerMemberWhereInput
    some?: MultiPlayerMemberWhereInput
    none?: MultiPlayerMemberWhereInput
  }

  export type TestParticipantRecordListRelationFilter = {
    every?: TestParticipantRecordWhereInput
    some?: TestParticipantRecordWhereInput
    none?: TestParticipantRecordWhereInput
  }

  export type AccessContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerVisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherRedemeerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTransactionArchiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultiPlayerMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParticipantRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    storageId?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    grade?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    storageId?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    storageId?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    grade?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufactur?: SortOrder
    os?: SortOrder
    ramSize?: SortOrder
    gpuName?: SortOrder
    cpuType?: SortOrder
    cpuCores?: SortOrder
    userId?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    ramSize?: SortOrder
    cpuCores?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufactur?: SortOrder
    os?: SortOrder
    ramSize?: SortOrder
    gpuName?: SortOrder
    cpuType?: SortOrder
    cpuCores?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufactur?: SortOrder
    os?: SortOrder
    ramSize?: SortOrder
    gpuName?: SortOrder
    cpuType?: SortOrder
    cpuCores?: SortOrder
    userId?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    ramSize?: SortOrder
    cpuCores?: SortOrder
  }

  export type LevelListRelationFilter = {
    every?: LevelWhereInput
    some?: LevelWhereInput
    none?: LevelWhereInput
  }

  export type GempoNullableScalarRelationFilter = {
    is?: GempoWhereInput | null
    isNot?: GempoWhereInput | null
  }

  export type ChampionshipNullableScalarRelationFilter = {
    is?: ChampionshipWhereInput | null
    isNot?: ChampionshipWhereInput | null
  }

  export type LevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneUserIdZoneIdCompoundUniqueInput = {
    userId: string
    zoneId: string
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    zoneId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneScalarRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type SubLevelListRelationFilter = {
    every?: SubLevelWhereInput
    some?: SubLevelWhereInput
    none?: SubLevelWhereInput
  }

  export type SubLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelZoneIdLevelIdCompoundUniqueInput = {
    zoneId: string
    levelId: string
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    levelId?: SortOrder
    zoneId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    levelId?: SortOrder
    zoneId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    levelId?: SortOrder
    zoneId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelScalarRelationFilter = {
    is?: LevelWhereInput
    isNot?: LevelWhereInput
  }

  export type InnerLevelListRelationFilter = {
    every?: InnerLevelWhereInput
    some?: InnerLevelWhereInput
    none?: InnerLevelWhereInput
  }

  export type InnerLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubLevelLevelIdSubLevelIdCompoundUniqueInput = {
    levelId: string
    subLevelId: string
  }

  export type SubLevelCountOrderByAggregateInput = {
    id?: SortOrder
    subLevelId?: SortOrder
    levelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    subLevelId?: SortOrder
    levelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubLevelMinOrderByAggregateInput = {
    id?: SortOrder
    subLevelId?: SortOrder
    levelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubLevelScalarRelationFilter = {
    is?: SubLevelWhereInput
    isNot?: SubLevelWhereInput
  }

  export type InnerLevelSubLevelIdInnerLevelIdCompoundUniqueInput = {
    subLevelId: string
    innerLevelId: string
  }

  export type InnerLevelCountOrderByAggregateInput = {
    id?: SortOrder
    innerLevelId?: SortOrder
    subLevelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InnerLevelAvgOrderByAggregateInput = {
    point?: SortOrder
    played?: SortOrder
  }

  export type InnerLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    innerLevelId?: SortOrder
    subLevelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InnerLevelMinOrderByAggregateInput = {
    id?: SortOrder
    innerLevelId?: SortOrder
    subLevelId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InnerLevelSumOrderByAggregateInput = {
    point?: SortOrder
    played?: SortOrder
  }

  export type GempoRecordListRelationFilter = {
    every?: GempoRecordWhereInput
    some?: GempoRecordWhereInput
    none?: GempoRecordWhereInput
  }

  export type GempoRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GempoZoneIdGempoIdCompoundUniqueInput = {
    zoneId: string
    gempoId: string
  }

  export type GempoCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    gempoId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GempoMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    gempoId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GempoMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    gempoId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChampionshipRecordListRelationFilter = {
    every?: ChampionshipRecordWhereInput
    some?: ChampionshipRecordWhereInput
    none?: ChampionshipRecordWhereInput
  }

  export type ChampionshipRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChampionshipZoneIdChampionshipIdCompoundUniqueInput = {
    zoneId: string
    championshipId: string
  }

  export type ChampionshipCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    championshipId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChampionshipMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    championshipId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChampionshipMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    championshipId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GempoScalarRelationFilter = {
    is?: GempoWhereInput
    isNot?: GempoWhereInput
  }

  export type GempoRecordGempoIdRecordIdCompoundUniqueInput = {
    gempoId: string
    recordId: string
  }

  export type GempoRecordCountOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    gempoId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GempoRecordAvgOrderByAggregateInput = {
    played?: SortOrder
    point?: SortOrder
  }

  export type GempoRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    gempoId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GempoRecordMinOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    gempoId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GempoRecordSumOrderByAggregateInput = {
    played?: SortOrder
    point?: SortOrder
  }

  export type ChampionshipScalarRelationFilter = {
    is?: ChampionshipWhereInput
    isNot?: ChampionshipWhereInput
  }

  export type ChampionshipRecordChampionshipIdRecordIdCompoundUniqueInput = {
    championshipId: string
    recordId: string
  }

  export type ChampionshipRecordCountOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    championshipId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChampionshipRecordAvgOrderByAggregateInput = {
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
  }

  export type ChampionshipRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    championshipId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChampionshipRecordMinOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    championshipId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChampionshipRecordSumOrderByAggregateInput = {
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
  }

  export type UserLoginCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type UserLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type UserLoginMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type AdminOperationHistoryListRelationFilter = {
    every?: AdminOperationHistoryWhereInput
    some?: AdminOperationHistoryWhereInput
    none?: AdminOperationHistoryWhereInput
  }

  export type BannerListRelationFilter = {
    every?: BannerWhereInput
    some?: BannerWhereInput
    none?: BannerWhereInput
  }

  export type AdminTransactionListRelationFilter = {
    every?: AdminTransactionWhereInput
    some?: AdminTransactionWhereInput
    none?: AdminTransactionWhereInput
  }

  export type AdminTransactionArchiveListRelationFilter = {
    every?: AdminTransactionArchiveWhereInput
    some?: AdminTransactionArchiveWhereInput
    none?: AdminTransactionArchiveWhereInput
  }

  export type AdminOperationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminTransactionArchiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type EnumOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationFilter<$PrismaModel> | $Enums.Operation
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AdminOperationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type AdminOperationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type AdminOperationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type EnumOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationWithAggregatesFilter<$PrismaModel> | $Enums.Operation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationFilter<$PrismaModel>
    _max?: NestedEnumOperationFilter<$PrismaModel>
  }

  export type AdminAuthorityCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
  }

  export type AdminAuthorityAvgOrderByAggregateInput = {
    grades?: SortOrder
  }

  export type AdminAuthorityMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
  }

  export type AdminAuthorityMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
  }

  export type AdminAuthoritySumOrderByAggregateInput = {
    grades?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
  }

  export type BannerScalarRelationFilter = {
    is?: BannerWhereInput
    isNot?: BannerWhereInput
  }

  export type BannerLocationCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
  }

  export type BannerLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
  }

  export type BannerLocationMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
  }

  export type BannerVisitorCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorAvgOrderByAggregateInput = {
    traffic?: SortOrder
  }

  export type BannerVisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorSumOrderByAggregateInput = {
    traffic?: SortOrder
  }

  export type EnumTestCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCategory | EnumTestCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCategoryFilter<$PrismaModel> | $Enums.TestCategory
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type EnumTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeFilter<$PrismaModel> | $Enums.TestType
  }

  export type TestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type EnumTestCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCategory | EnumTestCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TestCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestCategoryFilter<$PrismaModel>
    _max?: NestedEnumTestCategoryFilter<$PrismaModel>
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type EnumTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.TestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestTypeFilter<$PrismaModel>
    _max?: NestedEnumTestTypeFilter<$PrismaModel>
  }

  export type TestScalarRelationFilter = {
    is?: TestWhereInput
    isNot?: TestWhereInput
  }

  export type TestParticipantTestIdUserIdCompoundUniqueInput = {
    testId: string
    userId: string
  }

  export type TestParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrder
    lastTestAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
  }

  export type TestParticipantAvgOrderByAggregateInput = {
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
  }

  export type TestParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrder
    lastTestAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
  }

  export type TestParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrder
    lastTestAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
  }

  export type TestParticipantSumOrderByAggregateInput = {
    highscore?: SortOrder
    average?: SortOrder
    lowscore?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TestParticipantScalarRelationFilter = {
    is?: TestParticipantWhereInput
    isNot?: TestParticipantWhereInput
  }

  export type TestParticipantRecordCountOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    answers?: SortOrder
  }

  export type TestParticipantRecordAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TestParticipantRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TestParticipantRecordMinOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TestParticipantRecordSumOrderByAggregateInput = {
    score?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BackgroundCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackgroundMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackgroundMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    type?: SortOrder
    zones?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    type?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    type?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    id?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type EnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type VoucherScalarRelationFilter = {
    is?: VoucherWhereInput
    isNot?: VoucherWhereInput
  }

  export type VoucherRedemeerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
  }

  export type VoucherRedemeerAvgOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
  }

  export type VoucherRedemeerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
  }

  export type VoucherRedemeerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
  }

  export type VoucherRedemeerSumOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
  }

  export type AdminTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
  }

  export type AdminTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AdminTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type AdminTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type AdminTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AdminTransactionArchiveCountOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
  }

  export type AdminTransactionArchiveAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AdminTransactionArchiveMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type AdminTransactionArchiveMinOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type AdminTransactionArchiveSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
  }

  export type UserTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type UserTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type UserTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserTransactionArchiveCountOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
  }

  export type UserTransactionArchiveAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserTransactionArchiveMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type UserTransactionArchiveMinOrderByAggregateInput = {
    id?: SortOrder
    transactionName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    updatedAt?: SortOrder
    customerEmail?: SortOrder
    customerName?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
  }

  export type UserTransactionArchiveSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type MultiplayerRoomCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultiplayerRoomAvgOrderByAggregateInput = {
    max?: SortOrder
  }

  export type MultiplayerRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultiplayerRoomMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultiplayerRoomSumOrderByAggregateInput = {
    max?: SortOrder
  }

  export type MultiplayerRoomScalarRelationFilter = {
    is?: MultiplayerRoomWhereInput
    isNot?: MultiplayerRoomWhereInput
  }

  export type MultiPlayerMemberCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MultiPlayerMemberAvgOrderByAggregateInput = {
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type MultiPlayerMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MultiPlayerMemberMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MultiPlayerMemberSumOrderByAggregateInput = {
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type CityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationCreateNestedManyWithoutProvinceInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CityUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutProvinceInput | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutProvinceInput | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: CityUpdateManyWithWhereWithoutProvinceInput | CityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutProvinceInput | SchoolUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutProvinceInput | SchoolUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutProvinceInput | SchoolUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProvinceInput | UserUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProvinceInput | UserUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProvinceInput | UserUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutProvinceInput | AdminAuthorityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutProvinceInput | BannerLocationUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutProvinceInput | BannerLocationUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutProvinceInput | BannerLocationUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutProvinceInput | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutProvinceInput | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: CityUpdateManyWithWhereWithoutProvinceInput | CityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutProvinceInput | SchoolUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutProvinceInput | SchoolUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutProvinceInput | SchoolUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProvinceInput | UserUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProvinceInput | UserUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProvinceInput | UserUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutProvinceInput | AdminAuthorityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutProvinceInput | BannerLocationUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutProvinceInput | BannerLocationUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutProvinceInput | BannerLocationUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type ProvinceCreateNestedOneWithoutCitiesInput = {
    create?: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCitiesInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutCityInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutCitiesInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationCreateNestedManyWithoutCitiesInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type ProvinceUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCitiesInput
    upsert?: ProvinceUpsertWithoutCitiesInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutCitiesInput, ProvinceUpdateWithoutCitiesInput>, ProvinceUncheckedUpdateWithoutCitiesInput>
  }

  export type SchoolUpdateManyWithoutCityNestedInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCityInput | SchoolUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCityInput | SchoolUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCityInput | SchoolUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutCitiesInput | AdminAuthorityUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutCitiesInput | BannerLocationUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutCitiesInput | BannerLocationUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutCitiesInput | BannerLocationUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCityInput | SchoolUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCityInput | SchoolUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCityInput | SchoolUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutCitiesInput | AdminAuthorityUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutCitiesInput | BannerLocationUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutCitiesInput | BannerLocationUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutCitiesInput | BannerLocationUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolsInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSchoolsInput
    connect?: ProvinceWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolsInput
    upsert?: CityUpsertWithoutSchoolsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutSchoolsInput, CityUpdateWithoutSchoolsInput>, CityUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProvinceUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSchoolsInput
    upsert?: ProvinceUpsertWithoutSchoolsInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutSchoolsInput, ProvinceUpdateWithoutSchoolsInput>, ProvinceUncheckedUpdateWithoutSchoolsInput>
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput | AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput | AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AccessContentCreatezonesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOwnedAccessesInput = {
    create?: XOR<UserCreateWithoutOwnedAccessesInput, UserUncheckedCreateWithoutOwnedAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAccessesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutUserAccessesInput = {
    create?: XOR<UserCreateWithoutUserAccessesInput, UserUncheckedCreateWithoutUserAccessesInput> | UserCreateWithoutUserAccessesInput[] | UserUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserAccessesInput | UserCreateOrConnectWithoutUserAccessesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRedeemedAccessesInput = {
    create?: XOR<UserCreateWithoutRedeemedAccessesInput, UserUncheckedCreateWithoutRedeemedAccessesInput> | UserCreateWithoutRedeemedAccessesInput[] | UserUncheckedCreateWithoutRedeemedAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedAccessesInput | UserCreateOrConnectWithoutRedeemedAccessesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUserAccessesInput = {
    create?: XOR<UserCreateWithoutUserAccessesInput, UserUncheckedCreateWithoutUserAccessesInput> | UserCreateWithoutUserAccessesInput[] | UserUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserAccessesInput | UserCreateOrConnectWithoutUserAccessesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRedeemedAccessesInput = {
    create?: XOR<UserCreateWithoutRedeemedAccessesInput, UserUncheckedCreateWithoutRedeemedAccessesInput> | UserCreateWithoutRedeemedAccessesInput[] | UserUncheckedCreateWithoutRedeemedAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedAccessesInput | UserCreateOrConnectWithoutRedeemedAccessesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccessContentUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutOwnedAccessesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedAccessesInput, UserUncheckedCreateWithoutOwnedAccessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAccessesInput
    upsert?: UserUpsertWithoutOwnedAccessesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedAccessesInput, UserUpdateWithoutOwnedAccessesInput>, UserUncheckedUpdateWithoutOwnedAccessesInput>
  }

  export type UserUpdateManyWithoutUserAccessesNestedInput = {
    create?: XOR<UserCreateWithoutUserAccessesInput, UserUncheckedCreateWithoutUserAccessesInput> | UserCreateWithoutUserAccessesInput[] | UserUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserAccessesInput | UserCreateOrConnectWithoutUserAccessesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserAccessesInput | UserUpsertWithWhereUniqueWithoutUserAccessesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserAccessesInput | UserUpdateWithWhereUniqueWithoutUserAccessesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserAccessesInput | UserUpdateManyWithWhereWithoutUserAccessesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRedeemedAccessesNestedInput = {
    create?: XOR<UserCreateWithoutRedeemedAccessesInput, UserUncheckedCreateWithoutRedeemedAccessesInput> | UserCreateWithoutRedeemedAccessesInput[] | UserUncheckedCreateWithoutRedeemedAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedAccessesInput | UserCreateOrConnectWithoutRedeemedAccessesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRedeemedAccessesInput | UserUpsertWithWhereUniqueWithoutRedeemedAccessesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRedeemedAccessesInput | UserUpdateWithWhereUniqueWithoutRedeemedAccessesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRedeemedAccessesInput | UserUpdateManyWithWhereWithoutRedeemedAccessesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUncheckedUpdateManyWithoutUserAccessesNestedInput = {
    create?: XOR<UserCreateWithoutUserAccessesInput, UserUncheckedCreateWithoutUserAccessesInput> | UserCreateWithoutUserAccessesInput[] | UserUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserAccessesInput | UserCreateOrConnectWithoutUserAccessesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserAccessesInput | UserUpsertWithWhereUniqueWithoutUserAccessesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserAccessesInput | UserUpdateWithWhereUniqueWithoutUserAccessesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserAccessesInput | UserUpdateManyWithWhereWithoutUserAccessesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRedeemedAccessesNestedInput = {
    create?: XOR<UserCreateWithoutRedeemedAccessesInput, UserUncheckedCreateWithoutRedeemedAccessesInput> | UserCreateWithoutRedeemedAccessesInput[] | UserUncheckedCreateWithoutRedeemedAccessesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedAccessesInput | UserCreateOrConnectWithoutRedeemedAccessesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRedeemedAccessesInput | UserUpsertWithWhereUniqueWithoutRedeemedAccessesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRedeemedAccessesInput | UserUpdateWithWhereUniqueWithoutRedeemedAccessesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRedeemedAccessesInput | UserUpdateManyWithWhereWithoutRedeemedAccessesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateinventoryInput = {
    set: number[]
  }

  export type DeviceCreateNestedOneWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput
    connect?: DeviceWhereUniqueInput
  }

  export type AccessContentCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AccessContentCreateWithoutOwnerInput, AccessContentUncheckedCreateWithoutOwnerInput> | AccessContentCreateWithoutOwnerInput[] | AccessContentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutOwnerInput | AccessContentCreateOrConnectWithoutOwnerInput[]
    createMany?: AccessContentCreateManyOwnerInputEnvelope
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUsersInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type AccessContentCreateNestedManyWithoutUserAccessesInput = {
    create?: XOR<AccessContentCreateWithoutUserAccessesInput, AccessContentUncheckedCreateWithoutUserAccessesInput> | AccessContentCreateWithoutUserAccessesInput[] | AccessContentUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutUserAccessesInput | AccessContentCreateOrConnectWithoutUserAccessesInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
  }

  export type ZoneCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type AccessContentCreateNestedManyWithoutRedemeersInput = {
    create?: XOR<AccessContentCreateWithoutRedemeersInput, AccessContentUncheckedCreateWithoutRedemeersInput> | AccessContentCreateWithoutRedemeersInput[] | AccessContentUncheckedCreateWithoutRedemeersInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutRedemeersInput | AccessContentCreateOrConnectWithoutRedemeersInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
  }

  export type UserLoginCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
  }

  export type BannerVisitorCreateNestedManyWithoutUserInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type TestParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type VoucherRedemeerCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherRedemeerCreateWithoutUserInput, VoucherRedemeerUncheckedCreateWithoutUserInput> | VoucherRedemeerCreateWithoutUserInput[] | VoucherRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutUserInput | VoucherRedemeerCreateOrConnectWithoutUserInput[]
    createMany?: VoucherRedemeerCreateManyUserInputEnvelope
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
  }

  export type UserTransactionArchiveCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserTransactionArchiveCreateWithoutCustomerInput, UserTransactionArchiveUncheckedCreateWithoutCustomerInput> | UserTransactionArchiveCreateWithoutCustomerInput[] | UserTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionArchiveCreateOrConnectWithoutCustomerInput | UserTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    createMany?: UserTransactionArchiveCreateManyCustomerInputEnvelope
    connect?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
  }

  export type UserTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserTransactionCreateWithoutCustomerInput, UserTransactionUncheckedCreateWithoutCustomerInput> | UserTransactionCreateWithoutCustomerInput[] | UserTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionCreateOrConnectWithoutCustomerInput | UserTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: UserTransactionCreateManyCustomerInputEnvelope
    connect?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
  }

  export type MultiPlayerMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type TestParticipantRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantRecordCreateWithoutUserInput, TestParticipantRecordUncheckedCreateWithoutUserInput> | TestParticipantRecordCreateWithoutUserInput[] | TestParticipantRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutUserInput | TestParticipantRecordCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantRecordCreateManyUserInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput
    connect?: DeviceWhereUniqueInput
  }

  export type AccessContentUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AccessContentCreateWithoutOwnerInput, AccessContentUncheckedCreateWithoutOwnerInput> | AccessContentCreateWithoutOwnerInput[] | AccessContentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutOwnerInput | AccessContentCreateOrConnectWithoutOwnerInput[]
    createMany?: AccessContentCreateManyOwnerInputEnvelope
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
  }

  export type AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput = {
    create?: XOR<AccessContentCreateWithoutUserAccessesInput, AccessContentUncheckedCreateWithoutUserAccessesInput> | AccessContentCreateWithoutUserAccessesInput[] | AccessContentUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutUserAccessesInput | AccessContentCreateOrConnectWithoutUserAccessesInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type AccessContentUncheckedCreateNestedManyWithoutRedemeersInput = {
    create?: XOR<AccessContentCreateWithoutRedemeersInput, AccessContentUncheckedCreateWithoutRedemeersInput> | AccessContentCreateWithoutRedemeersInput[] | AccessContentUncheckedCreateWithoutRedemeersInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutRedemeersInput | AccessContentCreateOrConnectWithoutRedemeersInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
  }

  export type UserLoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
  }

  export type BannerVisitorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type TestParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherRedemeerCreateWithoutUserInput, VoucherRedemeerUncheckedCreateWithoutUserInput> | VoucherRedemeerCreateWithoutUserInput[] | VoucherRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutUserInput | VoucherRedemeerCreateOrConnectWithoutUserInput[]
    createMany?: VoucherRedemeerCreateManyUserInputEnvelope
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
  }

  export type UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserTransactionArchiveCreateWithoutCustomerInput, UserTransactionArchiveUncheckedCreateWithoutCustomerInput> | UserTransactionArchiveCreateWithoutCustomerInput[] | UserTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionArchiveCreateOrConnectWithoutCustomerInput | UserTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    createMany?: UserTransactionArchiveCreateManyCustomerInputEnvelope
    connect?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
  }

  export type UserTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<UserTransactionCreateWithoutCustomerInput, UserTransactionUncheckedCreateWithoutCustomerInput> | UserTransactionCreateWithoutCustomerInput[] | UserTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionCreateOrConnectWithoutCustomerInput | UserTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: UserTransactionCreateManyCustomerInputEnvelope
    connect?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
  }

  export type MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantRecordCreateWithoutUserInput, TestParticipantRecordUncheckedCreateWithoutUserInput> | TestParticipantRecordCreateWithoutUserInput[] | TestParticipantRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutUserInput | TestParticipantRecordCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantRecordCreateManyUserInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateinventoryInput = {
    set?: number[]
    push?: number | number[]
  }

  export type DeviceUpdateOneWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput
    upsert?: DeviceUpsertWithoutUserInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutUserInput, DeviceUpdateWithoutUserInput>, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type AccessContentUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AccessContentCreateWithoutOwnerInput, AccessContentUncheckedCreateWithoutOwnerInput> | AccessContentCreateWithoutOwnerInput[] | AccessContentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutOwnerInput | AccessContentCreateOrConnectWithoutOwnerInput[]
    upsert?: AccessContentUpsertWithWhereUniqueWithoutOwnerInput | AccessContentUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AccessContentCreateManyOwnerInputEnvelope
    set?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    disconnect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    delete?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    update?: AccessContentUpdateWithWhereUniqueWithoutOwnerInput | AccessContentUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AccessContentUpdateManyWithWhereWithoutOwnerInput | AccessContentUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
  }

  export type CityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutUsersInput, CityUpdateWithoutUsersInput>, CityUncheckedUpdateWithoutUsersInput>
  }

  export type ProvinceUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUsersInput
    upsert?: ProvinceUpsertWithoutUsersInput
    disconnect?: ProvinceWhereInput | boolean
    delete?: ProvinceWhereInput | boolean
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutUsersInput, ProvinceUpdateWithoutUsersInput>, ProvinceUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AccessContentUpdateManyWithoutUserAccessesNestedInput = {
    create?: XOR<AccessContentCreateWithoutUserAccessesInput, AccessContentUncheckedCreateWithoutUserAccessesInput> | AccessContentCreateWithoutUserAccessesInput[] | AccessContentUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutUserAccessesInput | AccessContentCreateOrConnectWithoutUserAccessesInput[]
    upsert?: AccessContentUpsertWithWhereUniqueWithoutUserAccessesInput | AccessContentUpsertWithWhereUniqueWithoutUserAccessesInput[]
    set?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    disconnect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    delete?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    update?: AccessContentUpdateWithWhereUniqueWithoutUserAccessesInput | AccessContentUpdateWithWhereUniqueWithoutUserAccessesInput[]
    updateMany?: AccessContentUpdateManyWithWhereWithoutUserAccessesInput | AccessContentUpdateManyWithWhereWithoutUserAccessesInput[]
    deleteMany?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
  }

  export type ZoneUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUserInput | ZoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUserInput | ZoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUserInput | ZoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type AccessContentUpdateManyWithoutRedemeersNestedInput = {
    create?: XOR<AccessContentCreateWithoutRedemeersInput, AccessContentUncheckedCreateWithoutRedemeersInput> | AccessContentCreateWithoutRedemeersInput[] | AccessContentUncheckedCreateWithoutRedemeersInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutRedemeersInput | AccessContentCreateOrConnectWithoutRedemeersInput[]
    upsert?: AccessContentUpsertWithWhereUniqueWithoutRedemeersInput | AccessContentUpsertWithWhereUniqueWithoutRedemeersInput[]
    set?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    disconnect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    delete?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    update?: AccessContentUpdateWithWhereUniqueWithoutRedemeersInput | AccessContentUpdateWithWhereUniqueWithoutRedemeersInput[]
    updateMany?: AccessContentUpdateManyWithWhereWithoutRedemeersInput | AccessContentUpdateManyWithWhereWithoutRedemeersInput[]
    deleteMany?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
  }

  export type UserLoginUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginUpsertWithWhereUniqueWithoutUserInput | UserLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    set?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    disconnect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    delete?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    update?: UserLoginUpdateWithWhereUniqueWithoutUserInput | UserLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginUpdateManyWithWhereWithoutUserInput | UserLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
  }

  export type BannerVisitorUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutUserInput | BannerVisitorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutUserInput | BannerVisitorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutUserInput | BannerVisitorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type TestParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutUserInput | TestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutUserInput | TestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutUserInput | TestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type VoucherRedemeerUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherRedemeerCreateWithoutUserInput, VoucherRedemeerUncheckedCreateWithoutUserInput> | VoucherRedemeerCreateWithoutUserInput[] | VoucherRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutUserInput | VoucherRedemeerCreateOrConnectWithoutUserInput[]
    upsert?: VoucherRedemeerUpsertWithWhereUniqueWithoutUserInput | VoucherRedemeerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherRedemeerCreateManyUserInputEnvelope
    set?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    disconnect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    delete?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    update?: VoucherRedemeerUpdateWithWhereUniqueWithoutUserInput | VoucherRedemeerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherRedemeerUpdateManyWithWhereWithoutUserInput | VoucherRedemeerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherRedemeerScalarWhereInput | VoucherRedemeerScalarWhereInput[]
  }

  export type UserTransactionArchiveUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserTransactionArchiveCreateWithoutCustomerInput, UserTransactionArchiveUncheckedCreateWithoutCustomerInput> | UserTransactionArchiveCreateWithoutCustomerInput[] | UserTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionArchiveCreateOrConnectWithoutCustomerInput | UserTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    upsert?: UserTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput | UserTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserTransactionArchiveCreateManyCustomerInputEnvelope
    set?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    disconnect?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    delete?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    connect?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    update?: UserTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput | UserTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserTransactionArchiveUpdateManyWithWhereWithoutCustomerInput | UserTransactionArchiveUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserTransactionArchiveScalarWhereInput | UserTransactionArchiveScalarWhereInput[]
  }

  export type UserTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserTransactionCreateWithoutCustomerInput, UserTransactionUncheckedCreateWithoutCustomerInput> | UserTransactionCreateWithoutCustomerInput[] | UserTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionCreateOrConnectWithoutCustomerInput | UserTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: UserTransactionUpsertWithWhereUniqueWithoutCustomerInput | UserTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserTransactionCreateManyCustomerInputEnvelope
    set?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    disconnect?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    delete?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    connect?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    update?: UserTransactionUpdateWithWhereUniqueWithoutCustomerInput | UserTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserTransactionUpdateManyWithWhereWithoutCustomerInput | UserTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserTransactionScalarWhereInput | UserTransactionScalarWhereInput[]
  }

  export type MultiPlayerMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutUserInput | MultiPlayerMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type TestParticipantRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutUserInput, TestParticipantRecordUncheckedCreateWithoutUserInput> | TestParticipantRecordCreateWithoutUserInput[] | TestParticipantRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutUserInput | TestParticipantRecordCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutUserInput | TestParticipantRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantRecordCreateManyUserInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutUserInput | TestParticipantRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutUserInput | TestParticipantRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput
    upsert?: DeviceUpsertWithoutUserInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutUserInput, DeviceUpdateWithoutUserInput>, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type AccessContentUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AccessContentCreateWithoutOwnerInput, AccessContentUncheckedCreateWithoutOwnerInput> | AccessContentCreateWithoutOwnerInput[] | AccessContentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutOwnerInput | AccessContentCreateOrConnectWithoutOwnerInput[]
    upsert?: AccessContentUpsertWithWhereUniqueWithoutOwnerInput | AccessContentUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AccessContentCreateManyOwnerInputEnvelope
    set?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    disconnect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    delete?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    update?: AccessContentUpdateWithWhereUniqueWithoutOwnerInput | AccessContentUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AccessContentUpdateManyWithWhereWithoutOwnerInput | AccessContentUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
  }

  export type AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput = {
    create?: XOR<AccessContentCreateWithoutUserAccessesInput, AccessContentUncheckedCreateWithoutUserAccessesInput> | AccessContentCreateWithoutUserAccessesInput[] | AccessContentUncheckedCreateWithoutUserAccessesInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutUserAccessesInput | AccessContentCreateOrConnectWithoutUserAccessesInput[]
    upsert?: AccessContentUpsertWithWhereUniqueWithoutUserAccessesInput | AccessContentUpsertWithWhereUniqueWithoutUserAccessesInput[]
    set?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    disconnect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    delete?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    update?: AccessContentUpdateWithWhereUniqueWithoutUserAccessesInput | AccessContentUpdateWithWhereUniqueWithoutUserAccessesInput[]
    updateMany?: AccessContentUpdateManyWithWhereWithoutUserAccessesInput | AccessContentUpdateManyWithWhereWithoutUserAccessesInput[]
    deleteMany?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUserInput | ZoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUserInput | ZoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUserInput | ZoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput = {
    create?: XOR<AccessContentCreateWithoutRedemeersInput, AccessContentUncheckedCreateWithoutRedemeersInput> | AccessContentCreateWithoutRedemeersInput[] | AccessContentUncheckedCreateWithoutRedemeersInput[]
    connectOrCreate?: AccessContentCreateOrConnectWithoutRedemeersInput | AccessContentCreateOrConnectWithoutRedemeersInput[]
    upsert?: AccessContentUpsertWithWhereUniqueWithoutRedemeersInput | AccessContentUpsertWithWhereUniqueWithoutRedemeersInput[]
    set?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    disconnect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    delete?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    connect?: AccessContentWhereUniqueInput | AccessContentWhereUniqueInput[]
    update?: AccessContentUpdateWithWhereUniqueWithoutRedemeersInput | AccessContentUpdateWithWhereUniqueWithoutRedemeersInput[]
    updateMany?: AccessContentUpdateManyWithWhereWithoutRedemeersInput | AccessContentUpdateManyWithWhereWithoutRedemeersInput[]
    deleteMany?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
  }

  export type UserLoginUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginUpsertWithWhereUniqueWithoutUserInput | UserLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    set?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    disconnect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    delete?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    update?: UserLoginUpdateWithWhereUniqueWithoutUserInput | UserLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginUpdateManyWithWhereWithoutUserInput | UserLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
  }

  export type BannerVisitorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutUserInput | BannerVisitorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutUserInput | BannerVisitorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutUserInput | BannerVisitorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type TestParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutUserInput | TestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutUserInput | TestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutUserInput | TestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherRedemeerCreateWithoutUserInput, VoucherRedemeerUncheckedCreateWithoutUserInput> | VoucherRedemeerCreateWithoutUserInput[] | VoucherRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutUserInput | VoucherRedemeerCreateOrConnectWithoutUserInput[]
    upsert?: VoucherRedemeerUpsertWithWhereUniqueWithoutUserInput | VoucherRedemeerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherRedemeerCreateManyUserInputEnvelope
    set?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    disconnect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    delete?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    update?: VoucherRedemeerUpdateWithWhereUniqueWithoutUserInput | VoucherRedemeerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherRedemeerUpdateManyWithWhereWithoutUserInput | VoucherRedemeerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherRedemeerScalarWhereInput | VoucherRedemeerScalarWhereInput[]
  }

  export type UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserTransactionArchiveCreateWithoutCustomerInput, UserTransactionArchiveUncheckedCreateWithoutCustomerInput> | UserTransactionArchiveCreateWithoutCustomerInput[] | UserTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionArchiveCreateOrConnectWithoutCustomerInput | UserTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    upsert?: UserTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput | UserTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserTransactionArchiveCreateManyCustomerInputEnvelope
    set?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    disconnect?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    delete?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    connect?: UserTransactionArchiveWhereUniqueInput | UserTransactionArchiveWhereUniqueInput[]
    update?: UserTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput | UserTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserTransactionArchiveUpdateManyWithWhereWithoutCustomerInput | UserTransactionArchiveUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserTransactionArchiveScalarWhereInput | UserTransactionArchiveScalarWhereInput[]
  }

  export type UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<UserTransactionCreateWithoutCustomerInput, UserTransactionUncheckedCreateWithoutCustomerInput> | UserTransactionCreateWithoutCustomerInput[] | UserTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: UserTransactionCreateOrConnectWithoutCustomerInput | UserTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: UserTransactionUpsertWithWhereUniqueWithoutCustomerInput | UserTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: UserTransactionCreateManyCustomerInputEnvelope
    set?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    disconnect?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    delete?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    connect?: UserTransactionWhereUniqueInput | UserTransactionWhereUniqueInput[]
    update?: UserTransactionUpdateWithWhereUniqueWithoutCustomerInput | UserTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: UserTransactionUpdateManyWithWhereWithoutCustomerInput | UserTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: UserTransactionScalarWhereInput | UserTransactionScalarWhereInput[]
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutUserInput | MultiPlayerMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutUserInput, TestParticipantRecordUncheckedCreateWithoutUserInput> | TestParticipantRecordCreateWithoutUserInput[] | TestParticipantRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutUserInput | TestParticipantRecordCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutUserInput | TestParticipantRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantRecordCreateManyUserInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutUserInput | TestParticipantRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutUserInput | TestParticipantRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeviceInput = {
    create?: XOR<UserCreateWithoutDeviceInput, UserUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceNestedInput = {
    create?: XOR<UserCreateWithoutDeviceInput, UserUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceInput
    upsert?: UserUpsertWithoutDeviceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceInput, UserUpdateWithoutDeviceInput>, UserUncheckedUpdateWithoutDeviceInput>
  }

  export type UserCreateNestedOneWithoutZonesInput = {
    create?: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutZonesInput
    connect?: UserWhereUniqueInput
  }

  export type LevelCreateNestedManyWithoutZoneInput = {
    create?: XOR<LevelCreateWithoutZoneInput, LevelUncheckedCreateWithoutZoneInput> | LevelCreateWithoutZoneInput[] | LevelUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutZoneInput | LevelCreateOrConnectWithoutZoneInput[]
    createMany?: LevelCreateManyZoneInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type GempoCreateNestedOneWithoutZoneInput = {
    create?: XOR<GempoCreateWithoutZoneInput, GempoUncheckedCreateWithoutZoneInput>
    connectOrCreate?: GempoCreateOrConnectWithoutZoneInput
    connect?: GempoWhereUniqueInput
  }

  export type ChampionshipCreateNestedOneWithoutZoneInput = {
    create?: XOR<ChampionshipCreateWithoutZoneInput, ChampionshipUncheckedCreateWithoutZoneInput>
    connectOrCreate?: ChampionshipCreateOrConnectWithoutZoneInput
    connect?: ChampionshipWhereUniqueInput
  }

  export type LevelUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<LevelCreateWithoutZoneInput, LevelUncheckedCreateWithoutZoneInput> | LevelCreateWithoutZoneInput[] | LevelUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutZoneInput | LevelCreateOrConnectWithoutZoneInput[]
    createMany?: LevelCreateManyZoneInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type GempoUncheckedCreateNestedOneWithoutZoneInput = {
    create?: XOR<GempoCreateWithoutZoneInput, GempoUncheckedCreateWithoutZoneInput>
    connectOrCreate?: GempoCreateOrConnectWithoutZoneInput
    connect?: GempoWhereUniqueInput
  }

  export type ChampionshipUncheckedCreateNestedOneWithoutZoneInput = {
    create?: XOR<ChampionshipCreateWithoutZoneInput, ChampionshipUncheckedCreateWithoutZoneInput>
    connectOrCreate?: ChampionshipCreateOrConnectWithoutZoneInput
    connect?: ChampionshipWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutZonesInput
    upsert?: UserUpsertWithoutZonesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZonesInput, UserUpdateWithoutZonesInput>, UserUncheckedUpdateWithoutZonesInput>
  }

  export type LevelUpdateManyWithoutZoneNestedInput = {
    create?: XOR<LevelCreateWithoutZoneInput, LevelUncheckedCreateWithoutZoneInput> | LevelCreateWithoutZoneInput[] | LevelUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutZoneInput | LevelCreateOrConnectWithoutZoneInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutZoneInput | LevelUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: LevelCreateManyZoneInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutZoneInput | LevelUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutZoneInput | LevelUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type GempoUpdateOneWithoutZoneNestedInput = {
    create?: XOR<GempoCreateWithoutZoneInput, GempoUncheckedCreateWithoutZoneInput>
    connectOrCreate?: GempoCreateOrConnectWithoutZoneInput
    upsert?: GempoUpsertWithoutZoneInput
    disconnect?: GempoWhereInput | boolean
    delete?: GempoWhereInput | boolean
    connect?: GempoWhereUniqueInput
    update?: XOR<XOR<GempoUpdateToOneWithWhereWithoutZoneInput, GempoUpdateWithoutZoneInput>, GempoUncheckedUpdateWithoutZoneInput>
  }

  export type ChampionshipUpdateOneWithoutZoneNestedInput = {
    create?: XOR<ChampionshipCreateWithoutZoneInput, ChampionshipUncheckedCreateWithoutZoneInput>
    connectOrCreate?: ChampionshipCreateOrConnectWithoutZoneInput
    upsert?: ChampionshipUpsertWithoutZoneInput
    disconnect?: ChampionshipWhereInput | boolean
    delete?: ChampionshipWhereInput | boolean
    connect?: ChampionshipWhereUniqueInput
    update?: XOR<XOR<ChampionshipUpdateToOneWithWhereWithoutZoneInput, ChampionshipUpdateWithoutZoneInput>, ChampionshipUncheckedUpdateWithoutZoneInput>
  }

  export type LevelUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<LevelCreateWithoutZoneInput, LevelUncheckedCreateWithoutZoneInput> | LevelCreateWithoutZoneInput[] | LevelUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutZoneInput | LevelCreateOrConnectWithoutZoneInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutZoneInput | LevelUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: LevelCreateManyZoneInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutZoneInput | LevelUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutZoneInput | LevelUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type GempoUncheckedUpdateOneWithoutZoneNestedInput = {
    create?: XOR<GempoCreateWithoutZoneInput, GempoUncheckedCreateWithoutZoneInput>
    connectOrCreate?: GempoCreateOrConnectWithoutZoneInput
    upsert?: GempoUpsertWithoutZoneInput
    disconnect?: GempoWhereInput | boolean
    delete?: GempoWhereInput | boolean
    connect?: GempoWhereUniqueInput
    update?: XOR<XOR<GempoUpdateToOneWithWhereWithoutZoneInput, GempoUpdateWithoutZoneInput>, GempoUncheckedUpdateWithoutZoneInput>
  }

  export type ChampionshipUncheckedUpdateOneWithoutZoneNestedInput = {
    create?: XOR<ChampionshipCreateWithoutZoneInput, ChampionshipUncheckedCreateWithoutZoneInput>
    connectOrCreate?: ChampionshipCreateOrConnectWithoutZoneInput
    upsert?: ChampionshipUpsertWithoutZoneInput
    disconnect?: ChampionshipWhereInput | boolean
    delete?: ChampionshipWhereInput | boolean
    connect?: ChampionshipWhereUniqueInput
    update?: XOR<XOR<ChampionshipUpdateToOneWithWhereWithoutZoneInput, ChampionshipUpdateWithoutZoneInput>, ChampionshipUncheckedUpdateWithoutZoneInput>
  }

  export type ZoneCreateNestedOneWithoutLevelsInput = {
    create?: XOR<ZoneCreateWithoutLevelsInput, ZoneUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutLevelsInput
    connect?: ZoneWhereUniqueInput
  }

  export type SubLevelCreateNestedManyWithoutLevelInput = {
    create?: XOR<SubLevelCreateWithoutLevelInput, SubLevelUncheckedCreateWithoutLevelInput> | SubLevelCreateWithoutLevelInput[] | SubLevelUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutLevelInput | SubLevelCreateOrConnectWithoutLevelInput[]
    createMany?: SubLevelCreateManyLevelInputEnvelope
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
  }

  export type SubLevelUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<SubLevelCreateWithoutLevelInput, SubLevelUncheckedCreateWithoutLevelInput> | SubLevelCreateWithoutLevelInput[] | SubLevelUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutLevelInput | SubLevelCreateOrConnectWithoutLevelInput[]
    createMany?: SubLevelCreateManyLevelInputEnvelope
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
  }

  export type ZoneUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<ZoneCreateWithoutLevelsInput, ZoneUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutLevelsInput
    upsert?: ZoneUpsertWithoutLevelsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutLevelsInput, ZoneUpdateWithoutLevelsInput>, ZoneUncheckedUpdateWithoutLevelsInput>
  }

  export type SubLevelUpdateManyWithoutLevelNestedInput = {
    create?: XOR<SubLevelCreateWithoutLevelInput, SubLevelUncheckedCreateWithoutLevelInput> | SubLevelCreateWithoutLevelInput[] | SubLevelUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutLevelInput | SubLevelCreateOrConnectWithoutLevelInput[]
    upsert?: SubLevelUpsertWithWhereUniqueWithoutLevelInput | SubLevelUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: SubLevelCreateManyLevelInputEnvelope
    set?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    disconnect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    delete?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    update?: SubLevelUpdateWithWhereUniqueWithoutLevelInput | SubLevelUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: SubLevelUpdateManyWithWhereWithoutLevelInput | SubLevelUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
  }

  export type SubLevelUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<SubLevelCreateWithoutLevelInput, SubLevelUncheckedCreateWithoutLevelInput> | SubLevelCreateWithoutLevelInput[] | SubLevelUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutLevelInput | SubLevelCreateOrConnectWithoutLevelInput[]
    upsert?: SubLevelUpsertWithWhereUniqueWithoutLevelInput | SubLevelUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: SubLevelCreateManyLevelInputEnvelope
    set?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    disconnect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    delete?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    update?: SubLevelUpdateWithWhereUniqueWithoutLevelInput | SubLevelUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: SubLevelUpdateManyWithWhereWithoutLevelInput | SubLevelUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
  }

  export type LevelCreateNestedOneWithoutSubLevelsInput = {
    create?: XOR<LevelCreateWithoutSubLevelsInput, LevelUncheckedCreateWithoutSubLevelsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutSubLevelsInput
    connect?: LevelWhereUniqueInput
  }

  export type InnerLevelCreateNestedManyWithoutSubLevelInput = {
    create?: XOR<InnerLevelCreateWithoutSubLevelInput, InnerLevelUncheckedCreateWithoutSubLevelInput> | InnerLevelCreateWithoutSubLevelInput[] | InnerLevelUncheckedCreateWithoutSubLevelInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutSubLevelInput | InnerLevelCreateOrConnectWithoutSubLevelInput[]
    createMany?: InnerLevelCreateManySubLevelInputEnvelope
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
  }

  export type InnerLevelUncheckedCreateNestedManyWithoutSubLevelInput = {
    create?: XOR<InnerLevelCreateWithoutSubLevelInput, InnerLevelUncheckedCreateWithoutSubLevelInput> | InnerLevelCreateWithoutSubLevelInput[] | InnerLevelUncheckedCreateWithoutSubLevelInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutSubLevelInput | InnerLevelCreateOrConnectWithoutSubLevelInput[]
    createMany?: InnerLevelCreateManySubLevelInputEnvelope
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
  }

  export type LevelUpdateOneRequiredWithoutSubLevelsNestedInput = {
    create?: XOR<LevelCreateWithoutSubLevelsInput, LevelUncheckedCreateWithoutSubLevelsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutSubLevelsInput
    upsert?: LevelUpsertWithoutSubLevelsInput
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutSubLevelsInput, LevelUpdateWithoutSubLevelsInput>, LevelUncheckedUpdateWithoutSubLevelsInput>
  }

  export type InnerLevelUpdateManyWithoutSubLevelNestedInput = {
    create?: XOR<InnerLevelCreateWithoutSubLevelInput, InnerLevelUncheckedCreateWithoutSubLevelInput> | InnerLevelCreateWithoutSubLevelInput[] | InnerLevelUncheckedCreateWithoutSubLevelInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutSubLevelInput | InnerLevelCreateOrConnectWithoutSubLevelInput[]
    upsert?: InnerLevelUpsertWithWhereUniqueWithoutSubLevelInput | InnerLevelUpsertWithWhereUniqueWithoutSubLevelInput[]
    createMany?: InnerLevelCreateManySubLevelInputEnvelope
    set?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    disconnect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    delete?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    update?: InnerLevelUpdateWithWhereUniqueWithoutSubLevelInput | InnerLevelUpdateWithWhereUniqueWithoutSubLevelInput[]
    updateMany?: InnerLevelUpdateManyWithWhereWithoutSubLevelInput | InnerLevelUpdateManyWithWhereWithoutSubLevelInput[]
    deleteMany?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
  }

  export type InnerLevelUncheckedUpdateManyWithoutSubLevelNestedInput = {
    create?: XOR<InnerLevelCreateWithoutSubLevelInput, InnerLevelUncheckedCreateWithoutSubLevelInput> | InnerLevelCreateWithoutSubLevelInput[] | InnerLevelUncheckedCreateWithoutSubLevelInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutSubLevelInput | InnerLevelCreateOrConnectWithoutSubLevelInput[]
    upsert?: InnerLevelUpsertWithWhereUniqueWithoutSubLevelInput | InnerLevelUpsertWithWhereUniqueWithoutSubLevelInput[]
    createMany?: InnerLevelCreateManySubLevelInputEnvelope
    set?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    disconnect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    delete?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    update?: InnerLevelUpdateWithWhereUniqueWithoutSubLevelInput | InnerLevelUpdateWithWhereUniqueWithoutSubLevelInput[]
    updateMany?: InnerLevelUpdateManyWithWhereWithoutSubLevelInput | InnerLevelUpdateManyWithWhereWithoutSubLevelInput[]
    deleteMany?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
  }

  export type SubLevelCreateNestedOneWithoutInnerLevelsInput = {
    create?: XOR<SubLevelCreateWithoutInnerLevelsInput, SubLevelUncheckedCreateWithoutInnerLevelsInput>
    connectOrCreate?: SubLevelCreateOrConnectWithoutInnerLevelsInput
    connect?: SubLevelWhereUniqueInput
  }

  export type SubLevelUpdateOneRequiredWithoutInnerLevelsNestedInput = {
    create?: XOR<SubLevelCreateWithoutInnerLevelsInput, SubLevelUncheckedCreateWithoutInnerLevelsInput>
    connectOrCreate?: SubLevelCreateOrConnectWithoutInnerLevelsInput
    upsert?: SubLevelUpsertWithoutInnerLevelsInput
    connect?: SubLevelWhereUniqueInput
    update?: XOR<XOR<SubLevelUpdateToOneWithWhereWithoutInnerLevelsInput, SubLevelUpdateWithoutInnerLevelsInput>, SubLevelUncheckedUpdateWithoutInnerLevelsInput>
  }

  export type ZoneCreateNestedOneWithoutGempoInput = {
    create?: XOR<ZoneCreateWithoutGempoInput, ZoneUncheckedCreateWithoutGempoInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutGempoInput
    connect?: ZoneWhereUniqueInput
  }

  export type GempoRecordCreateNestedManyWithoutGempoInput = {
    create?: XOR<GempoRecordCreateWithoutGempoInput, GempoRecordUncheckedCreateWithoutGempoInput> | GempoRecordCreateWithoutGempoInput[] | GempoRecordUncheckedCreateWithoutGempoInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutGempoInput | GempoRecordCreateOrConnectWithoutGempoInput[]
    createMany?: GempoRecordCreateManyGempoInputEnvelope
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
  }

  export type GempoRecordUncheckedCreateNestedManyWithoutGempoInput = {
    create?: XOR<GempoRecordCreateWithoutGempoInput, GempoRecordUncheckedCreateWithoutGempoInput> | GempoRecordCreateWithoutGempoInput[] | GempoRecordUncheckedCreateWithoutGempoInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutGempoInput | GempoRecordCreateOrConnectWithoutGempoInput[]
    createMany?: GempoRecordCreateManyGempoInputEnvelope
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
  }

  export type ZoneUpdateOneRequiredWithoutGempoNestedInput = {
    create?: XOR<ZoneCreateWithoutGempoInput, ZoneUncheckedCreateWithoutGempoInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutGempoInput
    upsert?: ZoneUpsertWithoutGempoInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutGempoInput, ZoneUpdateWithoutGempoInput>, ZoneUncheckedUpdateWithoutGempoInput>
  }

  export type GempoRecordUpdateManyWithoutGempoNestedInput = {
    create?: XOR<GempoRecordCreateWithoutGempoInput, GempoRecordUncheckedCreateWithoutGempoInput> | GempoRecordCreateWithoutGempoInput[] | GempoRecordUncheckedCreateWithoutGempoInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutGempoInput | GempoRecordCreateOrConnectWithoutGempoInput[]
    upsert?: GempoRecordUpsertWithWhereUniqueWithoutGempoInput | GempoRecordUpsertWithWhereUniqueWithoutGempoInput[]
    createMany?: GempoRecordCreateManyGempoInputEnvelope
    set?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    disconnect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    delete?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    update?: GempoRecordUpdateWithWhereUniqueWithoutGempoInput | GempoRecordUpdateWithWhereUniqueWithoutGempoInput[]
    updateMany?: GempoRecordUpdateManyWithWhereWithoutGempoInput | GempoRecordUpdateManyWithWhereWithoutGempoInput[]
    deleteMany?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
  }

  export type GempoRecordUncheckedUpdateManyWithoutGempoNestedInput = {
    create?: XOR<GempoRecordCreateWithoutGempoInput, GempoRecordUncheckedCreateWithoutGempoInput> | GempoRecordCreateWithoutGempoInput[] | GempoRecordUncheckedCreateWithoutGempoInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutGempoInput | GempoRecordCreateOrConnectWithoutGempoInput[]
    upsert?: GempoRecordUpsertWithWhereUniqueWithoutGempoInput | GempoRecordUpsertWithWhereUniqueWithoutGempoInput[]
    createMany?: GempoRecordCreateManyGempoInputEnvelope
    set?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    disconnect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    delete?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    update?: GempoRecordUpdateWithWhereUniqueWithoutGempoInput | GempoRecordUpdateWithWhereUniqueWithoutGempoInput[]
    updateMany?: GempoRecordUpdateManyWithWhereWithoutGempoInput | GempoRecordUpdateManyWithWhereWithoutGempoInput[]
    deleteMany?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
  }

  export type ZoneCreateNestedOneWithoutChampionshipInput = {
    create?: XOR<ZoneCreateWithoutChampionshipInput, ZoneUncheckedCreateWithoutChampionshipInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutChampionshipInput
    connect?: ZoneWhereUniqueInput
  }

  export type ChampionshipRecordCreateNestedManyWithoutChampionshipInput = {
    create?: XOR<ChampionshipRecordCreateWithoutChampionshipInput, ChampionshipRecordUncheckedCreateWithoutChampionshipInput> | ChampionshipRecordCreateWithoutChampionshipInput[] | ChampionshipRecordUncheckedCreateWithoutChampionshipInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutChampionshipInput | ChampionshipRecordCreateOrConnectWithoutChampionshipInput[]
    createMany?: ChampionshipRecordCreateManyChampionshipInputEnvelope
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
  }

  export type ChampionshipRecordUncheckedCreateNestedManyWithoutChampionshipInput = {
    create?: XOR<ChampionshipRecordCreateWithoutChampionshipInput, ChampionshipRecordUncheckedCreateWithoutChampionshipInput> | ChampionshipRecordCreateWithoutChampionshipInput[] | ChampionshipRecordUncheckedCreateWithoutChampionshipInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutChampionshipInput | ChampionshipRecordCreateOrConnectWithoutChampionshipInput[]
    createMany?: ChampionshipRecordCreateManyChampionshipInputEnvelope
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
  }

  export type ZoneUpdateOneRequiredWithoutChampionshipNestedInput = {
    create?: XOR<ZoneCreateWithoutChampionshipInput, ZoneUncheckedCreateWithoutChampionshipInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutChampionshipInput
    upsert?: ZoneUpsertWithoutChampionshipInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutChampionshipInput, ZoneUpdateWithoutChampionshipInput>, ZoneUncheckedUpdateWithoutChampionshipInput>
  }

  export type ChampionshipRecordUpdateManyWithoutChampionshipNestedInput = {
    create?: XOR<ChampionshipRecordCreateWithoutChampionshipInput, ChampionshipRecordUncheckedCreateWithoutChampionshipInput> | ChampionshipRecordCreateWithoutChampionshipInput[] | ChampionshipRecordUncheckedCreateWithoutChampionshipInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutChampionshipInput | ChampionshipRecordCreateOrConnectWithoutChampionshipInput[]
    upsert?: ChampionshipRecordUpsertWithWhereUniqueWithoutChampionshipInput | ChampionshipRecordUpsertWithWhereUniqueWithoutChampionshipInput[]
    createMany?: ChampionshipRecordCreateManyChampionshipInputEnvelope
    set?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    disconnect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    delete?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    update?: ChampionshipRecordUpdateWithWhereUniqueWithoutChampionshipInput | ChampionshipRecordUpdateWithWhereUniqueWithoutChampionshipInput[]
    updateMany?: ChampionshipRecordUpdateManyWithWhereWithoutChampionshipInput | ChampionshipRecordUpdateManyWithWhereWithoutChampionshipInput[]
    deleteMany?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
  }

  export type ChampionshipRecordUncheckedUpdateManyWithoutChampionshipNestedInput = {
    create?: XOR<ChampionshipRecordCreateWithoutChampionshipInput, ChampionshipRecordUncheckedCreateWithoutChampionshipInput> | ChampionshipRecordCreateWithoutChampionshipInput[] | ChampionshipRecordUncheckedCreateWithoutChampionshipInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutChampionshipInput | ChampionshipRecordCreateOrConnectWithoutChampionshipInput[]
    upsert?: ChampionshipRecordUpsertWithWhereUniqueWithoutChampionshipInput | ChampionshipRecordUpsertWithWhereUniqueWithoutChampionshipInput[]
    createMany?: ChampionshipRecordCreateManyChampionshipInputEnvelope
    set?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    disconnect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    delete?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    update?: ChampionshipRecordUpdateWithWhereUniqueWithoutChampionshipInput | ChampionshipRecordUpdateWithWhereUniqueWithoutChampionshipInput[]
    updateMany?: ChampionshipRecordUpdateManyWithWhereWithoutChampionshipInput | ChampionshipRecordUpdateManyWithWhereWithoutChampionshipInput[]
    deleteMany?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
  }

  export type GempoCreateNestedOneWithoutRecordsInput = {
    create?: XOR<GempoCreateWithoutRecordsInput, GempoUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: GempoCreateOrConnectWithoutRecordsInput
    connect?: GempoWhereUniqueInput
  }

  export type GempoUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<GempoCreateWithoutRecordsInput, GempoUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: GempoCreateOrConnectWithoutRecordsInput
    upsert?: GempoUpsertWithoutRecordsInput
    connect?: GempoWhereUniqueInput
    update?: XOR<XOR<GempoUpdateToOneWithWhereWithoutRecordsInput, GempoUpdateWithoutRecordsInput>, GempoUncheckedUpdateWithoutRecordsInput>
  }

  export type ChampionshipCreateNestedOneWithoutRecordsInput = {
    create?: XOR<ChampionshipCreateWithoutRecordsInput, ChampionshipUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: ChampionshipCreateOrConnectWithoutRecordsInput
    connect?: ChampionshipWhereUniqueInput
  }

  export type ChampionshipUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<ChampionshipCreateWithoutRecordsInput, ChampionshipUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: ChampionshipCreateOrConnectWithoutRecordsInput
    upsert?: ChampionshipUpsertWithoutRecordsInput
    connect?: ChampionshipWhereUniqueInput
    update?: XOR<XOR<ChampionshipUpdateToOneWithWhereWithoutRecordsInput, ChampionshipUpdateWithoutRecordsInput>, ChampionshipUncheckedUpdateWithoutRecordsInput>
  }

  export type UserCreateNestedOneWithoutUserLoginInput = {
    create?: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLoginNestedInput = {
    create?: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginInput
    upsert?: UserUpsertWithoutUserLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLoginInput, UserUpdateWithoutUserLoginInput>, UserUncheckedUpdateWithoutUserLoginInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminAuthorityCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminOperationHistoryCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminOperationHistoryCreateNestedManyWithoutOpAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type BannerCreateNestedManyWithoutAdminInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AdminTransactionCreateWithoutCustomerInput, AdminTransactionUncheckedCreateWithoutCustomerInput> | AdminTransactionCreateWithoutCustomerInput[] | AdminTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutCustomerInput | AdminTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: AdminTransactionCreateManyCustomerInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type AdminTransactionArchiveCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AdminTransactionArchiveCreateWithoutCustomerInput, AdminTransactionArchiveUncheckedCreateWithoutCustomerInput> | AdminTransactionArchiveCreateWithoutCustomerInput[] | AdminTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionArchiveCreateOrConnectWithoutCustomerInput | AdminTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    createMany?: AdminTransactionArchiveCreateManyCustomerInputEnvelope
    connect?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type BannerUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AdminTransactionCreateWithoutCustomerInput, AdminTransactionUncheckedCreateWithoutCustomerInput> | AdminTransactionCreateWithoutCustomerInput[] | AdminTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutCustomerInput | AdminTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: AdminTransactionCreateManyCustomerInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AdminTransactionArchiveCreateWithoutCustomerInput, AdminTransactionArchiveUncheckedCreateWithoutCustomerInput> | AdminTransactionArchiveCreateWithoutCustomerInput[] | AdminTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionArchiveCreateOrConnectWithoutCustomerInput | AdminTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    createMany?: AdminTransactionArchiveCreateManyCustomerInputEnvelope
    connect?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type UserUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput | AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput | AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutAdminInput | AdminAuthorityUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminOperationHistoryUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type BannerUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutAdminInput | BannerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutAdminInput | BannerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutAdminInput | BannerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutCustomerInput, AdminTransactionUncheckedCreateWithoutCustomerInput> | AdminTransactionCreateWithoutCustomerInput[] | AdminTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutCustomerInput | AdminTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutCustomerInput | AdminTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AdminTransactionCreateManyCustomerInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutCustomerInput | AdminTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutCustomerInput | AdminTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AdminTransactionArchiveCreateWithoutCustomerInput, AdminTransactionArchiveUncheckedCreateWithoutCustomerInput> | AdminTransactionArchiveCreateWithoutCustomerInput[] | AdminTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionArchiveCreateOrConnectWithoutCustomerInput | AdminTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    upsert?: AdminTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput | AdminTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AdminTransactionArchiveCreateManyCustomerInputEnvelope
    set?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    disconnect?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    delete?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    connect?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    update?: AdminTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput | AdminTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AdminTransactionArchiveUpdateManyWithWhereWithoutCustomerInput | AdminTransactionArchiveUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AdminTransactionArchiveScalarWhereInput | AdminTransactionArchiveScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput | AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput | AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutAdminInput | AdminAuthorityUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type BannerUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutAdminInput | BannerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutAdminInput | BannerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutAdminInput | BannerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutCustomerInput, AdminTransactionUncheckedCreateWithoutCustomerInput> | AdminTransactionCreateWithoutCustomerInput[] | AdminTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutCustomerInput | AdminTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutCustomerInput | AdminTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AdminTransactionCreateManyCustomerInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutCustomerInput | AdminTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutCustomerInput | AdminTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AdminTransactionArchiveCreateWithoutCustomerInput, AdminTransactionArchiveUncheckedCreateWithoutCustomerInput> | AdminTransactionArchiveCreateWithoutCustomerInput[] | AdminTransactionArchiveUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AdminTransactionArchiveCreateOrConnectWithoutCustomerInput | AdminTransactionArchiveCreateOrConnectWithoutCustomerInput[]
    upsert?: AdminTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput | AdminTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AdminTransactionArchiveCreateManyCustomerInputEnvelope
    set?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    disconnect?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    delete?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    connect?: AdminTransactionArchiveWhereUniqueInput | AdminTransactionArchiveWhereUniqueInput[]
    update?: AdminTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput | AdminTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AdminTransactionArchiveUpdateManyWithWhereWithoutCustomerInput | AdminTransactionArchiveUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AdminTransactionArchiveScalarWhereInput | AdminTransactionArchiveScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutOperationHistoriesInput = {
    create?: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationHistoriesInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutOperationsInput = {
    create?: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumOperationFieldUpdateOperationsInput = {
    set?: $Enums.Operation
  }

  export type AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput = {
    create?: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationHistoriesInput
    upsert?: AdminUpsertWithoutOperationHistoriesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOperationHistoriesInput, AdminUpdateWithoutOperationHistoriesInput>, AdminUncheckedUpdateWithoutOperationHistoriesInput>
  }

  export type AdminUpdateOneRequiredWithoutOperationsNestedInput = {
    create?: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationsInput
    upsert?: AdminUpsertWithoutOperationsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOperationsInput, AdminUpdateWithoutOperationsInput>, AdminUncheckedUpdateWithoutOperationsInput>
  }

  export type AdminAuthorityCreategradesInput = {
    set: number[]
  }

  export type AdminCreateNestedOneWithoutAuthorityInput = {
    create?: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthorityInput
    connect?: AdminWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutAdminAuthorityInput = {
    create?: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminAuthorityInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type AdminAuthorityUpdategradesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AdminUpdateOneRequiredWithoutAuthorityNestedInput = {
    create?: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthorityInput
    upsert?: AdminUpsertWithoutAuthorityInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuthorityInput, AdminUpdateWithoutAuthorityInput>, AdminUncheckedUpdateWithoutAuthorityInput>
  }

  export type ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput = {
    create?: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminAuthorityInput
    upsert?: ProvinceUpsertWithoutAdminAuthorityInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutAdminAuthorityInput, ProvinceUpdateWithoutAdminAuthorityInput>, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type CityUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutAdminAuthorityInput | CityUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutAdminAuthorityInput | CityUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: CityUpdateManyWithWhereWithoutAdminAuthorityInput | CityUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAdminAuthorityInput | SchoolUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutAdminAuthorityInput | CityUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutAdminAuthorityInput | CityUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: CityUpdateManyWithWhereWithoutAdminAuthorityInput | CityUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAdminAuthorityInput | SchoolUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type BannerVisitorCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutBannerInput = {
    create?: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    connectOrCreate?: AdminCreateOrConnectWithoutBannerInput
    connect?: AdminWhereUniqueInput
  }

  export type BannerLocationCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type BannerVisitorUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type BannerLocationUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type BannerVisitorUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutBannerInput | BannerVisitorUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutBannerInput | BannerVisitorUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutBannerInput | BannerVisitorUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type AdminUpdateOneRequiredWithoutBannerNestedInput = {
    create?: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    connectOrCreate?: AdminCreateOrConnectWithoutBannerInput
    upsert?: AdminUpsertWithoutBannerInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutBannerInput, AdminUpdateWithoutBannerInput>, AdminUncheckedUpdateWithoutBannerInput>
  }

  export type BannerLocationUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutBannerInput | BannerLocationUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutBannerInput | BannerLocationUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutBannerInput | BannerLocationUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutBannerInput | BannerVisitorUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutBannerInput | BannerVisitorUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutBannerInput | BannerVisitorUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type BannerLocationUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutBannerInput | BannerLocationUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutBannerInput | BannerLocationUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutBannerInput | BannerLocationUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type BannerCreateNestedOneWithoutBannerLocationInput = {
    create?: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: BannerCreateOrConnectWithoutBannerLocationInput
    connect?: BannerWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutBannerLocationInput = {
    create?: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannerLocationInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutBannerLocationInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutBannerLocationInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type BannerUpdateOneRequiredWithoutBannerLocationNestedInput = {
    create?: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: BannerCreateOrConnectWithoutBannerLocationInput
    upsert?: BannerUpsertWithoutBannerLocationInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutBannerLocationInput, BannerUpdateWithoutBannerLocationInput>, BannerUncheckedUpdateWithoutBannerLocationInput>
  }

  export type ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput = {
    create?: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannerLocationInput
    upsert?: ProvinceUpsertWithoutBannerLocationInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutBannerLocationInput, ProvinceUpdateWithoutBannerLocationInput>, ProvinceUncheckedUpdateWithoutBannerLocationInput>
  }

  export type CityUpdateManyWithoutBannerLocationNestedInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutBannerLocationInput | CityUpsertWithWhereUniqueWithoutBannerLocationInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutBannerLocationInput | CityUpdateWithWhereUniqueWithoutBannerLocationInput[]
    updateMany?: CityUpdateManyWithWhereWithoutBannerLocationInput | CityUpdateManyWithWhereWithoutBannerLocationInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutBannerLocationNestedInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutBannerLocationInput | CityUpsertWithWhereUniqueWithoutBannerLocationInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutBannerLocationInput | CityUpdateWithWhereUniqueWithoutBannerLocationInput[]
    updateMany?: CityUpdateManyWithWhereWithoutBannerLocationInput | CityUpdateManyWithWhereWithoutBannerLocationInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type BannerCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutVisitorsInput
    connect?: BannerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBannerVisitorInput = {
    create?: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannerVisitorInput
    connect?: UserWhereUniqueInput
  }

  export type BannerUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutVisitorsInput
    upsert?: BannerUpsertWithoutVisitorsInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutVisitorsInput, BannerUpdateWithoutVisitorsInput>, BannerUncheckedUpdateWithoutVisitorsInput>
  }

  export type UserUpdateOneRequiredWithoutBannerVisitorNestedInput = {
    create?: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannerVisitorInput
    upsert?: UserUpsertWithoutBannerVisitorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBannerVisitorInput, UserUpdateWithoutBannerVisitorInput>, UserUncheckedUpdateWithoutBannerVisitorInput>
  }

  export type TestParticipantCreateNestedManyWithoutTestInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type TestParticipantUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type EnumTestCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TestCategory
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type EnumTestTypeFieldUpdateOperationsInput = {
    set?: $Enums.TestType
  }

  export type TestParticipantUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutTestInput | TestParticipantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutTestInput | TestParticipantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutTestInput | TestParticipantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type TestParticipantUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutTestInput | TestParticipantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutTestInput | TestParticipantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutTestInput | TestParticipantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type TestCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TestCreateOrConnectWithoutParticipantsInput
    connect?: TestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestParticipantInput = {
    create?: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type TestParticipantRecordCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type TestUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TestCreateOrConnectWithoutParticipantsInput
    upsert?: TestUpsertWithoutParticipantsInput
    connect?: TestWhereUniqueInput
    update?: XOR<XOR<TestUpdateToOneWithWhereWithoutParticipantsInput, TestUpdateWithoutParticipantsInput>, TestUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTestParticipantNestedInput = {
    create?: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestParticipantInput
    upsert?: UserUpsertWithoutTestParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestParticipantInput, UserUpdateWithoutTestParticipantInput>, UserUncheckedUpdateWithoutTestParticipantInput>
  }

  export type TestParticipantRecordUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput | TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput | TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type TestParticipantCreateNestedOneWithoutRecordsInput = {
    create?: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TestParticipantCreateOrConnectWithoutRecordsInput
    connect?: TestParticipantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestRecordsInput = {
    create?: XOR<UserCreateWithoutTestRecordsInput, UserUncheckedCreateWithoutTestRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type TestParticipantUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TestParticipantCreateOrConnectWithoutRecordsInput
    upsert?: TestParticipantUpsertWithoutRecordsInput
    connect?: TestParticipantWhereUniqueInput
    update?: XOR<XOR<TestParticipantUpdateToOneWithWhereWithoutRecordsInput, TestParticipantUpdateWithoutRecordsInput>, TestParticipantUncheckedUpdateWithoutRecordsInput>
  }

  export type UserUpdateOneRequiredWithoutTestRecordsNestedInput = {
    create?: XOR<UserCreateWithoutTestRecordsInput, UserUncheckedCreateWithoutTestRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestRecordsInput
    upsert?: UserUpsertWithoutTestRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestRecordsInput, UserUpdateWithoutTestRecordsInput>, UserUncheckedUpdateWithoutTestRecordsInput>
  }

  export type VoucherCreatezonesInput = {
    set: string[]
  }

  export type VoucherRedemeerCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherRedemeerCreateWithoutVoucherInput, VoucherRedemeerUncheckedCreateWithoutVoucherInput> | VoucherRedemeerCreateWithoutVoucherInput[] | VoucherRedemeerUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutVoucherInput | VoucherRedemeerCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherRedemeerCreateManyVoucherInputEnvelope
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
  }

  export type VoucherRedemeerUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherRedemeerCreateWithoutVoucherInput, VoucherRedemeerUncheckedCreateWithoutVoucherInput> | VoucherRedemeerCreateWithoutVoucherInput[] | VoucherRedemeerUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutVoucherInput | VoucherRedemeerCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherRedemeerCreateManyVoucherInputEnvelope
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
  }

  export type EnumVoucherTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoucherType
  }

  export type VoucherUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VoucherRedemeerUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherRedemeerCreateWithoutVoucherInput, VoucherRedemeerUncheckedCreateWithoutVoucherInput> | VoucherRedemeerCreateWithoutVoucherInput[] | VoucherRedemeerUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutVoucherInput | VoucherRedemeerCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherRedemeerUpsertWithWhereUniqueWithoutVoucherInput | VoucherRedemeerUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherRedemeerCreateManyVoucherInputEnvelope
    set?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    disconnect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    delete?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    update?: VoucherRedemeerUpdateWithWhereUniqueWithoutVoucherInput | VoucherRedemeerUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherRedemeerUpdateManyWithWhereWithoutVoucherInput | VoucherRedemeerUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherRedemeerScalarWhereInput | VoucherRedemeerScalarWhereInput[]
  }

  export type VoucherRedemeerUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherRedemeerCreateWithoutVoucherInput, VoucherRedemeerUncheckedCreateWithoutVoucherInput> | VoucherRedemeerCreateWithoutVoucherInput[] | VoucherRedemeerUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherRedemeerCreateOrConnectWithoutVoucherInput | VoucherRedemeerCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherRedemeerUpsertWithWhereUniqueWithoutVoucherInput | VoucherRedemeerUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherRedemeerCreateManyVoucherInputEnvelope
    set?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    disconnect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    delete?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    connect?: VoucherRedemeerWhereUniqueInput | VoucherRedemeerWhereUniqueInput[]
    update?: VoucherRedemeerUpdateWithWhereUniqueWithoutVoucherInput | VoucherRedemeerUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherRedemeerUpdateManyWithWhereWithoutVoucherInput | VoucherRedemeerUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherRedemeerScalarWhereInput | VoucherRedemeerScalarWhereInput[]
  }

  export type VoucherCreateNestedOneWithoutRedemeersInput = {
    create?: XOR<VoucherCreateWithoutRedemeersInput, VoucherUncheckedCreateWithoutRedemeersInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutRedemeersInput
    connect?: VoucherWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVoucherRedemeerInput = {
    create?: XOR<UserCreateWithoutVoucherRedemeerInput, UserUncheckedCreateWithoutVoucherRedemeerInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherRedemeerInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherUpdateOneRequiredWithoutRedemeersNestedInput = {
    create?: XOR<VoucherCreateWithoutRedemeersInput, VoucherUncheckedCreateWithoutRedemeersInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutRedemeersInput
    upsert?: VoucherUpsertWithoutRedemeersInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutRedemeersInput, VoucherUpdateWithoutRedemeersInput>, VoucherUncheckedUpdateWithoutRedemeersInput>
  }

  export type UserUpdateOneRequiredWithoutVoucherRedemeerNestedInput = {
    create?: XOR<UserCreateWithoutVoucherRedemeerInput, UserUncheckedCreateWithoutVoucherRedemeerInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherRedemeerInput
    upsert?: UserUpsertWithoutVoucherRedemeerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoucherRedemeerInput, UserUpdateWithoutVoucherRedemeerInput>, UserUncheckedUpdateWithoutVoucherRedemeerInput>
  }

  export type AdminTransactionCreatezonesInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutAdminTransactionInput = {
    create?: XOR<AdminCreateWithoutAdminTransactionInput, AdminUncheckedCreateWithoutAdminTransactionInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminTransactionInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminTransactionUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutAdminTransactionNestedInput = {
    create?: XOR<AdminCreateWithoutAdminTransactionInput, AdminUncheckedCreateWithoutAdminTransactionInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminTransactionInput
    upsert?: AdminUpsertWithoutAdminTransactionInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAdminTransactionInput, AdminUpdateWithoutAdminTransactionInput>, AdminUncheckedUpdateWithoutAdminTransactionInput>
  }

  export type AdminTransactionArchiveCreatezonesInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutAdminTransactionArchiveInput = {
    create?: XOR<AdminCreateWithoutAdminTransactionArchiveInput, AdminUncheckedCreateWithoutAdminTransactionArchiveInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminTransactionArchiveInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminTransactionArchiveUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutAdminTransactionArchiveNestedInput = {
    create?: XOR<AdminCreateWithoutAdminTransactionArchiveInput, AdminUncheckedCreateWithoutAdminTransactionArchiveInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminTransactionArchiveInput
    upsert?: AdminUpsertWithoutAdminTransactionArchiveInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAdminTransactionArchiveInput, AdminUpdateWithoutAdminTransactionArchiveInput>, AdminUncheckedUpdateWithoutAdminTransactionArchiveInput>
  }

  export type UserTransactionCreatezonesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserTransactionInput = {
    create?: XOR<UserCreateWithoutUserTransactionInput, UserUncheckedCreateWithoutUserTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type UserTransactionUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserTransactionNestedInput = {
    create?: XOR<UserCreateWithoutUserTransactionInput, UserUncheckedCreateWithoutUserTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTransactionInput
    upsert?: UserUpsertWithoutUserTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserTransactionInput, UserUpdateWithoutUserTransactionInput>, UserUncheckedUpdateWithoutUserTransactionInput>
  }

  export type UserTransactionArchiveCreatezonesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserTransactionArchiveInput = {
    create?: XOR<UserCreateWithoutUserTransactionArchiveInput, UserUncheckedCreateWithoutUserTransactionArchiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTransactionArchiveInput
    connect?: UserWhereUniqueInput
  }

  export type UserTransactionArchiveUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserTransactionArchiveNestedInput = {
    create?: XOR<UserCreateWithoutUserTransactionArchiveInput, UserUncheckedCreateWithoutUserTransactionArchiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTransactionArchiveInput
    upsert?: UserUpsertWithoutUserTransactionArchiveInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserTransactionArchiveInput, UserUpdateWithoutUserTransactionArchiveInput>, UserUncheckedUpdateWithoutUserTransactionArchiveInput>
  }

  export type MultiPlayerMemberCreateNestedManyWithoutRoomInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type MultiPlayerMemberUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type MultiPlayerMemberUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput | MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput | MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMultiPlayerMemberInput = {
    create?: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMultiPlayerMemberInput
    connect?: UserWhereUniqueInput
  }

  export type MultiplayerRoomCreateNestedOneWithoutMembersInput = {
    create?: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MultiplayerRoomCreateOrConnectWithoutMembersInput
    connect?: MultiplayerRoomWhereUniqueInput
  }

  export type UserUpdateOneWithoutMultiPlayerMemberNestedInput = {
    create?: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMultiPlayerMemberInput
    upsert?: UserUpsertWithoutMultiPlayerMemberInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMultiPlayerMemberInput, UserUpdateWithoutMultiPlayerMemberInput>, UserUncheckedUpdateWithoutMultiPlayerMemberInput>
  }

  export type MultiplayerRoomUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MultiplayerRoomCreateOrConnectWithoutMembersInput
    upsert?: MultiplayerRoomUpsertWithoutMembersInput
    connect?: MultiplayerRoomWhereUniqueInput
    update?: XOR<XOR<MultiplayerRoomUpdateToOneWithWhereWithoutMembersInput, MultiplayerRoomUpdateWithoutMembersInput>, MultiplayerRoomUncheckedUpdateWithoutMembersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationFilter<$PrismaModel> | $Enums.Operation
  }

  export type NestedEnumOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationWithAggregatesFilter<$PrismaModel> | $Enums.Operation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationFilter<$PrismaModel>
    _max?: NestedEnumOperationFilter<$PrismaModel>
  }

  export type NestedEnumTestCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCategory | EnumTestCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCategoryFilter<$PrismaModel> | $Enums.TestCategory
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeFilter<$PrismaModel> | $Enums.TestType
  }

  export type NestedEnumTestCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestCategory | EnumTestCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestCategory[] | ListEnumTestCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTestCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TestCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestCategoryFilter<$PrismaModel>
    _max?: NestedEnumTestCategoryFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.TestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestTypeFilter<$PrismaModel>
    _max?: NestedEnumTestTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type CityCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutProvinceInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityCreateManyProvinceInputEnvelope = {
    data: CityCreateManyProvinceInput | CityCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutProvinceInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutProvinceInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput>
  }

  export type SchoolCreateManyProvinceInputEnvelope = {
    data: SchoolCreateManyProvinceInput | SchoolCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProvinceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput>
  }

  export type UserCreateManyProvinceInputEnvelope = {
    data: UserCreateManyProvinceInput | UserCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutProvinceInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutProvinceInput = {
    id?: string
    adminId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput>
  }

  export type AdminAuthorityCreateManyProvinceInputEnvelope = {
    data: AdminAuthorityCreateManyProvinceInput | AdminAuthorityCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type BannerLocationCreateWithoutProvinceInput = {
    id?: string
    banner: BannerCreateNestedOneWithoutBannerLocationInput
    cities?: CityCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateWithoutProvinceInput = {
    id?: string
    bannerId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationCreateOrConnectWithoutProvinceInput = {
    where: BannerLocationWhereUniqueInput
    create: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput>
  }

  export type BannerLocationCreateManyProvinceInputEnvelope = {
    data: BannerLocationCreateManyProvinceInput | BannerLocationCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
  }

  export type CityUpdateManyWithWhereWithoutProvinceInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutProvinceInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
  }

  export type SchoolUpsertWithWhereUniqueWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutProvinceInput, SchoolUncheckedUpdateWithoutProvinceInput>
    create: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutProvinceInput, SchoolUncheckedUpdateWithoutProvinceInput>
  }

  export type SchoolUpdateManyWithWhereWithoutProvinceInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutProvinceInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: StringFilter<"School"> | string
    identity?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringFilter<"School"> | string
    provinceId?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutProvinceInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProvinceInput, UserUncheckedUpdateWithoutProvinceInput>
    create: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProvinceInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProvinceInput, UserUncheckedUpdateWithoutProvinceInput>
  }

  export type UserUpdateManyWithWhereWithoutProvinceInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProvinceInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    authId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: IntFilter<"User"> | number
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    storageId?: StringNullableFilter<"User"> | string | null
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutProvinceInput, AdminAuthorityUncheckedUpdateWithoutProvinceInput>
    create: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutProvinceInput, AdminAuthorityUncheckedUpdateWithoutProvinceInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutProvinceInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutProvinceInput>
  }

  export type AdminAuthorityScalarWhereInput = {
    AND?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
    OR?: AdminAuthorityScalarWhereInput[]
    NOT?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
    id?: StringFilter<"AdminAuthority"> | string
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
  }

  export type BannerLocationUpsertWithWhereUniqueWithoutProvinceInput = {
    where: BannerLocationWhereUniqueInput
    update: XOR<BannerLocationUpdateWithoutProvinceInput, BannerLocationUncheckedUpdateWithoutProvinceInput>
    create: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput>
  }

  export type BannerLocationUpdateWithWhereUniqueWithoutProvinceInput = {
    where: BannerLocationWhereUniqueInput
    data: XOR<BannerLocationUpdateWithoutProvinceInput, BannerLocationUncheckedUpdateWithoutProvinceInput>
  }

  export type BannerLocationUpdateManyWithWhereWithoutProvinceInput = {
    where: BannerLocationScalarWhereInput
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyWithoutProvinceInput>
  }

  export type BannerLocationScalarWhereInput = {
    AND?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
    OR?: BannerLocationScalarWhereInput[]
    NOT?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
    id?: StringFilter<"BannerLocation"> | string
    bannerId?: StringFilter<"BannerLocation"> | string
    provinceId?: StringFilter<"BannerLocation"> | string
  }

  export type ProvinceCreateWithoutCitiesInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutCitiesInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
  }

  export type SchoolCreateWithoutCityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutCityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutCityInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput>
  }

  export type SchoolCreateManyCityInputEnvelope = {
    data: SchoolCreateManyCityInput | SchoolCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutCitiesInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutCitiesInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput>
  }

  export type BannerLocationCreateWithoutCitiesInput = {
    id?: string
    banner: BannerCreateNestedOneWithoutBannerLocationInput
    province: ProvinceCreateNestedOneWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateWithoutCitiesInput = {
    id?: string
    bannerId: string
    provinceId: string
  }

  export type BannerLocationCreateOrConnectWithoutCitiesInput = {
    where: BannerLocationWhereUniqueInput
    create: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput>
  }

  export type ProvinceUpsertWithoutCitiesInput = {
    update: XOR<ProvinceUpdateWithoutCitiesInput, ProvinceUncheckedUpdateWithoutCitiesInput>
    create: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutCitiesInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutCitiesInput, ProvinceUncheckedUpdateWithoutCitiesInput>
  }

  export type ProvinceUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type SchoolUpsertWithWhereUniqueWithoutCityInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutCityInput, SchoolUncheckedUpdateWithoutCityInput>
    create: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutCityInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutCityInput, SchoolUncheckedUpdateWithoutCityInput>
  }

  export type SchoolUpdateManyWithWhereWithoutCityInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutCityInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCityInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutCitiesInput, AdminAuthorityUncheckedUpdateWithoutCitiesInput>
    create: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutCitiesInput, AdminAuthorityUncheckedUpdateWithoutCitiesInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutCitiesInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type BannerLocationUpsertWithWhereUniqueWithoutCitiesInput = {
    where: BannerLocationWhereUniqueInput
    update: XOR<BannerLocationUpdateWithoutCitiesInput, BannerLocationUncheckedUpdateWithoutCitiesInput>
    create: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput>
  }

  export type BannerLocationUpdateWithWhereUniqueWithoutCitiesInput = {
    where: BannerLocationWhereUniqueInput
    data: XOR<BannerLocationUpdateWithoutCitiesInput, BannerLocationUncheckedUpdateWithoutCitiesInput>
  }

  export type BannerLocationUpdateManyWithWhereWithoutCitiesInput = {
    where: BannerLocationScalarWhereInput
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyWithoutCitiesInput>
  }

  export type CityCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutSchoolsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
  }

  export type ProvinceCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutSchoolsInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutSchoolsInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutSchoolsInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput>
  }

  export type CityUpsertWithoutSchoolsInput = {
    update: XOR<CityUpdateWithoutSchoolsInput, CityUncheckedUpdateWithoutSchoolsInput>
    create: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutSchoolsInput, CityUncheckedUpdateWithoutSchoolsInput>
  }

  export type CityUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type ProvinceUpsertWithoutSchoolsInput = {
    update: XOR<ProvinceUpdateWithoutSchoolsInput, ProvinceUncheckedUpdateWithoutSchoolsInput>
    create: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutSchoolsInput, ProvinceUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProvinceUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutSchoolsInput, AdminAuthorityUncheckedUpdateWithoutSchoolsInput>
    create: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutSchoolsInput, AdminAuthorityUncheckedUpdateWithoutSchoolsInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type UserCreateWithoutOwnedAccessesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedAccessesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedAccessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedAccessesInput, UserUncheckedCreateWithoutOwnedAccessesInput>
  }

  export type UserCreateWithoutUserAccessesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAccessesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAccessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAccessesInput, UserUncheckedCreateWithoutUserAccessesInput>
  }

  export type UserCreateWithoutRedeemedAccessesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRedeemedAccessesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRedeemedAccessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRedeemedAccessesInput, UserUncheckedCreateWithoutRedeemedAccessesInput>
  }

  export type UserUpsertWithoutOwnedAccessesInput = {
    update: XOR<UserUpdateWithoutOwnedAccessesInput, UserUncheckedUpdateWithoutOwnedAccessesInput>
    create: XOR<UserCreateWithoutOwnedAccessesInput, UserUncheckedCreateWithoutOwnedAccessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedAccessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedAccessesInput, UserUncheckedUpdateWithoutOwnedAccessesInput>
  }

  export type UserUpdateWithoutOwnedAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutUserAccessesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUserAccessesInput, UserUncheckedUpdateWithoutUserAccessesInput>
    create: XOR<UserCreateWithoutUserAccessesInput, UserUncheckedCreateWithoutUserAccessesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUserAccessesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUserAccessesInput, UserUncheckedUpdateWithoutUserAccessesInput>
  }

  export type UserUpdateManyWithWhereWithoutUserAccessesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserAccessesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRedeemedAccessesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRedeemedAccessesInput, UserUncheckedUpdateWithoutRedeemedAccessesInput>
    create: XOR<UserCreateWithoutRedeemedAccessesInput, UserUncheckedCreateWithoutRedeemedAccessesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRedeemedAccessesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRedeemedAccessesInput, UserUncheckedUpdateWithoutRedeemedAccessesInput>
  }

  export type UserUpdateManyWithWhereWithoutRedeemedAccessesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRedeemedAccessesInput>
  }

  export type DeviceCreateWithoutUserInput = {
    id?: string
    uuid: string
    model: string
    manufactur: string
    os: string
    ramSize: number
    gpuName: string
    cpuType: string
    cpuCores: number
  }

  export type DeviceUncheckedCreateWithoutUserInput = {
    id?: string
    uuid: string
    model: string
    manufactur: string
    os: string
    ramSize: number
    gpuName: string
    cpuType: string
    cpuCores: number
  }

  export type DeviceCreateOrConnectWithoutUserInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type AccessContentCreateWithoutOwnerInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userAccesses?: UserCreateNestedManyWithoutUserAccessesInput
    redemeers?: UserCreateNestedManyWithoutRedeemedAccessesInput
  }

  export type AccessContentUncheckedCreateWithoutOwnerInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userAccesses?: UserUncheckedCreateNestedManyWithoutUserAccessesInput
    redemeers?: UserUncheckedCreateNestedManyWithoutRedeemedAccessesInput
  }

  export type AccessContentCreateOrConnectWithoutOwnerInput = {
    where: AccessContentWhereUniqueInput
    create: XOR<AccessContentCreateWithoutOwnerInput, AccessContentUncheckedCreateWithoutOwnerInput>
  }

  export type AccessContentCreateManyOwnerInputEnvelope = {
    data: AccessContentCreateManyOwnerInput | AccessContentCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type ProvinceCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutUsersInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AccessContentCreateWithoutUserAccessesInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedAccessesInput
    redemeers?: UserCreateNestedManyWithoutRedeemedAccessesInput
  }

  export type AccessContentUncheckedCreateWithoutUserAccessesInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    ownerId?: string | null
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    redemeers?: UserUncheckedCreateNestedManyWithoutRedeemedAccessesInput
  }

  export type AccessContentCreateOrConnectWithoutUserAccessesInput = {
    where: AccessContentWhereUniqueInput
    create: XOR<AccessContentCreateWithoutUserAccessesInput, AccessContentUncheckedCreateWithoutUserAccessesInput>
  }

  export type ZoneCreateWithoutUserInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    levels?: LevelCreateNestedManyWithoutZoneInput
    gempo?: GempoCreateNestedOneWithoutZoneInput
    championship?: ChampionshipCreateNestedOneWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutUserInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    levels?: LevelUncheckedCreateNestedManyWithoutZoneInput
    gempo?: GempoUncheckedCreateNestedOneWithoutZoneInput
    championship?: ChampionshipUncheckedCreateNestedOneWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutUserInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput>
  }

  export type ZoneCreateManyUserInputEnvelope = {
    data: ZoneCreateManyUserInput | ZoneCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccessContentCreateWithoutRedemeersInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: UserCreateNestedOneWithoutOwnedAccessesInput
    userAccesses?: UserCreateNestedManyWithoutUserAccessesInput
  }

  export type AccessContentUncheckedCreateWithoutRedemeersInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    ownerId?: string | null
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userAccesses?: UserUncheckedCreateNestedManyWithoutUserAccessesInput
  }

  export type AccessContentCreateOrConnectWithoutRedemeersInput = {
    where: AccessContentWhereUniqueInput
    create: XOR<AccessContentCreateWithoutRedemeersInput, AccessContentUncheckedCreateWithoutRedemeersInput>
  }

  export type UserLoginCreateWithoutUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUncheckedCreateWithoutUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginCreateOrConnectWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    create: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput>
  }

  export type UserLoginCreateManyUserInputEnvelope = {
    data: UserLoginCreateManyUserInput | UserLoginCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BannerVisitorCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    banner: BannerCreateNestedOneWithoutVisitorsInput
  }

  export type BannerVisitorUncheckedCreateWithoutUserInput = {
    id?: string
    bannerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorCreateOrConnectWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    create: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput>
  }

  export type BannerVisitorCreateManyUserInputEnvelope = {
    data: BannerVisitorCreateManyUserInput | BannerVisitorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestParticipantCreateWithoutUserInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    testId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantCreateOrConnectWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantCreateManyUserInputEnvelope = {
    data: TestParticipantCreateManyUserInput | TestParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoucherRedemeerCreateWithoutUserInput = {
    createdAt?: Date | string
    voucher: VoucherCreateNestedOneWithoutRedemeersInput
  }

  export type VoucherRedemeerUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    voucherId: number
  }

  export type VoucherRedemeerCreateOrConnectWithoutUserInput = {
    where: VoucherRedemeerWhereUniqueInput
    create: XOR<VoucherRedemeerCreateWithoutUserInput, VoucherRedemeerUncheckedCreateWithoutUserInput>
  }

  export type VoucherRedemeerCreateManyUserInputEnvelope = {
    data: VoucherRedemeerCreateManyUserInput | VoucherRedemeerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTransactionArchiveCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionArchiveCreatezonesInput | string[]
  }

  export type UserTransactionArchiveUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionArchiveCreatezonesInput | string[]
  }

  export type UserTransactionArchiveCreateOrConnectWithoutCustomerInput = {
    where: UserTransactionArchiveWhereUniqueInput
    create: XOR<UserTransactionArchiveCreateWithoutCustomerInput, UserTransactionArchiveUncheckedCreateWithoutCustomerInput>
  }

  export type UserTransactionArchiveCreateManyCustomerInputEnvelope = {
    data: UserTransactionArchiveCreateManyCustomerInput | UserTransactionArchiveCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserTransactionCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionCreatezonesInput | string[]
  }

  export type UserTransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionCreatezonesInput | string[]
  }

  export type UserTransactionCreateOrConnectWithoutCustomerInput = {
    where: UserTransactionWhereUniqueInput
    create: XOR<UserTransactionCreateWithoutCustomerInput, UserTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type UserTransactionCreateManyCustomerInputEnvelope = {
    data: UserTransactionCreateManyCustomerInput | UserTransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type MultiPlayerMemberCreateWithoutUserInput = {
    id?: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    room: MultiplayerRoomCreateNestedOneWithoutMembersInput
  }

  export type MultiPlayerMemberUncheckedCreateWithoutUserInput = {
    id?: string
    roomId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberCreateOrConnectWithoutUserInput = {
    where: MultiPlayerMemberWhereUniqueInput
    create: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput>
  }

  export type MultiPlayerMemberCreateManyUserInputEnvelope = {
    data: MultiPlayerMemberCreateManyUserInput | MultiPlayerMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestParticipantRecordCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    participant: TestParticipantCreateNestedOneWithoutRecordsInput
  }

  export type TestParticipantRecordUncheckedCreateWithoutUserInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateOrConnectWithoutUserInput = {
    where: TestParticipantRecordWhereUniqueInput
    create: XOR<TestParticipantRecordCreateWithoutUserInput, TestParticipantRecordUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantRecordCreateManyUserInputEnvelope = {
    data: TestParticipantRecordCreateManyUserInput | TestParticipantRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceUpsertWithoutUserInput = {
    update: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutUserInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufactur?: StringFieldUpdateOperationsInput | string
    os?: StringFieldUpdateOperationsInput | string
    ramSize?: IntFieldUpdateOperationsInput | number
    gpuName?: StringFieldUpdateOperationsInput | string
    cpuType?: StringFieldUpdateOperationsInput | string
    cpuCores?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufactur?: StringFieldUpdateOperationsInput | string
    os?: StringFieldUpdateOperationsInput | string
    ramSize?: IntFieldUpdateOperationsInput | number
    gpuName?: StringFieldUpdateOperationsInput | string
    cpuType?: StringFieldUpdateOperationsInput | string
    cpuCores?: IntFieldUpdateOperationsInput | number
  }

  export type AccessContentUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AccessContentWhereUniqueInput
    update: XOR<AccessContentUpdateWithoutOwnerInput, AccessContentUncheckedUpdateWithoutOwnerInput>
    create: XOR<AccessContentCreateWithoutOwnerInput, AccessContentUncheckedCreateWithoutOwnerInput>
  }

  export type AccessContentUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AccessContentWhereUniqueInput
    data: XOR<AccessContentUpdateWithoutOwnerInput, AccessContentUncheckedUpdateWithoutOwnerInput>
  }

  export type AccessContentUpdateManyWithWhereWithoutOwnerInput = {
    where: AccessContentScalarWhereInput
    data: XOR<AccessContentUpdateManyMutationInput, AccessContentUncheckedUpdateManyWithoutOwnerInput>
  }

  export type AccessContentScalarWhereInput = {
    AND?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
    OR?: AccessContentScalarWhereInput[]
    NOT?: AccessContentScalarWhereInput | AccessContentScalarWhereInput[]
    id?: StringFilter<"AccessContent"> | string
    expired?: DateTimeFilter<"AccessContent"> | Date | string
    quota?: IntFilter<"AccessContent"> | number
    currentQuota?: IntFilter<"AccessContent"> | number
    ownerId?: StringNullableFilter<"AccessContent"> | string | null
    zones?: StringNullableListFilter<"AccessContent">
    createdAt?: DateTimeFilter<"AccessContent"> | Date | string
    updatedAt?: DateTimeFilter<"AccessContent"> | Date | string
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutUsersInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type ProvinceUpsertWithoutUsersInput = {
    update: XOR<ProvinceUpdateWithoutUsersInput, ProvinceUncheckedUpdateWithoutUsersInput>
    create: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutUsersInput, ProvinceUncheckedUpdateWithoutUsersInput>
  }

  export type ProvinceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AccessContentUpsertWithWhereUniqueWithoutUserAccessesInput = {
    where: AccessContentWhereUniqueInput
    update: XOR<AccessContentUpdateWithoutUserAccessesInput, AccessContentUncheckedUpdateWithoutUserAccessesInput>
    create: XOR<AccessContentCreateWithoutUserAccessesInput, AccessContentUncheckedCreateWithoutUserAccessesInput>
  }

  export type AccessContentUpdateWithWhereUniqueWithoutUserAccessesInput = {
    where: AccessContentWhereUniqueInput
    data: XOR<AccessContentUpdateWithoutUserAccessesInput, AccessContentUncheckedUpdateWithoutUserAccessesInput>
  }

  export type AccessContentUpdateManyWithWhereWithoutUserAccessesInput = {
    where: AccessContentScalarWhereInput
    data: XOR<AccessContentUpdateManyMutationInput, AccessContentUncheckedUpdateManyWithoutUserAccessesInput>
  }

  export type ZoneUpsertWithWhereUniqueWithoutUserInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutUserInput, ZoneUncheckedUpdateWithoutUserInput>
    create: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutUserInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutUserInput, ZoneUncheckedUpdateWithoutUserInput>
  }

  export type ZoneUpdateManyWithWhereWithoutUserInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutUserInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: StringFilter<"Zone"> | string
    zoneId?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
  }

  export type AccessContentUpsertWithWhereUniqueWithoutRedemeersInput = {
    where: AccessContentWhereUniqueInput
    update: XOR<AccessContentUpdateWithoutRedemeersInput, AccessContentUncheckedUpdateWithoutRedemeersInput>
    create: XOR<AccessContentCreateWithoutRedemeersInput, AccessContentUncheckedCreateWithoutRedemeersInput>
  }

  export type AccessContentUpdateWithWhereUniqueWithoutRedemeersInput = {
    where: AccessContentWhereUniqueInput
    data: XOR<AccessContentUpdateWithoutRedemeersInput, AccessContentUncheckedUpdateWithoutRedemeersInput>
  }

  export type AccessContentUpdateManyWithWhereWithoutRedemeersInput = {
    where: AccessContentScalarWhereInput
    data: XOR<AccessContentUpdateManyMutationInput, AccessContentUncheckedUpdateManyWithoutRedemeersInput>
  }

  export type UserLoginUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    update: XOR<UserLoginUpdateWithoutUserInput, UserLoginUncheckedUpdateWithoutUserInput>
    create: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput>
  }

  export type UserLoginUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    data: XOR<UserLoginUpdateWithoutUserInput, UserLoginUncheckedUpdateWithoutUserInput>
  }

  export type UserLoginUpdateManyWithWhereWithoutUserInput = {
    where: UserLoginScalarWhereInput
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLoginScalarWhereInput = {
    AND?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
    OR?: UserLoginScalarWhereInput[]
    NOT?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
    id?: StringFilter<"UserLogin"> | string
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
  }

  export type BannerVisitorUpsertWithWhereUniqueWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    update: XOR<BannerVisitorUpdateWithoutUserInput, BannerVisitorUncheckedUpdateWithoutUserInput>
    create: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput>
  }

  export type BannerVisitorUpdateWithWhereUniqueWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    data: XOR<BannerVisitorUpdateWithoutUserInput, BannerVisitorUncheckedUpdateWithoutUserInput>
  }

  export type BannerVisitorUpdateManyWithWhereWithoutUserInput = {
    where: BannerVisitorScalarWhereInput
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyWithoutUserInput>
  }

  export type BannerVisitorScalarWhereInput = {
    AND?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
    OR?: BannerVisitorScalarWhereInput[]
    NOT?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
    id?: StringFilter<"BannerVisitor"> | string
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
  }

  export type TestParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    update: XOR<TestParticipantUpdateWithoutUserInput, TestParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    data: XOR<TestParticipantUpdateWithoutUserInput, TestParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TestParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TestParticipantScalarWhereInput
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TestParticipantScalarWhereInput = {
    AND?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
    OR?: TestParticipantScalarWhereInput[]
    NOT?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
    id?: StringFilter<"TestParticipant"> | string
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    average?: FloatFilter<"TestParticipant"> | number
    lowscore?: FloatFilter<"TestParticipant"> | number
  }

  export type VoucherRedemeerUpsertWithWhereUniqueWithoutUserInput = {
    where: VoucherRedemeerWhereUniqueInput
    update: XOR<VoucherRedemeerUpdateWithoutUserInput, VoucherRedemeerUncheckedUpdateWithoutUserInput>
    create: XOR<VoucherRedemeerCreateWithoutUserInput, VoucherRedemeerUncheckedCreateWithoutUserInput>
  }

  export type VoucherRedemeerUpdateWithWhereUniqueWithoutUserInput = {
    where: VoucherRedemeerWhereUniqueInput
    data: XOR<VoucherRedemeerUpdateWithoutUserInput, VoucherRedemeerUncheckedUpdateWithoutUserInput>
  }

  export type VoucherRedemeerUpdateManyWithWhereWithoutUserInput = {
    where: VoucherRedemeerScalarWhereInput
    data: XOR<VoucherRedemeerUpdateManyMutationInput, VoucherRedemeerUncheckedUpdateManyWithoutUserInput>
  }

  export type VoucherRedemeerScalarWhereInput = {
    AND?: VoucherRedemeerScalarWhereInput | VoucherRedemeerScalarWhereInput[]
    OR?: VoucherRedemeerScalarWhereInput[]
    NOT?: VoucherRedemeerScalarWhereInput | VoucherRedemeerScalarWhereInput[]
    id?: IntFilter<"VoucherRedemeer"> | number
    createdAt?: DateTimeFilter<"VoucherRedemeer"> | Date | string
    voucherId?: IntFilter<"VoucherRedemeer"> | number
    userId?: StringFilter<"VoucherRedemeer"> | string
  }

  export type UserTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput = {
    where: UserTransactionArchiveWhereUniqueInput
    update: XOR<UserTransactionArchiveUpdateWithoutCustomerInput, UserTransactionArchiveUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserTransactionArchiveCreateWithoutCustomerInput, UserTransactionArchiveUncheckedCreateWithoutCustomerInput>
  }

  export type UserTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput = {
    where: UserTransactionArchiveWhereUniqueInput
    data: XOR<UserTransactionArchiveUpdateWithoutCustomerInput, UserTransactionArchiveUncheckedUpdateWithoutCustomerInput>
  }

  export type UserTransactionArchiveUpdateManyWithWhereWithoutCustomerInput = {
    where: UserTransactionArchiveScalarWhereInput
    data: XOR<UserTransactionArchiveUpdateManyMutationInput, UserTransactionArchiveUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserTransactionArchiveScalarWhereInput = {
    AND?: UserTransactionArchiveScalarWhereInput | UserTransactionArchiveScalarWhereInput[]
    OR?: UserTransactionArchiveScalarWhereInput[]
    NOT?: UserTransactionArchiveScalarWhereInput | UserTransactionArchiveScalarWhereInput[]
    id?: StringFilter<"UserTransactionArchive"> | string
    transactionName?: StringFilter<"UserTransactionArchive"> | string
    status?: StringFilter<"UserTransactionArchive"> | string
    createdAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    expiredAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    updatedAt?: DateTimeFilter<"UserTransactionArchive"> | Date | string
    customerEmail?: StringFilter<"UserTransactionArchive"> | string
    customerName?: StringFilter<"UserTransactionArchive"> | string
    customerId?: StringFilter<"UserTransactionArchive"> | string
    quantity?: IntFilter<"UserTransactionArchive"> | number
    zones?: StringNullableListFilter<"UserTransactionArchive">
  }

  export type UserTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: UserTransactionWhereUniqueInput
    update: XOR<UserTransactionUpdateWithoutCustomerInput, UserTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserTransactionCreateWithoutCustomerInput, UserTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type UserTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: UserTransactionWhereUniqueInput
    data: XOR<UserTransactionUpdateWithoutCustomerInput, UserTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type UserTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: UserTransactionScalarWhereInput
    data: XOR<UserTransactionUpdateManyMutationInput, UserTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserTransactionScalarWhereInput = {
    AND?: UserTransactionScalarWhereInput | UserTransactionScalarWhereInput[]
    OR?: UserTransactionScalarWhereInput[]
    NOT?: UserTransactionScalarWhereInput | UserTransactionScalarWhereInput[]
    id?: StringFilter<"UserTransaction"> | string
    transactionName?: StringFilter<"UserTransaction"> | string
    status?: StringFilter<"UserTransaction"> | string
    createdAt?: DateTimeFilter<"UserTransaction"> | Date | string
    expiredAt?: DateTimeFilter<"UserTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"UserTransaction"> | Date | string
    customerEmail?: StringFilter<"UserTransaction"> | string
    customerName?: StringFilter<"UserTransaction"> | string
    customerId?: StringFilter<"UserTransaction"> | string
    quantity?: IntFilter<"UserTransaction"> | number
    zones?: StringNullableListFilter<"UserTransaction">
  }

  export type MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MultiPlayerMemberWhereUniqueInput
    update: XOR<MultiPlayerMemberUpdateWithoutUserInput, MultiPlayerMemberUncheckedUpdateWithoutUserInput>
    create: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput>
  }

  export type MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MultiPlayerMemberWhereUniqueInput
    data: XOR<MultiPlayerMemberUpdateWithoutUserInput, MultiPlayerMemberUncheckedUpdateWithoutUserInput>
  }

  export type MultiPlayerMemberUpdateManyWithWhereWithoutUserInput = {
    where: MultiPlayerMemberScalarWhereInput
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MultiPlayerMemberScalarWhereInput = {
    AND?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
    OR?: MultiPlayerMemberScalarWhereInput[]
    NOT?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
    id?: StringFilter<"MultiPlayerMember"> | string
    roomId?: StringFilter<"MultiPlayerMember"> | string
    userId?: StringNullableFilter<"MultiPlayerMember"> | string | null
    point?: IntFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntFilter<"MultiPlayerMember"> | number
    isReady?: BoolFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MultiPlayerMember"> | boolean
  }

  export type TestParticipantRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: TestParticipantRecordWhereUniqueInput
    update: XOR<TestParticipantRecordUpdateWithoutUserInput, TestParticipantRecordUncheckedUpdateWithoutUserInput>
    create: XOR<TestParticipantRecordCreateWithoutUserInput, TestParticipantRecordUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: TestParticipantRecordWhereUniqueInput
    data: XOR<TestParticipantRecordUpdateWithoutUserInput, TestParticipantRecordUncheckedUpdateWithoutUserInput>
  }

  export type TestParticipantRecordUpdateManyWithWhereWithoutUserInput = {
    where: TestParticipantRecordScalarWhereInput
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type TestParticipantRecordScalarWhereInput = {
    AND?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
    OR?: TestParticipantRecordScalarWhereInput[]
    NOT?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
    id?: StringFilter<"TestParticipantRecord"> | string
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    userId?: StringFilter<"TestParticipantRecord"> | string
    answers?: JsonFilter<"TestParticipantRecord">
  }

  export type UserCreateWithoutDeviceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeviceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeviceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceInput, UserUncheckedCreateWithoutDeviceInput>
  }

  export type UserUpsertWithoutDeviceInput = {
    update: XOR<UserUpdateWithoutDeviceInput, UserUncheckedUpdateWithoutDeviceInput>
    create: XOR<UserCreateWithoutDeviceInput, UserUncheckedCreateWithoutDeviceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceInput, UserUncheckedUpdateWithoutDeviceInput>
  }

  export type UserUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutZonesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZonesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
  }

  export type LevelCreateWithoutZoneInput = {
    id?: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subLevels?: SubLevelCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateWithoutZoneInput = {
    id?: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelCreateOrConnectWithoutZoneInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutZoneInput, LevelUncheckedCreateWithoutZoneInput>
  }

  export type LevelCreateManyZoneInputEnvelope = {
    data: LevelCreateManyZoneInput | LevelCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type GempoCreateWithoutZoneInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: GempoRecordCreateNestedManyWithoutGempoInput
  }

  export type GempoUncheckedCreateWithoutZoneInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: GempoRecordUncheckedCreateNestedManyWithoutGempoInput
  }

  export type GempoCreateOrConnectWithoutZoneInput = {
    where: GempoWhereUniqueInput
    create: XOR<GempoCreateWithoutZoneInput, GempoUncheckedCreateWithoutZoneInput>
  }

  export type ChampionshipCreateWithoutZoneInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: ChampionshipRecordCreateNestedManyWithoutChampionshipInput
  }

  export type ChampionshipUncheckedCreateWithoutZoneInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    records?: ChampionshipRecordUncheckedCreateNestedManyWithoutChampionshipInput
  }

  export type ChampionshipCreateOrConnectWithoutZoneInput = {
    where: ChampionshipWhereUniqueInput
    create: XOR<ChampionshipCreateWithoutZoneInput, ChampionshipUncheckedCreateWithoutZoneInput>
  }

  export type UserUpsertWithoutZonesInput = {
    update: XOR<UserUpdateWithoutZonesInput, UserUncheckedUpdateWithoutZonesInput>
    create: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZonesInput, UserUncheckedUpdateWithoutZonesInput>
  }

  export type UserUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LevelUpsertWithWhereUniqueWithoutZoneInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutZoneInput, LevelUncheckedUpdateWithoutZoneInput>
    create: XOR<LevelCreateWithoutZoneInput, LevelUncheckedCreateWithoutZoneInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutZoneInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutZoneInput, LevelUncheckedUpdateWithoutZoneInput>
  }

  export type LevelUpdateManyWithWhereWithoutZoneInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutZoneInput>
  }

  export type LevelScalarWhereInput = {
    AND?: LevelScalarWhereInput | LevelScalarWhereInput[]
    OR?: LevelScalarWhereInput[]
    NOT?: LevelScalarWhereInput | LevelScalarWhereInput[]
    id?: StringFilter<"Level"> | string
    levelId?: StringFilter<"Level"> | string
    zoneId?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
  }

  export type GempoUpsertWithoutZoneInput = {
    update: XOR<GempoUpdateWithoutZoneInput, GempoUncheckedUpdateWithoutZoneInput>
    create: XOR<GempoCreateWithoutZoneInput, GempoUncheckedCreateWithoutZoneInput>
    where?: GempoWhereInput
  }

  export type GempoUpdateToOneWithWhereWithoutZoneInput = {
    where?: GempoWhereInput
    data: XOR<GempoUpdateWithoutZoneInput, GempoUncheckedUpdateWithoutZoneInput>
  }

  export type GempoUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: GempoRecordUpdateManyWithoutGempoNestedInput
  }

  export type GempoUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: GempoRecordUncheckedUpdateManyWithoutGempoNestedInput
  }

  export type ChampionshipUpsertWithoutZoneInput = {
    update: XOR<ChampionshipUpdateWithoutZoneInput, ChampionshipUncheckedUpdateWithoutZoneInput>
    create: XOR<ChampionshipCreateWithoutZoneInput, ChampionshipUncheckedCreateWithoutZoneInput>
    where?: ChampionshipWhereInput
  }

  export type ChampionshipUpdateToOneWithWhereWithoutZoneInput = {
    where?: ChampionshipWhereInput
    data: XOR<ChampionshipUpdateWithoutZoneInput, ChampionshipUncheckedUpdateWithoutZoneInput>
  }

  export type ChampionshipUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: ChampionshipRecordUpdateManyWithoutChampionshipNestedInput
  }

  export type ChampionshipUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: ChampionshipRecordUncheckedUpdateManyWithoutChampionshipNestedInput
  }

  export type ZoneCreateWithoutLevelsInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZonesInput
    gempo?: GempoCreateNestedOneWithoutZoneInput
    championship?: ChampionshipCreateNestedOneWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutLevelsInput = {
    id?: string
    zoneId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gempo?: GempoUncheckedCreateNestedOneWithoutZoneInput
    championship?: ChampionshipUncheckedCreateNestedOneWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutLevelsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutLevelsInput, ZoneUncheckedCreateWithoutLevelsInput>
  }

  export type SubLevelCreateWithoutLevelInput = {
    id?: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    innerLevels?: InnerLevelCreateNestedManyWithoutSubLevelInput
  }

  export type SubLevelUncheckedCreateWithoutLevelInput = {
    id?: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutSubLevelInput
  }

  export type SubLevelCreateOrConnectWithoutLevelInput = {
    where: SubLevelWhereUniqueInput
    create: XOR<SubLevelCreateWithoutLevelInput, SubLevelUncheckedCreateWithoutLevelInput>
  }

  export type SubLevelCreateManyLevelInputEnvelope = {
    data: SubLevelCreateManyLevelInput | SubLevelCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithoutLevelsInput = {
    update: XOR<ZoneUpdateWithoutLevelsInput, ZoneUncheckedUpdateWithoutLevelsInput>
    create: XOR<ZoneCreateWithoutLevelsInput, ZoneUncheckedCreateWithoutLevelsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutLevelsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutLevelsInput, ZoneUncheckedUpdateWithoutLevelsInput>
  }

  export type ZoneUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZonesNestedInput
    gempo?: GempoUpdateOneWithoutZoneNestedInput
    championship?: ChampionshipUpdateOneWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempo?: GempoUncheckedUpdateOneWithoutZoneNestedInput
    championship?: ChampionshipUncheckedUpdateOneWithoutZoneNestedInput
  }

  export type SubLevelUpsertWithWhereUniqueWithoutLevelInput = {
    where: SubLevelWhereUniqueInput
    update: XOR<SubLevelUpdateWithoutLevelInput, SubLevelUncheckedUpdateWithoutLevelInput>
    create: XOR<SubLevelCreateWithoutLevelInput, SubLevelUncheckedCreateWithoutLevelInput>
  }

  export type SubLevelUpdateWithWhereUniqueWithoutLevelInput = {
    where: SubLevelWhereUniqueInput
    data: XOR<SubLevelUpdateWithoutLevelInput, SubLevelUncheckedUpdateWithoutLevelInput>
  }

  export type SubLevelUpdateManyWithWhereWithoutLevelInput = {
    where: SubLevelScalarWhereInput
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyWithoutLevelInput>
  }

  export type SubLevelScalarWhereInput = {
    AND?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
    OR?: SubLevelScalarWhereInput[]
    NOT?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
    id?: StringFilter<"SubLevel"> | string
    subLevelId?: StringFilter<"SubLevel"> | string
    levelId?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
  }

  export type LevelCreateWithoutSubLevelsInput = {
    id?: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutLevelsInput
  }

  export type LevelUncheckedCreateWithoutSubLevelsInput = {
    id?: string
    levelId: string
    zoneId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelCreateOrConnectWithoutSubLevelsInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutSubLevelsInput, LevelUncheckedCreateWithoutSubLevelsInput>
  }

  export type InnerLevelCreateWithoutSubLevelInput = {
    id?: string
    innerLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelUncheckedCreateWithoutSubLevelInput = {
    id?: string
    innerLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelCreateOrConnectWithoutSubLevelInput = {
    where: InnerLevelWhereUniqueInput
    create: XOR<InnerLevelCreateWithoutSubLevelInput, InnerLevelUncheckedCreateWithoutSubLevelInput>
  }

  export type InnerLevelCreateManySubLevelInputEnvelope = {
    data: InnerLevelCreateManySubLevelInput | InnerLevelCreateManySubLevelInput[]
    skipDuplicates?: boolean
  }

  export type LevelUpsertWithoutSubLevelsInput = {
    update: XOR<LevelUpdateWithoutSubLevelsInput, LevelUncheckedUpdateWithoutSubLevelsInput>
    create: XOR<LevelCreateWithoutSubLevelsInput, LevelUncheckedCreateWithoutSubLevelsInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutSubLevelsInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutSubLevelsInput, LevelUncheckedUpdateWithoutSubLevelsInput>
  }

  export type LevelUpdateWithoutSubLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutLevelsNestedInput
  }

  export type LevelUncheckedUpdateWithoutSubLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUpsertWithWhereUniqueWithoutSubLevelInput = {
    where: InnerLevelWhereUniqueInput
    update: XOR<InnerLevelUpdateWithoutSubLevelInput, InnerLevelUncheckedUpdateWithoutSubLevelInput>
    create: XOR<InnerLevelCreateWithoutSubLevelInput, InnerLevelUncheckedCreateWithoutSubLevelInput>
  }

  export type InnerLevelUpdateWithWhereUniqueWithoutSubLevelInput = {
    where: InnerLevelWhereUniqueInput
    data: XOR<InnerLevelUpdateWithoutSubLevelInput, InnerLevelUncheckedUpdateWithoutSubLevelInput>
  }

  export type InnerLevelUpdateManyWithWhereWithoutSubLevelInput = {
    where: InnerLevelScalarWhereInput
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyWithoutSubLevelInput>
  }

  export type InnerLevelScalarWhereInput = {
    AND?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
    OR?: InnerLevelScalarWhereInput[]
    NOT?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
    id?: StringFilter<"InnerLevel"> | string
    innerLevelId?: StringFilter<"InnerLevel"> | string
    subLevelId?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
  }

  export type SubLevelCreateWithoutInnerLevelsInput = {
    id?: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level: LevelCreateNestedOneWithoutSubLevelsInput
  }

  export type SubLevelUncheckedCreateWithoutInnerLevelsInput = {
    id?: string
    subLevelId: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubLevelCreateOrConnectWithoutInnerLevelsInput = {
    where: SubLevelWhereUniqueInput
    create: XOR<SubLevelCreateWithoutInnerLevelsInput, SubLevelUncheckedCreateWithoutInnerLevelsInput>
  }

  export type SubLevelUpsertWithoutInnerLevelsInput = {
    update: XOR<SubLevelUpdateWithoutInnerLevelsInput, SubLevelUncheckedUpdateWithoutInnerLevelsInput>
    create: XOR<SubLevelCreateWithoutInnerLevelsInput, SubLevelUncheckedCreateWithoutInnerLevelsInput>
    where?: SubLevelWhereInput
  }

  export type SubLevelUpdateToOneWithWhereWithoutInnerLevelsInput = {
    where?: SubLevelWhereInput
    data: XOR<SubLevelUpdateWithoutInnerLevelsInput, SubLevelUncheckedUpdateWithoutInnerLevelsInput>
  }

  export type SubLevelUpdateWithoutInnerLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: LevelUpdateOneRequiredWithoutSubLevelsNestedInput
  }

  export type SubLevelUncheckedUpdateWithoutInnerLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateWithoutGempoInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZonesInput
    levels?: LevelCreateNestedManyWithoutZoneInput
    championship?: ChampionshipCreateNestedOneWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutGempoInput = {
    id?: string
    zoneId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    levels?: LevelUncheckedCreateNestedManyWithoutZoneInput
    championship?: ChampionshipUncheckedCreateNestedOneWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutGempoInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutGempoInput, ZoneUncheckedCreateWithoutGempoInput>
  }

  export type GempoRecordCreateWithoutGempoInput = {
    id?: string
    recordId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordUncheckedCreateWithoutGempoInput = {
    id?: string
    recordId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordCreateOrConnectWithoutGempoInput = {
    where: GempoRecordWhereUniqueInput
    create: XOR<GempoRecordCreateWithoutGempoInput, GempoRecordUncheckedCreateWithoutGempoInput>
  }

  export type GempoRecordCreateManyGempoInputEnvelope = {
    data: GempoRecordCreateManyGempoInput | GempoRecordCreateManyGempoInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithoutGempoInput = {
    update: XOR<ZoneUpdateWithoutGempoInput, ZoneUncheckedUpdateWithoutGempoInput>
    create: XOR<ZoneCreateWithoutGempoInput, ZoneUncheckedCreateWithoutGempoInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutGempoInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutGempoInput, ZoneUncheckedUpdateWithoutGempoInput>
  }

  export type ZoneUpdateWithoutGempoInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZonesNestedInput
    levels?: LevelUpdateManyWithoutZoneNestedInput
    championship?: ChampionshipUpdateOneWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutGempoInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    levels?: LevelUncheckedUpdateManyWithoutZoneNestedInput
    championship?: ChampionshipUncheckedUpdateOneWithoutZoneNestedInput
  }

  export type GempoRecordUpsertWithWhereUniqueWithoutGempoInput = {
    where: GempoRecordWhereUniqueInput
    update: XOR<GempoRecordUpdateWithoutGempoInput, GempoRecordUncheckedUpdateWithoutGempoInput>
    create: XOR<GempoRecordCreateWithoutGempoInput, GempoRecordUncheckedCreateWithoutGempoInput>
  }

  export type GempoRecordUpdateWithWhereUniqueWithoutGempoInput = {
    where: GempoRecordWhereUniqueInput
    data: XOR<GempoRecordUpdateWithoutGempoInput, GempoRecordUncheckedUpdateWithoutGempoInput>
  }

  export type GempoRecordUpdateManyWithWhereWithoutGempoInput = {
    where: GempoRecordScalarWhereInput
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyWithoutGempoInput>
  }

  export type GempoRecordScalarWhereInput = {
    AND?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
    OR?: GempoRecordScalarWhereInput[]
    NOT?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
    id?: StringFilter<"GempoRecord"> | string
    recordId?: StringFilter<"GempoRecord"> | string
    gempoId?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
  }

  export type ZoneCreateWithoutChampionshipInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZonesInput
    levels?: LevelCreateNestedManyWithoutZoneInput
    gempo?: GempoCreateNestedOneWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutChampionshipInput = {
    id?: string
    zoneId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    levels?: LevelUncheckedCreateNestedManyWithoutZoneInput
    gempo?: GempoUncheckedCreateNestedOneWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutChampionshipInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutChampionshipInput, ZoneUncheckedCreateWithoutChampionshipInput>
  }

  export type ChampionshipRecordCreateWithoutChampionshipInput = {
    id?: string
    recordId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordUncheckedCreateWithoutChampionshipInput = {
    id?: string
    recordId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordCreateOrConnectWithoutChampionshipInput = {
    where: ChampionshipRecordWhereUniqueInput
    create: XOR<ChampionshipRecordCreateWithoutChampionshipInput, ChampionshipRecordUncheckedCreateWithoutChampionshipInput>
  }

  export type ChampionshipRecordCreateManyChampionshipInputEnvelope = {
    data: ChampionshipRecordCreateManyChampionshipInput | ChampionshipRecordCreateManyChampionshipInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithoutChampionshipInput = {
    update: XOR<ZoneUpdateWithoutChampionshipInput, ZoneUncheckedUpdateWithoutChampionshipInput>
    create: XOR<ZoneCreateWithoutChampionshipInput, ZoneUncheckedCreateWithoutChampionshipInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutChampionshipInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutChampionshipInput, ZoneUncheckedUpdateWithoutChampionshipInput>
  }

  export type ZoneUpdateWithoutChampionshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZonesNestedInput
    levels?: LevelUpdateManyWithoutZoneNestedInput
    gempo?: GempoUpdateOneWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutChampionshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    levels?: LevelUncheckedUpdateManyWithoutZoneNestedInput
    gempo?: GempoUncheckedUpdateOneWithoutZoneNestedInput
  }

  export type ChampionshipRecordUpsertWithWhereUniqueWithoutChampionshipInput = {
    where: ChampionshipRecordWhereUniqueInput
    update: XOR<ChampionshipRecordUpdateWithoutChampionshipInput, ChampionshipRecordUncheckedUpdateWithoutChampionshipInput>
    create: XOR<ChampionshipRecordCreateWithoutChampionshipInput, ChampionshipRecordUncheckedCreateWithoutChampionshipInput>
  }

  export type ChampionshipRecordUpdateWithWhereUniqueWithoutChampionshipInput = {
    where: ChampionshipRecordWhereUniqueInput
    data: XOR<ChampionshipRecordUpdateWithoutChampionshipInput, ChampionshipRecordUncheckedUpdateWithoutChampionshipInput>
  }

  export type ChampionshipRecordUpdateManyWithWhereWithoutChampionshipInput = {
    where: ChampionshipRecordScalarWhereInput
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyWithoutChampionshipInput>
  }

  export type ChampionshipRecordScalarWhereInput = {
    AND?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
    OR?: ChampionshipRecordScalarWhereInput[]
    NOT?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
    id?: StringFilter<"ChampionshipRecord"> | string
    recordId?: StringFilter<"ChampionshipRecord"> | string
    championshipId?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
  }

  export type GempoCreateWithoutRecordsInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutGempoInput
  }

  export type GempoUncheckedCreateWithoutRecordsInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    gempoId: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoCreateOrConnectWithoutRecordsInput = {
    where: GempoWhereUniqueInput
    create: XOR<GempoCreateWithoutRecordsInput, GempoUncheckedCreateWithoutRecordsInput>
  }

  export type GempoUpsertWithoutRecordsInput = {
    update: XOR<GempoUpdateWithoutRecordsInput, GempoUncheckedUpdateWithoutRecordsInput>
    create: XOR<GempoCreateWithoutRecordsInput, GempoUncheckedCreateWithoutRecordsInput>
    where?: GempoWhereInput
  }

  export type GempoUpdateToOneWithWhereWithoutRecordsInput = {
    where?: GempoWhereInput
    data: XOR<GempoUpdateWithoutRecordsInput, GempoUncheckedUpdateWithoutRecordsInput>
  }

  export type GempoUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutGempoNestedInput
  }

  export type GempoUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gempoId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipCreateWithoutRecordsInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: ZoneCreateNestedOneWithoutChampionshipInput
  }

  export type ChampionshipUncheckedCreateWithoutRecordsInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    championshipId: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipCreateOrConnectWithoutRecordsInput = {
    where: ChampionshipWhereUniqueInput
    create: XOR<ChampionshipCreateWithoutRecordsInput, ChampionshipUncheckedCreateWithoutRecordsInput>
  }

  export type ChampionshipUpsertWithoutRecordsInput = {
    update: XOR<ChampionshipUpdateWithoutRecordsInput, ChampionshipUncheckedUpdateWithoutRecordsInput>
    create: XOR<ChampionshipCreateWithoutRecordsInput, ChampionshipUncheckedCreateWithoutRecordsInput>
    where?: ChampionshipWhereInput
  }

  export type ChampionshipUpdateToOneWithWhereWithoutRecordsInput = {
    where?: ChampionshipWhereInput
    data: XOR<ChampionshipUpdateWithoutRecordsInput, ChampionshipUncheckedUpdateWithoutRecordsInput>
  }

  export type ChampionshipUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutChampionshipNestedInput
  }

  export type ChampionshipUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    championshipId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserLoginInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLoginInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
  }

  export type UserUpsertWithoutUserLoginInput = {
    update: XOR<UserUpdateWithoutUserLoginInput, UserUncheckedUpdateWithoutUserLoginInput>
    create: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLoginInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLoginInput, UserUncheckedUpdateWithoutUserLoginInput>
  }

  export type UserUpdateWithoutUserLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityCreateWithoutAdminInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutAdminInput = {
    id?: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityCreateManyAdminInputEnvelope = {
    data: AdminAuthorityCreateManyAdminInput | AdminAuthorityCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminOperationHistoryCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    opAdmin: AdminCreateNestedOneWithoutOperationsInput
  }

  export type AdminOperationHistoryUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateOrConnectWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    create: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput>
  }

  export type AdminOperationHistoryCreateManyAdminInputEnvelope = {
    data: AdminOperationHistoryCreateManyAdminInput | AdminOperationHistoryCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminOperationHistoryCreateWithoutOpAdminInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    admin: AdminCreateNestedOneWithoutOperationHistoriesInput
  }

  export type AdminOperationHistoryUncheckedCreateWithoutOpAdminInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateOrConnectWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    create: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryCreateManyOpAdminInputEnvelope = {
    data: AdminOperationHistoryCreateManyOpAdminInput | AdminOperationHistoryCreateManyOpAdminInput[]
    skipDuplicates?: boolean
  }

  export type BannerCreateWithoutAdminInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutAdminInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutAdminInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput>
  }

  export type BannerCreateManyAdminInputEnvelope = {
    data: BannerCreateManyAdminInput | BannerCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
  }

  export type AdminTransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
  }

  export type AdminTransactionCreateOrConnectWithoutCustomerInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutCustomerInput, AdminTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type AdminTransactionCreateManyCustomerInputEnvelope = {
    data: AdminTransactionCreateManyCustomerInput | AdminTransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionArchiveCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionArchiveCreatezonesInput | string[]
  }

  export type AdminTransactionArchiveUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionArchiveCreatezonesInput | string[]
  }

  export type AdminTransactionArchiveCreateOrConnectWithoutCustomerInput = {
    where: AdminTransactionArchiveWhereUniqueInput
    create: XOR<AdminTransactionArchiveCreateWithoutCustomerInput, AdminTransactionArchiveUncheckedCreateWithoutCustomerInput>
  }

  export type AdminTransactionArchiveCreateManyCustomerInputEnvelope = {
    data: AdminTransactionArchiveCreateManyCustomerInput | AdminTransactionArchiveCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutAdminInput, AdminAuthorityUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutAdminInput, AdminAuthorityUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    update: XOR<AdminOperationHistoryUpdateWithoutAdminInput, AdminOperationHistoryUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput>
  }

  export type AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    data: XOR<AdminOperationHistoryUpdateWithoutAdminInput, AdminOperationHistoryUncheckedUpdateWithoutAdminInput>
  }

  export type AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput = {
    where: AdminOperationHistoryScalarWhereInput
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminOperationHistoryScalarWhereInput = {
    AND?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
    OR?: AdminOperationHistoryScalarWhereInput[]
    NOT?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
  }

  export type AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    update: XOR<AdminOperationHistoryUpdateWithoutOpAdminInput, AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput>
    create: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    data: XOR<AdminOperationHistoryUpdateWithoutOpAdminInput, AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput = {
    where: AdminOperationHistoryScalarWhereInput
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminInput>
  }

  export type BannerUpsertWithWhereUniqueWithoutAdminInput = {
    where: BannerWhereUniqueInput
    update: XOR<BannerUpdateWithoutAdminInput, BannerUncheckedUpdateWithoutAdminInput>
    create: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput>
  }

  export type BannerUpdateWithWhereUniqueWithoutAdminInput = {
    where: BannerWhereUniqueInput
    data: XOR<BannerUpdateWithoutAdminInput, BannerUncheckedUpdateWithoutAdminInput>
  }

  export type BannerUpdateManyWithWhereWithoutAdminInput = {
    where: BannerScalarWhereInput
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyWithoutAdminInput>
  }

  export type BannerScalarWhereInput = {
    AND?: BannerScalarWhereInput | BannerScalarWhereInput[]
    OR?: BannerScalarWhereInput[]
    NOT?: BannerScalarWhereInput | BannerScalarWhereInput[]
    id?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    adminId?: StringFilter<"Banner"> | string
  }

  export type AdminTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AdminTransactionWhereUniqueInput
    update: XOR<AdminTransactionUpdateWithoutCustomerInput, AdminTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<AdminTransactionCreateWithoutCustomerInput, AdminTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type AdminTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AdminTransactionWhereUniqueInput
    data: XOR<AdminTransactionUpdateWithoutCustomerInput, AdminTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type AdminTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: AdminTransactionScalarWhereInput
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AdminTransactionScalarWhereInput = {
    AND?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
    OR?: AdminTransactionScalarWhereInput[]
    NOT?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
    id?: StringFilter<"AdminTransaction"> | string
    transactionName?: StringFilter<"AdminTransaction"> | string
    status?: StringFilter<"AdminTransaction"> | string
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    expiredAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    customerEmail?: StringFilter<"AdminTransaction"> | string
    customerName?: StringFilter<"AdminTransaction"> | string
    customerId?: StringFilter<"AdminTransaction"> | string
    quantity?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
  }

  export type AdminTransactionArchiveUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AdminTransactionArchiveWhereUniqueInput
    update: XOR<AdminTransactionArchiveUpdateWithoutCustomerInput, AdminTransactionArchiveUncheckedUpdateWithoutCustomerInput>
    create: XOR<AdminTransactionArchiveCreateWithoutCustomerInput, AdminTransactionArchiveUncheckedCreateWithoutCustomerInput>
  }

  export type AdminTransactionArchiveUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AdminTransactionArchiveWhereUniqueInput
    data: XOR<AdminTransactionArchiveUpdateWithoutCustomerInput, AdminTransactionArchiveUncheckedUpdateWithoutCustomerInput>
  }

  export type AdminTransactionArchiveUpdateManyWithWhereWithoutCustomerInput = {
    where: AdminTransactionArchiveScalarWhereInput
    data: XOR<AdminTransactionArchiveUpdateManyMutationInput, AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AdminTransactionArchiveScalarWhereInput = {
    AND?: AdminTransactionArchiveScalarWhereInput | AdminTransactionArchiveScalarWhereInput[]
    OR?: AdminTransactionArchiveScalarWhereInput[]
    NOT?: AdminTransactionArchiveScalarWhereInput | AdminTransactionArchiveScalarWhereInput[]
    id?: StringFilter<"AdminTransactionArchive"> | string
    transactionName?: StringFilter<"AdminTransactionArchive"> | string
    status?: StringFilter<"AdminTransactionArchive"> | string
    createdAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    expiredAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransactionArchive"> | Date | string
    customerEmail?: StringFilter<"AdminTransactionArchive"> | string
    customerName?: StringFilter<"AdminTransactionArchive"> | string
    customerId?: StringFilter<"AdminTransactionArchive"> | string
    quantity?: IntFilter<"AdminTransactionArchive"> | number
    zones?: StringNullableListFilter<"AdminTransactionArchive">
  }

  export type AdminCreateWithoutOperationHistoriesInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutOperationHistoriesInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutOperationHistoriesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
  }

  export type AdminCreateWithoutOperationsInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutOperationsInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutOperationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
  }

  export type AdminUpsertWithoutOperationHistoriesInput = {
    update: XOR<AdminUpdateWithoutOperationHistoriesInput, AdminUncheckedUpdateWithoutOperationHistoriesInput>
    create: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOperationHistoriesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOperationHistoriesInput, AdminUncheckedUpdateWithoutOperationHistoriesInput>
  }

  export type AdminUpdateWithoutOperationHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutOperationHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUpsertWithoutOperationsInput = {
    update: XOR<AdminUpdateWithoutOperationsInput, AdminUncheckedUpdateWithoutOperationsInput>
    create: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOperationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOperationsInput, AdminUncheckedUpdateWithoutOperationsInput>
  }

  export type AdminUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AdminCreateWithoutAuthorityInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutAuthorityInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutAuthorityInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
  }

  export type ProvinceCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutAdminAuthorityInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type CityCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SchoolCreateWithoutAdminAuthorityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type AdminUpsertWithoutAuthorityInput = {
    update: XOR<AdminUpdateWithoutAuthorityInput, AdminUncheckedUpdateWithoutAuthorityInput>
    create: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuthorityInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuthorityInput, AdminUncheckedUpdateWithoutAuthorityInput>
  }

  export type AdminUpdateWithoutAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProvinceUpsertWithoutAdminAuthorityInput = {
    update: XOR<ProvinceUpdateWithoutAdminAuthorityInput, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutAdminAuthorityInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutAdminAuthorityInput, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type ProvinceUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutAdminAuthorityInput, CityUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type CityUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutAdminAuthorityInput, CityUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type CityUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutAdminAuthorityInput, SchoolUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutAdminAuthorityInput, SchoolUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type SchoolUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type BannerVisitorCreateWithoutBannerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    user: UserCreateNestedOneWithoutBannerVisitorInput
  }

  export type BannerVisitorUncheckedCreateWithoutBannerInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorCreateOrConnectWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    create: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput>
  }

  export type BannerVisitorCreateManyBannerInputEnvelope = {
    data: BannerVisitorCreateManyBannerInput | BannerVisitorCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutBannerInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutBannerInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutBannerInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
  }

  export type BannerLocationCreateWithoutBannerInput = {
    id?: string
    province: ProvinceCreateNestedOneWithoutBannerLocationInput
    cities?: CityCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateWithoutBannerInput = {
    id?: string
    provinceId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationCreateOrConnectWithoutBannerInput = {
    where: BannerLocationWhereUniqueInput
    create: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput>
  }

  export type BannerLocationCreateManyBannerInputEnvelope = {
    data: BannerLocationCreateManyBannerInput | BannerLocationCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type BannerVisitorUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    update: XOR<BannerVisitorUpdateWithoutBannerInput, BannerVisitorUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput>
  }

  export type BannerVisitorUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    data: XOR<BannerVisitorUpdateWithoutBannerInput, BannerVisitorUncheckedUpdateWithoutBannerInput>
  }

  export type BannerVisitorUpdateManyWithWhereWithoutBannerInput = {
    where: BannerVisitorScalarWhereInput
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyWithoutBannerInput>
  }

  export type AdminUpsertWithoutBannerInput = {
    update: XOR<AdminUpdateWithoutBannerInput, AdminUncheckedUpdateWithoutBannerInput>
    create: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutBannerInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutBannerInput, AdminUncheckedUpdateWithoutBannerInput>
  }

  export type AdminUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BannerLocationUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerLocationWhereUniqueInput
    update: XOR<BannerLocationUpdateWithoutBannerInput, BannerLocationUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput>
  }

  export type BannerLocationUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerLocationWhereUniqueInput
    data: XOR<BannerLocationUpdateWithoutBannerInput, BannerLocationUncheckedUpdateWithoutBannerInput>
  }

  export type BannerLocationUpdateManyWithWhereWithoutBannerInput = {
    where: BannerLocationScalarWhereInput
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyWithoutBannerInput>
  }

  export type BannerCreateWithoutBannerLocationInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
    admin: AdminCreateNestedOneWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutBannerLocationInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutBannerLocationInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
  }

  export type ProvinceCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutBannerLocationInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
  }

  export type CityCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutBannerLocationInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput>
  }

  export type BannerUpsertWithoutBannerLocationInput = {
    update: XOR<BannerUpdateWithoutBannerLocationInput, BannerUncheckedUpdateWithoutBannerLocationInput>
    create: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutBannerLocationInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutBannerLocationInput, BannerUncheckedUpdateWithoutBannerLocationInput>
  }

  export type BannerUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type ProvinceUpsertWithoutBannerLocationInput = {
    update: XOR<ProvinceUpdateWithoutBannerLocationInput, ProvinceUncheckedUpdateWithoutBannerLocationInput>
    create: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutBannerLocationInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutBannerLocationInput, ProvinceUncheckedUpdateWithoutBannerLocationInput>
  }

  export type ProvinceUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutBannerLocationInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutBannerLocationInput, CityUncheckedUpdateWithoutBannerLocationInput>
    create: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput>
  }

  export type CityUpdateWithWhereUniqueWithoutBannerLocationInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutBannerLocationInput, CityUncheckedUpdateWithoutBannerLocationInput>
  }

  export type CityUpdateManyWithWhereWithoutBannerLocationInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutBannerLocationInput>
  }

  export type BannerCreateWithoutVisitorsInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    admin: AdminCreateNestedOneWithoutBannerInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutVisitorsInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutVisitorsInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
  }

  export type UserCreateWithoutBannerVisitorInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBannerVisitorInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBannerVisitorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
  }

  export type BannerUpsertWithoutVisitorsInput = {
    update: XOR<BannerUpdateWithoutVisitorsInput, BannerUncheckedUpdateWithoutVisitorsInput>
    create: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutVisitorsInput, BannerUncheckedUpdateWithoutVisitorsInput>
  }

  export type BannerUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type UserUpsertWithoutBannerVisitorInput = {
    update: XOR<UserUpdateWithoutBannerVisitorInput, UserUncheckedUpdateWithoutBannerVisitorInput>
    create: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBannerVisitorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBannerVisitorInput, UserUncheckedUpdateWithoutBannerVisitorInput>
  }

  export type UserUpdateWithoutBannerVisitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBannerVisitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TestParticipantCreateWithoutTestInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    user: UserCreateNestedOneWithoutTestParticipantInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutTestInput = {
    id?: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantCreateOrConnectWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput>
  }

  export type TestParticipantCreateManyTestInputEnvelope = {
    data: TestParticipantCreateManyTestInput | TestParticipantCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TestParticipantUpsertWithWhereUniqueWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    update: XOR<TestParticipantUpdateWithoutTestInput, TestParticipantUncheckedUpdateWithoutTestInput>
    create: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput>
  }

  export type TestParticipantUpdateWithWhereUniqueWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    data: XOR<TestParticipantUpdateWithoutTestInput, TestParticipantUncheckedUpdateWithoutTestInput>
  }

  export type TestParticipantUpdateManyWithWhereWithoutTestInput = {
    where: TestParticipantScalarWhereInput
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyWithoutTestInput>
  }

  export type TestCreateWithoutParticipantsInput = {
    id?: string
    name?: string
    category: $Enums.TestCategory
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
  }

  export type TestUncheckedCreateWithoutParticipantsInput = {
    id?: string
    name?: string
    category: $Enums.TestCategory
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
  }

  export type TestCreateOrConnectWithoutParticipantsInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTestParticipantInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestParticipantInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
  }

  export type TestParticipantRecordCreateWithoutParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutTestRecordsInput
  }

  export type TestParticipantRecordUncheckedCreateWithoutParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateOrConnectWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    create: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput>
  }

  export type TestParticipantRecordCreateManyParticipantInputEnvelope = {
    data: TestParticipantRecordCreateManyParticipantInput | TestParticipantRecordCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TestUpsertWithoutParticipantsInput = {
    update: XOR<TestUpdateWithoutParticipantsInput, TestUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    where?: TestWhereInput
  }

  export type TestUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TestWhereInput
    data: XOR<TestUpdateWithoutParticipantsInput, TestUncheckedUpdateWithoutParticipantsInput>
  }

  export type TestUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumTestCategoryFieldUpdateOperationsInput | $Enums.TestCategory
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumTestCategoryFieldUpdateOperationsInput | $Enums.TestCategory
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutTestParticipantInput = {
    update: XOR<UserUpdateWithoutTestParticipantInput, UserUncheckedUpdateWithoutTestParticipantInput>
    create: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestParticipantInput, UserUncheckedUpdateWithoutTestParticipantInput>
  }

  export type UserUpdateWithoutTestParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    update: XOR<TestParticipantRecordUpdateWithoutParticipantInput, TestParticipantRecordUncheckedUpdateWithoutParticipantInput>
    create: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput>
  }

  export type TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    data: XOR<TestParticipantRecordUpdateWithoutParticipantInput, TestParticipantRecordUncheckedUpdateWithoutParticipantInput>
  }

  export type TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput = {
    where: TestParticipantRecordScalarWhereInput
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyWithoutParticipantInput>
  }

  export type TestParticipantCreateWithoutRecordsInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTestParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutRecordsInput = {
    id?: string
    testId: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
  }

  export type TestParticipantCreateOrConnectWithoutRecordsInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
  }

  export type UserCreateWithoutTestRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestRecordsInput, UserUncheckedCreateWithoutTestRecordsInput>
  }

  export type TestParticipantUpsertWithoutRecordsInput = {
    update: XOR<TestParticipantUpdateWithoutRecordsInput, TestParticipantUncheckedUpdateWithoutRecordsInput>
    create: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    where?: TestParticipantWhereInput
  }

  export type TestParticipantUpdateToOneWithWhereWithoutRecordsInput = {
    where?: TestParticipantWhereInput
    data: XOR<TestParticipantUpdateWithoutRecordsInput, TestParticipantUncheckedUpdateWithoutRecordsInput>
  }

  export type TestParticipantUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutTestRecordsInput = {
    update: XOR<UserUpdateWithoutTestRecordsInput, UserUncheckedUpdateWithoutTestRecordsInput>
    create: XOR<UserCreateWithoutTestRecordsInput, UserUncheckedCreateWithoutTestRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestRecordsInput, UserUncheckedUpdateWithoutTestRecordsInput>
  }

  export type UserUpdateWithoutTestRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherRedemeerCreateWithoutVoucherInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutVoucherRedemeerInput
  }

  export type VoucherRedemeerUncheckedCreateWithoutVoucherInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type VoucherRedemeerCreateOrConnectWithoutVoucherInput = {
    where: VoucherRedemeerWhereUniqueInput
    create: XOR<VoucherRedemeerCreateWithoutVoucherInput, VoucherRedemeerUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherRedemeerCreateManyVoucherInputEnvelope = {
    data: VoucherRedemeerCreateManyVoucherInput | VoucherRedemeerCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type VoucherRedemeerUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherRedemeerWhereUniqueInput
    update: XOR<VoucherRedemeerUpdateWithoutVoucherInput, VoucherRedemeerUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherRedemeerCreateWithoutVoucherInput, VoucherRedemeerUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherRedemeerUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherRedemeerWhereUniqueInput
    data: XOR<VoucherRedemeerUpdateWithoutVoucherInput, VoucherRedemeerUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherRedemeerUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherRedemeerScalarWhereInput
    data: XOR<VoucherRedemeerUpdateManyMutationInput, VoucherRedemeerUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherCreateWithoutRedemeersInput = {
    code: string
    quota?: number
    currentQuota?: number
    startedAt: Date | string
    endedAt?: Date | string | null
    type?: $Enums.VoucherType
    zones?: VoucherCreatezonesInput | string[]
  }

  export type VoucherUncheckedCreateWithoutRedemeersInput = {
    id?: number
    code: string
    quota?: number
    currentQuota?: number
    startedAt: Date | string
    endedAt?: Date | string | null
    type?: $Enums.VoucherType
    zones?: VoucherCreatezonesInput | string[]
  }

  export type VoucherCreateOrConnectWithoutRedemeersInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutRedemeersInput, VoucherUncheckedCreateWithoutRedemeersInput>
  }

  export type UserCreateWithoutVoucherRedemeerInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoucherRedemeerInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoucherRedemeerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoucherRedemeerInput, UserUncheckedCreateWithoutVoucherRedemeerInput>
  }

  export type VoucherUpsertWithoutRedemeersInput = {
    update: XOR<VoucherUpdateWithoutRedemeersInput, VoucherUncheckedUpdateWithoutRedemeersInput>
    create: XOR<VoucherCreateWithoutRedemeersInput, VoucherUncheckedCreateWithoutRedemeersInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutRedemeersInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutRedemeersInput, VoucherUncheckedUpdateWithoutRedemeersInput>
  }

  export type VoucherUpdateWithoutRedemeersInput = {
    code?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    zones?: VoucherUpdatezonesInput | string[]
  }

  export type VoucherUncheckedUpdateWithoutRedemeersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    zones?: VoucherUpdatezonesInput | string[]
  }

  export type UserUpsertWithoutVoucherRedemeerInput = {
    update: XOR<UserUpdateWithoutVoucherRedemeerInput, UserUncheckedUpdateWithoutVoucherRedemeerInput>
    create: XOR<UserCreateWithoutVoucherRedemeerInput, UserUncheckedCreateWithoutVoucherRedemeerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoucherRedemeerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoucherRedemeerInput, UserUncheckedUpdateWithoutVoucherRedemeerInput>
  }

  export type UserUpdateWithoutVoucherRedemeerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoucherRedemeerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminCreateWithoutAdminTransactionInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransactionArchive?: AdminTransactionArchiveCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutAdminTransactionInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutAdminTransactionInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAdminTransactionInput, AdminUncheckedCreateWithoutAdminTransactionInput>
  }

  export type AdminUpsertWithoutAdminTransactionInput = {
    update: XOR<AdminUpdateWithoutAdminTransactionInput, AdminUncheckedUpdateWithoutAdminTransactionInput>
    create: XOR<AdminCreateWithoutAdminTransactionInput, AdminUncheckedCreateWithoutAdminTransactionInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAdminTransactionInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAdminTransactionInput, AdminUncheckedUpdateWithoutAdminTransactionInput>
  }

  export type AdminUpdateWithoutAdminTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutAdminTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransactionArchive?: AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AdminCreateWithoutAdminTransactionArchiveInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionCreateNestedManyWithoutCustomerInput
  }

  export type AdminUncheckedCreateWithoutAdminTransactionArchiveInput = {
    id?: string
    authId: string
    email: string
    name: string
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    adminTransaction?: AdminTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AdminCreateOrConnectWithoutAdminTransactionArchiveInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAdminTransactionArchiveInput, AdminUncheckedCreateWithoutAdminTransactionArchiveInput>
  }

  export type AdminUpsertWithoutAdminTransactionArchiveInput = {
    update: XOR<AdminUpdateWithoutAdminTransactionArchiveInput, AdminUncheckedUpdateWithoutAdminTransactionArchiveInput>
    create: XOR<AdminCreateWithoutAdminTransactionArchiveInput, AdminUncheckedCreateWithoutAdminTransactionArchiveInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAdminTransactionArchiveInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAdminTransactionArchiveInput, AdminUncheckedUpdateWithoutAdminTransactionArchiveInput>
  }

  export type AdminUpdateWithoutAdminTransactionArchiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type AdminUncheckedUpdateWithoutAdminTransactionArchiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    adminTransaction?: AdminTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateWithoutUserTransactionInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTransactionInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTransactionInput, UserUncheckedCreateWithoutUserTransactionInput>
  }

  export type UserUpsertWithoutUserTransactionInput = {
    update: XOR<UserUpdateWithoutUserTransactionInput, UserUncheckedUpdateWithoutUserTransactionInput>
    create: XOR<UserCreateWithoutUserTransactionInput, UserUncheckedCreateWithoutUserTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserTransactionInput, UserUncheckedUpdateWithoutUserTransactionInput>
  }

  export type UserUpdateWithoutUserTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserTransactionArchiveInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTransactionArchiveInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTransactionArchiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTransactionArchiveInput, UserUncheckedCreateWithoutUserTransactionArchiveInput>
  }

  export type UserUpsertWithoutUserTransactionArchiveInput = {
    update: XOR<UserUpdateWithoutUserTransactionArchiveInput, UserUncheckedUpdateWithoutUserTransactionArchiveInput>
    create: XOR<UserCreateWithoutUserTransactionArchiveInput, UserUncheckedCreateWithoutUserTransactionArchiveInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserTransactionArchiveInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserTransactionArchiveInput, UserUncheckedUpdateWithoutUserTransactionArchiveInput>
  }

  export type UserUpdateWithoutUserTransactionArchiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserTransactionArchiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MultiPlayerMemberCreateWithoutRoomInput = {
    id?: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    user?: UserCreateNestedOneWithoutMultiPlayerMemberInput
  }

  export type MultiPlayerMemberUncheckedCreateWithoutRoomInput = {
    id?: string
    userId?: string | null
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberCreateOrConnectWithoutRoomInput = {
    where: MultiPlayerMemberWhereUniqueInput
    create: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput>
  }

  export type MultiPlayerMemberCreateManyRoomInputEnvelope = {
    data: MultiPlayerMemberCreateManyRoomInput | MultiPlayerMemberCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput = {
    where: MultiPlayerMemberWhereUniqueInput
    update: XOR<MultiPlayerMemberUpdateWithoutRoomInput, MultiPlayerMemberUncheckedUpdateWithoutRoomInput>
    create: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput>
  }

  export type MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput = {
    where: MultiPlayerMemberWhereUniqueInput
    data: XOR<MultiPlayerMemberUpdateWithoutRoomInput, MultiPlayerMemberUncheckedUpdateWithoutRoomInput>
  }

  export type MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput = {
    where: MultiPlayerMemberScalarWhereInput
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyWithoutRoomInput>
  }

  export type UserCreateWithoutMultiPlayerMemberInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentCreateNestedManyWithoutOwnerInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userAccesses?: AccessContentCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionCreateNestedManyWithoutCustomerInput
    testRecords?: TestParticipantRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMultiPlayerMemberInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    device?: DeviceUncheckedCreateNestedOneWithoutUserInput
    ownedAccesses?: AccessContentUncheckedCreateNestedManyWithoutOwnerInput
    userAccesses?: AccessContentUncheckedCreateNestedManyWithoutUserAccessesInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    redeemedAccesses?: AccessContentUncheckedCreateNestedManyWithoutRedemeersInput
    UserLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    voucherRedemeer?: VoucherRedemeerUncheckedCreateNestedManyWithoutUserInput
    userTransactionArchive?: UserTransactionArchiveUncheckedCreateNestedManyWithoutCustomerInput
    userTransaction?: UserTransactionUncheckedCreateNestedManyWithoutCustomerInput
    testRecords?: TestParticipantRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMultiPlayerMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
  }

  export type MultiplayerRoomCreateWithoutMembersInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultiplayerRoomUncheckedCreateWithoutMembersInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultiplayerRoomCreateOrConnectWithoutMembersInput = {
    where: MultiplayerRoomWhereUniqueInput
    create: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutMultiPlayerMemberInput = {
    update: XOR<UserUpdateWithoutMultiPlayerMemberInput, UserUncheckedUpdateWithoutMultiPlayerMemberInput>
    create: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMultiPlayerMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMultiPlayerMemberInput, UserUncheckedUpdateWithoutMultiPlayerMemberInput>
  }

  export type UserUpdateWithoutMultiPlayerMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMultiPlayerMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MultiplayerRoomUpsertWithoutMembersInput = {
    update: XOR<MultiplayerRoomUpdateWithoutMembersInput, MultiplayerRoomUncheckedUpdateWithoutMembersInput>
    create: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
    where?: MultiplayerRoomWhereInput
  }

  export type MultiplayerRoomUpdateToOneWithWhereWithoutMembersInput = {
    where?: MultiplayerRoomWhereInput
    data: XOR<MultiplayerRoomUpdateWithoutMembersInput, MultiplayerRoomUncheckedUpdateWithoutMembersInput>
  }

  export type MultiplayerRoomUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiplayerRoomUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateManyProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolCreateManyProvinceInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminAuthorityCreateManyProvinceInput = {
    id?: string
    adminId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type BannerLocationCreateManyProvinceInput = {
    id?: string
    bannerId: string
  }

  export type CityUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerLocationUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: BannerUpdateOneRequiredWithoutBannerLocationNestedInput
    cities?: CityUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolCreateManyCityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type SchoolUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerLocationUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: BannerUpdateOneRequiredWithoutBannerLocationNestedInput
    province?: ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerLocationUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManySchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity?: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: number
    inventory?: UserCreateinventoryInput | number[]
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    storageId?: string | null
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type UserUpdateWithoutUserAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    redeemedAccesses?: AccessContentUncheckedUpdateManyWithoutRedemeersNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutRedeemedAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUpdateManyWithoutOwnerNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userAccesses?: AccessContentUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    UserLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRedeemedAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    device?: DeviceUncheckedUpdateOneWithoutUserNestedInput
    ownedAccesses?: AccessContentUncheckedUpdateManyWithoutOwnerNestedInput
    userAccesses?: AccessContentUncheckedUpdateManyWithoutUserAccessesNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    UserLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    voucherRedemeer?: VoucherRedemeerUncheckedUpdateManyWithoutUserNestedInput
    userTransactionArchive?: UserTransactionArchiveUncheckedUpdateManyWithoutCustomerNestedInput
    userTransaction?: UserTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    testRecords?: TestParticipantRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRedeemedAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: IntFieldUpdateOperationsInput | number
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    storageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AccessContentCreateManyOwnerInput = {
    id?: string
    expired: Date | string
    quota: number
    currentQuota: number
    zones?: AccessContentCreatezonesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneCreateManyUserInput = {
    id?: string
    zoneId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLoginCreateManyUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type BannerVisitorCreateManyUserInput = {
    id?: string
    bannerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type TestParticipantCreateManyUserInput = {
    id?: string
    testId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
  }

  export type VoucherRedemeerCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    voucherId: number
  }

  export type UserTransactionArchiveCreateManyCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionArchiveCreatezonesInput | string[]
  }

  export type UserTransactionCreateManyCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: UserTransactionCreatezonesInput | string[]
  }

  export type MultiPlayerMemberCreateManyUserInput = {
    id?: string
    roomId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type TestParticipantRecordCreateManyUserInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type AccessContentUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAccesses?: UserUpdateManyWithoutUserAccessesNestedInput
    redemeers?: UserUpdateManyWithoutRedeemedAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAccesses?: UserUncheckedUpdateManyWithoutUserAccessesNestedInput
    redemeers?: UserUncheckedUpdateManyWithoutRedeemedAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessContentUpdateWithoutUserAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedAccessesNestedInput
    redemeers?: UserUpdateManyWithoutRedeemedAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateWithoutUserAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemeers?: UserUncheckedUpdateManyWithoutRedeemedAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateManyWithoutUserAccessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    levels?: LevelUpdateManyWithoutZoneNestedInput
    gempo?: GempoUpdateOneWithoutZoneNestedInput
    championship?: ChampionshipUpdateOneWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    levels?: LevelUncheckedUpdateManyWithoutZoneNestedInput
    gempo?: GempoUncheckedUpdateOneWithoutZoneNestedInput
    championship?: ChampionshipUncheckedUpdateOneWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessContentUpdateWithoutRedemeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneWithoutOwnedAccessesNestedInput
    userAccesses?: UserUpdateManyWithoutUserAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateWithoutRedemeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAccesses?: UserUncheckedUpdateManyWithoutUserAccessesNestedInput
  }

  export type AccessContentUncheckedUpdateManyWithoutRedemeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    expired?: DateTimeFieldUpdateOperationsInput | Date | string
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    zones?: AccessContentUpdatezonesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerVisitorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    banner?: BannerUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type BannerVisitorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type TestParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
  }

  export type VoucherRedemeerUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucher?: VoucherUpdateOneRequiredWithoutRedemeersNestedInput
  }

  export type VoucherRedemeerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherId?: IntFieldUpdateOperationsInput | number
  }

  export type VoucherRedemeerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherId?: IntFieldUpdateOperationsInput | number
  }

  export type UserTransactionArchiveUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
  }

  export type UserTransactionArchiveUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
  }

  export type UserTransactionArchiveUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionArchiveUpdatezonesInput | string[]
  }

  export type UserTransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
  }

  export type UserTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
  }

  export type UserTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: UserTransactionUpdatezonesInput | string[]
  }

  export type MultiPlayerMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    room?: MultiplayerRoomUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MultiPlayerMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestParticipantRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    participant?: TestParticipantUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type TestParticipantRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type LevelCreateManyZoneInput = {
    id?: string
    levelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subLevels?: SubLevelUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subLevels?: SubLevelUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubLevelCreateManyLevelInput = {
    id?: string
    subLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubLevelUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    innerLevels?: InnerLevelUpdateManyWithoutSubLevelNestedInput
  }

  export type SubLevelUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutSubLevelNestedInput
  }

  export type SubLevelUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    subLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelCreateManySubLevelInput = {
    id?: string
    innerLevelId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelUpdateWithoutSubLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUncheckedUpdateWithoutSubLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUncheckedUpdateManyWithoutSubLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    innerLevelId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordCreateManyGempoInput = {
    id?: string
    recordId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordUpdateWithoutGempoInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUncheckedUpdateWithoutGempoInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUncheckedUpdateManyWithoutGempoInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordCreateManyChampionshipInput = {
    id?: string
    recordId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordUpdateWithoutChampionshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUncheckedUpdateWithoutChampionshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUncheckedUpdateManyWithoutChampionshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuthorityCreateManyAdminInput = {
    id?: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type AdminOperationHistoryCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateManyOpAdminInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    operation?: $Enums.Operation
  }

  export type BannerCreateManyAdminInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
  }

  export type AdminTransactionCreateManyCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
  }

  export type AdminTransactionArchiveCreateManyCustomerInput = {
    id?: string
    transactionName: string
    status: string
    createdAt?: Date | string
    expiredAt: Date | string
    updatedAt?: Date | string
    customerEmail: string
    customerName: string
    quantity?: number
    zones?: AdminTransactionArchiveCreatezonesInput | string[]
  }

  export type AdminAuthorityUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminOperationHistoryUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    opAdmin?: AdminUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUpdateWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    admin?: AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type BannerUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminTransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
  }

  export type AdminTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
  }

  export type AdminTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
  }

  export type AdminTransactionArchiveUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
  }

  export type AdminTransactionArchiveUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
  }

  export type AdminTransactionArchiveUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionArchiveUpdatezonesInput | string[]
  }

  export type CityUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerVisitorCreateManyBannerInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerLocationCreateManyBannerInput = {
    id?: string
    provinceId: string
  }

  export type BannerVisitorUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBannerVisitorNestedInput
  }

  export type BannerVisitorUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerLocationUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    province?: ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput
    cities?: CityUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type CityUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateManyWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestParticipantCreateManyTestInput = {
    id?: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    average?: number
    lowscore?: number
  }

  export type TestParticipantUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    average?: FloatFieldUpdateOperationsInput | number
    lowscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantRecordCreateManyParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutTestRecordsNestedInput
  }

  export type TestParticipantRecordUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type VoucherRedemeerCreateManyVoucherInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type VoucherRedemeerUpdateWithoutVoucherInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoucherRedemeerNestedInput
  }

  export type VoucherRedemeerUncheckedUpdateWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherRedemeerUncheckedUpdateManyWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MultiPlayerMemberCreateManyRoomInput = {
    id?: string
    userId?: string | null
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutMultiPlayerMemberNestedInput
  }

  export type MultiPlayerMemberUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}