
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Province
 * 
 */
export type Province = $Result.DefaultSelection<Prisma.$ProvincePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Subdistrict
 * 
 */
export type Subdistrict = $Result.DefaultSelection<Prisma.$SubdistrictPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model SubLevel
 * 
 */
export type SubLevel = $Result.DefaultSelection<Prisma.$SubLevelPayload>
/**
 * Model InnerLevel
 * 
 */
export type InnerLevel = $Result.DefaultSelection<Prisma.$InnerLevelPayload>
/**
 * Model Gempo
 * 
 */
export type Gempo = $Result.DefaultSelection<Prisma.$GempoPayload>
/**
 * Model Championship
 * 
 */
export type Championship = $Result.DefaultSelection<Prisma.$ChampionshipPayload>
/**
 * Model GempoRecord
 * 
 */
export type GempoRecord = $Result.DefaultSelection<Prisma.$GempoRecordPayload>
/**
 * Model ChampionshipRecord
 * 
 */
export type ChampionshipRecord = $Result.DefaultSelection<Prisma.$ChampionshipRecordPayload>
/**
 * Model UserLogin
 * 
 */
export type UserLogin = $Result.DefaultSelection<Prisma.$UserLoginPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminLog
 * 
 */
export type AdminLog = $Result.DefaultSelection<Prisma.$AdminLogPayload>
/**
 * Model AdminOperationHistory
 * 
 */
export type AdminOperationHistory = $Result.DefaultSelection<Prisma.$AdminOperationHistoryPayload>
/**
 * Model AdminAuthority
 * 
 */
export type AdminAuthority = $Result.DefaultSelection<Prisma.$AdminAuthorityPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model BannerVisitor
 * 
 */
export type BannerVisitor = $Result.DefaultSelection<Prisma.$BannerVisitorPayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model TestParticipant
 * 
 */
export type TestParticipant = $Result.DefaultSelection<Prisma.$TestParticipantPayload>
/**
 * Model TestParticipantRecord
 * 
 */
export type TestParticipantRecord = $Result.DefaultSelection<Prisma.$TestParticipantRecordPayload>
/**
 * Model Background
 * 
 */
export type Background = $Result.DefaultSelection<Prisma.$BackgroundPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model AdminTransaction
 * 
 */
export type AdminTransaction = $Result.DefaultSelection<Prisma.$AdminTransactionPayload>
/**
 * Model RedeemCode
 * 
 */
export type RedeemCode = $Result.DefaultSelection<Prisma.$RedeemCodePayload>
/**
 * Model CodeRedeemer
 * 
 */
export type CodeRedeemer = $Result.DefaultSelection<Prisma.$CodeRedeemerPayload>
/**
 * Model ChampionshipMatch
 * 
 */
export type ChampionshipMatch = $Result.DefaultSelection<Prisma.$ChampionshipMatchPayload>
/**
 * Model MatchMember
 * 
 */
export type MatchMember = $Result.DefaultSelection<Prisma.$MatchMemberPayload>
/**
 * Model ChampionshipHistory
 * 
 */
export type ChampionshipHistory = $Result.DefaultSelection<Prisma.$ChampionshipHistoryPayload>
/**
 * Model MatchHistoryMember
 * 
 */
export type MatchHistoryMember = $Result.DefaultSelection<Prisma.$MatchHistoryMemberPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  Developer: 'Developer',
  SuperAdmin: 'SuperAdmin',
  Admin: 'Admin',
  SchoolAdmin: 'SchoolAdmin',
  Teacher: 'Teacher',
  User: 'User'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AccountType: {
  LMS: 'LMS',
  Self: 'Self'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const VoucherType: {
  Discount: 'Discount',
  FixedPrice: 'FixedPrice'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const QuestionType: {
  Addition: 'Addition',
  Multiplication: 'Multiplication',
  Subtraction: 'Subtraction',
  Division: 'Division',
  Bakalkubagi: 'Bakalkubagi'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const TestType: {
  PreTest: 'PreTest',
  PostTest: 'PostTest',
  FirstPreTest: 'FirstPreTest',
  Contest: 'Contest'
};

export type TestType = (typeof TestType)[keyof typeof TestType]


export const Operation: {
  None: 'None',
  Create: 'Create',
  Update: 'Update',
  Delete: 'Delete'
};

export type Operation = (typeof Operation)[keyof typeof Operation]


export const Transaction: {
  Pending: 'Pending',
  Cancelled: 'Cancelled',
  Settlement: 'Settlement'
};

export type Transaction = (typeof Transaction)[keyof typeof Transaction]


export const EducationLevel: {
  NONE: 'NONE',
  SD: 'SD',
  SMP: 'SMP',
  SMA: 'SMA'
};

export type EducationLevel = (typeof EducationLevel)[keyof typeof EducationLevel]


export const TeamType: {
  None: 'None',
  Blue: 'Blue',
  Red: 'Red'
};

export type TeamType = (typeof TeamType)[keyof typeof TeamType]


export const MatchMode: {
  Solo: 'Solo',
  Team: 'Team'
};

export type MatchMode = (typeof MatchMode)[keyof typeof MatchMode]


export const MatchStatus: {
  None: 'None',
  Win: 'Win',
  Lose: 'Lose',
  Draw: 'Draw'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type TestType = $Enums.TestType

export const TestType: typeof $Enums.TestType

export type Operation = $Enums.Operation

export const Operation: typeof $Enums.Operation

export type Transaction = $Enums.Transaction

export const Transaction: typeof $Enums.Transaction

export type EducationLevel = $Enums.EducationLevel

export const EducationLevel: typeof $Enums.EducationLevel

export type TeamType = $Enums.TeamType

export const TeamType: typeof $Enums.TeamType

export type MatchMode = $Enums.MatchMode

export const MatchMode: typeof $Enums.MatchMode

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Provinces
 * const provinces = await prisma.province.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Provinces
   * const provinces = await prisma.province.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.province`: Exposes CRUD operations for the **Province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.ProvinceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subdistrict`: Exposes CRUD operations for the **Subdistrict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subdistricts
    * const subdistricts = await prisma.subdistrict.findMany()
    * ```
    */
  get subdistrict(): Prisma.SubdistrictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subLevel`: Exposes CRUD operations for the **SubLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubLevels
    * const subLevels = await prisma.subLevel.findMany()
    * ```
    */
  get subLevel(): Prisma.SubLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.innerLevel`: Exposes CRUD operations for the **InnerLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InnerLevels
    * const innerLevels = await prisma.innerLevel.findMany()
    * ```
    */
  get innerLevel(): Prisma.InnerLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gempo`: Exposes CRUD operations for the **Gempo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gempos
    * const gempos = await prisma.gempo.findMany()
    * ```
    */
  get gempo(): Prisma.GempoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championship`: Exposes CRUD operations for the **Championship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Championships
    * const championships = await prisma.championship.findMany()
    * ```
    */
  get championship(): Prisma.ChampionshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gempoRecord`: Exposes CRUD operations for the **GempoRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GempoRecords
    * const gempoRecords = await prisma.gempoRecord.findMany()
    * ```
    */
  get gempoRecord(): Prisma.GempoRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championshipRecord`: Exposes CRUD operations for the **ChampionshipRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChampionshipRecords
    * const championshipRecords = await prisma.championshipRecord.findMany()
    * ```
    */
  get championshipRecord(): Prisma.ChampionshipRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLogin`: Exposes CRUD operations for the **UserLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLogins
    * const userLogins = await prisma.userLogin.findMany()
    * ```
    */
  get userLogin(): Prisma.UserLoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminLog`: Exposes CRUD operations for the **AdminLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminLogs
    * const adminLogs = await prisma.adminLog.findMany()
    * ```
    */
  get adminLog(): Prisma.AdminLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminOperationHistory`: Exposes CRUD operations for the **AdminOperationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminOperationHistories
    * const adminOperationHistories = await prisma.adminOperationHistory.findMany()
    * ```
    */
  get adminOperationHistory(): Prisma.AdminOperationHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuthority`: Exposes CRUD operations for the **AdminAuthority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuthorities
    * const adminAuthorities = await prisma.adminAuthority.findMany()
    * ```
    */
  get adminAuthority(): Prisma.AdminAuthorityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerVisitor`: Exposes CRUD operations for the **BannerVisitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerVisitors
    * const bannerVisitors = await prisma.bannerVisitor.findMany()
    * ```
    */
  get bannerVisitor(): Prisma.BannerVisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParticipant`: Exposes CRUD operations for the **TestParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParticipants
    * const testParticipants = await prisma.testParticipant.findMany()
    * ```
    */
  get testParticipant(): Prisma.TestParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParticipantRecord`: Exposes CRUD operations for the **TestParticipantRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParticipantRecords
    * const testParticipantRecords = await prisma.testParticipantRecord.findMany()
    * ```
    */
  get testParticipantRecord(): Prisma.TestParticipantRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.background`: Exposes CRUD operations for the **Background** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backgrounds
    * const backgrounds = await prisma.background.findMany()
    * ```
    */
  get background(): Prisma.BackgroundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminTransaction`: Exposes CRUD operations for the **AdminTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminTransactions
    * const adminTransactions = await prisma.adminTransaction.findMany()
    * ```
    */
  get adminTransaction(): Prisma.AdminTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemCode`: Exposes CRUD operations for the **RedeemCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedeemCodes
    * const redeemCodes = await prisma.redeemCode.findMany()
    * ```
    */
  get redeemCode(): Prisma.RedeemCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.codeRedeemer`: Exposes CRUD operations for the **CodeRedeemer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeRedeemers
    * const codeRedeemers = await prisma.codeRedeemer.findMany()
    * ```
    */
  get codeRedeemer(): Prisma.CodeRedeemerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championshipMatch`: Exposes CRUD operations for the **ChampionshipMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChampionshipMatches
    * const championshipMatches = await prisma.championshipMatch.findMany()
    * ```
    */
  get championshipMatch(): Prisma.ChampionshipMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchMember`: Exposes CRUD operations for the **MatchMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchMembers
    * const matchMembers = await prisma.matchMember.findMany()
    * ```
    */
  get matchMember(): Prisma.MatchMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championshipHistory`: Exposes CRUD operations for the **ChampionshipHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChampionshipHistories
    * const championshipHistories = await prisma.championshipHistory.findMany()
    * ```
    */
  get championshipHistory(): Prisma.ChampionshipHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchHistoryMember`: Exposes CRUD operations for the **MatchHistoryMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchHistoryMembers
    * const matchHistoryMembers = await prisma.matchHistoryMember.findMany()
    * ```
    */
  get matchHistoryMember(): Prisma.MatchHistoryMemberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Province: 'Province',
    City: 'City',
    Subdistrict: 'Subdistrict',
    School: 'School',
    User: 'User',
    Zone: 'Zone',
    Level: 'Level',
    SubLevel: 'SubLevel',
    InnerLevel: 'InnerLevel',
    Gempo: 'Gempo',
    Championship: 'Championship',
    GempoRecord: 'GempoRecord',
    ChampionshipRecord: 'ChampionshipRecord',
    UserLogin: 'UserLogin',
    Admin: 'Admin',
    AdminLog: 'AdminLog',
    AdminOperationHistory: 'AdminOperationHistory',
    AdminAuthority: 'AdminAuthority',
    Banner: 'Banner',
    BannerVisitor: 'BannerVisitor',
    Test: 'Test',
    TestParticipant: 'TestParticipant',
    TestParticipantRecord: 'TestParticipantRecord',
    Background: 'Background',
    Setting: 'Setting',
    AdminTransaction: 'AdminTransaction',
    RedeemCode: 'RedeemCode',
    CodeRedeemer: 'CodeRedeemer',
    ChampionshipMatch: 'ChampionshipMatch',
    MatchMember: 'MatchMember',
    ChampionshipHistory: 'ChampionshipHistory',
    MatchHistoryMember: 'MatchHistoryMember'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "province" | "city" | "subdistrict" | "school" | "user" | "zone" | "level" | "subLevel" | "innerLevel" | "gempo" | "championship" | "gempoRecord" | "championshipRecord" | "userLogin" | "admin" | "adminLog" | "adminOperationHistory" | "adminAuthority" | "banner" | "bannerVisitor" | "test" | "testParticipant" | "testParticipantRecord" | "background" | "setting" | "adminTransaction" | "redeemCode" | "codeRedeemer" | "championshipMatch" | "matchMember" | "championshipHistory" | "matchHistoryMember"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Province: {
        payload: Prisma.$ProvincePayload<ExtArgs>
        fields: Prisma.ProvinceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findFirst: {
            args: Prisma.ProvinceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findMany: {
            args: Prisma.ProvinceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          create: {
            args: Prisma.ProvinceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          createMany: {
            args: Prisma.ProvinceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvinceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          delete: {
            args: Prisma.ProvinceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          update: {
            args: Prisma.ProvinceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          deleteMany: {
            args: Prisma.ProvinceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvinceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          upsert: {
            args: Prisma.ProvinceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          aggregate: {
            args: Prisma.ProvinceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvince>
          }
          groupBy: {
            args: Prisma.ProvinceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinceCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinceCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Subdistrict: {
        payload: Prisma.$SubdistrictPayload<ExtArgs>
        fields: Prisma.SubdistrictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubdistrictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubdistrictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>
          }
          findFirst: {
            args: Prisma.SubdistrictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubdistrictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>
          }
          findMany: {
            args: Prisma.SubdistrictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>[]
          }
          create: {
            args: Prisma.SubdistrictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>
          }
          createMany: {
            args: Prisma.SubdistrictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubdistrictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>[]
          }
          delete: {
            args: Prisma.SubdistrictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>
          }
          update: {
            args: Prisma.SubdistrictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>
          }
          deleteMany: {
            args: Prisma.SubdistrictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubdistrictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubdistrictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>[]
          }
          upsert: {
            args: Prisma.SubdistrictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdistrictPayload>
          }
          aggregate: {
            args: Prisma.SubdistrictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubdistrict>
          }
          groupBy: {
            args: Prisma.SubdistrictGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubdistrictGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubdistrictCountArgs<ExtArgs>
            result: $Utils.Optional<SubdistrictCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      SubLevel: {
        payload: Prisma.$SubLevelPayload<ExtArgs>
        fields: Prisma.SubLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          findFirst: {
            args: Prisma.SubLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          findMany: {
            args: Prisma.SubLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          create: {
            args: Prisma.SubLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          createMany: {
            args: Prisma.SubLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          delete: {
            args: Prisma.SubLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          update: {
            args: Prisma.SubLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          deleteMany: {
            args: Prisma.SubLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          upsert: {
            args: Prisma.SubLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          aggregate: {
            args: Prisma.SubLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubLevel>
          }
          groupBy: {
            args: Prisma.SubLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubLevelCountArgs<ExtArgs>
            result: $Utils.Optional<SubLevelCountAggregateOutputType> | number
          }
        }
      }
      InnerLevel: {
        payload: Prisma.$InnerLevelPayload<ExtArgs>
        fields: Prisma.InnerLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InnerLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InnerLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          findFirst: {
            args: Prisma.InnerLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InnerLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          findMany: {
            args: Prisma.InnerLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          create: {
            args: Prisma.InnerLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          createMany: {
            args: Prisma.InnerLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InnerLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          delete: {
            args: Prisma.InnerLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          update: {
            args: Prisma.InnerLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          deleteMany: {
            args: Prisma.InnerLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InnerLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InnerLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          upsert: {
            args: Prisma.InnerLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          aggregate: {
            args: Prisma.InnerLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInnerLevel>
          }
          groupBy: {
            args: Prisma.InnerLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<InnerLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.InnerLevelCountArgs<ExtArgs>
            result: $Utils.Optional<InnerLevelCountAggregateOutputType> | number
          }
        }
      }
      Gempo: {
        payload: Prisma.$GempoPayload<ExtArgs>
        fields: Prisma.GempoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GempoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GempoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          findFirst: {
            args: Prisma.GempoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GempoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          findMany: {
            args: Prisma.GempoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          create: {
            args: Prisma.GempoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          createMany: {
            args: Prisma.GempoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GempoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          delete: {
            args: Prisma.GempoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          update: {
            args: Prisma.GempoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          deleteMany: {
            args: Prisma.GempoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GempoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GempoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          upsert: {
            args: Prisma.GempoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          aggregate: {
            args: Prisma.GempoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGempo>
          }
          groupBy: {
            args: Prisma.GempoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GempoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GempoCountArgs<ExtArgs>
            result: $Utils.Optional<GempoCountAggregateOutputType> | number
          }
        }
      }
      Championship: {
        payload: Prisma.$ChampionshipPayload<ExtArgs>
        fields: Prisma.ChampionshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          findMany: {
            args: Prisma.ChampionshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          create: {
            args: Prisma.ChampionshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          createMany: {
            args: Prisma.ChampionshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          update: {
            args: Prisma.ChampionshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionship>
          }
          groupBy: {
            args: Prisma.ChampionshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipCountAggregateOutputType> | number
          }
        }
      }
      GempoRecord: {
        payload: Prisma.$GempoRecordPayload<ExtArgs>
        fields: Prisma.GempoRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GempoRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GempoRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          findFirst: {
            args: Prisma.GempoRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GempoRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          findMany: {
            args: Prisma.GempoRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          create: {
            args: Prisma.GempoRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          createMany: {
            args: Prisma.GempoRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GempoRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          delete: {
            args: Prisma.GempoRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          update: {
            args: Prisma.GempoRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          deleteMany: {
            args: Prisma.GempoRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GempoRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GempoRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          upsert: {
            args: Prisma.GempoRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          aggregate: {
            args: Prisma.GempoRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGempoRecord>
          }
          groupBy: {
            args: Prisma.GempoRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<GempoRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.GempoRecordCountArgs<ExtArgs>
            result: $Utils.Optional<GempoRecordCountAggregateOutputType> | number
          }
        }
      }
      ChampionshipRecord: {
        payload: Prisma.$ChampionshipRecordPayload<ExtArgs>
        fields: Prisma.ChampionshipRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          findMany: {
            args: Prisma.ChampionshipRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          create: {
            args: Prisma.ChampionshipRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          createMany: {
            args: Prisma.ChampionshipRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          update: {
            args: Prisma.ChampionshipRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionshipRecord>
          }
          groupBy: {
            args: Prisma.ChampionshipRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipRecordCountAggregateOutputType> | number
          }
        }
      }
      UserLogin: {
        payload: Prisma.$UserLoginPayload<ExtArgs>
        fields: Prisma.UserLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          findFirst: {
            args: Prisma.UserLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          findMany: {
            args: Prisma.UserLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          create: {
            args: Prisma.UserLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          createMany: {
            args: Prisma.UserLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLoginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          delete: {
            args: Prisma.UserLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          update: {
            args: Prisma.UserLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          deleteMany: {
            args: Prisma.UserLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLoginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          upsert: {
            args: Prisma.UserLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          aggregate: {
            args: Prisma.UserLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLogin>
          }
          groupBy: {
            args: Prisma.UserLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLoginCountArgs<ExtArgs>
            result: $Utils.Optional<UserLoginCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminLog: {
        payload: Prisma.$AdminLogPayload<ExtArgs>
        fields: Prisma.AdminLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          findFirst: {
            args: Prisma.AdminLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          findMany: {
            args: Prisma.AdminLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>[]
          }
          create: {
            args: Prisma.AdminLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          createMany: {
            args: Prisma.AdminLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>[]
          }
          delete: {
            args: Prisma.AdminLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          update: {
            args: Prisma.AdminLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLogPayload>
          }
          aggregate: {
            args: Prisma.AdminLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminLog>
          }
          groupBy: {
            args: Prisma.AdminLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminLogCountAggregateOutputType> | number
          }
        }
      }
      AdminOperationHistory: {
        payload: Prisma.$AdminOperationHistoryPayload<ExtArgs>
        fields: Prisma.AdminOperationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminOperationHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          findFirst: {
            args: Prisma.AdminOperationHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          findMany: {
            args: Prisma.AdminOperationHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          create: {
            args: Prisma.AdminOperationHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          createMany: {
            args: Prisma.AdminOperationHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          delete: {
            args: Prisma.AdminOperationHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          update: {
            args: Prisma.AdminOperationHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AdminOperationHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminOperationHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          upsert: {
            args: Prisma.AdminOperationHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          aggregate: {
            args: Prisma.AdminOperationHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminOperationHistory>
          }
          groupBy: {
            args: Prisma.AdminOperationHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminOperationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminOperationHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AdminOperationHistoryCountAggregateOutputType> | number
          }
        }
      }
      AdminAuthority: {
        payload: Prisma.$AdminAuthorityPayload<ExtArgs>
        fields: Prisma.AdminAuthorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuthorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuthorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          findFirst: {
            args: Prisma.AdminAuthorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuthorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          findMany: {
            args: Prisma.AdminAuthorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          create: {
            args: Prisma.AdminAuthorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          createMany: {
            args: Prisma.AdminAuthorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuthorityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          delete: {
            args: Prisma.AdminAuthorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          update: {
            args: Prisma.AdminAuthorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuthorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuthorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuthorityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuthorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          aggregate: {
            args: Prisma.AdminAuthorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuthority>
          }
          groupBy: {
            args: Prisma.AdminAuthorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuthorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuthorityCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuthorityCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      BannerVisitor: {
        payload: Prisma.$BannerVisitorPayload<ExtArgs>
        fields: Prisma.BannerVisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerVisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerVisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          findFirst: {
            args: Prisma.BannerVisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerVisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          findMany: {
            args: Prisma.BannerVisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          create: {
            args: Prisma.BannerVisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          createMany: {
            args: Prisma.BannerVisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerVisitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          delete: {
            args: Prisma.BannerVisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          update: {
            args: Prisma.BannerVisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          deleteMany: {
            args: Prisma.BannerVisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerVisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerVisitorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          upsert: {
            args: Prisma.BannerVisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          aggregate: {
            args: Prisma.BannerVisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerVisitor>
          }
          groupBy: {
            args: Prisma.BannerVisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerVisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerVisitorCountArgs<ExtArgs>
            result: $Utils.Optional<BannerVisitorCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      TestParticipant: {
        payload: Prisma.$TestParticipantPayload<ExtArgs>
        fields: Prisma.TestParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          findFirst: {
            args: Prisma.TestParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          findMany: {
            args: Prisma.TestParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          create: {
            args: Prisma.TestParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          createMany: {
            args: Prisma.TestParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          delete: {
            args: Prisma.TestParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          update: {
            args: Prisma.TestParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TestParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          upsert: {
            args: Prisma.TestParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          aggregate: {
            args: Prisma.TestParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParticipant>
          }
          groupBy: {
            args: Prisma.TestParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantCountAggregateOutputType> | number
          }
        }
      }
      TestParticipantRecord: {
        payload: Prisma.$TestParticipantRecordPayload<ExtArgs>
        fields: Prisma.TestParticipantRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParticipantRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          findFirst: {
            args: Prisma.TestParticipantRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParticipantRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          findMany: {
            args: Prisma.TestParticipantRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          create: {
            args: Prisma.TestParticipantRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          createMany: {
            args: Prisma.TestParticipantRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParticipantRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          delete: {
            args: Prisma.TestParticipantRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          update: {
            args: Prisma.TestParticipantRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          deleteMany: {
            args: Prisma.TestParticipantRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParticipantRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          upsert: {
            args: Prisma.TestParticipantRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          aggregate: {
            args: Prisma.TestParticipantRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParticipantRecord>
          }
          groupBy: {
            args: Prisma.TestParticipantRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParticipantRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantRecordCountAggregateOutputType> | number
          }
        }
      }
      Background: {
        payload: Prisma.$BackgroundPayload<ExtArgs>
        fields: Prisma.BackgroundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackgroundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackgroundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findFirst: {
            args: Prisma.BackgroundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackgroundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findMany: {
            args: Prisma.BackgroundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          create: {
            args: Prisma.BackgroundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          createMany: {
            args: Prisma.BackgroundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackgroundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          delete: {
            args: Prisma.BackgroundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          update: {
            args: Prisma.BackgroundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          deleteMany: {
            args: Prisma.BackgroundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackgroundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BackgroundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          upsert: {
            args: Prisma.BackgroundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          aggregate: {
            args: Prisma.BackgroundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackground>
          }
          groupBy: {
            args: Prisma.BackgroundGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackgroundGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackgroundCountArgs<ExtArgs>
            result: $Utils.Optional<BackgroundCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      AdminTransaction: {
        payload: Prisma.$AdminTransactionPayload<ExtArgs>
        fields: Prisma.AdminTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          findFirst: {
            args: Prisma.AdminTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          findMany: {
            args: Prisma.AdminTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          create: {
            args: Prisma.AdminTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          createMany: {
            args: Prisma.AdminTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          delete: {
            args: Prisma.AdminTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          update: {
            args: Prisma.AdminTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          deleteMany: {
            args: Prisma.AdminTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          upsert: {
            args: Prisma.AdminTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          aggregate: {
            args: Prisma.AdminTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminTransaction>
          }
          groupBy: {
            args: Prisma.AdminTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionCountAggregateOutputType> | number
          }
        }
      }
      RedeemCode: {
        payload: Prisma.$RedeemCodePayload<ExtArgs>
        fields: Prisma.RedeemCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedeemCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedeemCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          findFirst: {
            args: Prisma.RedeemCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedeemCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          findMany: {
            args: Prisma.RedeemCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          create: {
            args: Prisma.RedeemCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          createMany: {
            args: Prisma.RedeemCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedeemCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          delete: {
            args: Prisma.RedeemCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          update: {
            args: Prisma.RedeemCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          deleteMany: {
            args: Prisma.RedeemCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedeemCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RedeemCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          upsert: {
            args: Prisma.RedeemCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          aggregate: {
            args: Prisma.RedeemCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemCode>
          }
          groupBy: {
            args: Prisma.RedeemCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedeemCodeCountArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeCountAggregateOutputType> | number
          }
        }
      }
      CodeRedeemer: {
        payload: Prisma.$CodeRedeemerPayload<ExtArgs>
        fields: Prisma.CodeRedeemerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodeRedeemerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodeRedeemerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>
          }
          findFirst: {
            args: Prisma.CodeRedeemerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodeRedeemerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>
          }
          findMany: {
            args: Prisma.CodeRedeemerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>[]
          }
          create: {
            args: Prisma.CodeRedeemerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>
          }
          createMany: {
            args: Prisma.CodeRedeemerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CodeRedeemerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>[]
          }
          delete: {
            args: Prisma.CodeRedeemerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>
          }
          update: {
            args: Prisma.CodeRedeemerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>
          }
          deleteMany: {
            args: Prisma.CodeRedeemerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodeRedeemerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CodeRedeemerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>[]
          }
          upsert: {
            args: Prisma.CodeRedeemerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedeemerPayload>
          }
          aggregate: {
            args: Prisma.CodeRedeemerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodeRedeemer>
          }
          groupBy: {
            args: Prisma.CodeRedeemerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodeRedeemerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodeRedeemerCountArgs<ExtArgs>
            result: $Utils.Optional<CodeRedeemerCountAggregateOutputType> | number
          }
        }
      }
      ChampionshipMatch: {
        payload: Prisma.$ChampionshipMatchPayload<ExtArgs>
        fields: Prisma.ChampionshipMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>
          }
          findMany: {
            args: Prisma.ChampionshipMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>[]
          }
          create: {
            args: Prisma.ChampionshipMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>
          }
          createMany: {
            args: Prisma.ChampionshipMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>
          }
          update: {
            args: Prisma.ChampionshipMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipMatchPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionshipMatch>
          }
          groupBy: {
            args: Prisma.ChampionshipMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipMatchCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipMatchCountAggregateOutputType> | number
          }
        }
      }
      MatchMember: {
        payload: Prisma.$MatchMemberPayload<ExtArgs>
        fields: Prisma.MatchMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>
          }
          findFirst: {
            args: Prisma.MatchMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>
          }
          findMany: {
            args: Prisma.MatchMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>[]
          }
          create: {
            args: Prisma.MatchMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>
          }
          createMany: {
            args: Prisma.MatchMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>[]
          }
          delete: {
            args: Prisma.MatchMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>
          }
          update: {
            args: Prisma.MatchMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>
          }
          deleteMany: {
            args: Prisma.MatchMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>[]
          }
          upsert: {
            args: Prisma.MatchMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMemberPayload>
          }
          aggregate: {
            args: Prisma.MatchMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchMember>
          }
          groupBy: {
            args: Prisma.MatchMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchMemberCountArgs<ExtArgs>
            result: $Utils.Optional<MatchMemberCountAggregateOutputType> | number
          }
        }
      }
      ChampionshipHistory: {
        payload: Prisma.$ChampionshipHistoryPayload<ExtArgs>
        fields: Prisma.ChampionshipHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>
          }
          findMany: {
            args: Prisma.ChampionshipHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>[]
          }
          create: {
            args: Prisma.ChampionshipHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>
          }
          createMany: {
            args: Prisma.ChampionshipHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>
          }
          update: {
            args: Prisma.ChampionshipHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipHistoryPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionshipHistory>
          }
          groupBy: {
            args: Prisma.ChampionshipHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipHistoryCountAggregateOutputType> | number
          }
        }
      }
      MatchHistoryMember: {
        payload: Prisma.$MatchHistoryMemberPayload<ExtArgs>
        fields: Prisma.MatchHistoryMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchHistoryMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchHistoryMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>
          }
          findFirst: {
            args: Prisma.MatchHistoryMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchHistoryMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>
          }
          findMany: {
            args: Prisma.MatchHistoryMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>[]
          }
          create: {
            args: Prisma.MatchHistoryMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>
          }
          createMany: {
            args: Prisma.MatchHistoryMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchHistoryMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>[]
          }
          delete: {
            args: Prisma.MatchHistoryMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>
          }
          update: {
            args: Prisma.MatchHistoryMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>
          }
          deleteMany: {
            args: Prisma.MatchHistoryMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchHistoryMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchHistoryMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>[]
          }
          upsert: {
            args: Prisma.MatchHistoryMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchHistoryMemberPayload>
          }
          aggregate: {
            args: Prisma.MatchHistoryMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchHistoryMember>
          }
          groupBy: {
            args: Prisma.MatchHistoryMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchHistoryMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchHistoryMemberCountArgs<ExtArgs>
            result: $Utils.Optional<MatchHistoryMemberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    province?: ProvinceOmit
    city?: CityOmit
    subdistrict?: SubdistrictOmit
    school?: SchoolOmit
    user?: UserOmit
    zone?: ZoneOmit
    level?: LevelOmit
    subLevel?: SubLevelOmit
    innerLevel?: InnerLevelOmit
    gempo?: GempoOmit
    championship?: ChampionshipOmit
    gempoRecord?: GempoRecordOmit
    championshipRecord?: ChampionshipRecordOmit
    userLogin?: UserLoginOmit
    admin?: AdminOmit
    adminLog?: AdminLogOmit
    adminOperationHistory?: AdminOperationHistoryOmit
    adminAuthority?: AdminAuthorityOmit
    banner?: BannerOmit
    bannerVisitor?: BannerVisitorOmit
    test?: TestOmit
    testParticipant?: TestParticipantOmit
    testParticipantRecord?: TestParticipantRecordOmit
    background?: BackgroundOmit
    setting?: SettingOmit
    adminTransaction?: AdminTransactionOmit
    redeemCode?: RedeemCodeOmit
    codeRedeemer?: CodeRedeemerOmit
    championshipMatch?: ChampionshipMatchOmit
    matchMember?: MatchMemberOmit
    championshipHistory?: ChampionshipHistoryOmit
    matchHistoryMember?: MatchHistoryMemberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProvinceCountOutputType
   */

  export type ProvinceCountOutputType = {
    admin: number
    adminAuthority: number
    cities: number
    schools: number
    users: number
    subdistricts: number
    banners: number
  }

  export type ProvinceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | ProvinceCountOutputTypeCountAdminArgs
    adminAuthority?: boolean | ProvinceCountOutputTypeCountAdminAuthorityArgs
    cities?: boolean | ProvinceCountOutputTypeCountCitiesArgs
    schools?: boolean | ProvinceCountOutputTypeCountSchoolsArgs
    users?: boolean | ProvinceCountOutputTypeCountUsersArgs
    subdistricts?: boolean | ProvinceCountOutputTypeCountSubdistrictsArgs
    banners?: boolean | ProvinceCountOutputTypeCountBannersArgs
  }

  // Custom InputTypes
  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinceCountOutputType
     */
    select?: ProvinceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountSubdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdistrictWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    admin: number
    schools: number
    subdistricts: number
    users: number
    adminAuthority: number
    banners: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | CityCountOutputTypeCountAdminArgs
    schools?: boolean | CityCountOutputTypeCountSchoolsArgs
    subdistricts?: boolean | CityCountOutputTypeCountSubdistrictsArgs
    users?: boolean | CityCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | CityCountOutputTypeCountAdminAuthorityArgs
    banners?: boolean | CityCountOutputTypeCountBannersArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountSubdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdistrictWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
  }


  /**
   * Count Type SubdistrictCountOutputType
   */

  export type SubdistrictCountOutputType = {
    schools: number
    users: number
    admins: number
    adminAuthority: number
    banners: number
  }

  export type SubdistrictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | SubdistrictCountOutputTypeCountSchoolsArgs
    users?: boolean | SubdistrictCountOutputTypeCountUsersArgs
    admins?: boolean | SubdistrictCountOutputTypeCountAdminsArgs
    adminAuthority?: boolean | SubdistrictCountOutputTypeCountAdminAuthorityArgs
    banners?: boolean | SubdistrictCountOutputTypeCountBannersArgs
  }

  // Custom InputTypes
  /**
   * SubdistrictCountOutputType without action
   */
  export type SubdistrictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubdistrictCountOutputType
     */
    select?: SubdistrictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubdistrictCountOutputType without action
   */
  export type SubdistrictCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * SubdistrictCountOutputType without action
   */
  export type SubdistrictCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SubdistrictCountOutputType without action
   */
  export type SubdistrictCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * SubdistrictCountOutputType without action
   */
  export type SubdistrictCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * SubdistrictCountOutputType without action
   */
  export type SubdistrictCountOutputTypeCountBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    admin: number
    users: number
    adminAuthority: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | SchoolCountOutputTypeCountAdminArgs
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | SchoolCountOutputTypeCountAdminAuthorityArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bannerVisitor: number
    championships: number
    championshipRecords: number
    redeemedCodes: number
    gempos: number
    gempoRecords: number
    innerLevels: number
    levels: number
    matchMembers: number
    historyMatchMembers: number
    subLevels: number
    testParticipant: number
    userLogin: number
    zones: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bannerVisitor?: boolean | UserCountOutputTypeCountBannerVisitorArgs
    championships?: boolean | UserCountOutputTypeCountChampionshipsArgs
    championshipRecords?: boolean | UserCountOutputTypeCountChampionshipRecordsArgs
    redeemedCodes?: boolean | UserCountOutputTypeCountRedeemedCodesArgs
    gempos?: boolean | UserCountOutputTypeCountGemposArgs
    gempoRecords?: boolean | UserCountOutputTypeCountGempoRecordsArgs
    innerLevels?: boolean | UserCountOutputTypeCountInnerLevelsArgs
    levels?: boolean | UserCountOutputTypeCountLevelsArgs
    matchMembers?: boolean | UserCountOutputTypeCountMatchMembersArgs
    historyMatchMembers?: boolean | UserCountOutputTypeCountHistoryMatchMembersArgs
    subLevels?: boolean | UserCountOutputTypeCountSubLevelsArgs
    testParticipant?: boolean | UserCountOutputTypeCountTestParticipantArgs
    userLogin?: boolean | UserCountOutputTypeCountUserLoginArgs
    zones?: boolean | UserCountOutputTypeCountZonesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBannerVisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChampionshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChampionshipRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRedeemedCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeRedeemerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGemposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGempoRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInnerLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InnerLevelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHistoryMatchMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchHistoryMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubLevelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    authority: number
    logs: number
    operationHistories: number
    operations: number
    transactions: number
    transactionProcessed: number
    banner: number
    redeemCodes: number
    tests: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authority?: boolean | AdminCountOutputTypeCountAuthorityArgs
    logs?: boolean | AdminCountOutputTypeCountLogsArgs
    operationHistories?: boolean | AdminCountOutputTypeCountOperationHistoriesArgs
    operations?: boolean | AdminCountOutputTypeCountOperationsArgs
    transactions?: boolean | AdminCountOutputTypeCountTransactionsArgs
    transactionProcessed?: boolean | AdminCountOutputTypeCountTransactionProcessedArgs
    banner?: boolean | AdminCountOutputTypeCountBannerArgs
    redeemCodes?: boolean | AdminCountOutputTypeCountRedeemCodesArgs
    tests?: boolean | AdminCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLogWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOperationHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountTransactionProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountRedeemCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
  }


  /**
   * Count Type AdminAuthorityCountOutputType
   */

  export type AdminAuthorityCountOutputType = {
    cities: number
    subdistricts: number
    schools: number
  }

  export type AdminAuthorityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | AdminAuthorityCountOutputTypeCountCitiesArgs
    subdistricts?: boolean | AdminAuthorityCountOutputTypeCountSubdistrictsArgs
    schools?: boolean | AdminAuthorityCountOutputTypeCountSchoolsArgs
  }

  // Custom InputTypes
  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthorityCountOutputType
     */
    select?: AdminAuthorityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountSubdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdistrictWhereInput
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }


  /**
   * Count Type BannerCountOutputType
   */

  export type BannerCountOutputType = {
    provincies: number
    cities: number
    subdistricts: number
    visitors: number
  }

  export type BannerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provincies?: boolean | BannerCountOutputTypeCountProvinciesArgs
    cities?: boolean | BannerCountOutputTypeCountCitiesArgs
    subdistricts?: boolean | BannerCountOutputTypeCountSubdistrictsArgs
    visitors?: boolean | BannerCountOutputTypeCountVisitorsArgs
  }

  // Custom InputTypes
  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerCountOutputType
     */
    select?: BannerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountProvinciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinceWhereInput
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountSubdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdistrictWhereInput
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
  }


  /**
   * Count Type TestCountOutputType
   */

  export type TestCountOutputType = {
    participants: number
  }

  export type TestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | TestCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCountOutputType
     */
    select?: TestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
  }


  /**
   * Count Type TestParticipantCountOutputType
   */

  export type TestParticipantCountOutputType = {
    records: number
  }

  export type TestParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | TestParticipantCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * TestParticipantCountOutputType without action
   */
  export type TestParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantCountOutputType
     */
    select?: TestParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestParticipantCountOutputType without action
   */
  export type TestParticipantCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
  }


  /**
   * Count Type RedeemCodeCountOutputType
   */

  export type RedeemCodeCountOutputType = {
    redeemers: number
  }

  export type RedeemCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemers?: boolean | RedeemCodeCountOutputTypeCountRedeemersArgs
  }

  // Custom InputTypes
  /**
   * RedeemCodeCountOutputType without action
   */
  export type RedeemCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeCountOutputType
     */
    select?: RedeemCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RedeemCodeCountOutputType without action
   */
  export type RedeemCodeCountOutputTypeCountRedeemersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeRedeemerWhereInput
  }


  /**
   * Count Type ChampionshipMatchCountOutputType
   */

  export type ChampionshipMatchCountOutputType = {
    members: number
  }

  export type ChampionshipMatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChampionshipMatchCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChampionshipMatchCountOutputType without action
   */
  export type ChampionshipMatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatchCountOutputType
     */
    select?: ChampionshipMatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChampionshipMatchCountOutputType without action
   */
  export type ChampionshipMatchCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMemberWhereInput
  }


  /**
   * Count Type ChampionshipHistoryCountOutputType
   */

  export type ChampionshipHistoryCountOutputType = {
    members: number
  }

  export type ChampionshipHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChampionshipHistoryCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChampionshipHistoryCountOutputType without action
   */
  export type ChampionshipHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistoryCountOutputType
     */
    select?: ChampionshipHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChampionshipHistoryCountOutputType without action
   */
  export type ChampionshipHistoryCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchHistoryMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Province
   */

  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type ProvinceSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type ProvinceMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvinceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvinceCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProvinceAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type ProvinceSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type ProvinceMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvinceMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvinceCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProvinceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Province to aggregate.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }




  export type ProvinceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinceWhereInput
    orderBy?: ProvinceOrderByWithAggregationInput | ProvinceOrderByWithAggregationInput[]
    by: ProvinceScalarFieldEnum[] | ProvinceScalarFieldEnum
    having?: ProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _avg?: ProvinceAvgAggregateInputType
    _sum?: ProvinceSumAggregateInputType
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }

  export type ProvinceGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt: Date
    updatedAt: Date
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends ProvinceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      >
    >


  export type ProvinceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | Province$adminArgs<ExtArgs>
    adminAuthority?: boolean | Province$adminAuthorityArgs<ExtArgs>
    cities?: boolean | Province$citiesArgs<ExtArgs>
    schools?: boolean | Province$schoolsArgs<ExtArgs>
    users?: boolean | Province$usersArgs<ExtArgs>
    subdistricts?: boolean | Province$subdistrictsArgs<ExtArgs>
    banners?: boolean | Province$bannersArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProvinceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "createdAt" | "updatedAt", ExtArgs["result"]["province"]>
  export type ProvinceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Province$adminArgs<ExtArgs>
    adminAuthority?: boolean | Province$adminAuthorityArgs<ExtArgs>
    cities?: boolean | Province$citiesArgs<ExtArgs>
    schools?: boolean | Province$schoolsArgs<ExtArgs>
    users?: boolean | Province$usersArgs<ExtArgs>
    subdistricts?: boolean | Province$subdistrictsArgs<ExtArgs>
    banners?: boolean | Province$bannersArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvinceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProvinceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProvincePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Province"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      cities: Prisma.$CityPayload<ExtArgs>[]
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      subdistricts: Prisma.$SubdistrictPayload<ExtArgs>[]
      banners: Prisma.$BannerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["province"]>
    composites: {}
  }

  type ProvinceGetPayload<S extends boolean | null | undefined | ProvinceDefaultArgs> = $Result.GetResult<Prisma.$ProvincePayload, S>

  type ProvinceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvinceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvinceCountAggregateInputType | true
    }

  export interface ProvinceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Province'], meta: { name: 'Province' } }
    /**
     * Find zero or one Province that matches the filter.
     * @param {ProvinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvinceFindUniqueArgs>(args: SelectSubset<T, ProvinceFindUniqueArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Province that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvinceFindUniqueOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvinceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvinceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvinceFindFirstArgs>(args?: SelectSubset<T, ProvinceFindFirstArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Province that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvinceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvinceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinceWithIdOnly = await prisma.province.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProvinceFindManyArgs>(args?: SelectSubset<T, ProvinceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Province.
     * @param {ProvinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
     */
    create<T extends ProvinceCreateArgs>(args: SelectSubset<T, ProvinceCreateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provinces.
     * @param {ProvinceCreateManyArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvinceCreateManyArgs>(args?: SelectSubset<T, ProvinceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provinces and returns the data saved in the database.
     * @param {ProvinceCreateManyAndReturnArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvinceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvinceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Province.
     * @param {ProvinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
     */
    delete<T extends ProvinceDeleteArgs>(args: SelectSubset<T, ProvinceDeleteArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Province.
     * @param {ProvinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvinceUpdateArgs>(args: SelectSubset<T, ProvinceUpdateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provinces.
     * @param {ProvinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvinceDeleteManyArgs>(args?: SelectSubset<T, ProvinceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvinceUpdateManyArgs>(args: SelectSubset<T, ProvinceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces and returns the data updated in the database.
     * @param {ProvinceUpdateManyAndReturnArgs} args - Arguments to update many Provinces.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvinceUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvinceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Province.
     * @param {ProvinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
     */
    upsert<T extends ProvinceUpsertArgs>(args: SelectSubset<T, ProvinceUpsertArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends ProvinceCountArgs>(
      args?: Subset<T, ProvinceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): Prisma.PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinceGroupByArgs['orderBy'] }
        : { orderBy?: ProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Province model
   */
  readonly fields: ProvinceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends Province$adminArgs<ExtArgs> = {}>(args?: Subset<T, Province$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends Province$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, Province$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cities<T extends Province$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Province$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends Province$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Province$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Province$usersArgs<ExtArgs> = {}>(args?: Subset<T, Province$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subdistricts<T extends Province$subdistrictsArgs<ExtArgs> = {}>(args?: Subset<T, Province$subdistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banners<T extends Province$bannersArgs<ExtArgs> = {}>(args?: Subset<T, Province$bannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Province model
   */
  interface ProvinceFieldRefs {
    readonly id: FieldRef<"Province", 'String'>
    readonly name: FieldRef<"Province", 'String'>
    readonly longitude: FieldRef<"Province", 'Float'>
    readonly latitude: FieldRef<"Province", 'Float'>
    readonly geoId: FieldRef<"Province", 'String'>
    readonly createdAt: FieldRef<"Province", 'DateTime'>
    readonly updatedAt: FieldRef<"Province", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Province findUnique
   */
  export type ProvinceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findUniqueOrThrow
   */
  export type ProvinceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findFirst
   */
  export type ProvinceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findFirstOrThrow
   */
  export type ProvinceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findMany
   */
  export type ProvinceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Provinces to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province create
   */
  export type ProvinceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to create a Province.
     */
    data: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
  }

  /**
   * Province createMany
   */
  export type ProvinceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province createManyAndReturn
   */
  export type ProvinceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province update
   */
  export type ProvinceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to update a Province.
     */
    data: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
    /**
     * Choose, which Province to update.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province updateMany
   */
  export type ProvinceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province updateManyAndReturn
   */
  export type ProvinceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province upsert
   */
  export type ProvinceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The filter to search for the Province to update in case it exists.
     */
    where: ProvinceWhereUniqueInput
    /**
     * In case the Province found by the `where` argument doesn't exist, create a new Province with this data.
     */
    create: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
    /**
     * In case the Province was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
  }

  /**
   * Province delete
   */
  export type ProvinceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter which Province to delete.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province deleteMany
   */
  export type ProvinceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provinces to delete
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to delete.
     */
    limit?: number
  }

  /**
   * Province.admin
   */
  export type Province$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Province.adminAuthority
   */
  export type Province$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Province.cities
   */
  export type Province$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Province.schools
   */
  export type Province$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * Province.users
   */
  export type Province$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Province.subdistricts
   */
  export type Province$subdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    cursor?: SubdistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * Province.banners
   */
  export type Province$bannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    cursor?: BannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Province without action
   */
  export type ProvinceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type CitySumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    provinceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type CitySumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | City$adminArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    schools?: boolean | City$schoolsArgs<ExtArgs>
    subdistricts?: boolean | City$subdistrictsArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    adminAuthority?: boolean | City$adminAuthorityArgs<ExtArgs>
    banners?: boolean | City$bannersArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "provinceId" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | City$adminArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    schools?: boolean | City$schoolsArgs<ExtArgs>
    subdistricts?: boolean | City$subdistrictsArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    adminAuthority?: boolean | City$adminAuthorityArgs<ExtArgs>
    banners?: boolean | City$bannersArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>[]
      province: Prisma.$ProvincePayload<ExtArgs>
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      subdistricts: Prisma.$SubdistrictPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      banners: Prisma.$BannerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      provinceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends City$adminArgs<ExtArgs> = {}>(args?: Subset<T, City$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schools<T extends City$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, City$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subdistricts<T extends City$subdistrictsArgs<ExtArgs> = {}>(args?: Subset<T, City$subdistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends City$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, City$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banners<T extends City$bannersArgs<ExtArgs> = {}>(args?: Subset<T, City$bannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly longitude: FieldRef<"City", 'Float'>
    readonly latitude: FieldRef<"City", 'Float'>
    readonly geoId: FieldRef<"City", 'String'>
    readonly provinceId: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.admin
   */
  export type City$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * City.schools
   */
  export type City$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * City.subdistricts
   */
  export type City$subdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    cursor?: SubdistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * City.adminAuthority
   */
  export type City$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * City.banners
   */
  export type City$bannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    cursor?: BannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Subdistrict
   */

  export type AggregateSubdistrict = {
    _count: SubdistrictCountAggregateOutputType | null
    _avg: SubdistrictAvgAggregateOutputType | null
    _sum: SubdistrictSumAggregateOutputType | null
    _min: SubdistrictMinAggregateOutputType | null
    _max: SubdistrictMaxAggregateOutputType | null
  }

  export type SubdistrictAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SubdistrictSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SubdistrictMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubdistrictMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    cityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubdistrictCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    provinceId: number
    cityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubdistrictAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SubdistrictSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SubdistrictMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubdistrictMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubdistrictCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    cityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubdistrictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subdistrict to aggregate.
     */
    where?: SubdistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdistricts to fetch.
     */
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubdistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subdistricts
    **/
    _count?: true | SubdistrictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubdistrictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubdistrictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubdistrictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubdistrictMaxAggregateInputType
  }

  export type GetSubdistrictAggregateType<T extends SubdistrictAggregateArgs> = {
        [P in keyof T & keyof AggregateSubdistrict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubdistrict[P]>
      : GetScalarType<T[P], AggregateSubdistrict[P]>
  }




  export type SubdistrictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdistrictWhereInput
    orderBy?: SubdistrictOrderByWithAggregationInput | SubdistrictOrderByWithAggregationInput[]
    by: SubdistrictScalarFieldEnum[] | SubdistrictScalarFieldEnum
    having?: SubdistrictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubdistrictCountAggregateInputType | true
    _avg?: SubdistrictAvgAggregateInputType
    _sum?: SubdistrictSumAggregateInputType
    _min?: SubdistrictMinAggregateInputType
    _max?: SubdistrictMaxAggregateInputType
  }

  export type SubdistrictGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    cityId: string
    createdAt: Date
    updatedAt: Date
    _count: SubdistrictCountAggregateOutputType | null
    _avg: SubdistrictAvgAggregateOutputType | null
    _sum: SubdistrictSumAggregateOutputType | null
    _min: SubdistrictMinAggregateOutputType | null
    _max: SubdistrictMaxAggregateOutputType | null
  }

  type GetSubdistrictGroupByPayload<T extends SubdistrictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubdistrictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubdistrictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubdistrictGroupByOutputType[P]>
            : GetScalarType<T[P], SubdistrictGroupByOutputType[P]>
        }
      >
    >


  export type SubdistrictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    schools?: boolean | Subdistrict$schoolsArgs<ExtArgs>
    users?: boolean | Subdistrict$usersArgs<ExtArgs>
    admins?: boolean | Subdistrict$adminsArgs<ExtArgs>
    adminAuthority?: boolean | Subdistrict$adminAuthorityArgs<ExtArgs>
    banners?: boolean | Subdistrict$bannersArgs<ExtArgs>
    _count?: boolean | SubdistrictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdistrict"]>

  export type SubdistrictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdistrict"]>

  export type SubdistrictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdistrict"]>

  export type SubdistrictSelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    cityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubdistrictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "provinceId" | "cityId" | "createdAt" | "updatedAt", ExtArgs["result"]["subdistrict"]>
  export type SubdistrictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    schools?: boolean | Subdistrict$schoolsArgs<ExtArgs>
    users?: boolean | Subdistrict$usersArgs<ExtArgs>
    admins?: boolean | Subdistrict$adminsArgs<ExtArgs>
    adminAuthority?: boolean | Subdistrict$adminAuthorityArgs<ExtArgs>
    banners?: boolean | Subdistrict$bannersArgs<ExtArgs>
    _count?: boolean | SubdistrictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubdistrictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type SubdistrictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $SubdistrictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subdistrict"
    objects: {
      province: Prisma.$ProvincePayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      admins: Prisma.$AdminPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      banners: Prisma.$BannerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      provinceId: string
      cityId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subdistrict"]>
    composites: {}
  }

  type SubdistrictGetPayload<S extends boolean | null | undefined | SubdistrictDefaultArgs> = $Result.GetResult<Prisma.$SubdistrictPayload, S>

  type SubdistrictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubdistrictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubdistrictCountAggregateInputType | true
    }

  export interface SubdistrictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subdistrict'], meta: { name: 'Subdistrict' } }
    /**
     * Find zero or one Subdistrict that matches the filter.
     * @param {SubdistrictFindUniqueArgs} args - Arguments to find a Subdistrict
     * @example
     * // Get one Subdistrict
     * const subdistrict = await prisma.subdistrict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubdistrictFindUniqueArgs>(args: SelectSubset<T, SubdistrictFindUniqueArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subdistrict that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubdistrictFindUniqueOrThrowArgs} args - Arguments to find a Subdistrict
     * @example
     * // Get one Subdistrict
     * const subdistrict = await prisma.subdistrict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubdistrictFindUniqueOrThrowArgs>(args: SelectSubset<T, SubdistrictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subdistrict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictFindFirstArgs} args - Arguments to find a Subdistrict
     * @example
     * // Get one Subdistrict
     * const subdistrict = await prisma.subdistrict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubdistrictFindFirstArgs>(args?: SelectSubset<T, SubdistrictFindFirstArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subdistrict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictFindFirstOrThrowArgs} args - Arguments to find a Subdistrict
     * @example
     * // Get one Subdistrict
     * const subdistrict = await prisma.subdistrict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubdistrictFindFirstOrThrowArgs>(args?: SelectSubset<T, SubdistrictFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subdistricts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subdistricts
     * const subdistricts = await prisma.subdistrict.findMany()
     * 
     * // Get first 10 Subdistricts
     * const subdistricts = await prisma.subdistrict.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subdistrictWithIdOnly = await prisma.subdistrict.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubdistrictFindManyArgs>(args?: SelectSubset<T, SubdistrictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subdistrict.
     * @param {SubdistrictCreateArgs} args - Arguments to create a Subdistrict.
     * @example
     * // Create one Subdistrict
     * const Subdistrict = await prisma.subdistrict.create({
     *   data: {
     *     // ... data to create a Subdistrict
     *   }
     * })
     * 
     */
    create<T extends SubdistrictCreateArgs>(args: SelectSubset<T, SubdistrictCreateArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subdistricts.
     * @param {SubdistrictCreateManyArgs} args - Arguments to create many Subdistricts.
     * @example
     * // Create many Subdistricts
     * const subdistrict = await prisma.subdistrict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubdistrictCreateManyArgs>(args?: SelectSubset<T, SubdistrictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subdistricts and returns the data saved in the database.
     * @param {SubdistrictCreateManyAndReturnArgs} args - Arguments to create many Subdistricts.
     * @example
     * // Create many Subdistricts
     * const subdistrict = await prisma.subdistrict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subdistricts and only return the `id`
     * const subdistrictWithIdOnly = await prisma.subdistrict.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubdistrictCreateManyAndReturnArgs>(args?: SelectSubset<T, SubdistrictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subdistrict.
     * @param {SubdistrictDeleteArgs} args - Arguments to delete one Subdistrict.
     * @example
     * // Delete one Subdistrict
     * const Subdistrict = await prisma.subdistrict.delete({
     *   where: {
     *     // ... filter to delete one Subdistrict
     *   }
     * })
     * 
     */
    delete<T extends SubdistrictDeleteArgs>(args: SelectSubset<T, SubdistrictDeleteArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subdistrict.
     * @param {SubdistrictUpdateArgs} args - Arguments to update one Subdistrict.
     * @example
     * // Update one Subdistrict
     * const subdistrict = await prisma.subdistrict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubdistrictUpdateArgs>(args: SelectSubset<T, SubdistrictUpdateArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subdistricts.
     * @param {SubdistrictDeleteManyArgs} args - Arguments to filter Subdistricts to delete.
     * @example
     * // Delete a few Subdistricts
     * const { count } = await prisma.subdistrict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubdistrictDeleteManyArgs>(args?: SelectSubset<T, SubdistrictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subdistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subdistricts
     * const subdistrict = await prisma.subdistrict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubdistrictUpdateManyArgs>(args: SelectSubset<T, SubdistrictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subdistricts and returns the data updated in the database.
     * @param {SubdistrictUpdateManyAndReturnArgs} args - Arguments to update many Subdistricts.
     * @example
     * // Update many Subdistricts
     * const subdistrict = await prisma.subdistrict.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subdistricts and only return the `id`
     * const subdistrictWithIdOnly = await prisma.subdistrict.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubdistrictUpdateManyAndReturnArgs>(args: SelectSubset<T, SubdistrictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subdistrict.
     * @param {SubdistrictUpsertArgs} args - Arguments to update or create a Subdistrict.
     * @example
     * // Update or create a Subdistrict
     * const subdistrict = await prisma.subdistrict.upsert({
     *   create: {
     *     // ... data to create a Subdistrict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subdistrict we want to update
     *   }
     * })
     */
    upsert<T extends SubdistrictUpsertArgs>(args: SelectSubset<T, SubdistrictUpsertArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subdistricts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictCountArgs} args - Arguments to filter Subdistricts to count.
     * @example
     * // Count the number of Subdistricts
     * const count = await prisma.subdistrict.count({
     *   where: {
     *     // ... the filter for the Subdistricts we want to count
     *   }
     * })
    **/
    count<T extends SubdistrictCountArgs>(
      args?: Subset<T, SubdistrictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubdistrictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subdistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubdistrictAggregateArgs>(args: Subset<T, SubdistrictAggregateArgs>): Prisma.PrismaPromise<GetSubdistrictAggregateType<T>>

    /**
     * Group by Subdistrict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdistrictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubdistrictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubdistrictGroupByArgs['orderBy'] }
        : { orderBy?: SubdistrictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubdistrictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubdistrictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subdistrict model
   */
  readonly fields: SubdistrictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subdistrict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubdistrictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schools<T extends Subdistrict$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Subdistrict$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Subdistrict$usersArgs<ExtArgs> = {}>(args?: Subset<T, Subdistrict$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admins<T extends Subdistrict$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Subdistrict$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends Subdistrict$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, Subdistrict$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banners<T extends Subdistrict$bannersArgs<ExtArgs> = {}>(args?: Subset<T, Subdistrict$bannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subdistrict model
   */
  interface SubdistrictFieldRefs {
    readonly id: FieldRef<"Subdistrict", 'String'>
    readonly name: FieldRef<"Subdistrict", 'String'>
    readonly longitude: FieldRef<"Subdistrict", 'Float'>
    readonly latitude: FieldRef<"Subdistrict", 'Float'>
    readonly geoId: FieldRef<"Subdistrict", 'String'>
    readonly provinceId: FieldRef<"Subdistrict", 'String'>
    readonly cityId: FieldRef<"Subdistrict", 'String'>
    readonly createdAt: FieldRef<"Subdistrict", 'DateTime'>
    readonly updatedAt: FieldRef<"Subdistrict", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subdistrict findUnique
   */
  export type SubdistrictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * Filter, which Subdistrict to fetch.
     */
    where: SubdistrictWhereUniqueInput
  }

  /**
   * Subdistrict findUniqueOrThrow
   */
  export type SubdistrictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * Filter, which Subdistrict to fetch.
     */
    where: SubdistrictWhereUniqueInput
  }

  /**
   * Subdistrict findFirst
   */
  export type SubdistrictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * Filter, which Subdistrict to fetch.
     */
    where?: SubdistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdistricts to fetch.
     */
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subdistricts.
     */
    cursor?: SubdistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subdistricts.
     */
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * Subdistrict findFirstOrThrow
   */
  export type SubdistrictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * Filter, which Subdistrict to fetch.
     */
    where?: SubdistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdistricts to fetch.
     */
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subdistricts.
     */
    cursor?: SubdistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdistricts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subdistricts.
     */
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * Subdistrict findMany
   */
  export type SubdistrictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * Filter, which Subdistricts to fetch.
     */
    where?: SubdistrictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdistricts to fetch.
     */
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subdistricts.
     */
    cursor?: SubdistrictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdistricts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdistricts.
     */
    skip?: number
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * Subdistrict create
   */
  export type SubdistrictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * The data needed to create a Subdistrict.
     */
    data: XOR<SubdistrictCreateInput, SubdistrictUncheckedCreateInput>
  }

  /**
   * Subdistrict createMany
   */
  export type SubdistrictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subdistricts.
     */
    data: SubdistrictCreateManyInput | SubdistrictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subdistrict createManyAndReturn
   */
  export type SubdistrictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * The data used to create many Subdistricts.
     */
    data: SubdistrictCreateManyInput | SubdistrictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subdistrict update
   */
  export type SubdistrictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * The data needed to update a Subdistrict.
     */
    data: XOR<SubdistrictUpdateInput, SubdistrictUncheckedUpdateInput>
    /**
     * Choose, which Subdistrict to update.
     */
    where: SubdistrictWhereUniqueInput
  }

  /**
   * Subdistrict updateMany
   */
  export type SubdistrictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subdistricts.
     */
    data: XOR<SubdistrictUpdateManyMutationInput, SubdistrictUncheckedUpdateManyInput>
    /**
     * Filter which Subdistricts to update
     */
    where?: SubdistrictWhereInput
    /**
     * Limit how many Subdistricts to update.
     */
    limit?: number
  }

  /**
   * Subdistrict updateManyAndReturn
   */
  export type SubdistrictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * The data used to update Subdistricts.
     */
    data: XOR<SubdistrictUpdateManyMutationInput, SubdistrictUncheckedUpdateManyInput>
    /**
     * Filter which Subdistricts to update
     */
    where?: SubdistrictWhereInput
    /**
     * Limit how many Subdistricts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subdistrict upsert
   */
  export type SubdistrictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * The filter to search for the Subdistrict to update in case it exists.
     */
    where: SubdistrictWhereUniqueInput
    /**
     * In case the Subdistrict found by the `where` argument doesn't exist, create a new Subdistrict with this data.
     */
    create: XOR<SubdistrictCreateInput, SubdistrictUncheckedCreateInput>
    /**
     * In case the Subdistrict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubdistrictUpdateInput, SubdistrictUncheckedUpdateInput>
  }

  /**
   * Subdistrict delete
   */
  export type SubdistrictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    /**
     * Filter which Subdistrict to delete.
     */
    where: SubdistrictWhereUniqueInput
  }

  /**
   * Subdistrict deleteMany
   */
  export type SubdistrictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subdistricts to delete
     */
    where?: SubdistrictWhereInput
    /**
     * Limit how many Subdistricts to delete.
     */
    limit?: number
  }

  /**
   * Subdistrict.schools
   */
  export type Subdistrict$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * Subdistrict.users
   */
  export type Subdistrict$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Subdistrict.admins
   */
  export type Subdistrict$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Subdistrict.adminAuthority
   */
  export type Subdistrict$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Subdistrict.banners
   */
  export type Subdistrict$bannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    cursor?: BannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Subdistrict without action
   */
  export type SubdistrictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SchoolSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    identity: string | null
    level: $Enums.EducationLevel | null
    name: string | null
    longitude: number | null
    latitude: number | null
    cityId: string | null
    provinceId: string | null
    subdistrictId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    identity: string | null
    level: $Enums.EducationLevel | null
    name: string | null
    longitude: number | null
    latitude: number | null
    cityId: string | null
    provinceId: string | null
    subdistrictId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    identity: number
    level: number
    name: number
    longitude: number
    latitude: number
    cityId: number
    provinceId: number
    subdistrictId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SchoolSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    identity?: true
    level?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    subdistrictId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    identity?: true
    level?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    subdistrictId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    identity?: true
    level?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    subdistrictId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    identity: string
    level: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId: string | null
    provinceId: string | null
    subdistrictId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    level?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | School$adminArgs<ExtArgs>
    city?: boolean | School$cityArgs<ExtArgs>
    province?: boolean | School$provinceArgs<ExtArgs>
    subdistrict?: boolean | School$subdistrictArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    adminAuthority?: boolean | School$adminAuthorityArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    level?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | School$cityArgs<ExtArgs>
    province?: boolean | School$provinceArgs<ExtArgs>
    subdistrict?: boolean | School$subdistrictArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    level?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | School$cityArgs<ExtArgs>
    province?: boolean | School$provinceArgs<ExtArgs>
    subdistrict?: boolean | School$subdistrictArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    identity?: boolean
    level?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identity" | "level" | "name" | "longitude" | "latitude" | "cityId" | "provinceId" | "subdistrictId" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | School$adminArgs<ExtArgs>
    city?: boolean | School$cityArgs<ExtArgs>
    province?: boolean | School$provinceArgs<ExtArgs>
    subdistrict?: boolean | School$subdistrictArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    adminAuthority?: boolean | School$adminAuthorityArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | School$cityArgs<ExtArgs>
    province?: boolean | School$provinceArgs<ExtArgs>
    subdistrict?: boolean | School$subdistrictArgs<ExtArgs>
  }
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | School$cityArgs<ExtArgs>
    province?: boolean | School$provinceArgs<ExtArgs>
    subdistrict?: boolean | School$subdistrictArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>[]
      city: Prisma.$CityPayload<ExtArgs> | null
      province: Prisma.$ProvincePayload<ExtArgs> | null
      subdistrict: Prisma.$SubdistrictPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identity: string
      level: $Enums.EducationLevel
      name: string
      longitude: number
      latitude: number
      cityId: string | null
      provinceId: string | null
      subdistrictId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends School$adminArgs<ExtArgs> = {}>(args?: Subset<T, School$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    city<T extends School$cityArgs<ExtArgs> = {}>(args?: Subset<T, School$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    province<T extends School$provinceArgs<ExtArgs> = {}>(args?: Subset<T, School$provinceArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subdistrict<T extends School$subdistrictArgs<ExtArgs> = {}>(args?: Subset<T, School$subdistrictArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends School$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, School$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly identity: FieldRef<"School", 'String'>
    readonly level: FieldRef<"School", 'EducationLevel'>
    readonly name: FieldRef<"School", 'String'>
    readonly longitude: FieldRef<"School", 'Float'>
    readonly latitude: FieldRef<"School", 'Float'>
    readonly cityId: FieldRef<"School", 'String'>
    readonly provinceId: FieldRef<"School", 'String'>
    readonly subdistrictId: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.admin
   */
  export type School$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * School.city
   */
  export type School$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * School.province
   */
  export type School$provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
  }

  /**
   * School.subdistrict
   */
  export type School$subdistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.adminAuthority
   */
  export type School$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    grade: number | null
    playTime: number | null
    inventory: number | null
  }

  export type UserSumAggregateOutputType = {
    grade: number | null
    playTime: number | null
    inventory: number[]
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    role: $Enums.Role | null
    suspend: boolean | null
    accountType: $Enums.AccountType | null
    firstTest: boolean | null
    fullname: string | null
    birthDate: Date | null
    grade: number | null
    lastGradeUpdateAt: Date | null
    schoolIdentity: string | null
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number | null
    characterUsed: string | null
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    subdistrictId: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    lastIdZoneUnlocked: string | null
    lastIdZonePosition: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    role: $Enums.Role | null
    suspend: boolean | null
    accountType: $Enums.AccountType | null
    firstTest: boolean | null
    fullname: string | null
    birthDate: Date | null
    grade: number | null
    lastGradeUpdateAt: Date | null
    schoolIdentity: string | null
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number | null
    characterUsed: string | null
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    subdistrictId: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    lastIdZoneUnlocked: string | null
    lastIdZonePosition: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    authId: number
    email: number
    role: number
    suspend: number
    accountType: number
    firstTest: number
    fullname: number
    birthDate: number
    grade: number
    lastGradeUpdateAt: number
    schoolIdentity: number
    loginAt: number
    logoutAt: number
    playTime: number
    characterUsed: number
    inventory: number
    schoolId: number
    cityId: number
    provinceId: number
    subdistrictId: number
    adminId: number
    createdAt: number
    updatedAt: number
    username: number
    lastIdZoneUnlocked: number
    lastIdZonePosition: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    grade?: true
    playTime?: true
    inventory?: true
  }

  export type UserSumAggregateInputType = {
    grade?: true
    playTime?: true
    inventory?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    subdistrictId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    subdistrictId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    inventory?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    subdistrictId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    authId: string
    email: string
    role: $Enums.Role
    suspend: boolean
    accountType: $Enums.AccountType
    firstTest: boolean
    fullname: string
    birthDate: Date | null
    grade: number
    lastGradeUpdateAt: Date | null
    schoolIdentity: string
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number
    characterUsed: string
    inventory: number[]
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    subdistrictId: string | null
    adminId: string | null
    createdAt: Date
    updatedAt: Date
    username: string
    lastIdZoneUnlocked: string
    lastIdZonePosition: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    bannerVisitor?: boolean | User$bannerVisitorArgs<ExtArgs>
    championships?: boolean | User$championshipsArgs<ExtArgs>
    championshipRecords?: boolean | User$championshipRecordsArgs<ExtArgs>
    redeemedCodes?: boolean | User$redeemedCodesArgs<ExtArgs>
    gempos?: boolean | User$gemposArgs<ExtArgs>
    gempoRecords?: boolean | User$gempoRecordsArgs<ExtArgs>
    innerLevels?: boolean | User$innerLevelsArgs<ExtArgs>
    levels?: boolean | User$levelsArgs<ExtArgs>
    matchMembers?: boolean | User$matchMembersArgs<ExtArgs>
    historyMatchMembers?: boolean | User$historyMatchMembersArgs<ExtArgs>
    subLevels?: boolean | User$subLevelsArgs<ExtArgs>
    testParticipant?: boolean | User$testParticipantArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    subdistrict?: boolean | User$subdistrictArgs<ExtArgs>
    userLogin?: boolean | User$userLoginArgs<ExtArgs>
    zones?: boolean | User$zonesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    subdistrict?: boolean | User$subdistrictArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    subdistrict?: boolean | User$subdistrictArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    subdistrictId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "email" | "role" | "suspend" | "accountType" | "firstTest" | "fullname" | "birthDate" | "grade" | "lastGradeUpdateAt" | "schoolIdentity" | "loginAt" | "logoutAt" | "playTime" | "characterUsed" | "inventory" | "schoolId" | "cityId" | "provinceId" | "subdistrictId" | "adminId" | "createdAt" | "updatedAt" | "username" | "lastIdZoneUnlocked" | "lastIdZonePosition", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bannerVisitor?: boolean | User$bannerVisitorArgs<ExtArgs>
    championships?: boolean | User$championshipsArgs<ExtArgs>
    championshipRecords?: boolean | User$championshipRecordsArgs<ExtArgs>
    redeemedCodes?: boolean | User$redeemedCodesArgs<ExtArgs>
    gempos?: boolean | User$gemposArgs<ExtArgs>
    gempoRecords?: boolean | User$gempoRecordsArgs<ExtArgs>
    innerLevels?: boolean | User$innerLevelsArgs<ExtArgs>
    levels?: boolean | User$levelsArgs<ExtArgs>
    matchMembers?: boolean | User$matchMembersArgs<ExtArgs>
    historyMatchMembers?: boolean | User$historyMatchMembersArgs<ExtArgs>
    subLevels?: boolean | User$subLevelsArgs<ExtArgs>
    testParticipant?: boolean | User$testParticipantArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    subdistrict?: boolean | User$subdistrictArgs<ExtArgs>
    userLogin?: boolean | User$userLoginArgs<ExtArgs>
    zones?: boolean | User$zonesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    subdistrict?: boolean | User$subdistrictArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    subdistrict?: boolean | User$subdistrictArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      bannerVisitor: Prisma.$BannerVisitorPayload<ExtArgs>[]
      championships: Prisma.$ChampionshipPayload<ExtArgs>[]
      championshipRecords: Prisma.$ChampionshipRecordPayload<ExtArgs>[]
      redeemedCodes: Prisma.$CodeRedeemerPayload<ExtArgs>[]
      gempos: Prisma.$GempoPayload<ExtArgs>[]
      gempoRecords: Prisma.$GempoRecordPayload<ExtArgs>[]
      innerLevels: Prisma.$InnerLevelPayload<ExtArgs>[]
      levels: Prisma.$LevelPayload<ExtArgs>[]
      matchMembers: Prisma.$MatchMemberPayload<ExtArgs>[]
      historyMatchMembers: Prisma.$MatchHistoryMemberPayload<ExtArgs>[]
      subLevels: Prisma.$SubLevelPayload<ExtArgs>[]
      testParticipant: Prisma.$TestParticipantPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs> | null
      city: Prisma.$CityPayload<ExtArgs> | null
      province: Prisma.$ProvincePayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      subdistrict: Prisma.$SubdistrictPayload<ExtArgs> | null
      userLogin: Prisma.$UserLoginPayload<ExtArgs>[]
      zones: Prisma.$ZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      email: string
      role: $Enums.Role
      suspend: boolean
      accountType: $Enums.AccountType
      firstTest: boolean
      fullname: string
      birthDate: Date | null
      grade: number
      lastGradeUpdateAt: Date | null
      schoolIdentity: string
      loginAt: Date | null
      logoutAt: Date | null
      playTime: number
      characterUsed: string
      inventory: number[]
      schoolId: string | null
      cityId: string | null
      provinceId: string | null
      subdistrictId: string | null
      adminId: string | null
      createdAt: Date
      updatedAt: Date
      username: string
      lastIdZoneUnlocked: string
      lastIdZonePosition: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bannerVisitor<T extends User$bannerVisitorArgs<ExtArgs> = {}>(args?: Subset<T, User$bannerVisitorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    championships<T extends User$championshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$championshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    championshipRecords<T extends User$championshipRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$championshipRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redeemedCodes<T extends User$redeemedCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$redeemedCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gempos<T extends User$gemposArgs<ExtArgs> = {}>(args?: Subset<T, User$gemposArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gempoRecords<T extends User$gempoRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$gempoRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    innerLevels<T extends User$innerLevelsArgs<ExtArgs> = {}>(args?: Subset<T, User$innerLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    levels<T extends User$levelsArgs<ExtArgs> = {}>(args?: Subset<T, User$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchMembers<T extends User$matchMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$matchMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    historyMatchMembers<T extends User$historyMatchMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$historyMatchMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subLevels<T extends User$subLevelsArgs<ExtArgs> = {}>(args?: Subset<T, User$subLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testParticipant<T extends User$testParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$testParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    city<T extends User$cityArgs<ExtArgs> = {}>(args?: Subset<T, User$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    province<T extends User$provinceArgs<ExtArgs> = {}>(args?: Subset<T, User$provinceArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subdistrict<T extends User$subdistrictArgs<ExtArgs> = {}>(args?: Subset<T, User$subdistrictArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userLogin<T extends User$userLoginArgs<ExtArgs> = {}>(args?: Subset<T, User$userLoginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zones<T extends User$zonesArgs<ExtArgs> = {}>(args?: Subset<T, User$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly authId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly suspend: FieldRef<"User", 'Boolean'>
    readonly accountType: FieldRef<"User", 'AccountType'>
    readonly firstTest: FieldRef<"User", 'Boolean'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly grade: FieldRef<"User", 'Int'>
    readonly lastGradeUpdateAt: FieldRef<"User", 'DateTime'>
    readonly schoolIdentity: FieldRef<"User", 'String'>
    readonly loginAt: FieldRef<"User", 'DateTime'>
    readonly logoutAt: FieldRef<"User", 'DateTime'>
    readonly playTime: FieldRef<"User", 'Int'>
    readonly characterUsed: FieldRef<"User", 'String'>
    readonly inventory: FieldRef<"User", 'Int[]'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly provinceId: FieldRef<"User", 'String'>
    readonly subdistrictId: FieldRef<"User", 'String'>
    readonly adminId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly lastIdZoneUnlocked: FieldRef<"User", 'String'>
    readonly lastIdZonePosition: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bannerVisitor
   */
  export type User$bannerVisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    cursor?: BannerVisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * User.championships
   */
  export type User$championshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    where?: ChampionshipWhereInput
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    cursor?: ChampionshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * User.championshipRecords
   */
  export type User$championshipRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    where?: ChampionshipRecordWhereInput
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    cursor?: ChampionshipRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * User.redeemedCodes
   */
  export type User$redeemedCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    where?: CodeRedeemerWhereInput
    orderBy?: CodeRedeemerOrderByWithRelationInput | CodeRedeemerOrderByWithRelationInput[]
    cursor?: CodeRedeemerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeRedeemerScalarFieldEnum | CodeRedeemerScalarFieldEnum[]
  }

  /**
   * User.gempos
   */
  export type User$gemposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    where?: GempoWhereInput
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    cursor?: GempoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * User.gempoRecords
   */
  export type User$gempoRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    where?: GempoRecordWhereInput
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    cursor?: GempoRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * User.innerLevels
   */
  export type User$innerLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    where?: InnerLevelWhereInput
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    cursor?: InnerLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * User.levels
   */
  export type User$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * User.matchMembers
   */
  export type User$matchMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    where?: MatchMemberWhereInput
    orderBy?: MatchMemberOrderByWithRelationInput | MatchMemberOrderByWithRelationInput[]
    cursor?: MatchMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchMemberScalarFieldEnum | MatchMemberScalarFieldEnum[]
  }

  /**
   * User.historyMatchMembers
   */
  export type User$historyMatchMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    where?: MatchHistoryMemberWhereInput
    orderBy?: MatchHistoryMemberOrderByWithRelationInput | MatchHistoryMemberOrderByWithRelationInput[]
    cursor?: MatchHistoryMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchHistoryMemberScalarFieldEnum | MatchHistoryMemberScalarFieldEnum[]
  }

  /**
   * User.subLevels
   */
  export type User$subLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    where?: SubLevelWhereInput
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    cursor?: SubLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * User.testParticipant
   */
  export type User$testParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    cursor?: TestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.city
   */
  export type User$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * User.province
   */
  export type User$provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.subdistrict
   */
  export type User$subdistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
  }

  /**
   * User.userLogin
   */
  export type User$userLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    where?: UserLoginWhereInput
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    cursor?: UserLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * User.zones
   */
  export type User$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    posttest: number | null
    posttestTryCount: number | null
    pretest: number | null
    pretestTryCount: number | null
  }

  export type ZoneSumAggregateOutputType = {
    posttest: number | null
    posttestTryCount: number | null
    pretest: number | null
    pretestTryCount: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    userId: string | null
    isComplete: boolean | null
    completedAt: Date | null
    lastLevelId: string | null
    lastSubLevelId: string | null
    lastInnerLevelId: string | null
    lastLevelUnlock: string | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    posttest: number | null
    posttestTryCount: number | null
    pretest: number | null
    pretestTryCount: number | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    isComplete: boolean | null
    completedAt: Date | null
    lastLevelId: string | null
    lastSubLevelId: string | null
    lastInnerLevelId: string | null
    lastLevelUnlock: string | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    posttest: number | null
    posttestTryCount: number | null
    pretest: number | null
    pretestTryCount: number | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    userId: number
    isComplete: number
    completedAt: number
    lastLevelId: number
    lastSubLevelId: number
    lastInnerLevelId: number
    lastLevelUnlock: number
    createdAt: number
    updatedAt: number
    inGameId: number
    posttest: number
    posttestTryCount: number
    pretest: number
    pretestTryCount: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    posttest?: true
    posttestTryCount?: true
    pretest?: true
    pretestTryCount?: true
  }

  export type ZoneSumAggregateInputType = {
    posttest?: true
    posttestTryCount?: true
    pretest?: true
    pretestTryCount?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    posttest?: true
    posttestTryCount?: true
    pretest?: true
    pretestTryCount?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    posttest?: true
    posttestTryCount?: true
    pretest?: true
    pretestTryCount?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    posttest?: true
    posttestTryCount?: true
    pretest?: true
    pretestTryCount?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    userId: string
    isComplete: boolean
    completedAt: Date | null
    lastLevelId: string
    lastSubLevelId: string
    lastInnerLevelId: string
    lastLevelUnlock: string
    createdAt: Date
    updatedAt: Date
    inGameId: string
    posttest: number
    posttestTryCount: number
    pretest: number
    pretestTryCount: number
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    posttest?: boolean
    posttestTryCount?: boolean
    pretest?: boolean
    pretestTryCount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    posttest?: boolean
    posttestTryCount?: boolean
    pretest?: boolean
    pretestTryCount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    posttest?: boolean
    posttestTryCount?: boolean
    pretest?: boolean
    pretestTryCount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    posttest?: boolean
    posttestTryCount?: boolean
    pretest?: boolean
    pretestTryCount?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "isComplete" | "completedAt" | "lastLevelId" | "lastSubLevelId" | "lastInnerLevelId" | "lastLevelUnlock" | "createdAt" | "updatedAt" | "inGameId" | "posttest" | "posttestTryCount" | "pretest" | "pretestTryCount", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      isComplete: boolean
      completedAt: Date | null
      lastLevelId: string
      lastSubLevelId: string
      lastInnerLevelId: string
      lastLevelUnlock: string
      createdAt: Date
      updatedAt: Date
      inGameId: string
      posttest: number
      posttestTryCount: number
      pretest: number
      pretestTryCount: number
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly userId: FieldRef<"Zone", 'String'>
    readonly isComplete: FieldRef<"Zone", 'Boolean'>
    readonly completedAt: FieldRef<"Zone", 'DateTime'>
    readonly lastLevelId: FieldRef<"Zone", 'String'>
    readonly lastSubLevelId: FieldRef<"Zone", 'String'>
    readonly lastInnerLevelId: FieldRef<"Zone", 'String'>
    readonly lastLevelUnlock: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
    readonly inGameId: FieldRef<"Zone", 'String'>
    readonly posttest: FieldRef<"Zone", 'Int'>
    readonly posttestTryCount: FieldRef<"Zone", 'Int'>
    readonly pretest: FieldRef<"Zone", 'Int'>
    readonly pretestTryCount: FieldRef<"Zone", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    inGameId: number
    userId: number
    zoneInGameId: number
    _all: number
  }


  export type LevelMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    inGameId: string
    userId: string
    zoneInGameId: string
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "createdAt" | "updatedAt" | "inGameId" | "userId" | "zoneInGameId", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      inGameId: string
      userId: string
      zoneInGameId: string
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {LevelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LevelUpdateManyAndReturnArgs>(args: SelectSubset<T, LevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly isUnlock: FieldRef<"Level", 'Boolean'>
    readonly unlockedAt: FieldRef<"Level", 'DateTime'>
    readonly isComplete: FieldRef<"Level", 'Boolean'>
    readonly completedAt: FieldRef<"Level", 'DateTime'>
    readonly createdAt: FieldRef<"Level", 'DateTime'>
    readonly updatedAt: FieldRef<"Level", 'DateTime'>
    readonly inGameId: FieldRef<"Level", 'String'>
    readonly userId: FieldRef<"Level", 'String'>
    readonly zoneInGameId: FieldRef<"Level", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level updateManyAndReturn
   */
  export type LevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model SubLevel
   */

  export type AggregateSubLevel = {
    _count: SubLevelCountAggregateOutputType | null
    _min: SubLevelMinAggregateOutputType | null
    _max: SubLevelMaxAggregateOutputType | null
  }

  export type SubLevelMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    levelInGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type SubLevelMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    levelInGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type SubLevelCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    inGameId: number
    levelInGameId: number
    userId: number
    zoneInGameId: number
    _all: number
  }


  export type SubLevelMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    levelInGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type SubLevelMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    levelInGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type SubLevelCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    levelInGameId?: true
    userId?: true
    zoneInGameId?: true
    _all?: true
  }

  export type SubLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubLevel to aggregate.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubLevels
    **/
    _count?: true | SubLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubLevelMaxAggregateInputType
  }

  export type GetSubLevelAggregateType<T extends SubLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateSubLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubLevel[P]>
      : GetScalarType<T[P], AggregateSubLevel[P]>
  }




  export type SubLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubLevelWhereInput
    orderBy?: SubLevelOrderByWithAggregationInput | SubLevelOrderByWithAggregationInput[]
    by: SubLevelScalarFieldEnum[] | SubLevelScalarFieldEnum
    having?: SubLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubLevelCountAggregateInputType | true
    _min?: SubLevelMinAggregateInputType
    _max?: SubLevelMaxAggregateInputType
  }

  export type SubLevelGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    inGameId: string
    levelInGameId: string
    userId: string
    zoneInGameId: string
    _count: SubLevelCountAggregateOutputType | null
    _min: SubLevelMinAggregateOutputType | null
    _max: SubLevelMaxAggregateOutputType | null
  }

  type GetSubLevelGroupByPayload<T extends SubLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubLevelGroupByOutputType[P]>
            : GetScalarType<T[P], SubLevelGroupByOutputType[P]>
        }
      >
    >


  export type SubLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
  }

  export type SubLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "createdAt" | "updatedAt" | "inGameId" | "levelInGameId" | "userId" | "zoneInGameId", ExtArgs["result"]["subLevel"]>
  export type SubLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubLevel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      inGameId: string
      levelInGameId: string
      userId: string
      zoneInGameId: string
    }, ExtArgs["result"]["subLevel"]>
    composites: {}
  }

  type SubLevelGetPayload<S extends boolean | null | undefined | SubLevelDefaultArgs> = $Result.GetResult<Prisma.$SubLevelPayload, S>

  type SubLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubLevelCountAggregateInputType | true
    }

  export interface SubLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubLevel'], meta: { name: 'SubLevel' } }
    /**
     * Find zero or one SubLevel that matches the filter.
     * @param {SubLevelFindUniqueArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubLevelFindUniqueArgs>(args: SelectSubset<T, SubLevelFindUniqueArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubLevelFindUniqueOrThrowArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, SubLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindFirstArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubLevelFindFirstArgs>(args?: SelectSubset<T, SubLevelFindFirstArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindFirstOrThrowArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, SubLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubLevels
     * const subLevels = await prisma.subLevel.findMany()
     * 
     * // Get first 10 SubLevels
     * const subLevels = await prisma.subLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubLevelFindManyArgs>(args?: SelectSubset<T, SubLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubLevel.
     * @param {SubLevelCreateArgs} args - Arguments to create a SubLevel.
     * @example
     * // Create one SubLevel
     * const SubLevel = await prisma.subLevel.create({
     *   data: {
     *     // ... data to create a SubLevel
     *   }
     * })
     * 
     */
    create<T extends SubLevelCreateArgs>(args: SelectSubset<T, SubLevelCreateArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubLevels.
     * @param {SubLevelCreateManyArgs} args - Arguments to create many SubLevels.
     * @example
     * // Create many SubLevels
     * const subLevel = await prisma.subLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubLevelCreateManyArgs>(args?: SelectSubset<T, SubLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubLevels and returns the data saved in the database.
     * @param {SubLevelCreateManyAndReturnArgs} args - Arguments to create many SubLevels.
     * @example
     * // Create many SubLevels
     * const subLevel = await prisma.subLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubLevels and only return the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, SubLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubLevel.
     * @param {SubLevelDeleteArgs} args - Arguments to delete one SubLevel.
     * @example
     * // Delete one SubLevel
     * const SubLevel = await prisma.subLevel.delete({
     *   where: {
     *     // ... filter to delete one SubLevel
     *   }
     * })
     * 
     */
    delete<T extends SubLevelDeleteArgs>(args: SelectSubset<T, SubLevelDeleteArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubLevel.
     * @param {SubLevelUpdateArgs} args - Arguments to update one SubLevel.
     * @example
     * // Update one SubLevel
     * const subLevel = await prisma.subLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubLevelUpdateArgs>(args: SelectSubset<T, SubLevelUpdateArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubLevels.
     * @param {SubLevelDeleteManyArgs} args - Arguments to filter SubLevels to delete.
     * @example
     * // Delete a few SubLevels
     * const { count } = await prisma.subLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubLevelDeleteManyArgs>(args?: SelectSubset<T, SubLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubLevels
     * const subLevel = await prisma.subLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubLevelUpdateManyArgs>(args: SelectSubset<T, SubLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubLevels and returns the data updated in the database.
     * @param {SubLevelUpdateManyAndReturnArgs} args - Arguments to update many SubLevels.
     * @example
     * // Update many SubLevels
     * const subLevel = await prisma.subLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubLevels and only return the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, SubLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubLevel.
     * @param {SubLevelUpsertArgs} args - Arguments to update or create a SubLevel.
     * @example
     * // Update or create a SubLevel
     * const subLevel = await prisma.subLevel.upsert({
     *   create: {
     *     // ... data to create a SubLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubLevel we want to update
     *   }
     * })
     */
    upsert<T extends SubLevelUpsertArgs>(args: SelectSubset<T, SubLevelUpsertArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelCountArgs} args - Arguments to filter SubLevels to count.
     * @example
     * // Count the number of SubLevels
     * const count = await prisma.subLevel.count({
     *   where: {
     *     // ... the filter for the SubLevels we want to count
     *   }
     * })
    **/
    count<T extends SubLevelCountArgs>(
      args?: Subset<T, SubLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubLevelAggregateArgs>(args: Subset<T, SubLevelAggregateArgs>): Prisma.PrismaPromise<GetSubLevelAggregateType<T>>

    /**
     * Group by SubLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubLevelGroupByArgs['orderBy'] }
        : { orderBy?: SubLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubLevel model
   */
  readonly fields: SubLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubLevel model
   */
  interface SubLevelFieldRefs {
    readonly id: FieldRef<"SubLevel", 'String'>
    readonly isUnlock: FieldRef<"SubLevel", 'Boolean'>
    readonly unlockedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly isComplete: FieldRef<"SubLevel", 'Boolean'>
    readonly completedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly createdAt: FieldRef<"SubLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly inGameId: FieldRef<"SubLevel", 'String'>
    readonly levelInGameId: FieldRef<"SubLevel", 'String'>
    readonly userId: FieldRef<"SubLevel", 'String'>
    readonly zoneInGameId: FieldRef<"SubLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubLevel findUnique
   */
  export type SubLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel findUniqueOrThrow
   */
  export type SubLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel findFirst
   */
  export type SubLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubLevels.
     */
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel findFirstOrThrow
   */
  export type SubLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubLevels.
     */
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel findMany
   */
  export type SubLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevels to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel create
   */
  export type SubLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a SubLevel.
     */
    data: XOR<SubLevelCreateInput, SubLevelUncheckedCreateInput>
  }

  /**
   * SubLevel createMany
   */
  export type SubLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubLevels.
     */
    data: SubLevelCreateManyInput | SubLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubLevel createManyAndReturn
   */
  export type SubLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * The data used to create many SubLevels.
     */
    data: SubLevelCreateManyInput | SubLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubLevel update
   */
  export type SubLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a SubLevel.
     */
    data: XOR<SubLevelUpdateInput, SubLevelUncheckedUpdateInput>
    /**
     * Choose, which SubLevel to update.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel updateMany
   */
  export type SubLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubLevels.
     */
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyInput>
    /**
     * Filter which SubLevels to update
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to update.
     */
    limit?: number
  }

  /**
   * SubLevel updateManyAndReturn
   */
  export type SubLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * The data used to update SubLevels.
     */
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyInput>
    /**
     * Filter which SubLevels to update
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubLevel upsert
   */
  export type SubLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the SubLevel to update in case it exists.
     */
    where: SubLevelWhereUniqueInput
    /**
     * In case the SubLevel found by the `where` argument doesn't exist, create a new SubLevel with this data.
     */
    create: XOR<SubLevelCreateInput, SubLevelUncheckedCreateInput>
    /**
     * In case the SubLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubLevelUpdateInput, SubLevelUncheckedUpdateInput>
  }

  /**
   * SubLevel delete
   */
  export type SubLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter which SubLevel to delete.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel deleteMany
   */
  export type SubLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubLevels to delete
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to delete.
     */
    limit?: number
  }

  /**
   * SubLevel without action
   */
  export type SubLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
  }


  /**
   * Model InnerLevel
   */

  export type AggregateInnerLevel = {
    _count: InnerLevelCountAggregateOutputType | null
    _avg: InnerLevelAvgAggregateOutputType | null
    _sum: InnerLevelSumAggregateOutputType | null
    _min: InnerLevelMinAggregateOutputType | null
    _max: InnerLevelMaxAggregateOutputType | null
  }

  export type InnerLevelAvgAggregateOutputType = {
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
  }

  export type InnerLevelSumAggregateOutputType = {
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
  }

  export type InnerLevelMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    levelInGameId: string | null
    subLevelInGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type InnerLevelMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    levelInGameId: string | null
    subLevelInGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type InnerLevelCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    correctAttempt: number
    playTime: number
    point: number
    played: number
    createdAt: number
    updatedAt: number
    inGameId: number
    levelInGameId: number
    subLevelInGameId: number
    userId: number
    zoneInGameId: number
    _all: number
  }


  export type InnerLevelAvgAggregateInputType = {
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
  }

  export type InnerLevelSumAggregateInputType = {
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
  }

  export type InnerLevelMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    levelInGameId?: true
    subLevelInGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type InnerLevelMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    levelInGameId?: true
    subLevelInGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type InnerLevelCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    levelInGameId?: true
    subLevelInGameId?: true
    userId?: true
    zoneInGameId?: true
    _all?: true
  }

  export type InnerLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnerLevel to aggregate.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InnerLevels
    **/
    _count?: true | InnerLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InnerLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InnerLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InnerLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InnerLevelMaxAggregateInputType
  }

  export type GetInnerLevelAggregateType<T extends InnerLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateInnerLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInnerLevel[P]>
      : GetScalarType<T[P], AggregateInnerLevel[P]>
  }




  export type InnerLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InnerLevelWhereInput
    orderBy?: InnerLevelOrderByWithAggregationInput | InnerLevelOrderByWithAggregationInput[]
    by: InnerLevelScalarFieldEnum[] | InnerLevelScalarFieldEnum
    having?: InnerLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InnerLevelCountAggregateInputType | true
    _avg?: InnerLevelAvgAggregateInputType
    _sum?: InnerLevelSumAggregateInputType
    _min?: InnerLevelMinAggregateInputType
    _max?: InnerLevelMaxAggregateInputType
  }

  export type InnerLevelGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    correctAttempt: number
    playTime: number
    point: number
    played: number
    createdAt: Date
    updatedAt: Date
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    userId: string
    zoneInGameId: string
    _count: InnerLevelCountAggregateOutputType | null
    _avg: InnerLevelAvgAggregateOutputType | null
    _sum: InnerLevelSumAggregateOutputType | null
    _min: InnerLevelMinAggregateOutputType | null
    _max: InnerLevelMaxAggregateOutputType | null
  }

  type GetInnerLevelGroupByPayload<T extends InnerLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InnerLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InnerLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InnerLevelGroupByOutputType[P]>
            : GetScalarType<T[P], InnerLevelGroupByOutputType[P]>
        }
      >
    >


  export type InnerLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
  }

  export type InnerLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "correctAttempt" | "playTime" | "point" | "played" | "createdAt" | "updatedAt" | "inGameId" | "levelInGameId" | "subLevelInGameId" | "userId" | "zoneInGameId", ExtArgs["result"]["innerLevel"]>
  export type InnerLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InnerLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InnerLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InnerLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InnerLevel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      correctAttempt: number
      playTime: number
      point: number
      played: number
      createdAt: Date
      updatedAt: Date
      inGameId: string
      levelInGameId: string
      subLevelInGameId: string
      userId: string
      zoneInGameId: string
    }, ExtArgs["result"]["innerLevel"]>
    composites: {}
  }

  type InnerLevelGetPayload<S extends boolean | null | undefined | InnerLevelDefaultArgs> = $Result.GetResult<Prisma.$InnerLevelPayload, S>

  type InnerLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InnerLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InnerLevelCountAggregateInputType | true
    }

  export interface InnerLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InnerLevel'], meta: { name: 'InnerLevel' } }
    /**
     * Find zero or one InnerLevel that matches the filter.
     * @param {InnerLevelFindUniqueArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InnerLevelFindUniqueArgs>(args: SelectSubset<T, InnerLevelFindUniqueArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InnerLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InnerLevelFindUniqueOrThrowArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InnerLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, InnerLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InnerLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindFirstArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InnerLevelFindFirstArgs>(args?: SelectSubset<T, InnerLevelFindFirstArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InnerLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindFirstOrThrowArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InnerLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, InnerLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InnerLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InnerLevels
     * const innerLevels = await prisma.innerLevel.findMany()
     * 
     * // Get first 10 InnerLevels
     * const innerLevels = await prisma.innerLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InnerLevelFindManyArgs>(args?: SelectSubset<T, InnerLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InnerLevel.
     * @param {InnerLevelCreateArgs} args - Arguments to create a InnerLevel.
     * @example
     * // Create one InnerLevel
     * const InnerLevel = await prisma.innerLevel.create({
     *   data: {
     *     // ... data to create a InnerLevel
     *   }
     * })
     * 
     */
    create<T extends InnerLevelCreateArgs>(args: SelectSubset<T, InnerLevelCreateArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InnerLevels.
     * @param {InnerLevelCreateManyArgs} args - Arguments to create many InnerLevels.
     * @example
     * // Create many InnerLevels
     * const innerLevel = await prisma.innerLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InnerLevelCreateManyArgs>(args?: SelectSubset<T, InnerLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InnerLevels and returns the data saved in the database.
     * @param {InnerLevelCreateManyAndReturnArgs} args - Arguments to create many InnerLevels.
     * @example
     * // Create many InnerLevels
     * const innerLevel = await prisma.innerLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InnerLevels and only return the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InnerLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, InnerLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InnerLevel.
     * @param {InnerLevelDeleteArgs} args - Arguments to delete one InnerLevel.
     * @example
     * // Delete one InnerLevel
     * const InnerLevel = await prisma.innerLevel.delete({
     *   where: {
     *     // ... filter to delete one InnerLevel
     *   }
     * })
     * 
     */
    delete<T extends InnerLevelDeleteArgs>(args: SelectSubset<T, InnerLevelDeleteArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InnerLevel.
     * @param {InnerLevelUpdateArgs} args - Arguments to update one InnerLevel.
     * @example
     * // Update one InnerLevel
     * const innerLevel = await prisma.innerLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InnerLevelUpdateArgs>(args: SelectSubset<T, InnerLevelUpdateArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InnerLevels.
     * @param {InnerLevelDeleteManyArgs} args - Arguments to filter InnerLevels to delete.
     * @example
     * // Delete a few InnerLevels
     * const { count } = await prisma.innerLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InnerLevelDeleteManyArgs>(args?: SelectSubset<T, InnerLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnerLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InnerLevels
     * const innerLevel = await prisma.innerLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InnerLevelUpdateManyArgs>(args: SelectSubset<T, InnerLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnerLevels and returns the data updated in the database.
     * @param {InnerLevelUpdateManyAndReturnArgs} args - Arguments to update many InnerLevels.
     * @example
     * // Update many InnerLevels
     * const innerLevel = await prisma.innerLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InnerLevels and only return the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InnerLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, InnerLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InnerLevel.
     * @param {InnerLevelUpsertArgs} args - Arguments to update or create a InnerLevel.
     * @example
     * // Update or create a InnerLevel
     * const innerLevel = await prisma.innerLevel.upsert({
     *   create: {
     *     // ... data to create a InnerLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InnerLevel we want to update
     *   }
     * })
     */
    upsert<T extends InnerLevelUpsertArgs>(args: SelectSubset<T, InnerLevelUpsertArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InnerLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelCountArgs} args - Arguments to filter InnerLevels to count.
     * @example
     * // Count the number of InnerLevels
     * const count = await prisma.innerLevel.count({
     *   where: {
     *     // ... the filter for the InnerLevels we want to count
     *   }
     * })
    **/
    count<T extends InnerLevelCountArgs>(
      args?: Subset<T, InnerLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InnerLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InnerLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InnerLevelAggregateArgs>(args: Subset<T, InnerLevelAggregateArgs>): Prisma.PrismaPromise<GetInnerLevelAggregateType<T>>

    /**
     * Group by InnerLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InnerLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InnerLevelGroupByArgs['orderBy'] }
        : { orderBy?: InnerLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InnerLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInnerLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InnerLevel model
   */
  readonly fields: InnerLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InnerLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InnerLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InnerLevel model
   */
  interface InnerLevelFieldRefs {
    readonly id: FieldRef<"InnerLevel", 'String'>
    readonly isUnlock: FieldRef<"InnerLevel", 'Boolean'>
    readonly unlockedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly isComplete: FieldRef<"InnerLevel", 'Boolean'>
    readonly completedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly correctAttempt: FieldRef<"InnerLevel", 'Float'>
    readonly playTime: FieldRef<"InnerLevel", 'Int'>
    readonly point: FieldRef<"InnerLevel", 'Int'>
    readonly played: FieldRef<"InnerLevel", 'Int'>
    readonly createdAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly inGameId: FieldRef<"InnerLevel", 'String'>
    readonly levelInGameId: FieldRef<"InnerLevel", 'String'>
    readonly subLevelInGameId: FieldRef<"InnerLevel", 'String'>
    readonly userId: FieldRef<"InnerLevel", 'String'>
    readonly zoneInGameId: FieldRef<"InnerLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InnerLevel findUnique
   */
  export type InnerLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel findUniqueOrThrow
   */
  export type InnerLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel findFirst
   */
  export type InnerLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnerLevels.
     */
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel findFirstOrThrow
   */
  export type InnerLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnerLevels.
     */
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel findMany
   */
  export type InnerLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevels to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel create
   */
  export type InnerLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a InnerLevel.
     */
    data: XOR<InnerLevelCreateInput, InnerLevelUncheckedCreateInput>
  }

  /**
   * InnerLevel createMany
   */
  export type InnerLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InnerLevels.
     */
    data: InnerLevelCreateManyInput | InnerLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InnerLevel createManyAndReturn
   */
  export type InnerLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * The data used to create many InnerLevels.
     */
    data: InnerLevelCreateManyInput | InnerLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InnerLevel update
   */
  export type InnerLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a InnerLevel.
     */
    data: XOR<InnerLevelUpdateInput, InnerLevelUncheckedUpdateInput>
    /**
     * Choose, which InnerLevel to update.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel updateMany
   */
  export type InnerLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InnerLevels.
     */
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyInput>
    /**
     * Filter which InnerLevels to update
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to update.
     */
    limit?: number
  }

  /**
   * InnerLevel updateManyAndReturn
   */
  export type InnerLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * The data used to update InnerLevels.
     */
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyInput>
    /**
     * Filter which InnerLevels to update
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InnerLevel upsert
   */
  export type InnerLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the InnerLevel to update in case it exists.
     */
    where: InnerLevelWhereUniqueInput
    /**
     * In case the InnerLevel found by the `where` argument doesn't exist, create a new InnerLevel with this data.
     */
    create: XOR<InnerLevelCreateInput, InnerLevelUncheckedCreateInput>
    /**
     * In case the InnerLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InnerLevelUpdateInput, InnerLevelUncheckedUpdateInput>
  }

  /**
   * InnerLevel delete
   */
  export type InnerLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter which InnerLevel to delete.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel deleteMany
   */
  export type InnerLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnerLevels to delete
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to delete.
     */
    limit?: number
  }

  /**
   * InnerLevel without action
   */
  export type InnerLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
  }


  /**
   * Model Gempo
   */

  export type AggregateGempo = {
    _count: GempoCountAggregateOutputType | null
    _min: GempoMinAggregateOutputType | null
    _max: GempoMaxAggregateOutputType | null
  }

  export type GempoMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type GempoMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type GempoCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    inGameId: number
    userId: number
    zoneInGameId: number
    _all: number
  }


  export type GempoMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type GempoMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type GempoCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    _all?: true
  }

  export type GempoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gempo to aggregate.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gempos
    **/
    _count?: true | GempoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GempoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GempoMaxAggregateInputType
  }

  export type GetGempoAggregateType<T extends GempoAggregateArgs> = {
        [P in keyof T & keyof AggregateGempo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGempo[P]>
      : GetScalarType<T[P], AggregateGempo[P]>
  }




  export type GempoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoWhereInput
    orderBy?: GempoOrderByWithAggregationInput | GempoOrderByWithAggregationInput[]
    by: GempoScalarFieldEnum[] | GempoScalarFieldEnum
    having?: GempoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GempoCountAggregateInputType | true
    _min?: GempoMinAggregateInputType
    _max?: GempoMaxAggregateInputType
  }

  export type GempoGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    inGameId: string
    userId: string
    zoneInGameId: string
    _count: GempoCountAggregateOutputType | null
    _min: GempoMinAggregateOutputType | null
    _max: GempoMaxAggregateOutputType | null
  }

  type GetGempoGroupByPayload<T extends GempoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GempoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GempoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GempoGroupByOutputType[P]>
            : GetScalarType<T[P], GempoGroupByOutputType[P]>
        }
      >
    >


  export type GempoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
  }

  export type GempoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "createdAt" | "updatedAt" | "inGameId" | "userId" | "zoneInGameId", ExtArgs["result"]["gempo"]>
  export type GempoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GempoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gempo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date
      inGameId: string
      userId: string
      zoneInGameId: string
    }, ExtArgs["result"]["gempo"]>
    composites: {}
  }

  type GempoGetPayload<S extends boolean | null | undefined | GempoDefaultArgs> = $Result.GetResult<Prisma.$GempoPayload, S>

  type GempoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GempoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GempoCountAggregateInputType | true
    }

  export interface GempoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gempo'], meta: { name: 'Gempo' } }
    /**
     * Find zero or one Gempo that matches the filter.
     * @param {GempoFindUniqueArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GempoFindUniqueArgs>(args: SelectSubset<T, GempoFindUniqueArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gempo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GempoFindUniqueOrThrowArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GempoFindUniqueOrThrowArgs>(args: SelectSubset<T, GempoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gempo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindFirstArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GempoFindFirstArgs>(args?: SelectSubset<T, GempoFindFirstArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gempo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindFirstOrThrowArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GempoFindFirstOrThrowArgs>(args?: SelectSubset<T, GempoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gempos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gempos
     * const gempos = await prisma.gempo.findMany()
     * 
     * // Get first 10 Gempos
     * const gempos = await prisma.gempo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gempoWithIdOnly = await prisma.gempo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GempoFindManyArgs>(args?: SelectSubset<T, GempoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gempo.
     * @param {GempoCreateArgs} args - Arguments to create a Gempo.
     * @example
     * // Create one Gempo
     * const Gempo = await prisma.gempo.create({
     *   data: {
     *     // ... data to create a Gempo
     *   }
     * })
     * 
     */
    create<T extends GempoCreateArgs>(args: SelectSubset<T, GempoCreateArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gempos.
     * @param {GempoCreateManyArgs} args - Arguments to create many Gempos.
     * @example
     * // Create many Gempos
     * const gempo = await prisma.gempo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GempoCreateManyArgs>(args?: SelectSubset<T, GempoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gempos and returns the data saved in the database.
     * @param {GempoCreateManyAndReturnArgs} args - Arguments to create many Gempos.
     * @example
     * // Create many Gempos
     * const gempo = await prisma.gempo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gempos and only return the `id`
     * const gempoWithIdOnly = await prisma.gempo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GempoCreateManyAndReturnArgs>(args?: SelectSubset<T, GempoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gempo.
     * @param {GempoDeleteArgs} args - Arguments to delete one Gempo.
     * @example
     * // Delete one Gempo
     * const Gempo = await prisma.gempo.delete({
     *   where: {
     *     // ... filter to delete one Gempo
     *   }
     * })
     * 
     */
    delete<T extends GempoDeleteArgs>(args: SelectSubset<T, GempoDeleteArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gempo.
     * @param {GempoUpdateArgs} args - Arguments to update one Gempo.
     * @example
     * // Update one Gempo
     * const gempo = await prisma.gempo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GempoUpdateArgs>(args: SelectSubset<T, GempoUpdateArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gempos.
     * @param {GempoDeleteManyArgs} args - Arguments to filter Gempos to delete.
     * @example
     * // Delete a few Gempos
     * const { count } = await prisma.gempo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GempoDeleteManyArgs>(args?: SelectSubset<T, GempoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gempos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gempos
     * const gempo = await prisma.gempo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GempoUpdateManyArgs>(args: SelectSubset<T, GempoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gempos and returns the data updated in the database.
     * @param {GempoUpdateManyAndReturnArgs} args - Arguments to update many Gempos.
     * @example
     * // Update many Gempos
     * const gempo = await prisma.gempo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gempos and only return the `id`
     * const gempoWithIdOnly = await prisma.gempo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GempoUpdateManyAndReturnArgs>(args: SelectSubset<T, GempoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gempo.
     * @param {GempoUpsertArgs} args - Arguments to update or create a Gempo.
     * @example
     * // Update or create a Gempo
     * const gempo = await prisma.gempo.upsert({
     *   create: {
     *     // ... data to create a Gempo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gempo we want to update
     *   }
     * })
     */
    upsert<T extends GempoUpsertArgs>(args: SelectSubset<T, GempoUpsertArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gempos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoCountArgs} args - Arguments to filter Gempos to count.
     * @example
     * // Count the number of Gempos
     * const count = await prisma.gempo.count({
     *   where: {
     *     // ... the filter for the Gempos we want to count
     *   }
     * })
    **/
    count<T extends GempoCountArgs>(
      args?: Subset<T, GempoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GempoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gempo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GempoAggregateArgs>(args: Subset<T, GempoAggregateArgs>): Prisma.PrismaPromise<GetGempoAggregateType<T>>

    /**
     * Group by Gempo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GempoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GempoGroupByArgs['orderBy'] }
        : { orderBy?: GempoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GempoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGempoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gempo model
   */
  readonly fields: GempoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gempo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GempoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gempo model
   */
  interface GempoFieldRefs {
    readonly id: FieldRef<"Gempo", 'String'>
    readonly isUnlock: FieldRef<"Gempo", 'Boolean'>
    readonly unlockedAt: FieldRef<"Gempo", 'DateTime'>
    readonly createdAt: FieldRef<"Gempo", 'DateTime'>
    readonly updatedAt: FieldRef<"Gempo", 'DateTime'>
    readonly inGameId: FieldRef<"Gempo", 'String'>
    readonly userId: FieldRef<"Gempo", 'String'>
    readonly zoneInGameId: FieldRef<"Gempo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gempo findUnique
   */
  export type GempoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo findUniqueOrThrow
   */
  export type GempoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo findFirst
   */
  export type GempoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gempos.
     */
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo findFirstOrThrow
   */
  export type GempoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gempos.
     */
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo findMany
   */
  export type GempoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempos to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo create
   */
  export type GempoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The data needed to create a Gempo.
     */
    data: XOR<GempoCreateInput, GempoUncheckedCreateInput>
  }

  /**
   * Gempo createMany
   */
  export type GempoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gempos.
     */
    data: GempoCreateManyInput | GempoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gempo createManyAndReturn
   */
  export type GempoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * The data used to create many Gempos.
     */
    data: GempoCreateManyInput | GempoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gempo update
   */
  export type GempoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The data needed to update a Gempo.
     */
    data: XOR<GempoUpdateInput, GempoUncheckedUpdateInput>
    /**
     * Choose, which Gempo to update.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo updateMany
   */
  export type GempoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gempos.
     */
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyInput>
    /**
     * Filter which Gempos to update
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to update.
     */
    limit?: number
  }

  /**
   * Gempo updateManyAndReturn
   */
  export type GempoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * The data used to update Gempos.
     */
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyInput>
    /**
     * Filter which Gempos to update
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gempo upsert
   */
  export type GempoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The filter to search for the Gempo to update in case it exists.
     */
    where: GempoWhereUniqueInput
    /**
     * In case the Gempo found by the `where` argument doesn't exist, create a new Gempo with this data.
     */
    create: XOR<GempoCreateInput, GempoUncheckedCreateInput>
    /**
     * In case the Gempo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GempoUpdateInput, GempoUncheckedUpdateInput>
  }

  /**
   * Gempo delete
   */
  export type GempoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter which Gempo to delete.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo deleteMany
   */
  export type GempoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gempos to delete
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to delete.
     */
    limit?: number
  }

  /**
   * Gempo without action
   */
  export type GempoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
  }


  /**
   * Model Championship
   */

  export type AggregateChampionship = {
    _count: ChampionshipCountAggregateOutputType | null
    _min: ChampionshipMinAggregateOutputType | null
    _max: ChampionshipMaxAggregateOutputType | null
  }

  export type ChampionshipMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type ChampionshipMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type ChampionshipCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    inGameId: number
    userId: number
    zoneInGameId: number
    _all: number
  }


  export type ChampionshipMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type ChampionshipMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type ChampionshipCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    _all?: true
  }

  export type ChampionshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Championship to aggregate.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Championships
    **/
    _count?: true | ChampionshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipMaxAggregateInputType
  }

  export type GetChampionshipAggregateType<T extends ChampionshipAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionship[P]>
      : GetScalarType<T[P], AggregateChampionship[P]>
  }




  export type ChampionshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipWhereInput
    orderBy?: ChampionshipOrderByWithAggregationInput | ChampionshipOrderByWithAggregationInput[]
    by: ChampionshipScalarFieldEnum[] | ChampionshipScalarFieldEnum
    having?: ChampionshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipCountAggregateInputType | true
    _min?: ChampionshipMinAggregateInputType
    _max?: ChampionshipMaxAggregateInputType
  }

  export type ChampionshipGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    inGameId: string
    userId: string
    zoneInGameId: string
    _count: ChampionshipCountAggregateOutputType | null
    _min: ChampionshipMinAggregateOutputType | null
    _max: ChampionshipMaxAggregateOutputType | null
  }

  type GetChampionshipGroupByPayload<T extends ChampionshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
  }

  export type ChampionshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "createdAt" | "updatedAt" | "inGameId" | "userId" | "zoneInGameId", ExtArgs["result"]["championship"]>
  export type ChampionshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChampionshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Championship"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date
      inGameId: string
      userId: string
      zoneInGameId: string
    }, ExtArgs["result"]["championship"]>
    composites: {}
  }

  type ChampionshipGetPayload<S extends boolean | null | undefined | ChampionshipDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipPayload, S>

  type ChampionshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipCountAggregateInputType | true
    }

  export interface ChampionshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Championship'], meta: { name: 'Championship' } }
    /**
     * Find zero or one Championship that matches the filter.
     * @param {ChampionshipFindUniqueArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipFindUniqueArgs>(args: SelectSubset<T, ChampionshipFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Championship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipFindUniqueOrThrowArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Championship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindFirstArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipFindFirstArgs>(args?: SelectSubset<T, ChampionshipFindFirstArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Championship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindFirstOrThrowArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Championships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Championships
     * const championships = await prisma.championship.findMany()
     * 
     * // Get first 10 Championships
     * const championships = await prisma.championship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipWithIdOnly = await prisma.championship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipFindManyArgs>(args?: SelectSubset<T, ChampionshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Championship.
     * @param {ChampionshipCreateArgs} args - Arguments to create a Championship.
     * @example
     * // Create one Championship
     * const Championship = await prisma.championship.create({
     *   data: {
     *     // ... data to create a Championship
     *   }
     * })
     * 
     */
    create<T extends ChampionshipCreateArgs>(args: SelectSubset<T, ChampionshipCreateArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Championships.
     * @param {ChampionshipCreateManyArgs} args - Arguments to create many Championships.
     * @example
     * // Create many Championships
     * const championship = await prisma.championship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipCreateManyArgs>(args?: SelectSubset<T, ChampionshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Championships and returns the data saved in the database.
     * @param {ChampionshipCreateManyAndReturnArgs} args - Arguments to create many Championships.
     * @example
     * // Create many Championships
     * const championship = await prisma.championship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Championships and only return the `id`
     * const championshipWithIdOnly = await prisma.championship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Championship.
     * @param {ChampionshipDeleteArgs} args - Arguments to delete one Championship.
     * @example
     * // Delete one Championship
     * const Championship = await prisma.championship.delete({
     *   where: {
     *     // ... filter to delete one Championship
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipDeleteArgs>(args: SelectSubset<T, ChampionshipDeleteArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Championship.
     * @param {ChampionshipUpdateArgs} args - Arguments to update one Championship.
     * @example
     * // Update one Championship
     * const championship = await prisma.championship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipUpdateArgs>(args: SelectSubset<T, ChampionshipUpdateArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Championships.
     * @param {ChampionshipDeleteManyArgs} args - Arguments to filter Championships to delete.
     * @example
     * // Delete a few Championships
     * const { count } = await prisma.championship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipDeleteManyArgs>(args?: SelectSubset<T, ChampionshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Championships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Championships
     * const championship = await prisma.championship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipUpdateManyArgs>(args: SelectSubset<T, ChampionshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Championships and returns the data updated in the database.
     * @param {ChampionshipUpdateManyAndReturnArgs} args - Arguments to update many Championships.
     * @example
     * // Update many Championships
     * const championship = await prisma.championship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Championships and only return the `id`
     * const championshipWithIdOnly = await prisma.championship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Championship.
     * @param {ChampionshipUpsertArgs} args - Arguments to update or create a Championship.
     * @example
     * // Update or create a Championship
     * const championship = await prisma.championship.upsert({
     *   create: {
     *     // ... data to create a Championship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Championship we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipUpsertArgs>(args: SelectSubset<T, ChampionshipUpsertArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Championships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipCountArgs} args - Arguments to filter Championships to count.
     * @example
     * // Count the number of Championships
     * const count = await prisma.championship.count({
     *   where: {
     *     // ... the filter for the Championships we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipCountArgs>(
      args?: Subset<T, ChampionshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Championship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipAggregateArgs>(args: Subset<T, ChampionshipAggregateArgs>): Prisma.PrismaPromise<GetChampionshipAggregateType<T>>

    /**
     * Group by Championship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Championship model
   */
  readonly fields: ChampionshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Championship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Championship model
   */
  interface ChampionshipFieldRefs {
    readonly id: FieldRef<"Championship", 'String'>
    readonly isUnlock: FieldRef<"Championship", 'Boolean'>
    readonly unlockedAt: FieldRef<"Championship", 'DateTime'>
    readonly createdAt: FieldRef<"Championship", 'DateTime'>
    readonly updatedAt: FieldRef<"Championship", 'DateTime'>
    readonly inGameId: FieldRef<"Championship", 'String'>
    readonly userId: FieldRef<"Championship", 'String'>
    readonly zoneInGameId: FieldRef<"Championship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Championship findUnique
   */
  export type ChampionshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship findUniqueOrThrow
   */
  export type ChampionshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship findFirst
   */
  export type ChampionshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Championships.
     */
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship findFirstOrThrow
   */
  export type ChampionshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Championships.
     */
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship findMany
   */
  export type ChampionshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championships to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship create
   */
  export type ChampionshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Championship.
     */
    data: XOR<ChampionshipCreateInput, ChampionshipUncheckedCreateInput>
  }

  /**
   * Championship createMany
   */
  export type ChampionshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Championships.
     */
    data: ChampionshipCreateManyInput | ChampionshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Championship createManyAndReturn
   */
  export type ChampionshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * The data used to create many Championships.
     */
    data: ChampionshipCreateManyInput | ChampionshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Championship update
   */
  export type ChampionshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Championship.
     */
    data: XOR<ChampionshipUpdateInput, ChampionshipUncheckedUpdateInput>
    /**
     * Choose, which Championship to update.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship updateMany
   */
  export type ChampionshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Championships.
     */
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyInput>
    /**
     * Filter which Championships to update
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to update.
     */
    limit?: number
  }

  /**
   * Championship updateManyAndReturn
   */
  export type ChampionshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * The data used to update Championships.
     */
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyInput>
    /**
     * Filter which Championships to update
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Championship upsert
   */
  export type ChampionshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Championship to update in case it exists.
     */
    where: ChampionshipWhereUniqueInput
    /**
     * In case the Championship found by the `where` argument doesn't exist, create a new Championship with this data.
     */
    create: XOR<ChampionshipCreateInput, ChampionshipUncheckedCreateInput>
    /**
     * In case the Championship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipUpdateInput, ChampionshipUncheckedUpdateInput>
  }

  /**
   * Championship delete
   */
  export type ChampionshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter which Championship to delete.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship deleteMany
   */
  export type ChampionshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Championships to delete
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to delete.
     */
    limit?: number
  }

  /**
   * Championship without action
   */
  export type ChampionshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
  }


  /**
   * Model GempoRecord
   */

  export type AggregateGempoRecord = {
    _count: GempoRecordCountAggregateOutputType | null
    _avg: GempoRecordAvgAggregateOutputType | null
    _sum: GempoRecordSumAggregateOutputType | null
    _min: GempoRecordMinAggregateOutputType | null
    _max: GempoRecordMaxAggregateOutputType | null
  }

  export type GempoRecordAvgAggregateOutputType = {
    played: number | null
    point: number | null
    highestPoint: number | null
    correctAttempt: number | null
  }

  export type GempoRecordSumAggregateOutputType = {
    played: number | null
    point: number | null
    highestPoint: number | null
    correctAttempt: number | null
  }

  export type GempoRecordMinAggregateOutputType = {
    id: string | null
    played: number | null
    point: number | null
    highestPoint: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    gempoInGameId: string | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
    correctAttempt: number | null
  }

  export type GempoRecordMaxAggregateOutputType = {
    id: string | null
    played: number | null
    point: number | null
    highestPoint: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    gempoInGameId: string | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
    correctAttempt: number | null
  }

  export type GempoRecordCountAggregateOutputType = {
    id: number
    played: number
    point: number
    highestPoint: number
    lastPlayedAt: number
    createdAt: number
    updatedAt: number
    gempoInGameId: number
    inGameId: number
    userId: number
    zoneInGameId: number
    correctAttempt: number
    _all: number
  }


  export type GempoRecordAvgAggregateInputType = {
    played?: true
    point?: true
    highestPoint?: true
    correctAttempt?: true
  }

  export type GempoRecordSumAggregateInputType = {
    played?: true
    point?: true
    highestPoint?: true
    correctAttempt?: true
  }

  export type GempoRecordMinAggregateInputType = {
    id?: true
    played?: true
    point?: true
    highestPoint?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    gempoInGameId?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    correctAttempt?: true
  }

  export type GempoRecordMaxAggregateInputType = {
    id?: true
    played?: true
    point?: true
    highestPoint?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    gempoInGameId?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    correctAttempt?: true
  }

  export type GempoRecordCountAggregateInputType = {
    id?: true
    played?: true
    point?: true
    highestPoint?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    gempoInGameId?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    correctAttempt?: true
    _all?: true
  }

  export type GempoRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GempoRecord to aggregate.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GempoRecords
    **/
    _count?: true | GempoRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GempoRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GempoRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GempoRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GempoRecordMaxAggregateInputType
  }

  export type GetGempoRecordAggregateType<T extends GempoRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateGempoRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGempoRecord[P]>
      : GetScalarType<T[P], AggregateGempoRecord[P]>
  }




  export type GempoRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoRecordWhereInput
    orderBy?: GempoRecordOrderByWithAggregationInput | GempoRecordOrderByWithAggregationInput[]
    by: GempoRecordScalarFieldEnum[] | GempoRecordScalarFieldEnum
    having?: GempoRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GempoRecordCountAggregateInputType | true
    _avg?: GempoRecordAvgAggregateInputType
    _sum?: GempoRecordSumAggregateInputType
    _min?: GempoRecordMinAggregateInputType
    _max?: GempoRecordMaxAggregateInputType
  }

  export type GempoRecordGroupByOutputType = {
    id: string
    played: number
    point: number
    highestPoint: number
    lastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    gempoInGameId: string
    inGameId: string
    userId: string
    zoneInGameId: string
    correctAttempt: number
    _count: GempoRecordCountAggregateOutputType | null
    _avg: GempoRecordAvgAggregateOutputType | null
    _sum: GempoRecordSumAggregateOutputType | null
    _min: GempoRecordMinAggregateOutputType | null
    _max: GempoRecordMaxAggregateOutputType | null
  }

  type GetGempoRecordGroupByPayload<T extends GempoRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GempoRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GempoRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GempoRecordGroupByOutputType[P]>
            : GetScalarType<T[P], GempoRecordGroupByOutputType[P]>
        }
      >
    >


  export type GempoRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    played?: boolean
    point?: boolean
    highestPoint?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempoInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    correctAttempt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    played?: boolean
    point?: boolean
    highestPoint?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempoInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    correctAttempt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    played?: boolean
    point?: boolean
    highestPoint?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempoInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    correctAttempt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectScalar = {
    id?: boolean
    played?: boolean
    point?: boolean
    highestPoint?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gempoInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    correctAttempt?: boolean
  }

  export type GempoRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "played" | "point" | "highestPoint" | "lastPlayedAt" | "createdAt" | "updatedAt" | "gempoInGameId" | "inGameId" | "userId" | "zoneInGameId" | "correctAttempt", ExtArgs["result"]["gempoRecord"]>
  export type GempoRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GempoRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GempoRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      played: number
      point: number
      highestPoint: number
      lastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
      gempoInGameId: string
      inGameId: string
      userId: string
      zoneInGameId: string
      correctAttempt: number
    }, ExtArgs["result"]["gempoRecord"]>
    composites: {}
  }

  type GempoRecordGetPayload<S extends boolean | null | undefined | GempoRecordDefaultArgs> = $Result.GetResult<Prisma.$GempoRecordPayload, S>

  type GempoRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GempoRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GempoRecordCountAggregateInputType | true
    }

  export interface GempoRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GempoRecord'], meta: { name: 'GempoRecord' } }
    /**
     * Find zero or one GempoRecord that matches the filter.
     * @param {GempoRecordFindUniqueArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GempoRecordFindUniqueArgs>(args: SelectSubset<T, GempoRecordFindUniqueArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GempoRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GempoRecordFindUniqueOrThrowArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GempoRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, GempoRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GempoRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindFirstArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GempoRecordFindFirstArgs>(args?: SelectSubset<T, GempoRecordFindFirstArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GempoRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindFirstOrThrowArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GempoRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, GempoRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GempoRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GempoRecords
     * const gempoRecords = await prisma.gempoRecord.findMany()
     * 
     * // Get first 10 GempoRecords
     * const gempoRecords = await prisma.gempoRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GempoRecordFindManyArgs>(args?: SelectSubset<T, GempoRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GempoRecord.
     * @param {GempoRecordCreateArgs} args - Arguments to create a GempoRecord.
     * @example
     * // Create one GempoRecord
     * const GempoRecord = await prisma.gempoRecord.create({
     *   data: {
     *     // ... data to create a GempoRecord
     *   }
     * })
     * 
     */
    create<T extends GempoRecordCreateArgs>(args: SelectSubset<T, GempoRecordCreateArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GempoRecords.
     * @param {GempoRecordCreateManyArgs} args - Arguments to create many GempoRecords.
     * @example
     * // Create many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GempoRecordCreateManyArgs>(args?: SelectSubset<T, GempoRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GempoRecords and returns the data saved in the database.
     * @param {GempoRecordCreateManyAndReturnArgs} args - Arguments to create many GempoRecords.
     * @example
     * // Create many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GempoRecords and only return the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GempoRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, GempoRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GempoRecord.
     * @param {GempoRecordDeleteArgs} args - Arguments to delete one GempoRecord.
     * @example
     * // Delete one GempoRecord
     * const GempoRecord = await prisma.gempoRecord.delete({
     *   where: {
     *     // ... filter to delete one GempoRecord
     *   }
     * })
     * 
     */
    delete<T extends GempoRecordDeleteArgs>(args: SelectSubset<T, GempoRecordDeleteArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GempoRecord.
     * @param {GempoRecordUpdateArgs} args - Arguments to update one GempoRecord.
     * @example
     * // Update one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GempoRecordUpdateArgs>(args: SelectSubset<T, GempoRecordUpdateArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GempoRecords.
     * @param {GempoRecordDeleteManyArgs} args - Arguments to filter GempoRecords to delete.
     * @example
     * // Delete a few GempoRecords
     * const { count } = await prisma.gempoRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GempoRecordDeleteManyArgs>(args?: SelectSubset<T, GempoRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GempoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GempoRecordUpdateManyArgs>(args: SelectSubset<T, GempoRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GempoRecords and returns the data updated in the database.
     * @param {GempoRecordUpdateManyAndReturnArgs} args - Arguments to update many GempoRecords.
     * @example
     * // Update many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GempoRecords and only return the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GempoRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, GempoRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GempoRecord.
     * @param {GempoRecordUpsertArgs} args - Arguments to update or create a GempoRecord.
     * @example
     * // Update or create a GempoRecord
     * const gempoRecord = await prisma.gempoRecord.upsert({
     *   create: {
     *     // ... data to create a GempoRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GempoRecord we want to update
     *   }
     * })
     */
    upsert<T extends GempoRecordUpsertArgs>(args: SelectSubset<T, GempoRecordUpsertArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GempoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordCountArgs} args - Arguments to filter GempoRecords to count.
     * @example
     * // Count the number of GempoRecords
     * const count = await prisma.gempoRecord.count({
     *   where: {
     *     // ... the filter for the GempoRecords we want to count
     *   }
     * })
    **/
    count<T extends GempoRecordCountArgs>(
      args?: Subset<T, GempoRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GempoRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GempoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GempoRecordAggregateArgs>(args: Subset<T, GempoRecordAggregateArgs>): Prisma.PrismaPromise<GetGempoRecordAggregateType<T>>

    /**
     * Group by GempoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GempoRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GempoRecordGroupByArgs['orderBy'] }
        : { orderBy?: GempoRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GempoRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGempoRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GempoRecord model
   */
  readonly fields: GempoRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GempoRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GempoRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GempoRecord model
   */
  interface GempoRecordFieldRefs {
    readonly id: FieldRef<"GempoRecord", 'String'>
    readonly played: FieldRef<"GempoRecord", 'Int'>
    readonly point: FieldRef<"GempoRecord", 'Int'>
    readonly highestPoint: FieldRef<"GempoRecord", 'Int'>
    readonly lastPlayedAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly createdAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly gempoInGameId: FieldRef<"GempoRecord", 'String'>
    readonly inGameId: FieldRef<"GempoRecord", 'String'>
    readonly userId: FieldRef<"GempoRecord", 'String'>
    readonly zoneInGameId: FieldRef<"GempoRecord", 'String'>
    readonly correctAttempt: FieldRef<"GempoRecord", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * GempoRecord findUnique
   */
  export type GempoRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord findUniqueOrThrow
   */
  export type GempoRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord findFirst
   */
  export type GempoRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GempoRecords.
     */
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord findFirstOrThrow
   */
  export type GempoRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GempoRecords.
     */
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord findMany
   */
  export type GempoRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecords to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord create
   */
  export type GempoRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a GempoRecord.
     */
    data: XOR<GempoRecordCreateInput, GempoRecordUncheckedCreateInput>
  }

  /**
   * GempoRecord createMany
   */
  export type GempoRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GempoRecords.
     */
    data: GempoRecordCreateManyInput | GempoRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GempoRecord createManyAndReturn
   */
  export type GempoRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * The data used to create many GempoRecords.
     */
    data: GempoRecordCreateManyInput | GempoRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GempoRecord update
   */
  export type GempoRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a GempoRecord.
     */
    data: XOR<GempoRecordUpdateInput, GempoRecordUncheckedUpdateInput>
    /**
     * Choose, which GempoRecord to update.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord updateMany
   */
  export type GempoRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GempoRecords.
     */
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyInput>
    /**
     * Filter which GempoRecords to update
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to update.
     */
    limit?: number
  }

  /**
   * GempoRecord updateManyAndReturn
   */
  export type GempoRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * The data used to update GempoRecords.
     */
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyInput>
    /**
     * Filter which GempoRecords to update
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GempoRecord upsert
   */
  export type GempoRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the GempoRecord to update in case it exists.
     */
    where: GempoRecordWhereUniqueInput
    /**
     * In case the GempoRecord found by the `where` argument doesn't exist, create a new GempoRecord with this data.
     */
    create: XOR<GempoRecordCreateInput, GempoRecordUncheckedCreateInput>
    /**
     * In case the GempoRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GempoRecordUpdateInput, GempoRecordUncheckedUpdateInput>
  }

  /**
   * GempoRecord delete
   */
  export type GempoRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter which GempoRecord to delete.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord deleteMany
   */
  export type GempoRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GempoRecords to delete
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to delete.
     */
    limit?: number
  }

  /**
   * GempoRecord without action
   */
  export type GempoRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
  }


  /**
   * Model ChampionshipRecord
   */

  export type AggregateChampionshipRecord = {
    _count: ChampionshipRecordCountAggregateOutputType | null
    _avg: ChampionshipRecordAvgAggregateOutputType | null
    _sum: ChampionshipRecordSumAggregateOutputType | null
    _min: ChampionshipRecordMinAggregateOutputType | null
    _max: ChampionshipRecordMaxAggregateOutputType | null
  }

  export type ChampionshipRecordAvgAggregateOutputType = {
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
  }

  export type ChampionshipRecordSumAggregateOutputType = {
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
  }

  export type ChampionshipRecordMinAggregateOutputType = {
    id: string | null
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    teamLastPlayedAt: Date | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
    soloLastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    championshipInGameId: string | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type ChampionshipRecordMaxAggregateOutputType = {
    id: string | null
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    teamLastPlayedAt: Date | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
    soloLastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    championshipInGameId: string | null
    inGameId: string | null
    userId: string | null
    zoneInGameId: string | null
  }

  export type ChampionshipRecordCountAggregateOutputType = {
    id: number
    teamWin: number
    teamLose: number
    teamPlayed: number
    teamPoint: number
    teamLastPlayedAt: number
    soloWin: number
    soloLose: number
    soloPlayed: number
    soloPoint: number
    soloLastPlayedAt: number
    createdAt: number
    updatedAt: number
    championshipInGameId: number
    inGameId: number
    userId: number
    zoneInGameId: number
    _all: number
  }


  export type ChampionshipRecordAvgAggregateInputType = {
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
  }

  export type ChampionshipRecordSumAggregateInputType = {
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
  }

  export type ChampionshipRecordMinAggregateInputType = {
    id?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    championshipInGameId?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type ChampionshipRecordMaxAggregateInputType = {
    id?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    championshipInGameId?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
  }

  export type ChampionshipRecordCountAggregateInputType = {
    id?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    championshipInGameId?: true
    inGameId?: true
    userId?: true
    zoneInGameId?: true
    _all?: true
  }

  export type ChampionshipRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipRecord to aggregate.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChampionshipRecords
    **/
    _count?: true | ChampionshipRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChampionshipRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChampionshipRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipRecordMaxAggregateInputType
  }

  export type GetChampionshipRecordAggregateType<T extends ChampionshipRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionshipRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionshipRecord[P]>
      : GetScalarType<T[P], AggregateChampionshipRecord[P]>
  }




  export type ChampionshipRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipRecordWhereInput
    orderBy?: ChampionshipRecordOrderByWithAggregationInput | ChampionshipRecordOrderByWithAggregationInput[]
    by: ChampionshipRecordScalarFieldEnum[] | ChampionshipRecordScalarFieldEnum
    having?: ChampionshipRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipRecordCountAggregateInputType | true
    _avg?: ChampionshipRecordAvgAggregateInputType
    _sum?: ChampionshipRecordSumAggregateInputType
    _min?: ChampionshipRecordMinAggregateInputType
    _max?: ChampionshipRecordMaxAggregateInputType
  }

  export type ChampionshipRecordGroupByOutputType = {
    id: string
    teamWin: number
    teamLose: number
    teamPlayed: number
    teamPoint: number
    teamLastPlayedAt: Date | null
    soloWin: number
    soloLose: number
    soloPlayed: number
    soloPoint: number
    soloLastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    championshipInGameId: string
    inGameId: string
    userId: string
    zoneInGameId: string
    _count: ChampionshipRecordCountAggregateOutputType | null
    _avg: ChampionshipRecordAvgAggregateOutputType | null
    _sum: ChampionshipRecordSumAggregateOutputType | null
    _min: ChampionshipRecordMinAggregateOutputType | null
    _max: ChampionshipRecordMaxAggregateOutputType | null
  }

  type GetChampionshipRecordGroupByPayload<T extends ChampionshipRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipRecordGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championshipInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championshipInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championshipInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectScalar = {
    id?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    championshipInGameId?: boolean
    inGameId?: boolean
    userId?: boolean
    zoneInGameId?: boolean
  }

  export type ChampionshipRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamWin" | "teamLose" | "teamPlayed" | "teamPoint" | "teamLastPlayedAt" | "soloWin" | "soloLose" | "soloPlayed" | "soloPoint" | "soloLastPlayedAt" | "createdAt" | "updatedAt" | "championshipInGameId" | "inGameId" | "userId" | "zoneInGameId", ExtArgs["result"]["championshipRecord"]>
  export type ChampionshipRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChampionshipRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChampionshipRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamWin: number
      teamLose: number
      teamPlayed: number
      teamPoint: number
      teamLastPlayedAt: Date | null
      soloWin: number
      soloLose: number
      soloPlayed: number
      soloPoint: number
      soloLastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
      championshipInGameId: string
      inGameId: string
      userId: string
      zoneInGameId: string
    }, ExtArgs["result"]["championshipRecord"]>
    composites: {}
  }

  type ChampionshipRecordGetPayload<S extends boolean | null | undefined | ChampionshipRecordDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipRecordPayload, S>

  type ChampionshipRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipRecordCountAggregateInputType | true
    }

  export interface ChampionshipRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChampionshipRecord'], meta: { name: 'ChampionshipRecord' } }
    /**
     * Find zero or one ChampionshipRecord that matches the filter.
     * @param {ChampionshipRecordFindUniqueArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipRecordFindUniqueArgs>(args: SelectSubset<T, ChampionshipRecordFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChampionshipRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipRecordFindUniqueOrThrowArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindFirstArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipRecordFindFirstArgs>(args?: SelectSubset<T, ChampionshipRecordFindFirstArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindFirstOrThrowArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChampionshipRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChampionshipRecords
     * const championshipRecords = await prisma.championshipRecord.findMany()
     * 
     * // Get first 10 ChampionshipRecords
     * const championshipRecords = await prisma.championshipRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipRecordFindManyArgs>(args?: SelectSubset<T, ChampionshipRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChampionshipRecord.
     * @param {ChampionshipRecordCreateArgs} args - Arguments to create a ChampionshipRecord.
     * @example
     * // Create one ChampionshipRecord
     * const ChampionshipRecord = await prisma.championshipRecord.create({
     *   data: {
     *     // ... data to create a ChampionshipRecord
     *   }
     * })
     * 
     */
    create<T extends ChampionshipRecordCreateArgs>(args: SelectSubset<T, ChampionshipRecordCreateArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChampionshipRecords.
     * @param {ChampionshipRecordCreateManyArgs} args - Arguments to create many ChampionshipRecords.
     * @example
     * // Create many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipRecordCreateManyArgs>(args?: SelectSubset<T, ChampionshipRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChampionshipRecords and returns the data saved in the database.
     * @param {ChampionshipRecordCreateManyAndReturnArgs} args - Arguments to create many ChampionshipRecords.
     * @example
     * // Create many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChampionshipRecords and only return the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChampionshipRecord.
     * @param {ChampionshipRecordDeleteArgs} args - Arguments to delete one ChampionshipRecord.
     * @example
     * // Delete one ChampionshipRecord
     * const ChampionshipRecord = await prisma.championshipRecord.delete({
     *   where: {
     *     // ... filter to delete one ChampionshipRecord
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipRecordDeleteArgs>(args: SelectSubset<T, ChampionshipRecordDeleteArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChampionshipRecord.
     * @param {ChampionshipRecordUpdateArgs} args - Arguments to update one ChampionshipRecord.
     * @example
     * // Update one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipRecordUpdateArgs>(args: SelectSubset<T, ChampionshipRecordUpdateArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChampionshipRecords.
     * @param {ChampionshipRecordDeleteManyArgs} args - Arguments to filter ChampionshipRecords to delete.
     * @example
     * // Delete a few ChampionshipRecords
     * const { count } = await prisma.championshipRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipRecordDeleteManyArgs>(args?: SelectSubset<T, ChampionshipRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipRecordUpdateManyArgs>(args: SelectSubset<T, ChampionshipRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipRecords and returns the data updated in the database.
     * @param {ChampionshipRecordUpdateManyAndReturnArgs} args - Arguments to update many ChampionshipRecords.
     * @example
     * // Update many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChampionshipRecords and only return the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChampionshipRecord.
     * @param {ChampionshipRecordUpsertArgs} args - Arguments to update or create a ChampionshipRecord.
     * @example
     * // Update or create a ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.upsert({
     *   create: {
     *     // ... data to create a ChampionshipRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChampionshipRecord we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipRecordUpsertArgs>(args: SelectSubset<T, ChampionshipRecordUpsertArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChampionshipRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordCountArgs} args - Arguments to filter ChampionshipRecords to count.
     * @example
     * // Count the number of ChampionshipRecords
     * const count = await prisma.championshipRecord.count({
     *   where: {
     *     // ... the filter for the ChampionshipRecords we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipRecordCountArgs>(
      args?: Subset<T, ChampionshipRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChampionshipRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipRecordAggregateArgs>(args: Subset<T, ChampionshipRecordAggregateArgs>): Prisma.PrismaPromise<GetChampionshipRecordAggregateType<T>>

    /**
     * Group by ChampionshipRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipRecordGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChampionshipRecord model
   */
  readonly fields: ChampionshipRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChampionshipRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChampionshipRecord model
   */
  interface ChampionshipRecordFieldRefs {
    readonly id: FieldRef<"ChampionshipRecord", 'String'>
    readonly teamWin: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamLose: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamPlayed: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamPoint: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamLastPlayedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly soloWin: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloLose: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloPlayed: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloPoint: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloLastPlayedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly championshipInGameId: FieldRef<"ChampionshipRecord", 'String'>
    readonly inGameId: FieldRef<"ChampionshipRecord", 'String'>
    readonly userId: FieldRef<"ChampionshipRecord", 'String'>
    readonly zoneInGameId: FieldRef<"ChampionshipRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChampionshipRecord findUnique
   */
  export type ChampionshipRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord findUniqueOrThrow
   */
  export type ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord findFirst
   */
  export type ChampionshipRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipRecords.
     */
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord findFirstOrThrow
   */
  export type ChampionshipRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipRecords.
     */
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord findMany
   */
  export type ChampionshipRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecords to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord create
   */
  export type ChampionshipRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ChampionshipRecord.
     */
    data: XOR<ChampionshipRecordCreateInput, ChampionshipRecordUncheckedCreateInput>
  }

  /**
   * ChampionshipRecord createMany
   */
  export type ChampionshipRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChampionshipRecords.
     */
    data: ChampionshipRecordCreateManyInput | ChampionshipRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipRecord createManyAndReturn
   */
  export type ChampionshipRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ChampionshipRecords.
     */
    data: ChampionshipRecordCreateManyInput | ChampionshipRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChampionshipRecord update
   */
  export type ChampionshipRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ChampionshipRecord.
     */
    data: XOR<ChampionshipRecordUpdateInput, ChampionshipRecordUncheckedUpdateInput>
    /**
     * Choose, which ChampionshipRecord to update.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord updateMany
   */
  export type ChampionshipRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChampionshipRecords.
     */
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipRecords to update
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to update.
     */
    limit?: number
  }

  /**
   * ChampionshipRecord updateManyAndReturn
   */
  export type ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * The data used to update ChampionshipRecords.
     */
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipRecords to update
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChampionshipRecord upsert
   */
  export type ChampionshipRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ChampionshipRecord to update in case it exists.
     */
    where: ChampionshipRecordWhereUniqueInput
    /**
     * In case the ChampionshipRecord found by the `where` argument doesn't exist, create a new ChampionshipRecord with this data.
     */
    create: XOR<ChampionshipRecordCreateInput, ChampionshipRecordUncheckedCreateInput>
    /**
     * In case the ChampionshipRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipRecordUpdateInput, ChampionshipRecordUncheckedUpdateInput>
  }

  /**
   * ChampionshipRecord delete
   */
  export type ChampionshipRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter which ChampionshipRecord to delete.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord deleteMany
   */
  export type ChampionshipRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipRecords to delete
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to delete.
     */
    limit?: number
  }

  /**
   * ChampionshipRecord without action
   */
  export type ChampionshipRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
  }


  /**
   * Model UserLogin
   */

  export type AggregateUserLogin = {
    _count: UserLoginCountAggregateOutputType | null
    _min: UserLoginMinAggregateOutputType | null
    _max: UserLoginMaxAggregateOutputType | null
  }

  export type UserLoginMinAggregateOutputType = {
    id: string | null
    userId: string | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type UserLoginMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type UserLoginCountAggregateOutputType = {
    id: number
    userId: number
    loginDate: number
    logoutDate: number
    _all: number
  }


  export type UserLoginMinAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
  }

  export type UserLoginMaxAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
  }

  export type UserLoginCountAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
    _all?: true
  }

  export type UserLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogin to aggregate.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLogins
    **/
    _count?: true | UserLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLoginMaxAggregateInputType
  }

  export type GetUserLoginAggregateType<T extends UserLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLogin[P]>
      : GetScalarType<T[P], AggregateUserLogin[P]>
  }




  export type UserLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginWhereInput
    orderBy?: UserLoginOrderByWithAggregationInput | UserLoginOrderByWithAggregationInput[]
    by: UserLoginScalarFieldEnum[] | UserLoginScalarFieldEnum
    having?: UserLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLoginCountAggregateInputType | true
    _min?: UserLoginMinAggregateInputType
    _max?: UserLoginMaxAggregateInputType
  }

  export type UserLoginGroupByOutputType = {
    id: string
    userId: string
    loginDate: Date
    logoutDate: Date | null
    _count: UserLoginCountAggregateOutputType | null
    _min: UserLoginMinAggregateOutputType | null
    _max: UserLoginMaxAggregateOutputType | null
  }

  type GetUserLoginGroupByPayload<T extends UserLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLoginGroupByOutputType[P]>
            : GetScalarType<T[P], UserLoginGroupByOutputType[P]>
        }
      >
    >


  export type UserLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectScalar = {
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
  }

  export type UserLoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "loginDate" | "logoutDate", ExtArgs["result"]["userLogin"]>
  export type UserLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLogin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      loginDate: Date
      logoutDate: Date | null
    }, ExtArgs["result"]["userLogin"]>
    composites: {}
  }

  type UserLoginGetPayload<S extends boolean | null | undefined | UserLoginDefaultArgs> = $Result.GetResult<Prisma.$UserLoginPayload, S>

  type UserLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLoginCountAggregateInputType | true
    }

  export interface UserLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLogin'], meta: { name: 'UserLogin' } }
    /**
     * Find zero or one UserLogin that matches the filter.
     * @param {UserLoginFindUniqueArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLoginFindUniqueArgs>(args: SelectSubset<T, UserLoginFindUniqueArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLogin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLoginFindUniqueOrThrowArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindFirstArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLoginFindFirstArgs>(args?: SelectSubset<T, UserLoginFindFirstArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindFirstOrThrowArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLogins
     * const userLogins = await prisma.userLogin.findMany()
     * 
     * // Get first 10 UserLogins
     * const userLogins = await prisma.userLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLoginFindManyArgs>(args?: SelectSubset<T, UserLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLogin.
     * @param {UserLoginCreateArgs} args - Arguments to create a UserLogin.
     * @example
     * // Create one UserLogin
     * const UserLogin = await prisma.userLogin.create({
     *   data: {
     *     // ... data to create a UserLogin
     *   }
     * })
     * 
     */
    create<T extends UserLoginCreateArgs>(args: SelectSubset<T, UserLoginCreateArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLogins.
     * @param {UserLoginCreateManyArgs} args - Arguments to create many UserLogins.
     * @example
     * // Create many UserLogins
     * const userLogin = await prisma.userLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLoginCreateManyArgs>(args?: SelectSubset<T, UserLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLogins and returns the data saved in the database.
     * @param {UserLoginCreateManyAndReturnArgs} args - Arguments to create many UserLogins.
     * @example
     * // Create many UserLogins
     * const userLogin = await prisma.userLogin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLogins and only return the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLoginCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLoginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLogin.
     * @param {UserLoginDeleteArgs} args - Arguments to delete one UserLogin.
     * @example
     * // Delete one UserLogin
     * const UserLogin = await prisma.userLogin.delete({
     *   where: {
     *     // ... filter to delete one UserLogin
     *   }
     * })
     * 
     */
    delete<T extends UserLoginDeleteArgs>(args: SelectSubset<T, UserLoginDeleteArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLogin.
     * @param {UserLoginUpdateArgs} args - Arguments to update one UserLogin.
     * @example
     * // Update one UserLogin
     * const userLogin = await prisma.userLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLoginUpdateArgs>(args: SelectSubset<T, UserLoginUpdateArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLogins.
     * @param {UserLoginDeleteManyArgs} args - Arguments to filter UserLogins to delete.
     * @example
     * // Delete a few UserLogins
     * const { count } = await prisma.userLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLoginDeleteManyArgs>(args?: SelectSubset<T, UserLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLogins
     * const userLogin = await prisma.userLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLoginUpdateManyArgs>(args: SelectSubset<T, UserLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogins and returns the data updated in the database.
     * @param {UserLoginUpdateManyAndReturnArgs} args - Arguments to update many UserLogins.
     * @example
     * // Update many UserLogins
     * const userLogin = await prisma.userLogin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLogins and only return the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLoginUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLoginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLogin.
     * @param {UserLoginUpsertArgs} args - Arguments to update or create a UserLogin.
     * @example
     * // Update or create a UserLogin
     * const userLogin = await prisma.userLogin.upsert({
     *   create: {
     *     // ... data to create a UserLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLogin we want to update
     *   }
     * })
     */
    upsert<T extends UserLoginUpsertArgs>(args: SelectSubset<T, UserLoginUpsertArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginCountArgs} args - Arguments to filter UserLogins to count.
     * @example
     * // Count the number of UserLogins
     * const count = await prisma.userLogin.count({
     *   where: {
     *     // ... the filter for the UserLogins we want to count
     *   }
     * })
    **/
    count<T extends UserLoginCountArgs>(
      args?: Subset<T, UserLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLoginAggregateArgs>(args: Subset<T, UserLoginAggregateArgs>): Prisma.PrismaPromise<GetUserLoginAggregateType<T>>

    /**
     * Group by UserLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLoginGroupByArgs['orderBy'] }
        : { orderBy?: UserLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLogin model
   */
  readonly fields: UserLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLogin model
   */
  interface UserLoginFieldRefs {
    readonly id: FieldRef<"UserLogin", 'String'>
    readonly userId: FieldRef<"UserLogin", 'String'>
    readonly loginDate: FieldRef<"UserLogin", 'DateTime'>
    readonly logoutDate: FieldRef<"UserLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLogin findUnique
   */
  export type UserLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin findUniqueOrThrow
   */
  export type UserLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin findFirst
   */
  export type UserLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogins.
     */
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin findFirstOrThrow
   */
  export type UserLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogins.
     */
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin findMany
   */
  export type UserLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogins to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin create
   */
  export type UserLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLogin.
     */
    data: XOR<UserLoginCreateInput, UserLoginUncheckedCreateInput>
  }

  /**
   * UserLogin createMany
   */
  export type UserLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLogins.
     */
    data: UserLoginCreateManyInput | UserLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLogin createManyAndReturn
   */
  export type UserLoginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * The data used to create many UserLogins.
     */
    data: UserLoginCreateManyInput | UserLoginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLogin update
   */
  export type UserLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLogin.
     */
    data: XOR<UserLoginUpdateInput, UserLoginUncheckedUpdateInput>
    /**
     * Choose, which UserLogin to update.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin updateMany
   */
  export type UserLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLogins.
     */
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyInput>
    /**
     * Filter which UserLogins to update
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to update.
     */
    limit?: number
  }

  /**
   * UserLogin updateManyAndReturn
   */
  export type UserLoginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * The data used to update UserLogins.
     */
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyInput>
    /**
     * Filter which UserLogins to update
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLogin upsert
   */
  export type UserLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLogin to update in case it exists.
     */
    where: UserLoginWhereUniqueInput
    /**
     * In case the UserLogin found by the `where` argument doesn't exist, create a new UserLogin with this data.
     */
    create: XOR<UserLoginCreateInput, UserLoginUncheckedCreateInput>
    /**
     * In case the UserLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLoginUpdateInput, UserLoginUncheckedUpdateInput>
  }

  /**
   * UserLogin delete
   */
  export type UserLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter which UserLogin to delete.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin deleteMany
   */
  export type UserLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogins to delete
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to delete.
     */
    limit?: number
  }

  /**
   * UserLogin without action
   */
  export type UserLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    name: string | null
    suspend: boolean | null
    role: $Enums.Role | null
    provinceId: string | null
    cityId: string | null
    subdistrictId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authenticatorEnabled: boolean | null
    authenticatorQrUrl: string | null
    authenticatorSecret: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    name: string | null
    suspend: boolean | null
    role: $Enums.Role | null
    provinceId: string | null
    cityId: string | null
    subdistrictId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authenticatorEnabled: boolean | null
    authenticatorQrUrl: string | null
    authenticatorSecret: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    authId: number
    email: number
    name: number
    suspend: number
    role: number
    provinceId: number
    cityId: number
    subdistrictId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    authenticatorEnabled: number
    authenticatorQrUrl: number
    authenticatorSecret: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    suspend?: true
    role?: true
    provinceId?: true
    cityId?: true
    subdistrictId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    authenticatorEnabled?: true
    authenticatorQrUrl?: true
    authenticatorSecret?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    suspend?: true
    role?: true
    provinceId?: true
    cityId?: true
    subdistrictId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    authenticatorEnabled?: true
    authenticatorQrUrl?: true
    authenticatorSecret?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    suspend?: true
    role?: true
    provinceId?: true
    cityId?: true
    subdistrictId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    authenticatorEnabled?: true
    authenticatorQrUrl?: true
    authenticatorSecret?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    authId: string
    email: string
    name: string
    suspend: boolean
    role: $Enums.Role | null
    provinceId: string | null
    cityId: string | null
    subdistrictId: string | null
    schoolId: string | null
    createdAt: Date
    updatedAt: Date
    authenticatorEnabled: boolean
    authenticatorQrUrl: string | null
    authenticatorSecret: string | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    subdistrictId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: boolean
    authenticatorSecret?: boolean
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    subdistrict?: boolean | Admin$subdistrictArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
    authority?: boolean | Admin$authorityArgs<ExtArgs>
    logs?: boolean | Admin$logsArgs<ExtArgs>
    operationHistories?: boolean | Admin$operationHistoriesArgs<ExtArgs>
    operations?: boolean | Admin$operationsArgs<ExtArgs>
    transactions?: boolean | Admin$transactionsArgs<ExtArgs>
    transactionProcessed?: boolean | Admin$transactionProcessedArgs<ExtArgs>
    banner?: boolean | Admin$bannerArgs<ExtArgs>
    redeemCodes?: boolean | Admin$redeemCodesArgs<ExtArgs>
    tests?: boolean | Admin$testsArgs<ExtArgs>
    user?: boolean | Admin$userArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    subdistrictId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: boolean
    authenticatorSecret?: boolean
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    subdistrict?: boolean | Admin$subdistrictArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    subdistrictId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: boolean
    authenticatorSecret?: boolean
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    subdistrict?: boolean | Admin$subdistrictArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    subdistrictId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: boolean
    authenticatorSecret?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "email" | "name" | "suspend" | "role" | "provinceId" | "cityId" | "subdistrictId" | "schoolId" | "createdAt" | "updatedAt" | "authenticatorEnabled" | "authenticatorQrUrl" | "authenticatorSecret", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    subdistrict?: boolean | Admin$subdistrictArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
    authority?: boolean | Admin$authorityArgs<ExtArgs>
    logs?: boolean | Admin$logsArgs<ExtArgs>
    operationHistories?: boolean | Admin$operationHistoriesArgs<ExtArgs>
    operations?: boolean | Admin$operationsArgs<ExtArgs>
    transactions?: boolean | Admin$transactionsArgs<ExtArgs>
    transactionProcessed?: boolean | Admin$transactionProcessedArgs<ExtArgs>
    banner?: boolean | Admin$bannerArgs<ExtArgs>
    redeemCodes?: boolean | Admin$redeemCodesArgs<ExtArgs>
    tests?: boolean | Admin$testsArgs<ExtArgs>
    user?: boolean | Admin$userArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    subdistrict?: boolean | Admin$subdistrictArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    subdistrict?: boolean | Admin$subdistrictArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      province: Prisma.$ProvincePayload<ExtArgs> | null
      city: Prisma.$CityPayload<ExtArgs> | null
      subdistrict: Prisma.$SubdistrictPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      authority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      logs: Prisma.$AdminLogPayload<ExtArgs>[]
      operationHistories: Prisma.$AdminOperationHistoryPayload<ExtArgs>[]
      operations: Prisma.$AdminOperationHistoryPayload<ExtArgs>[]
      transactions: Prisma.$AdminTransactionPayload<ExtArgs>[]
      transactionProcessed: Prisma.$AdminTransactionPayload<ExtArgs>[]
      banner: Prisma.$BannerPayload<ExtArgs>[]
      redeemCodes: Prisma.$RedeemCodePayload<ExtArgs>[]
      tests: Prisma.$TestPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      email: string
      name: string
      suspend: boolean
      role: $Enums.Role | null
      provinceId: string | null
      cityId: string | null
      subdistrictId: string | null
      schoolId: string | null
      createdAt: Date
      updatedAt: Date
      authenticatorEnabled: boolean
      authenticatorQrUrl: string | null
      authenticatorSecret: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    province<T extends Admin$provinceArgs<ExtArgs> = {}>(args?: Subset<T, Admin$provinceArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    city<T extends Admin$cityArgs<ExtArgs> = {}>(args?: Subset<T, Admin$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subdistrict<T extends Admin$subdistrictArgs<ExtArgs> = {}>(args?: Subset<T, Admin$subdistrictArgs<ExtArgs>>): Prisma__SubdistrictClient<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends Admin$schoolArgs<ExtArgs> = {}>(args?: Subset<T, Admin$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    authority<T extends Admin$authorityArgs<ExtArgs> = {}>(args?: Subset<T, Admin$authorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Admin$logsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operationHistories<T extends Admin$operationHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$operationHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operations<T extends Admin$operationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Admin$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionProcessed<T extends Admin$transactionProcessedArgs<ExtArgs> = {}>(args?: Subset<T, Admin$transactionProcessedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banner<T extends Admin$bannerArgs<ExtArgs> = {}>(args?: Subset<T, Admin$bannerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redeemCodes<T extends Admin$redeemCodesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$redeemCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tests<T extends Admin$testsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Admin$userArgs<ExtArgs> = {}>(args?: Subset<T, Admin$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly authId: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly suspend: FieldRef<"Admin", 'Boolean'>
    readonly role: FieldRef<"Admin", 'Role'>
    readonly provinceId: FieldRef<"Admin", 'String'>
    readonly cityId: FieldRef<"Admin", 'String'>
    readonly subdistrictId: FieldRef<"Admin", 'String'>
    readonly schoolId: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly authenticatorEnabled: FieldRef<"Admin", 'Boolean'>
    readonly authenticatorQrUrl: FieldRef<"Admin", 'String'>
    readonly authenticatorSecret: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.province
   */
  export type Admin$provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
  }

  /**
   * Admin.city
   */
  export type Admin$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * Admin.subdistrict
   */
  export type Admin$subdistrictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
  }

  /**
   * Admin.school
   */
  export type Admin$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * Admin.authority
   */
  export type Admin$authorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Admin.logs
   */
  export type Admin$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    where?: AdminLogWhereInput
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    cursor?: AdminLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * Admin.operationHistories
   */
  export type Admin$operationHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    cursor?: AdminOperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * Admin.operations
   */
  export type Admin$operationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    cursor?: AdminOperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * Admin.transactions
   */
  export type Admin$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    cursor?: AdminTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * Admin.transactionProcessed
   */
  export type Admin$transactionProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    cursor?: AdminTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * Admin.banner
   */
  export type Admin$bannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    cursor?: BannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Admin.redeemCodes
   */
  export type Admin$redeemCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    where?: RedeemCodeWhereInput
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    cursor?: RedeemCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * Admin.tests
   */
  export type Admin$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    where?: TestWhereInput
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    cursor?: TestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Admin.user
   */
  export type Admin$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model AdminLog
   */

  export type AggregateAdminLog = {
    _count: AdminLogCountAggregateOutputType | null
    _min: AdminLogMinAggregateOutputType | null
    _max: AdminLogMaxAggregateOutputType | null
  }

  export type AdminLogMinAggregateOutputType = {
    id: string | null
    ipAddress: string | null
    adminId: string | null
    table: string | null
    operation: string | null
    createdAt: Date | null
  }

  export type AdminLogMaxAggregateOutputType = {
    id: string | null
    ipAddress: string | null
    adminId: string | null
    table: string | null
    operation: string | null
    createdAt: Date | null
  }

  export type AdminLogCountAggregateOutputType = {
    id: number
    ipAddress: number
    old: number
    new: number
    adminId: number
    table: number
    operation: number
    createdAt: number
    _all: number
  }


  export type AdminLogMinAggregateInputType = {
    id?: true
    ipAddress?: true
    adminId?: true
    table?: true
    operation?: true
    createdAt?: true
  }

  export type AdminLogMaxAggregateInputType = {
    id?: true
    ipAddress?: true
    adminId?: true
    table?: true
    operation?: true
    createdAt?: true
  }

  export type AdminLogCountAggregateInputType = {
    id?: true
    ipAddress?: true
    old?: true
    new?: true
    adminId?: true
    table?: true
    operation?: true
    createdAt?: true
    _all?: true
  }

  export type AdminLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLog to aggregate.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminLogs
    **/
    _count?: true | AdminLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminLogMaxAggregateInputType
  }

  export type GetAdminLogAggregateType<T extends AdminLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminLog[P]>
      : GetScalarType<T[P], AggregateAdminLog[P]>
  }




  export type AdminLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLogWhereInput
    orderBy?: AdminLogOrderByWithAggregationInput | AdminLogOrderByWithAggregationInput[]
    by: AdminLogScalarFieldEnum[] | AdminLogScalarFieldEnum
    having?: AdminLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminLogCountAggregateInputType | true
    _min?: AdminLogMinAggregateInputType
    _max?: AdminLogMaxAggregateInputType
  }

  export type AdminLogGroupByOutputType = {
    id: string
    ipAddress: string | null
    old: JsonValue | null
    new: JsonValue | null
    adminId: string
    table: string | null
    operation: string | null
    createdAt: Date
    _count: AdminLogCountAggregateOutputType | null
    _min: AdminLogMinAggregateOutputType | null
    _max: AdminLogMaxAggregateOutputType | null
  }

  type GetAdminLogGroupByPayload<T extends AdminLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddress?: boolean
    old?: boolean
    new?: boolean
    adminId?: boolean
    table?: boolean
    operation?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLog"]>

  export type AdminLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddress?: boolean
    old?: boolean
    new?: boolean
    adminId?: boolean
    table?: boolean
    operation?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLog"]>

  export type AdminLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddress?: boolean
    old?: boolean
    new?: boolean
    adminId?: boolean
    table?: boolean
    operation?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLog"]>

  export type AdminLogSelectScalar = {
    id?: boolean
    ipAddress?: boolean
    old?: boolean
    new?: boolean
    adminId?: boolean
    table?: boolean
    operation?: boolean
    createdAt?: boolean
  }

  export type AdminLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ipAddress" | "old" | "new" | "adminId" | "table" | "operation" | "createdAt", ExtArgs["result"]["adminLog"]>
  export type AdminLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminLog"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipAddress: string | null
      old: Prisma.JsonValue | null
      new: Prisma.JsonValue | null
      adminId: string
      table: string | null
      operation: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminLog"]>
    composites: {}
  }

  type AdminLogGetPayload<S extends boolean | null | undefined | AdminLogDefaultArgs> = $Result.GetResult<Prisma.$AdminLogPayload, S>

  type AdminLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminLogCountAggregateInputType | true
    }

  export interface AdminLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminLog'], meta: { name: 'AdminLog' } }
    /**
     * Find zero or one AdminLog that matches the filter.
     * @param {AdminLogFindUniqueArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminLogFindUniqueArgs>(args: SelectSubset<T, AdminLogFindUniqueArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminLogFindUniqueOrThrowArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogFindFirstArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminLogFindFirstArgs>(args?: SelectSubset<T, AdminLogFindFirstArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogFindFirstOrThrowArgs} args - Arguments to find a AdminLog
     * @example
     * // Get one AdminLog
     * const adminLog = await prisma.adminLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminLogs
     * const adminLogs = await prisma.adminLog.findMany()
     * 
     * // Get first 10 AdminLogs
     * const adminLogs = await prisma.adminLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminLogWithIdOnly = await prisma.adminLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminLogFindManyArgs>(args?: SelectSubset<T, AdminLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminLog.
     * @param {AdminLogCreateArgs} args - Arguments to create a AdminLog.
     * @example
     * // Create one AdminLog
     * const AdminLog = await prisma.adminLog.create({
     *   data: {
     *     // ... data to create a AdminLog
     *   }
     * })
     * 
     */
    create<T extends AdminLogCreateArgs>(args: SelectSubset<T, AdminLogCreateArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminLogs.
     * @param {AdminLogCreateManyArgs} args - Arguments to create many AdminLogs.
     * @example
     * // Create many AdminLogs
     * const adminLog = await prisma.adminLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminLogCreateManyArgs>(args?: SelectSubset<T, AdminLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminLogs and returns the data saved in the database.
     * @param {AdminLogCreateManyAndReturnArgs} args - Arguments to create many AdminLogs.
     * @example
     * // Create many AdminLogs
     * const adminLog = await prisma.adminLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminLogs and only return the `id`
     * const adminLogWithIdOnly = await prisma.adminLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminLog.
     * @param {AdminLogDeleteArgs} args - Arguments to delete one AdminLog.
     * @example
     * // Delete one AdminLog
     * const AdminLog = await prisma.adminLog.delete({
     *   where: {
     *     // ... filter to delete one AdminLog
     *   }
     * })
     * 
     */
    delete<T extends AdminLogDeleteArgs>(args: SelectSubset<T, AdminLogDeleteArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminLog.
     * @param {AdminLogUpdateArgs} args - Arguments to update one AdminLog.
     * @example
     * // Update one AdminLog
     * const adminLog = await prisma.adminLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminLogUpdateArgs>(args: SelectSubset<T, AdminLogUpdateArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminLogs.
     * @param {AdminLogDeleteManyArgs} args - Arguments to filter AdminLogs to delete.
     * @example
     * // Delete a few AdminLogs
     * const { count } = await prisma.adminLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminLogDeleteManyArgs>(args?: SelectSubset<T, AdminLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminLogs
     * const adminLog = await prisma.adminLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminLogUpdateManyArgs>(args: SelectSubset<T, AdminLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminLogs and returns the data updated in the database.
     * @param {AdminLogUpdateManyAndReturnArgs} args - Arguments to update many AdminLogs.
     * @example
     * // Update many AdminLogs
     * const adminLog = await prisma.adminLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminLogs and only return the `id`
     * const adminLogWithIdOnly = await prisma.adminLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminLog.
     * @param {AdminLogUpsertArgs} args - Arguments to update or create a AdminLog.
     * @example
     * // Update or create a AdminLog
     * const adminLog = await prisma.adminLog.upsert({
     *   create: {
     *     // ... data to create a AdminLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminLogUpsertArgs>(args: SelectSubset<T, AdminLogUpsertArgs<ExtArgs>>): Prisma__AdminLogClient<$Result.GetResult<Prisma.$AdminLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogCountArgs} args - Arguments to filter AdminLogs to count.
     * @example
     * // Count the number of AdminLogs
     * const count = await prisma.adminLog.count({
     *   where: {
     *     // ... the filter for the AdminLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminLogCountArgs>(
      args?: Subset<T, AdminLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminLogAggregateArgs>(args: Subset<T, AdminLogAggregateArgs>): Prisma.PrismaPromise<GetAdminLogAggregateType<T>>

    /**
     * Group by AdminLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminLog model
   */
  readonly fields: AdminLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminLog model
   */
  interface AdminLogFieldRefs {
    readonly id: FieldRef<"AdminLog", 'String'>
    readonly ipAddress: FieldRef<"AdminLog", 'String'>
    readonly old: FieldRef<"AdminLog", 'Json'>
    readonly new: FieldRef<"AdminLog", 'Json'>
    readonly adminId: FieldRef<"AdminLog", 'String'>
    readonly table: FieldRef<"AdminLog", 'String'>
    readonly operation: FieldRef<"AdminLog", 'String'>
    readonly createdAt: FieldRef<"AdminLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminLog findUnique
   */
  export type AdminLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog findUniqueOrThrow
   */
  export type AdminLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog findFirst
   */
  export type AdminLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLogs.
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLogs.
     */
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * AdminLog findFirstOrThrow
   */
  export type AdminLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLog to fetch.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLogs.
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLogs.
     */
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * AdminLog findMany
   */
  export type AdminLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminLogs to fetch.
     */
    where?: AdminLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLogs to fetch.
     */
    orderBy?: AdminLogOrderByWithRelationInput | AdminLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminLogs.
     */
    cursor?: AdminLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLogs.
     */
    skip?: number
    distinct?: AdminLogScalarFieldEnum | AdminLogScalarFieldEnum[]
  }

  /**
   * AdminLog create
   */
  export type AdminLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminLog.
     */
    data: XOR<AdminLogCreateInput, AdminLogUncheckedCreateInput>
  }

  /**
   * AdminLog createMany
   */
  export type AdminLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminLogs.
     */
    data: AdminLogCreateManyInput | AdminLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminLog createManyAndReturn
   */
  export type AdminLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminLogs.
     */
    data: AdminLogCreateManyInput | AdminLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminLog update
   */
  export type AdminLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminLog.
     */
    data: XOR<AdminLogUpdateInput, AdminLogUncheckedUpdateInput>
    /**
     * Choose, which AdminLog to update.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog updateMany
   */
  export type AdminLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminLogs.
     */
    data: XOR<AdminLogUpdateManyMutationInput, AdminLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminLogs to update
     */
    where?: AdminLogWhereInput
    /**
     * Limit how many AdminLogs to update.
     */
    limit?: number
  }

  /**
   * AdminLog updateManyAndReturn
   */
  export type AdminLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminLogs.
     */
    data: XOR<AdminLogUpdateManyMutationInput, AdminLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminLogs to update
     */
    where?: AdminLogWhereInput
    /**
     * Limit how many AdminLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminLog upsert
   */
  export type AdminLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminLog to update in case it exists.
     */
    where: AdminLogWhereUniqueInput
    /**
     * In case the AdminLog found by the `where` argument doesn't exist, create a new AdminLog with this data.
     */
    create: XOR<AdminLogCreateInput, AdminLogUncheckedCreateInput>
    /**
     * In case the AdminLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminLogUpdateInput, AdminLogUncheckedUpdateInput>
  }

  /**
   * AdminLog delete
   */
  export type AdminLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
    /**
     * Filter which AdminLog to delete.
     */
    where: AdminLogWhereUniqueInput
  }

  /**
   * AdminLog deleteMany
   */
  export type AdminLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLogs to delete
     */
    where?: AdminLogWhereInput
    /**
     * Limit how many AdminLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminLog without action
   */
  export type AdminLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLog
     */
    select?: AdminLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminLog
     */
    omit?: AdminLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLogInclude<ExtArgs> | null
  }


  /**
   * Model AdminOperationHistory
   */

  export type AggregateAdminOperationHistory = {
    _count: AdminOperationHistoryCountAggregateOutputType | null
    _min: AdminOperationHistoryMinAggregateOutputType | null
    _max: AdminOperationHistoryMaxAggregateOutputType | null
  }

  export type AdminOperationHistoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    adminId: string | null
    opAdminId: string | null
    operation: $Enums.Operation | null
  }

  export type AdminOperationHistoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    adminId: string | null
    opAdminId: string | null
    operation: $Enums.Operation | null
  }

  export type AdminOperationHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    adminId: number
    opAdminId: number
    operation: number
    _all: number
  }


  export type AdminOperationHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
  }

  export type AdminOperationHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
  }

  export type AdminOperationHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
    _all?: true
  }

  export type AdminOperationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminOperationHistory to aggregate.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminOperationHistories
    **/
    _count?: true | AdminOperationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminOperationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminOperationHistoryMaxAggregateInputType
  }

  export type GetAdminOperationHistoryAggregateType<T extends AdminOperationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminOperationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminOperationHistory[P]>
      : GetScalarType<T[P], AggregateAdminOperationHistory[P]>
  }




  export type AdminOperationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithAggregationInput | AdminOperationHistoryOrderByWithAggregationInput[]
    by: AdminOperationHistoryScalarFieldEnum[] | AdminOperationHistoryScalarFieldEnum
    having?: AdminOperationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminOperationHistoryCountAggregateInputType | true
    _min?: AdminOperationHistoryMinAggregateInputType
    _max?: AdminOperationHistoryMaxAggregateInputType
  }

  export type AdminOperationHistoryGroupByOutputType = {
    id: string
    createdAt: Date
    adminId: string
    opAdminId: string
    operation: $Enums.Operation
    _count: AdminOperationHistoryCountAggregateOutputType | null
    _min: AdminOperationHistoryMinAggregateOutputType | null
    _max: AdminOperationHistoryMaxAggregateOutputType | null
  }

  type GetAdminOperationHistoryGroupByPayload<T extends AdminOperationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminOperationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminOperationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminOperationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AdminOperationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AdminOperationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
  }

  export type AdminOperationHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "adminId" | "opAdminId" | "operation", ExtArgs["result"]["adminOperationHistory"]>
  export type AdminOperationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminOperationHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminOperationHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminOperationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminOperationHistory"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      opAdmin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      adminId: string
      opAdminId: string
      operation: $Enums.Operation
    }, ExtArgs["result"]["adminOperationHistory"]>
    composites: {}
  }

  type AdminOperationHistoryGetPayload<S extends boolean | null | undefined | AdminOperationHistoryDefaultArgs> = $Result.GetResult<Prisma.$AdminOperationHistoryPayload, S>

  type AdminOperationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminOperationHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminOperationHistoryCountAggregateInputType | true
    }

  export interface AdminOperationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminOperationHistory'], meta: { name: 'AdminOperationHistory' } }
    /**
     * Find zero or one AdminOperationHistory that matches the filter.
     * @param {AdminOperationHistoryFindUniqueArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminOperationHistoryFindUniqueArgs>(args: SelectSubset<T, AdminOperationHistoryFindUniqueArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminOperationHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminOperationHistoryFindUniqueOrThrowArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminOperationHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminOperationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindFirstArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminOperationHistoryFindFirstArgs>(args?: SelectSubset<T, AdminOperationHistoryFindFirstArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminOperationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindFirstOrThrowArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminOperationHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminOperationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminOperationHistories
     * const adminOperationHistories = await prisma.adminOperationHistory.findMany()
     * 
     * // Get first 10 AdminOperationHistories
     * const adminOperationHistories = await prisma.adminOperationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminOperationHistoryFindManyArgs>(args?: SelectSubset<T, AdminOperationHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminOperationHistory.
     * @param {AdminOperationHistoryCreateArgs} args - Arguments to create a AdminOperationHistory.
     * @example
     * // Create one AdminOperationHistory
     * const AdminOperationHistory = await prisma.adminOperationHistory.create({
     *   data: {
     *     // ... data to create a AdminOperationHistory
     *   }
     * })
     * 
     */
    create<T extends AdminOperationHistoryCreateArgs>(args: SelectSubset<T, AdminOperationHistoryCreateArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminOperationHistories.
     * @param {AdminOperationHistoryCreateManyArgs} args - Arguments to create many AdminOperationHistories.
     * @example
     * // Create many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminOperationHistoryCreateManyArgs>(args?: SelectSubset<T, AdminOperationHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminOperationHistories and returns the data saved in the database.
     * @param {AdminOperationHistoryCreateManyAndReturnArgs} args - Arguments to create many AdminOperationHistories.
     * @example
     * // Create many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminOperationHistories and only return the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminOperationHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminOperationHistory.
     * @param {AdminOperationHistoryDeleteArgs} args - Arguments to delete one AdminOperationHistory.
     * @example
     * // Delete one AdminOperationHistory
     * const AdminOperationHistory = await prisma.adminOperationHistory.delete({
     *   where: {
     *     // ... filter to delete one AdminOperationHistory
     *   }
     * })
     * 
     */
    delete<T extends AdminOperationHistoryDeleteArgs>(args: SelectSubset<T, AdminOperationHistoryDeleteArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminOperationHistory.
     * @param {AdminOperationHistoryUpdateArgs} args - Arguments to update one AdminOperationHistory.
     * @example
     * // Update one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminOperationHistoryUpdateArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminOperationHistories.
     * @param {AdminOperationHistoryDeleteManyArgs} args - Arguments to filter AdminOperationHistories to delete.
     * @example
     * // Delete a few AdminOperationHistories
     * const { count } = await prisma.adminOperationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminOperationHistoryDeleteManyArgs>(args?: SelectSubset<T, AdminOperationHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminOperationHistoryUpdateManyArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOperationHistories and returns the data updated in the database.
     * @param {AdminOperationHistoryUpdateManyAndReturnArgs} args - Arguments to update many AdminOperationHistories.
     * @example
     * // Update many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminOperationHistories and only return the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminOperationHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminOperationHistory.
     * @param {AdminOperationHistoryUpsertArgs} args - Arguments to update or create a AdminOperationHistory.
     * @example
     * // Update or create a AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.upsert({
     *   create: {
     *     // ... data to create a AdminOperationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminOperationHistory we want to update
     *   }
     * })
     */
    upsert<T extends AdminOperationHistoryUpsertArgs>(args: SelectSubset<T, AdminOperationHistoryUpsertArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminOperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryCountArgs} args - Arguments to filter AdminOperationHistories to count.
     * @example
     * // Count the number of AdminOperationHistories
     * const count = await prisma.adminOperationHistory.count({
     *   where: {
     *     // ... the filter for the AdminOperationHistories we want to count
     *   }
     * })
    **/
    count<T extends AdminOperationHistoryCountArgs>(
      args?: Subset<T, AdminOperationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminOperationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminOperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminOperationHistoryAggregateArgs>(args: Subset<T, AdminOperationHistoryAggregateArgs>): Prisma.PrismaPromise<GetAdminOperationHistoryAggregateType<T>>

    /**
     * Group by AdminOperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminOperationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminOperationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AdminOperationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminOperationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminOperationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminOperationHistory model
   */
  readonly fields: AdminOperationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminOperationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminOperationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminOperationHistory model
   */
  interface AdminOperationHistoryFieldRefs {
    readonly id: FieldRef<"AdminOperationHistory", 'String'>
    readonly createdAt: FieldRef<"AdminOperationHistory", 'DateTime'>
    readonly adminId: FieldRef<"AdminOperationHistory", 'String'>
    readonly opAdminId: FieldRef<"AdminOperationHistory", 'String'>
    readonly operation: FieldRef<"AdminOperationHistory", 'Operation'>
  }
    

  // Custom InputTypes
  /**
   * AdminOperationHistory findUnique
   */
  export type AdminOperationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory findUniqueOrThrow
   */
  export type AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory findFirst
   */
  export type AdminOperationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOperationHistories.
     */
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory findFirstOrThrow
   */
  export type AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOperationHistories.
     */
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory findMany
   */
  export type AdminOperationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistories to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory create
   */
  export type AdminOperationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminOperationHistory.
     */
    data: XOR<AdminOperationHistoryCreateInput, AdminOperationHistoryUncheckedCreateInput>
  }

  /**
   * AdminOperationHistory createMany
   */
  export type AdminOperationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminOperationHistories.
     */
    data: AdminOperationHistoryCreateManyInput | AdminOperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminOperationHistory createManyAndReturn
   */
  export type AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many AdminOperationHistories.
     */
    data: AdminOperationHistoryCreateManyInput | AdminOperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminOperationHistory update
   */
  export type AdminOperationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminOperationHistory.
     */
    data: XOR<AdminOperationHistoryUpdateInput, AdminOperationHistoryUncheckedUpdateInput>
    /**
     * Choose, which AdminOperationHistory to update.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory updateMany
   */
  export type AdminOperationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminOperationHistories.
     */
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AdminOperationHistories to update
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to update.
     */
    limit?: number
  }

  /**
   * AdminOperationHistory updateManyAndReturn
   */
  export type AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * The data used to update AdminOperationHistories.
     */
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AdminOperationHistories to update
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminOperationHistory upsert
   */
  export type AdminOperationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminOperationHistory to update in case it exists.
     */
    where: AdminOperationHistoryWhereUniqueInput
    /**
     * In case the AdminOperationHistory found by the `where` argument doesn't exist, create a new AdminOperationHistory with this data.
     */
    create: XOR<AdminOperationHistoryCreateInput, AdminOperationHistoryUncheckedCreateInput>
    /**
     * In case the AdminOperationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminOperationHistoryUpdateInput, AdminOperationHistoryUncheckedUpdateInput>
  }

  /**
   * AdminOperationHistory delete
   */
  export type AdminOperationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter which AdminOperationHistory to delete.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory deleteMany
   */
  export type AdminOperationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminOperationHistories to delete
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to delete.
     */
    limit?: number
  }

  /**
   * AdminOperationHistory without action
   */
  export type AdminOperationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuthority
   */

  export type AggregateAdminAuthority = {
    _count: AdminAuthorityCountAggregateOutputType | null
    _avg: AdminAuthorityAvgAggregateOutputType | null
    _sum: AdminAuthoritySumAggregateOutputType | null
    _min: AdminAuthorityMinAggregateOutputType | null
    _max: AdminAuthorityMaxAggregateOutputType | null
  }

  export type AdminAuthorityAvgAggregateOutputType = {
    grades: number | null
  }

  export type AdminAuthoritySumAggregateOutputType = {
    grades: number[]
  }

  export type AdminAuthorityMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    provinceId: string | null
  }

  export type AdminAuthorityMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    provinceId: string | null
  }

  export type AdminAuthorityCountAggregateOutputType = {
    id: number
    adminId: number
    provinceId: number
    grades: number
    _all: number
  }


  export type AdminAuthorityAvgAggregateInputType = {
    grades?: true
  }

  export type AdminAuthoritySumAggregateInputType = {
    grades?: true
  }

  export type AdminAuthorityMinAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
  }

  export type AdminAuthorityMaxAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
  }

  export type AdminAuthorityCountAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
    grades?: true
    _all?: true
  }

  export type AdminAuthorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuthority to aggregate.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuthorities
    **/
    _count?: true | AdminAuthorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAuthorityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAuthoritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuthorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuthorityMaxAggregateInputType
  }

  export type GetAdminAuthorityAggregateType<T extends AdminAuthorityAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuthority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuthority[P]>
      : GetScalarType<T[P], AggregateAdminAuthority[P]>
  }




  export type AdminAuthorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithAggregationInput | AdminAuthorityOrderByWithAggregationInput[]
    by: AdminAuthorityScalarFieldEnum[] | AdminAuthorityScalarFieldEnum
    having?: AdminAuthorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuthorityCountAggregateInputType | true
    _avg?: AdminAuthorityAvgAggregateInputType
    _sum?: AdminAuthoritySumAggregateInputType
    _min?: AdminAuthorityMinAggregateInputType
    _max?: AdminAuthorityMaxAggregateInputType
  }

  export type AdminAuthorityGroupByOutputType = {
    id: string
    adminId: string
    provinceId: string
    grades: number[]
    _count: AdminAuthorityCountAggregateOutputType | null
    _avg: AdminAuthorityAvgAggregateOutputType | null
    _sum: AdminAuthoritySumAggregateOutputType | null
    _min: AdminAuthorityMinAggregateOutputType | null
    _max: AdminAuthorityMaxAggregateOutputType | null
  }

  type GetAdminAuthorityGroupByPayload<T extends AdminAuthorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuthorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuthorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuthorityGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuthorityGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuthoritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | AdminAuthority$citiesArgs<ExtArgs>
    subdistricts?: boolean | AdminAuthority$subdistrictsArgs<ExtArgs>
    schools?: boolean | AdminAuthority$schoolsArgs<ExtArgs>
    _count?: boolean | AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectScalar = {
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
  }

  export type AdminAuthorityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "provinceId" | "grades", ExtArgs["result"]["adminAuthority"]>
  export type AdminAuthorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | AdminAuthority$citiesArgs<ExtArgs>
    subdistricts?: boolean | AdminAuthority$subdistrictsArgs<ExtArgs>
    schools?: boolean | AdminAuthority$schoolsArgs<ExtArgs>
    _count?: boolean | AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminAuthorityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type AdminAuthorityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $AdminAuthorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuthority"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
      subdistricts: Prisma.$SubdistrictPayload<ExtArgs>[]
      schools: Prisma.$SchoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      provinceId: string
      grades: number[]
    }, ExtArgs["result"]["adminAuthority"]>
    composites: {}
  }

  type AdminAuthorityGetPayload<S extends boolean | null | undefined | AdminAuthorityDefaultArgs> = $Result.GetResult<Prisma.$AdminAuthorityPayload, S>

  type AdminAuthorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuthorityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuthorityCountAggregateInputType | true
    }

  export interface AdminAuthorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuthority'], meta: { name: 'AdminAuthority' } }
    /**
     * Find zero or one AdminAuthority that matches the filter.
     * @param {AdminAuthorityFindUniqueArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuthorityFindUniqueArgs>(args: SelectSubset<T, AdminAuthorityFindUniqueArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuthority that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuthorityFindUniqueOrThrowArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuthorityFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuthorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuthority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindFirstArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuthorityFindFirstArgs>(args?: SelectSubset<T, AdminAuthorityFindFirstArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuthority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindFirstOrThrowArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuthorityFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuthorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuthorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuthorities
     * const adminAuthorities = await prisma.adminAuthority.findMany()
     * 
     * // Get first 10 AdminAuthorities
     * const adminAuthorities = await prisma.adminAuthority.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuthorityFindManyArgs>(args?: SelectSubset<T, AdminAuthorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuthority.
     * @param {AdminAuthorityCreateArgs} args - Arguments to create a AdminAuthority.
     * @example
     * // Create one AdminAuthority
     * const AdminAuthority = await prisma.adminAuthority.create({
     *   data: {
     *     // ... data to create a AdminAuthority
     *   }
     * })
     * 
     */
    create<T extends AdminAuthorityCreateArgs>(args: SelectSubset<T, AdminAuthorityCreateArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuthorities.
     * @param {AdminAuthorityCreateManyArgs} args - Arguments to create many AdminAuthorities.
     * @example
     * // Create many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuthorityCreateManyArgs>(args?: SelectSubset<T, AdminAuthorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuthorities and returns the data saved in the database.
     * @param {AdminAuthorityCreateManyAndReturnArgs} args - Arguments to create many AdminAuthorities.
     * @example
     * // Create many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuthorities and only return the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuthorityCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuthorityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuthority.
     * @param {AdminAuthorityDeleteArgs} args - Arguments to delete one AdminAuthority.
     * @example
     * // Delete one AdminAuthority
     * const AdminAuthority = await prisma.adminAuthority.delete({
     *   where: {
     *     // ... filter to delete one AdminAuthority
     *   }
     * })
     * 
     */
    delete<T extends AdminAuthorityDeleteArgs>(args: SelectSubset<T, AdminAuthorityDeleteArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuthority.
     * @param {AdminAuthorityUpdateArgs} args - Arguments to update one AdminAuthority.
     * @example
     * // Update one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuthorityUpdateArgs>(args: SelectSubset<T, AdminAuthorityUpdateArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuthorities.
     * @param {AdminAuthorityDeleteManyArgs} args - Arguments to filter AdminAuthorities to delete.
     * @example
     * // Delete a few AdminAuthorities
     * const { count } = await prisma.adminAuthority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuthorityDeleteManyArgs>(args?: SelectSubset<T, AdminAuthorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuthorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuthorityUpdateManyArgs>(args: SelectSubset<T, AdminAuthorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuthorities and returns the data updated in the database.
     * @param {AdminAuthorityUpdateManyAndReturnArgs} args - Arguments to update many AdminAuthorities.
     * @example
     * // Update many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuthorities and only return the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuthorityUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuthorityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuthority.
     * @param {AdminAuthorityUpsertArgs} args - Arguments to update or create a AdminAuthority.
     * @example
     * // Update or create a AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.upsert({
     *   create: {
     *     // ... data to create a AdminAuthority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuthority we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuthorityUpsertArgs>(args: SelectSubset<T, AdminAuthorityUpsertArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuthorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityCountArgs} args - Arguments to filter AdminAuthorities to count.
     * @example
     * // Count the number of AdminAuthorities
     * const count = await prisma.adminAuthority.count({
     *   where: {
     *     // ... the filter for the AdminAuthorities we want to count
     *   }
     * })
    **/
    count<T extends AdminAuthorityCountArgs>(
      args?: Subset<T, AdminAuthorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuthorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuthority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuthorityAggregateArgs>(args: Subset<T, AdminAuthorityAggregateArgs>): Prisma.PrismaPromise<GetAdminAuthorityAggregateType<T>>

    /**
     * Group by AdminAuthority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuthorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuthorityGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuthorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuthorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuthorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuthority model
   */
  readonly fields: AdminAuthorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuthority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuthorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cities<T extends AdminAuthority$citiesArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subdistricts<T extends AdminAuthority$subdistrictsArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$subdistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends AdminAuthority$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuthority model
   */
  interface AdminAuthorityFieldRefs {
    readonly id: FieldRef<"AdminAuthority", 'String'>
    readonly adminId: FieldRef<"AdminAuthority", 'String'>
    readonly provinceId: FieldRef<"AdminAuthority", 'String'>
    readonly grades: FieldRef<"AdminAuthority", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuthority findUnique
   */
  export type AdminAuthorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority findUniqueOrThrow
   */
  export type AdminAuthorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority findFirst
   */
  export type AdminAuthorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuthorities.
     */
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority findFirstOrThrow
   */
  export type AdminAuthorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuthorities.
     */
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority findMany
   */
  export type AdminAuthorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthorities to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority create
   */
  export type AdminAuthorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuthority.
     */
    data: XOR<AdminAuthorityCreateInput, AdminAuthorityUncheckedCreateInput>
  }

  /**
   * AdminAuthority createMany
   */
  export type AdminAuthorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuthorities.
     */
    data: AdminAuthorityCreateManyInput | AdminAuthorityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuthority createManyAndReturn
   */
  export type AdminAuthorityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuthorities.
     */
    data: AdminAuthorityCreateManyInput | AdminAuthorityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuthority update
   */
  export type AdminAuthorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuthority.
     */
    data: XOR<AdminAuthorityUpdateInput, AdminAuthorityUncheckedUpdateInput>
    /**
     * Choose, which AdminAuthority to update.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority updateMany
   */
  export type AdminAuthorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuthorities.
     */
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuthorities to update
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to update.
     */
    limit?: number
  }

  /**
   * AdminAuthority updateManyAndReturn
   */
  export type AdminAuthorityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuthorities.
     */
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuthorities to update
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuthority upsert
   */
  export type AdminAuthorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuthority to update in case it exists.
     */
    where: AdminAuthorityWhereUniqueInput
    /**
     * In case the AdminAuthority found by the `where` argument doesn't exist, create a new AdminAuthority with this data.
     */
    create: XOR<AdminAuthorityCreateInput, AdminAuthorityUncheckedCreateInput>
    /**
     * In case the AdminAuthority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuthorityUpdateInput, AdminAuthorityUncheckedUpdateInput>
  }

  /**
   * AdminAuthority delete
   */
  export type AdminAuthorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter which AdminAuthority to delete.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority deleteMany
   */
  export type AdminAuthorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuthorities to delete
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to delete.
     */
    limit?: number
  }

  /**
   * AdminAuthority.cities
   */
  export type AdminAuthority$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * AdminAuthority.subdistricts
   */
  export type AdminAuthority$subdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    cursor?: SubdistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * AdminAuthority.schools
   */
  export type AdminAuthority$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * AdminAuthority without action
   */
  export type AdminAuthorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    thumbnail: string | null
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean | null
    lastBroadcastedAt: Date | null
    adminId: string | null
    thumbnailId: string | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    thumbnail: string | null
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean | null
    lastBroadcastedAt: Date | null
    adminId: string | null
    thumbnailId: string | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    thumbnail: number
    link: number
    startedAt: number
    endedAt: number
    isHide: number
    lastBroadcastedAt: number
    adminId: number
    thumbnailId: number
    _all: number
  }


  export type BannerMinAggregateInputType = {
    id?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    lastBroadcastedAt?: true
    adminId?: true
    thumbnailId?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    lastBroadcastedAt?: true
    adminId?: true
    thumbnailId?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    lastBroadcastedAt?: true
    adminId?: true
    thumbnailId?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    thumbnail: string
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean
    lastBroadcastedAt: Date | null
    adminId: string
    thumbnailId: string
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    lastBroadcastedAt?: boolean
    adminId?: boolean
    thumbnailId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    provincies?: boolean | Banner$provinciesArgs<ExtArgs>
    cities?: boolean | Banner$citiesArgs<ExtArgs>
    subdistricts?: boolean | Banner$subdistrictsArgs<ExtArgs>
    visitors?: boolean | Banner$visitorsArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    lastBroadcastedAt?: boolean
    adminId?: boolean
    thumbnailId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    lastBroadcastedAt?: boolean
    adminId?: boolean
    thumbnailId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    lastBroadcastedAt?: boolean
    adminId?: boolean
    thumbnailId?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "thumbnail" | "link" | "startedAt" | "endedAt" | "isHide" | "lastBroadcastedAt" | "adminId" | "thumbnailId", ExtArgs["result"]["banner"]>
  export type BannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    provincies?: boolean | Banner$provinciesArgs<ExtArgs>
    cities?: boolean | Banner$citiesArgs<ExtArgs>
    subdistricts?: boolean | Banner$subdistrictsArgs<ExtArgs>
    visitors?: boolean | Banner$visitorsArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type BannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      provincies: Prisma.$ProvincePayload<ExtArgs>[]
      cities: Prisma.$CityPayload<ExtArgs>[]
      subdistricts: Prisma.$SubdistrictPayload<ExtArgs>[]
      visitors: Prisma.$BannerVisitorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      thumbnail: string
      link: string | null
      startedAt: Date | null
      endedAt: Date | null
      isHide: boolean
      lastBroadcastedAt: Date | null
      adminId: string
      thumbnailId: string
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {BannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners and returns the data updated in the database.
     * @param {BannerUpdateManyAndReturnArgs} args - Arguments to update many Banners.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provincies<T extends Banner$provinciesArgs<ExtArgs> = {}>(args?: Subset<T, Banner$provinciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cities<T extends Banner$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Banner$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subdistricts<T extends Banner$subdistrictsArgs<ExtArgs> = {}>(args?: Subset<T, Banner$subdistrictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdistrictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitors<T extends Banner$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Banner$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly thumbnail: FieldRef<"Banner", 'String'>
    readonly link: FieldRef<"Banner", 'String'>
    readonly startedAt: FieldRef<"Banner", 'DateTime'>
    readonly endedAt: FieldRef<"Banner", 'DateTime'>
    readonly isHide: FieldRef<"Banner", 'Boolean'>
    readonly lastBroadcastedAt: FieldRef<"Banner", 'DateTime'>
    readonly adminId: FieldRef<"Banner", 'String'>
    readonly thumbnailId: FieldRef<"Banner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner createManyAndReturn
   */
  export type BannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner updateManyAndReturn
   */
  export type BannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner.provincies
   */
  export type Banner$provinciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    cursor?: ProvinceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Banner.cities
   */
  export type Banner$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Banner.subdistricts
   */
  export type Banner$subdistrictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdistrict
     */
    select?: SubdistrictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdistrict
     */
    omit?: SubdistrictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdistrictInclude<ExtArgs> | null
    where?: SubdistrictWhereInput
    orderBy?: SubdistrictOrderByWithRelationInput | SubdistrictOrderByWithRelationInput[]
    cursor?: SubdistrictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubdistrictScalarFieldEnum | SubdistrictScalarFieldEnum[]
  }

  /**
   * Banner.visitors
   */
  export type Banner$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    cursor?: BannerVisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
  }


  /**
   * Model BannerVisitor
   */

  export type AggregateBannerVisitor = {
    _count: BannerVisitorCountAggregateOutputType | null
    _avg: BannerVisitorAvgAggregateOutputType | null
    _sum: BannerVisitorSumAggregateOutputType | null
    _min: BannerVisitorMinAggregateOutputType | null
    _max: BannerVisitorMaxAggregateOutputType | null
  }

  export type BannerVisitorAvgAggregateOutputType = {
    traffic: number | null
  }

  export type BannerVisitorSumAggregateOutputType = {
    traffic: number | null
  }

  export type BannerVisitorMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    traffic: number | null
  }

  export type BannerVisitorMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    traffic: number | null
  }

  export type BannerVisitorCountAggregateOutputType = {
    id: number
    bannerId: number
    userId: number
    createdAt: number
    updatedAt: number
    traffic: number
    _all: number
  }


  export type BannerVisitorAvgAggregateInputType = {
    traffic?: true
  }

  export type BannerVisitorSumAggregateInputType = {
    traffic?: true
  }

  export type BannerVisitorMinAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
  }

  export type BannerVisitorMaxAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
  }

  export type BannerVisitorCountAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
    _all?: true
  }

  export type BannerVisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerVisitor to aggregate.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerVisitors
    **/
    _count?: true | BannerVisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerVisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerVisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerVisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerVisitorMaxAggregateInputType
  }

  export type GetBannerVisitorAggregateType<T extends BannerVisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerVisitor[P]>
      : GetScalarType<T[P], AggregateBannerVisitor[P]>
  }




  export type BannerVisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithAggregationInput | BannerVisitorOrderByWithAggregationInput[]
    by: BannerVisitorScalarFieldEnum[] | BannerVisitorScalarFieldEnum
    having?: BannerVisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerVisitorCountAggregateInputType | true
    _avg?: BannerVisitorAvgAggregateInputType
    _sum?: BannerVisitorSumAggregateInputType
    _min?: BannerVisitorMinAggregateInputType
    _max?: BannerVisitorMaxAggregateInputType
  }

  export type BannerVisitorGroupByOutputType = {
    id: string
    bannerId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    traffic: number
    _count: BannerVisitorCountAggregateOutputType | null
    _avg: BannerVisitorAvgAggregateOutputType | null
    _sum: BannerVisitorSumAggregateOutputType | null
    _min: BannerVisitorMinAggregateOutputType | null
    _max: BannerVisitorMaxAggregateOutputType | null
  }

  type GetBannerVisitorGroupByPayload<T extends BannerVisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerVisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerVisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerVisitorGroupByOutputType[P]>
            : GetScalarType<T[P], BannerVisitorGroupByOutputType[P]>
        }
      >
    >


  export type BannerVisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectScalar = {
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
  }

  export type BannerVisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "userId" | "createdAt" | "updatedAt" | "traffic", ExtArgs["result"]["bannerVisitor"]>
  export type BannerVisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BannerVisitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BannerVisitorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BannerVisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerVisitor"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      userId: string
      createdAt: Date
      updatedAt: Date
      traffic: number
    }, ExtArgs["result"]["bannerVisitor"]>
    composites: {}
  }

  type BannerVisitorGetPayload<S extends boolean | null | undefined | BannerVisitorDefaultArgs> = $Result.GetResult<Prisma.$BannerVisitorPayload, S>

  type BannerVisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerVisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerVisitorCountAggregateInputType | true
    }

  export interface BannerVisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerVisitor'], meta: { name: 'BannerVisitor' } }
    /**
     * Find zero or one BannerVisitor that matches the filter.
     * @param {BannerVisitorFindUniqueArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerVisitorFindUniqueArgs>(args: SelectSubset<T, BannerVisitorFindUniqueArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerVisitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerVisitorFindUniqueOrThrowArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerVisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerVisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerVisitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindFirstArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerVisitorFindFirstArgs>(args?: SelectSubset<T, BannerVisitorFindFirstArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerVisitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindFirstOrThrowArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerVisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerVisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerVisitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerVisitors
     * const bannerVisitors = await prisma.bannerVisitor.findMany()
     * 
     * // Get first 10 BannerVisitors
     * const bannerVisitors = await prisma.bannerVisitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerVisitorFindManyArgs>(args?: SelectSubset<T, BannerVisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerVisitor.
     * @param {BannerVisitorCreateArgs} args - Arguments to create a BannerVisitor.
     * @example
     * // Create one BannerVisitor
     * const BannerVisitor = await prisma.bannerVisitor.create({
     *   data: {
     *     // ... data to create a BannerVisitor
     *   }
     * })
     * 
     */
    create<T extends BannerVisitorCreateArgs>(args: SelectSubset<T, BannerVisitorCreateArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerVisitors.
     * @param {BannerVisitorCreateManyArgs} args - Arguments to create many BannerVisitors.
     * @example
     * // Create many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerVisitorCreateManyArgs>(args?: SelectSubset<T, BannerVisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BannerVisitors and returns the data saved in the database.
     * @param {BannerVisitorCreateManyAndReturnArgs} args - Arguments to create many BannerVisitors.
     * @example
     * // Create many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BannerVisitors and only return the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerVisitorCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerVisitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BannerVisitor.
     * @param {BannerVisitorDeleteArgs} args - Arguments to delete one BannerVisitor.
     * @example
     * // Delete one BannerVisitor
     * const BannerVisitor = await prisma.bannerVisitor.delete({
     *   where: {
     *     // ... filter to delete one BannerVisitor
     *   }
     * })
     * 
     */
    delete<T extends BannerVisitorDeleteArgs>(args: SelectSubset<T, BannerVisitorDeleteArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerVisitor.
     * @param {BannerVisitorUpdateArgs} args - Arguments to update one BannerVisitor.
     * @example
     * // Update one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerVisitorUpdateArgs>(args: SelectSubset<T, BannerVisitorUpdateArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerVisitors.
     * @param {BannerVisitorDeleteManyArgs} args - Arguments to filter BannerVisitors to delete.
     * @example
     * // Delete a few BannerVisitors
     * const { count } = await prisma.bannerVisitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerVisitorDeleteManyArgs>(args?: SelectSubset<T, BannerVisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerVisitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerVisitorUpdateManyArgs>(args: SelectSubset<T, BannerVisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerVisitors and returns the data updated in the database.
     * @param {BannerVisitorUpdateManyAndReturnArgs} args - Arguments to update many BannerVisitors.
     * @example
     * // Update many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BannerVisitors and only return the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerVisitorUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerVisitorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BannerVisitor.
     * @param {BannerVisitorUpsertArgs} args - Arguments to update or create a BannerVisitor.
     * @example
     * // Update or create a BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.upsert({
     *   create: {
     *     // ... data to create a BannerVisitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerVisitor we want to update
     *   }
     * })
     */
    upsert<T extends BannerVisitorUpsertArgs>(args: SelectSubset<T, BannerVisitorUpsertArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerVisitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorCountArgs} args - Arguments to filter BannerVisitors to count.
     * @example
     * // Count the number of BannerVisitors
     * const count = await prisma.bannerVisitor.count({
     *   where: {
     *     // ... the filter for the BannerVisitors we want to count
     *   }
     * })
    **/
    count<T extends BannerVisitorCountArgs>(
      args?: Subset<T, BannerVisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerVisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerVisitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerVisitorAggregateArgs>(args: Subset<T, BannerVisitorAggregateArgs>): Prisma.PrismaPromise<GetBannerVisitorAggregateType<T>>

    /**
     * Group by BannerVisitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerVisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerVisitorGroupByArgs['orderBy'] }
        : { orderBy?: BannerVisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerVisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerVisitor model
   */
  readonly fields: BannerVisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerVisitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerVisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerVisitor model
   */
  interface BannerVisitorFieldRefs {
    readonly id: FieldRef<"BannerVisitor", 'String'>
    readonly bannerId: FieldRef<"BannerVisitor", 'String'>
    readonly userId: FieldRef<"BannerVisitor", 'String'>
    readonly createdAt: FieldRef<"BannerVisitor", 'DateTime'>
    readonly updatedAt: FieldRef<"BannerVisitor", 'DateTime'>
    readonly traffic: FieldRef<"BannerVisitor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BannerVisitor findUnique
   */
  export type BannerVisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor findUniqueOrThrow
   */
  export type BannerVisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor findFirst
   */
  export type BannerVisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerVisitors.
     */
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor findFirstOrThrow
   */
  export type BannerVisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerVisitors.
     */
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor findMany
   */
  export type BannerVisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitors to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor create
   */
  export type BannerVisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerVisitor.
     */
    data: XOR<BannerVisitorCreateInput, BannerVisitorUncheckedCreateInput>
  }

  /**
   * BannerVisitor createMany
   */
  export type BannerVisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerVisitors.
     */
    data: BannerVisitorCreateManyInput | BannerVisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerVisitor createManyAndReturn
   */
  export type BannerVisitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * The data used to create many BannerVisitors.
     */
    data: BannerVisitorCreateManyInput | BannerVisitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerVisitor update
   */
  export type BannerVisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerVisitor.
     */
    data: XOR<BannerVisitorUpdateInput, BannerVisitorUncheckedUpdateInput>
    /**
     * Choose, which BannerVisitor to update.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor updateMany
   */
  export type BannerVisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerVisitors.
     */
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyInput>
    /**
     * Filter which BannerVisitors to update
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to update.
     */
    limit?: number
  }

  /**
   * BannerVisitor updateManyAndReturn
   */
  export type BannerVisitorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * The data used to update BannerVisitors.
     */
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyInput>
    /**
     * Filter which BannerVisitors to update
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerVisitor upsert
   */
  export type BannerVisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerVisitor to update in case it exists.
     */
    where: BannerVisitorWhereUniqueInput
    /**
     * In case the BannerVisitor found by the `where` argument doesn't exist, create a new BannerVisitor with this data.
     */
    create: XOR<BannerVisitorCreateInput, BannerVisitorUncheckedCreateInput>
    /**
     * In case the BannerVisitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerVisitorUpdateInput, BannerVisitorUncheckedUpdateInput>
  }

  /**
   * BannerVisitor delete
   */
  export type BannerVisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter which BannerVisitor to delete.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor deleteMany
   */
  export type BannerVisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerVisitors to delete
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to delete.
     */
    limit?: number
  }

  /**
   * BannerVisitor without action
   */
  export type BannerVisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
  }


  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type TestSumAggregateOutputType = {
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type TestMinAggregateOutputType = {
    id: string | null
    name: string | null
    question: $Enums.QuestionType | null
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    type: $Enums.TestType | null
    quota: number | null
    currentQuota: number | null
    code: string | null
    zoneId: string | null
    startedAt: Date | null
    endedAt: Date | null
    description: string | null
    category: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    adminId: string | null
  }

  export type TestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    question: $Enums.QuestionType | null
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    type: $Enums.TestType | null
    quota: number | null
    currentQuota: number | null
    code: string | null
    zoneId: string | null
    startedAt: Date | null
    endedAt: Date | null
    description: string | null
    category: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    adminId: string | null
  }

  export type TestCountAggregateOutputType = {
    id: number
    name: number
    question: number
    duration: number
    passedPoint: number
    remidialCount: number
    type: number
    quota: number
    currentQuota: number
    code: number
    zoneId: number
    startedAt: number
    endedAt: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    adminId: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    duration?: true
    passedPoint?: true
    remidialCount?: true
    quota?: true
    currentQuota?: true
  }

  export type TestSumAggregateInputType = {
    duration?: true
    passedPoint?: true
    remidialCount?: true
    quota?: true
    currentQuota?: true
  }

  export type TestMinAggregateInputType = {
    id?: true
    name?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    adminId?: true
  }

  export type TestMaxAggregateInputType = {
    id?: true
    name?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    adminId?: true
  }

  export type TestCountAggregateInputType = {
    id?: true
    name?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    adminId?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    id: string
    name: string
    question: $Enums.QuestionType
    duration: number
    passedPoint: number
    remidialCount: number
    type: $Enums.TestType
    quota: number
    currentQuota: number
    code: string | null
    zoneId: string | null
    startedAt: Date
    endedAt: Date | null
    description: string | null
    category: $Enums.Role
    createdAt: Date
    updatedAt: Date
    adminId: string
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    participants?: boolean | Test$participantsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>

  export type TestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>

  export type TestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>

  export type TestSelectScalar = {
    id?: boolean
    name?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
  }

  export type TestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "question" | "duration" | "passedPoint" | "remidialCount" | "type" | "quota" | "currentQuota" | "code" | "zoneId" | "startedAt" | "endedAt" | "description" | "category" | "createdAt" | "updatedAt" | "adminId", ExtArgs["result"]["test"]>
  export type TestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    participants?: boolean | Test$participantsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type TestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      participants: Prisma.$TestParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      question: $Enums.QuestionType
      duration: number
      passedPoint: number
      remidialCount: number
      type: $Enums.TestType
      quota: number
      currentQuota: number
      code: string | null
      zoneId: string | null
      startedAt: Date
      endedAt: Date | null
      description: string | null
      category: $Enums.Role
      createdAt: Date
      updatedAt: Date
      adminId: string
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestFindUniqueArgs>(args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs>(args: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestFindFirstArgs>(args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs>(args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testWithIdOnly = await prisma.test.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestFindManyArgs>(args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends TestCreateArgs>(args: SelectSubset<T, TestCreateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tests.
     * @param {TestCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCreateManyArgs>(args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tests and returns the data saved in the database.
     * @param {TestCreateManyAndReturnArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tests and only return the `id`
     * const testWithIdOnly = await prisma.test.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestCreateManyAndReturnArgs>(args?: SelectSubset<T, TestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends TestDeleteArgs>(args: SelectSubset<T, TestDeleteArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestUpdateArgs>(args: SelectSubset<T, TestUpdateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDeleteManyArgs>(args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestUpdateManyArgs>(args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests and returns the data updated in the database.
     * @param {TestUpdateManyAndReturnArgs} args - Arguments to update many Tests.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tests and only return the `id`
     * const testWithIdOnly = await prisma.test.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestUpdateManyAndReturnArgs>(args: SelectSubset<T, TestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends TestUpsertArgs>(args: SelectSubset<T, TestUpsertArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Test$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Test$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Test model
   */
  interface TestFieldRefs {
    readonly id: FieldRef<"Test", 'String'>
    readonly name: FieldRef<"Test", 'String'>
    readonly question: FieldRef<"Test", 'QuestionType'>
    readonly duration: FieldRef<"Test", 'Int'>
    readonly passedPoint: FieldRef<"Test", 'Int'>
    readonly remidialCount: FieldRef<"Test", 'Int'>
    readonly type: FieldRef<"Test", 'TestType'>
    readonly quota: FieldRef<"Test", 'Int'>
    readonly currentQuota: FieldRef<"Test", 'Int'>
    readonly code: FieldRef<"Test", 'String'>
    readonly zoneId: FieldRef<"Test", 'String'>
    readonly startedAt: FieldRef<"Test", 'DateTime'>
    readonly endedAt: FieldRef<"Test", 'DateTime'>
    readonly description: FieldRef<"Test", 'String'>
    readonly category: FieldRef<"Test", 'Role'>
    readonly createdAt: FieldRef<"Test", 'DateTime'>
    readonly updatedAt: FieldRef<"Test", 'DateTime'>
    readonly adminId: FieldRef<"Test", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }

  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Test createManyAndReturn
   */
  export type TestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test updateManyAndReturn
   */
  export type TestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }

  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to delete.
     */
    limit?: number
  }

  /**
   * Test.participants
   */
  export type Test$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    cursor?: TestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
  }


  /**
   * Model TestParticipant
   */

  export type AggregateTestParticipant = {
    _count: TestParticipantCountAggregateOutputType | null
    _avg: TestParticipantAvgAggregateOutputType | null
    _sum: TestParticipantSumAggregateOutputType | null
    _min: TestParticipantMinAggregateOutputType | null
    _max: TestParticipantMaxAggregateOutputType | null
  }

  export type TestParticipantAvgAggregateOutputType = {
    highscore: number | null
  }

  export type TestParticipantSumAggregateOutputType = {
    highscore: number | null
  }

  export type TestParticipantMinAggregateOutputType = {
    id: string | null
    testId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    highscore: number | null
  }

  export type TestParticipantMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    highscore: number | null
  }

  export type TestParticipantCountAggregateOutputType = {
    id: number
    testId: number
    userId: number
    createdAt: number
    updatedAt: number
    highscore: number
    _all: number
  }


  export type TestParticipantAvgAggregateInputType = {
    highscore?: true
  }

  export type TestParticipantSumAggregateInputType = {
    highscore?: true
  }

  export type TestParticipantMinAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
  }

  export type TestParticipantMaxAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
  }

  export type TestParticipantCountAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
    _all?: true
  }

  export type TestParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipant to aggregate.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParticipants
    **/
    _count?: true | TestParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParticipantMaxAggregateInputType
  }

  export type GetTestParticipantAggregateType<T extends TestParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParticipant[P]>
      : GetScalarType<T[P], AggregateTestParticipant[P]>
  }




  export type TestParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithAggregationInput | TestParticipantOrderByWithAggregationInput[]
    by: TestParticipantScalarFieldEnum[] | TestParticipantScalarFieldEnum
    having?: TestParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParticipantCountAggregateInputType | true
    _avg?: TestParticipantAvgAggregateInputType
    _sum?: TestParticipantSumAggregateInputType
    _min?: TestParticipantMinAggregateInputType
    _max?: TestParticipantMaxAggregateInputType
  }

  export type TestParticipantGroupByOutputType = {
    id: string
    testId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    highscore: number
    _count: TestParticipantCountAggregateOutputType | null
    _avg: TestParticipantAvgAggregateOutputType | null
    _sum: TestParticipantSumAggregateOutputType | null
    _min: TestParticipantMinAggregateOutputType | null
    _max: TestParticipantMaxAggregateOutputType | null
  }

  type GetTestParticipantGroupByPayload<T extends TestParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TestParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TestParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    records?: boolean | TestParticipant$recordsArgs<ExtArgs>
    _count?: boolean | TestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectScalar = {
    id?: boolean
    testId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
  }

  export type TestParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "userId" | "createdAt" | "updatedAt" | "highscore", ExtArgs["result"]["testParticipant"]>
  export type TestParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    records?: boolean | TestParticipant$recordsArgs<ExtArgs>
    _count?: boolean | TestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParticipant"
    objects: {
      test: Prisma.$TestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      records: Prisma.$TestParticipantRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      userId: string
      createdAt: Date
      updatedAt: Date
      highscore: number
    }, ExtArgs["result"]["testParticipant"]>
    composites: {}
  }

  type TestParticipantGetPayload<S extends boolean | null | undefined | TestParticipantDefaultArgs> = $Result.GetResult<Prisma.$TestParticipantPayload, S>

  type TestParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParticipantCountAggregateInputType | true
    }

  export interface TestParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParticipant'], meta: { name: 'TestParticipant' } }
    /**
     * Find zero or one TestParticipant that matches the filter.
     * @param {TestParticipantFindUniqueArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParticipantFindUniqueArgs>(args: SelectSubset<T, TestParticipantFindUniqueArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParticipantFindUniqueOrThrowArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindFirstArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParticipantFindFirstArgs>(args?: SelectSubset<T, TestParticipantFindFirstArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindFirstOrThrowArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParticipants
     * const testParticipants = await prisma.testParticipant.findMany()
     * 
     * // Get first 10 TestParticipants
     * const testParticipants = await prisma.testParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParticipantFindManyArgs>(args?: SelectSubset<T, TestParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParticipant.
     * @param {TestParticipantCreateArgs} args - Arguments to create a TestParticipant.
     * @example
     * // Create one TestParticipant
     * const TestParticipant = await prisma.testParticipant.create({
     *   data: {
     *     // ... data to create a TestParticipant
     *   }
     * })
     * 
     */
    create<T extends TestParticipantCreateArgs>(args: SelectSubset<T, TestParticipantCreateArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParticipants.
     * @param {TestParticipantCreateManyArgs} args - Arguments to create many TestParticipants.
     * @example
     * // Create many TestParticipants
     * const testParticipant = await prisma.testParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParticipantCreateManyArgs>(args?: SelectSubset<T, TestParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParticipants and returns the data saved in the database.
     * @param {TestParticipantCreateManyAndReturnArgs} args - Arguments to create many TestParticipants.
     * @example
     * // Create many TestParticipants
     * const testParticipant = await prisma.testParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParticipants and only return the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParticipant.
     * @param {TestParticipantDeleteArgs} args - Arguments to delete one TestParticipant.
     * @example
     * // Delete one TestParticipant
     * const TestParticipant = await prisma.testParticipant.delete({
     *   where: {
     *     // ... filter to delete one TestParticipant
     *   }
     * })
     * 
     */
    delete<T extends TestParticipantDeleteArgs>(args: SelectSubset<T, TestParticipantDeleteArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParticipant.
     * @param {TestParticipantUpdateArgs} args - Arguments to update one TestParticipant.
     * @example
     * // Update one TestParticipant
     * const testParticipant = await prisma.testParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParticipantUpdateArgs>(args: SelectSubset<T, TestParticipantUpdateArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParticipants.
     * @param {TestParticipantDeleteManyArgs} args - Arguments to filter TestParticipants to delete.
     * @example
     * // Delete a few TestParticipants
     * const { count } = await prisma.testParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParticipantDeleteManyArgs>(args?: SelectSubset<T, TestParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParticipants
     * const testParticipant = await prisma.testParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParticipantUpdateManyArgs>(args: SelectSubset<T, TestParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipants and returns the data updated in the database.
     * @param {TestParticipantUpdateManyAndReturnArgs} args - Arguments to update many TestParticipants.
     * @example
     * // Update many TestParticipants
     * const testParticipant = await prisma.testParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParticipants and only return the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParticipant.
     * @param {TestParticipantUpsertArgs} args - Arguments to update or create a TestParticipant.
     * @example
     * // Update or create a TestParticipant
     * const testParticipant = await prisma.testParticipant.upsert({
     *   create: {
     *     // ... data to create a TestParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TestParticipantUpsertArgs>(args: SelectSubset<T, TestParticipantUpsertArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantCountArgs} args - Arguments to filter TestParticipants to count.
     * @example
     * // Count the number of TestParticipants
     * const count = await prisma.testParticipant.count({
     *   where: {
     *     // ... the filter for the TestParticipants we want to count
     *   }
     * })
    **/
    count<T extends TestParticipantCountArgs>(
      args?: Subset<T, TestParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParticipantAggregateArgs>(args: Subset<T, TestParticipantAggregateArgs>): Prisma.PrismaPromise<GetTestParticipantAggregateType<T>>

    /**
     * Group by TestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TestParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParticipant model
   */
  readonly fields: TestParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends TestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestDefaultArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    records<T extends TestParticipant$recordsArgs<ExtArgs> = {}>(args?: Subset<T, TestParticipant$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParticipant model
   */
  interface TestParticipantFieldRefs {
    readonly id: FieldRef<"TestParticipant", 'String'>
    readonly testId: FieldRef<"TestParticipant", 'String'>
    readonly userId: FieldRef<"TestParticipant", 'String'>
    readonly createdAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly highscore: FieldRef<"TestParticipant", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TestParticipant findUnique
   */
  export type TestParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant findUniqueOrThrow
   */
  export type TestParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant findFirst
   */
  export type TestParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipants.
     */
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant findFirstOrThrow
   */
  export type TestParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipants.
     */
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant findMany
   */
  export type TestParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipants to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant create
   */
  export type TestParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParticipant.
     */
    data: XOR<TestParticipantCreateInput, TestParticipantUncheckedCreateInput>
  }

  /**
   * TestParticipant createMany
   */
  export type TestParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParticipants.
     */
    data: TestParticipantCreateManyInput | TestParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParticipant createManyAndReturn
   */
  export type TestParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many TestParticipants.
     */
    data: TestParticipantCreateManyInput | TestParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipant update
   */
  export type TestParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParticipant.
     */
    data: XOR<TestParticipantUpdateInput, TestParticipantUncheckedUpdateInput>
    /**
     * Choose, which TestParticipant to update.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant updateMany
   */
  export type TestParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParticipants.
     */
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipants to update
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to update.
     */
    limit?: number
  }

  /**
   * TestParticipant updateManyAndReturn
   */
  export type TestParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * The data used to update TestParticipants.
     */
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipants to update
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipant upsert
   */
  export type TestParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParticipant to update in case it exists.
     */
    where: TestParticipantWhereUniqueInput
    /**
     * In case the TestParticipant found by the `where` argument doesn't exist, create a new TestParticipant with this data.
     */
    create: XOR<TestParticipantCreateInput, TestParticipantUncheckedCreateInput>
    /**
     * In case the TestParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParticipantUpdateInput, TestParticipantUncheckedUpdateInput>
  }

  /**
   * TestParticipant delete
   */
  export type TestParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter which TestParticipant to delete.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant deleteMany
   */
  export type TestParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipants to delete
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to delete.
     */
    limit?: number
  }

  /**
   * TestParticipant.records
   */
  export type TestParticipant$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    cursor?: TestParticipantRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipant without action
   */
  export type TestParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
  }


  /**
   * Model TestParticipantRecord
   */

  export type AggregateTestParticipantRecord = {
    _count: TestParticipantRecordCountAggregateOutputType | null
    _avg: TestParticipantRecordAvgAggregateOutputType | null
    _sum: TestParticipantRecordSumAggregateOutputType | null
    _min: TestParticipantRecordMinAggregateOutputType | null
    _max: TestParticipantRecordMaxAggregateOutputType | null
  }

  export type TestParticipantRecordAvgAggregateOutputType = {
    score: number | null
  }

  export type TestParticipantRecordSumAggregateOutputType = {
    score: number | null
  }

  export type TestParticipantRecordMinAggregateOutputType = {
    id: string | null
    participantId: string | null
    startedAt: Date | null
    endedAt: Date | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestParticipantRecordMaxAggregateOutputType = {
    id: string | null
    participantId: string | null
    startedAt: Date | null
    endedAt: Date | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestParticipantRecordCountAggregateOutputType = {
    id: number
    participantId: number
    startedAt: number
    endedAt: number
    score: number
    createdAt: number
    updatedAt: number
    answers: number
    _all: number
  }


  export type TestParticipantRecordAvgAggregateInputType = {
    score?: true
  }

  export type TestParticipantRecordSumAggregateInputType = {
    score?: true
  }

  export type TestParticipantRecordMinAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestParticipantRecordMaxAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestParticipantRecordCountAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    answers?: true
    _all?: true
  }

  export type TestParticipantRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipantRecord to aggregate.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParticipantRecords
    **/
    _count?: true | TestParticipantRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestParticipantRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestParticipantRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParticipantRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParticipantRecordMaxAggregateInputType
  }

  export type GetTestParticipantRecordAggregateType<T extends TestParticipantRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParticipantRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParticipantRecord[P]>
      : GetScalarType<T[P], AggregateTestParticipantRecord[P]>
  }




  export type TestParticipantRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithAggregationInput | TestParticipantRecordOrderByWithAggregationInput[]
    by: TestParticipantRecordScalarFieldEnum[] | TestParticipantRecordScalarFieldEnum
    having?: TestParticipantRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParticipantRecordCountAggregateInputType | true
    _avg?: TestParticipantRecordAvgAggregateInputType
    _sum?: TestParticipantRecordSumAggregateInputType
    _min?: TestParticipantRecordMinAggregateInputType
    _max?: TestParticipantRecordMaxAggregateInputType
  }

  export type TestParticipantRecordGroupByOutputType = {
    id: string
    participantId: string
    startedAt: Date | null
    endedAt: Date | null
    score: number
    createdAt: Date
    updatedAt: Date
    answers: JsonValue
    _count: TestParticipantRecordCountAggregateOutputType | null
    _avg: TestParticipantRecordAvgAggregateOutputType | null
    _sum: TestParticipantRecordSumAggregateOutputType | null
    _min: TestParticipantRecordMinAggregateOutputType | null
    _max: TestParticipantRecordMaxAggregateOutputType | null
  }

  type GetTestParticipantRecordGroupByPayload<T extends TestParticipantRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParticipantRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParticipantRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParticipantRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TestParticipantRecordGroupByOutputType[P]>
        }
      >
    >


  export type TestParticipantRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectScalar = {
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
  }

  export type TestParticipantRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participantId" | "startedAt" | "endedAt" | "score" | "createdAt" | "updatedAt" | "answers", ExtArgs["result"]["testParticipantRecord"]>
  export type TestParticipantRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }
  export type TestParticipantRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }
  export type TestParticipantRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }

  export type $TestParticipantRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParticipantRecord"
    objects: {
      participant: Prisma.$TestParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participantId: string
      startedAt: Date | null
      endedAt: Date | null
      score: number
      createdAt: Date
      updatedAt: Date
      answers: Prisma.JsonValue
    }, ExtArgs["result"]["testParticipantRecord"]>
    composites: {}
  }

  type TestParticipantRecordGetPayload<S extends boolean | null | undefined | TestParticipantRecordDefaultArgs> = $Result.GetResult<Prisma.$TestParticipantRecordPayload, S>

  type TestParticipantRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParticipantRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParticipantRecordCountAggregateInputType | true
    }

  export interface TestParticipantRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParticipantRecord'], meta: { name: 'TestParticipantRecord' } }
    /**
     * Find zero or one TestParticipantRecord that matches the filter.
     * @param {TestParticipantRecordFindUniqueArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParticipantRecordFindUniqueArgs>(args: SelectSubset<T, TestParticipantRecordFindUniqueArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParticipantRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParticipantRecordFindUniqueOrThrowArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParticipantRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipantRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindFirstArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParticipantRecordFindFirstArgs>(args?: SelectSubset<T, TestParticipantRecordFindFirstArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipantRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindFirstOrThrowArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParticipantRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParticipantRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParticipantRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParticipantRecords
     * const testParticipantRecords = await prisma.testParticipantRecord.findMany()
     * 
     * // Get first 10 TestParticipantRecords
     * const testParticipantRecords = await prisma.testParticipantRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParticipantRecordFindManyArgs>(args?: SelectSubset<T, TestParticipantRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParticipantRecord.
     * @param {TestParticipantRecordCreateArgs} args - Arguments to create a TestParticipantRecord.
     * @example
     * // Create one TestParticipantRecord
     * const TestParticipantRecord = await prisma.testParticipantRecord.create({
     *   data: {
     *     // ... data to create a TestParticipantRecord
     *   }
     * })
     * 
     */
    create<T extends TestParticipantRecordCreateArgs>(args: SelectSubset<T, TestParticipantRecordCreateArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParticipantRecords.
     * @param {TestParticipantRecordCreateManyArgs} args - Arguments to create many TestParticipantRecords.
     * @example
     * // Create many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParticipantRecordCreateManyArgs>(args?: SelectSubset<T, TestParticipantRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParticipantRecords and returns the data saved in the database.
     * @param {TestParticipantRecordCreateManyAndReturnArgs} args - Arguments to create many TestParticipantRecords.
     * @example
     * // Create many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParticipantRecords and only return the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParticipantRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParticipantRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParticipantRecord.
     * @param {TestParticipantRecordDeleteArgs} args - Arguments to delete one TestParticipantRecord.
     * @example
     * // Delete one TestParticipantRecord
     * const TestParticipantRecord = await prisma.testParticipantRecord.delete({
     *   where: {
     *     // ... filter to delete one TestParticipantRecord
     *   }
     * })
     * 
     */
    delete<T extends TestParticipantRecordDeleteArgs>(args: SelectSubset<T, TestParticipantRecordDeleteArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParticipantRecord.
     * @param {TestParticipantRecordUpdateArgs} args - Arguments to update one TestParticipantRecord.
     * @example
     * // Update one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParticipantRecordUpdateArgs>(args: SelectSubset<T, TestParticipantRecordUpdateArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParticipantRecords.
     * @param {TestParticipantRecordDeleteManyArgs} args - Arguments to filter TestParticipantRecords to delete.
     * @example
     * // Delete a few TestParticipantRecords
     * const { count } = await prisma.testParticipantRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParticipantRecordDeleteManyArgs>(args?: SelectSubset<T, TestParticipantRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipantRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParticipantRecordUpdateManyArgs>(args: SelectSubset<T, TestParticipantRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipantRecords and returns the data updated in the database.
     * @param {TestParticipantRecordUpdateManyAndReturnArgs} args - Arguments to update many TestParticipantRecords.
     * @example
     * // Update many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParticipantRecords and only return the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParticipantRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParticipantRecord.
     * @param {TestParticipantRecordUpsertArgs} args - Arguments to update or create a TestParticipantRecord.
     * @example
     * // Update or create a TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.upsert({
     *   create: {
     *     // ... data to create a TestParticipantRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParticipantRecord we want to update
     *   }
     * })
     */
    upsert<T extends TestParticipantRecordUpsertArgs>(args: SelectSubset<T, TestParticipantRecordUpsertArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParticipantRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordCountArgs} args - Arguments to filter TestParticipantRecords to count.
     * @example
     * // Count the number of TestParticipantRecords
     * const count = await prisma.testParticipantRecord.count({
     *   where: {
     *     // ... the filter for the TestParticipantRecords we want to count
     *   }
     * })
    **/
    count<T extends TestParticipantRecordCountArgs>(
      args?: Subset<T, TestParticipantRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParticipantRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParticipantRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParticipantRecordAggregateArgs>(args: Subset<T, TestParticipantRecordAggregateArgs>): Prisma.PrismaPromise<GetTestParticipantRecordAggregateType<T>>

    /**
     * Group by TestParticipantRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParticipantRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParticipantRecordGroupByArgs['orderBy'] }
        : { orderBy?: TestParticipantRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParticipantRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParticipantRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParticipantRecord model
   */
  readonly fields: TestParticipantRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParticipantRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParticipantRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends TestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParticipantDefaultArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParticipantRecord model
   */
  interface TestParticipantRecordFieldRefs {
    readonly id: FieldRef<"TestParticipantRecord", 'String'>
    readonly participantId: FieldRef<"TestParticipantRecord", 'String'>
    readonly startedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly endedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly score: FieldRef<"TestParticipantRecord", 'Float'>
    readonly createdAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly answers: FieldRef<"TestParticipantRecord", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TestParticipantRecord findUnique
   */
  export type TestParticipantRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord findUniqueOrThrow
   */
  export type TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord findFirst
   */
  export type TestParticipantRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipantRecords.
     */
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord findFirstOrThrow
   */
  export type TestParticipantRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipantRecords.
     */
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord findMany
   */
  export type TestParticipantRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecords to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord create
   */
  export type TestParticipantRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParticipantRecord.
     */
    data: XOR<TestParticipantRecordCreateInput, TestParticipantRecordUncheckedCreateInput>
  }

  /**
   * TestParticipantRecord createMany
   */
  export type TestParticipantRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParticipantRecords.
     */
    data: TestParticipantRecordCreateManyInput | TestParticipantRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParticipantRecord createManyAndReturn
   */
  export type TestParticipantRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TestParticipantRecords.
     */
    data: TestParticipantRecordCreateManyInput | TestParticipantRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipantRecord update
   */
  export type TestParticipantRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParticipantRecord.
     */
    data: XOR<TestParticipantRecordUpdateInput, TestParticipantRecordUncheckedUpdateInput>
    /**
     * Choose, which TestParticipantRecord to update.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord updateMany
   */
  export type TestParticipantRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParticipantRecords.
     */
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipantRecords to update
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to update.
     */
    limit?: number
  }

  /**
   * TestParticipantRecord updateManyAndReturn
   */
  export type TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * The data used to update TestParticipantRecords.
     */
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipantRecords to update
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipantRecord upsert
   */
  export type TestParticipantRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParticipantRecord to update in case it exists.
     */
    where: TestParticipantRecordWhereUniqueInput
    /**
     * In case the TestParticipantRecord found by the `where` argument doesn't exist, create a new TestParticipantRecord with this data.
     */
    create: XOR<TestParticipantRecordCreateInput, TestParticipantRecordUncheckedCreateInput>
    /**
     * In case the TestParticipantRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParticipantRecordUpdateInput, TestParticipantRecordUncheckedUpdateInput>
  }

  /**
   * TestParticipantRecord delete
   */
  export type TestParticipantRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter which TestParticipantRecord to delete.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord deleteMany
   */
  export type TestParticipantRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipantRecords to delete
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to delete.
     */
    limit?: number
  }

  /**
   * TestParticipantRecord without action
   */
  export type TestParticipantRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
  }


  /**
   * Model Background
   */

  export type AggregateBackground = {
    _count: BackgroundCountAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  export type BackgroundMinAggregateOutputType = {
    id: string | null
    name: string | null
    thumbnail: string | null
    isUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    thumbnailId: string | null
  }

  export type BackgroundMaxAggregateOutputType = {
    id: string | null
    name: string | null
    thumbnail: string | null
    isUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    thumbnailId: string | null
  }

  export type BackgroundCountAggregateOutputType = {
    id: number
    name: number
    thumbnail: number
    isUse: number
    createdAt: number
    updatedAt: number
    thumbnailId: number
    _all: number
  }


  export type BackgroundMinAggregateInputType = {
    id?: true
    name?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
    thumbnailId?: true
  }

  export type BackgroundMaxAggregateInputType = {
    id?: true
    name?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
    thumbnailId?: true
  }

  export type BackgroundCountAggregateInputType = {
    id?: true
    name?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
    thumbnailId?: true
    _all?: true
  }

  export type BackgroundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Background to aggregate.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backgrounds
    **/
    _count?: true | BackgroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackgroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackgroundMaxAggregateInputType
  }

  export type GetBackgroundAggregateType<T extends BackgroundAggregateArgs> = {
        [P in keyof T & keyof AggregateBackground]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackground[P]>
      : GetScalarType<T[P], AggregateBackground[P]>
  }




  export type BackgroundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackgroundWhereInput
    orderBy?: BackgroundOrderByWithAggregationInput | BackgroundOrderByWithAggregationInput[]
    by: BackgroundScalarFieldEnum[] | BackgroundScalarFieldEnum
    having?: BackgroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackgroundCountAggregateInputType | true
    _min?: BackgroundMinAggregateInputType
    _max?: BackgroundMaxAggregateInputType
  }

  export type BackgroundGroupByOutputType = {
    id: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt: Date
    updatedAt: Date
    thumbnailId: string
    _count: BackgroundCountAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  type GetBackgroundGroupByPayload<T extends BackgroundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackgroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackgroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
            : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
        }
      >
    >


  export type BackgroundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnailId?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnailId?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnailId?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectScalar = {
    id?: boolean
    name?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnailId?: boolean
  }

  export type BackgroundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "thumbnail" | "isUse" | "createdAt" | "updatedAt" | "thumbnailId", ExtArgs["result"]["background"]>

  export type $BackgroundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Background"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      thumbnail: string
      isUse: boolean
      createdAt: Date
      updatedAt: Date
      thumbnailId: string
    }, ExtArgs["result"]["background"]>
    composites: {}
  }

  type BackgroundGetPayload<S extends boolean | null | undefined | BackgroundDefaultArgs> = $Result.GetResult<Prisma.$BackgroundPayload, S>

  type BackgroundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BackgroundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BackgroundCountAggregateInputType | true
    }

  export interface BackgroundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Background'], meta: { name: 'Background' } }
    /**
     * Find zero or one Background that matches the filter.
     * @param {BackgroundFindUniqueArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackgroundFindUniqueArgs>(args: SelectSubset<T, BackgroundFindUniqueArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Background that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BackgroundFindUniqueOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackgroundFindUniqueOrThrowArgs>(args: SelectSubset<T, BackgroundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackgroundFindFirstArgs>(args?: SelectSubset<T, BackgroundFindFirstArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackgroundFindFirstOrThrowArgs>(args?: SelectSubset<T, BackgroundFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Backgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backgrounds
     * const backgrounds = await prisma.background.findMany()
     * 
     * // Get first 10 Backgrounds
     * const backgrounds = await prisma.background.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backgroundWithIdOnly = await prisma.background.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackgroundFindManyArgs>(args?: SelectSubset<T, BackgroundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Background.
     * @param {BackgroundCreateArgs} args - Arguments to create a Background.
     * @example
     * // Create one Background
     * const Background = await prisma.background.create({
     *   data: {
     *     // ... data to create a Background
     *   }
     * })
     * 
     */
    create<T extends BackgroundCreateArgs>(args: SelectSubset<T, BackgroundCreateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Backgrounds.
     * @param {BackgroundCreateManyArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackgroundCreateManyArgs>(args?: SelectSubset<T, BackgroundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Backgrounds and returns the data saved in the database.
     * @param {BackgroundCreateManyAndReturnArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Backgrounds and only return the `id`
     * const backgroundWithIdOnly = await prisma.background.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackgroundCreateManyAndReturnArgs>(args?: SelectSubset<T, BackgroundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Background.
     * @param {BackgroundDeleteArgs} args - Arguments to delete one Background.
     * @example
     * // Delete one Background
     * const Background = await prisma.background.delete({
     *   where: {
     *     // ... filter to delete one Background
     *   }
     * })
     * 
     */
    delete<T extends BackgroundDeleteArgs>(args: SelectSubset<T, BackgroundDeleteArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Background.
     * @param {BackgroundUpdateArgs} args - Arguments to update one Background.
     * @example
     * // Update one Background
     * const background = await prisma.background.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackgroundUpdateArgs>(args: SelectSubset<T, BackgroundUpdateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Backgrounds.
     * @param {BackgroundDeleteManyArgs} args - Arguments to filter Backgrounds to delete.
     * @example
     * // Delete a few Backgrounds
     * const { count } = await prisma.background.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackgroundDeleteManyArgs>(args?: SelectSubset<T, BackgroundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackgroundUpdateManyArgs>(args: SelectSubset<T, BackgroundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds and returns the data updated in the database.
     * @param {BackgroundUpdateManyAndReturnArgs} args - Arguments to update many Backgrounds.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Backgrounds and only return the `id`
     * const backgroundWithIdOnly = await prisma.background.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BackgroundUpdateManyAndReturnArgs>(args: SelectSubset<T, BackgroundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Background.
     * @param {BackgroundUpsertArgs} args - Arguments to update or create a Background.
     * @example
     * // Update or create a Background
     * const background = await prisma.background.upsert({
     *   create: {
     *     // ... data to create a Background
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Background we want to update
     *   }
     * })
     */
    upsert<T extends BackgroundUpsertArgs>(args: SelectSubset<T, BackgroundUpsertArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundCountArgs} args - Arguments to filter Backgrounds to count.
     * @example
     * // Count the number of Backgrounds
     * const count = await prisma.background.count({
     *   where: {
     *     // ... the filter for the Backgrounds we want to count
     *   }
     * })
    **/
    count<T extends BackgroundCountArgs>(
      args?: Subset<T, BackgroundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackgroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackgroundAggregateArgs>(args: Subset<T, BackgroundAggregateArgs>): Prisma.PrismaPromise<GetBackgroundAggregateType<T>>

    /**
     * Group by Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackgroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackgroundGroupByArgs['orderBy'] }
        : { orderBy?: BackgroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackgroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackgroundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Background model
   */
  readonly fields: BackgroundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Background.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackgroundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Background model
   */
  interface BackgroundFieldRefs {
    readonly id: FieldRef<"Background", 'String'>
    readonly name: FieldRef<"Background", 'String'>
    readonly thumbnail: FieldRef<"Background", 'String'>
    readonly isUse: FieldRef<"Background", 'Boolean'>
    readonly createdAt: FieldRef<"Background", 'DateTime'>
    readonly updatedAt: FieldRef<"Background", 'DateTime'>
    readonly thumbnailId: FieldRef<"Background", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Background findUnique
   */
  export type BackgroundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findUniqueOrThrow
   */
  export type BackgroundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findFirst
   */
  export type BackgroundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findFirstOrThrow
   */
  export type BackgroundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findMany
   */
  export type BackgroundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Backgrounds to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background create
   */
  export type BackgroundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data needed to create a Background.
     */
    data: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
  }

  /**
   * Background createMany
   */
  export type BackgroundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background createManyAndReturn
   */
  export type BackgroundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background update
   */
  export type BackgroundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data needed to update a Background.
     */
    data: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
    /**
     * Choose, which Background to update.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background updateMany
   */
  export type BackgroundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background updateManyAndReturn
   */
  export type BackgroundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background upsert
   */
  export type BackgroundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The filter to search for the Background to update in case it exists.
     */
    where: BackgroundWhereUniqueInput
    /**
     * In case the Background found by the `where` argument doesn't exist, create a new Background with this data.
     */
    create: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
    /**
     * In case the Background was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
  }

  /**
   * Background delete
   */
  export type BackgroundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter which Background to delete.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background deleteMany
   */
  export type BackgroundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backgrounds to delete
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to delete.
     */
    limit?: number
  }

  /**
   * Background without action
   */
  export type BackgroundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    name: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    name: string
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "title" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly name: FieldRef<"Setting", 'String'>
    readonly title: FieldRef<"Setting", 'String'>
    readonly content: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model AdminTransaction
   */

  export type AggregateAdminTransaction = {
    _count: AdminTransactionCountAggregateOutputType | null
    _avg: AdminTransactionAvgAggregateOutputType | null
    _sum: AdminTransactionSumAggregateOutputType | null
    _min: AdminTransactionMinAggregateOutputType | null
    _max: AdminTransactionMaxAggregateOutputType | null
  }

  export type AdminTransactionAvgAggregateOutputType = {
    quantity: number | null
    amount: number | null
    subscriptionTime: number | null
  }

  export type AdminTransactionSumAggregateOutputType = {
    quantity: number | null
    amount: number | null
    subscriptionTime: number | null
  }

  export type AdminTransactionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    quantity: number | null
    adminId: string | null
    amount: number | null
    archived: boolean | null
    description: string | null
    name: string | null
    subscriptionTime: number | null
    transactionImageId: string | null
    transactionImageUrl: string | null
    transactionRef: string | null
    status: $Enums.Transaction | null
    processedAt: Date | null
    processedById: string | null
  }

  export type AdminTransactionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    quantity: number | null
    adminId: string | null
    amount: number | null
    archived: boolean | null
    description: string | null
    name: string | null
    subscriptionTime: number | null
    transactionImageId: string | null
    transactionImageUrl: string | null
    transactionRef: string | null
    status: $Enums.Transaction | null
    processedAt: Date | null
    processedById: string | null
  }

  export type AdminTransactionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    quantity: number
    zones: number
    adminId: number
    amount: number
    archived: number
    description: number
    name: number
    subscriptionTime: number
    transactionImageId: number
    transactionImageUrl: number
    transactionRef: number
    status: number
    processedAt: number
    processedById: number
    _all: number
  }


  export type AdminTransactionAvgAggregateInputType = {
    quantity?: true
    amount?: true
    subscriptionTime?: true
  }

  export type AdminTransactionSumAggregateInputType = {
    quantity?: true
    amount?: true
    subscriptionTime?: true
  }

  export type AdminTransactionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    quantity?: true
    adminId?: true
    amount?: true
    archived?: true
    description?: true
    name?: true
    subscriptionTime?: true
    transactionImageId?: true
    transactionImageUrl?: true
    transactionRef?: true
    status?: true
    processedAt?: true
    processedById?: true
  }

  export type AdminTransactionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    quantity?: true
    adminId?: true
    amount?: true
    archived?: true
    description?: true
    name?: true
    subscriptionTime?: true
    transactionImageId?: true
    transactionImageUrl?: true
    transactionRef?: true
    status?: true
    processedAt?: true
    processedById?: true
  }

  export type AdminTransactionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    quantity?: true
    zones?: true
    adminId?: true
    amount?: true
    archived?: true
    description?: true
    name?: true
    subscriptionTime?: true
    transactionImageId?: true
    transactionImageUrl?: true
    transactionRef?: true
    status?: true
    processedAt?: true
    processedById?: true
    _all?: true
  }

  export type AdminTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransaction to aggregate.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminTransactions
    **/
    _count?: true | AdminTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminTransactionMaxAggregateInputType
  }

  export type GetAdminTransactionAggregateType<T extends AdminTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminTransaction[P]>
      : GetScalarType<T[P], AggregateAdminTransaction[P]>
  }




  export type AdminTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithAggregationInput | AdminTransactionOrderByWithAggregationInput[]
    by: AdminTransactionScalarFieldEnum[] | AdminTransactionScalarFieldEnum
    having?: AdminTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminTransactionCountAggregateInputType | true
    _avg?: AdminTransactionAvgAggregateInputType
    _sum?: AdminTransactionSumAggregateInputType
    _min?: AdminTransactionMinAggregateInputType
    _max?: AdminTransactionMaxAggregateInputType
  }

  export type AdminTransactionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    quantity: number
    zones: string[]
    adminId: string
    amount: number
    archived: boolean
    description: string | null
    name: string
    subscriptionTime: number
    transactionImageId: string | null
    transactionImageUrl: string | null
    transactionRef: string | null
    status: $Enums.Transaction
    processedAt: Date | null
    processedById: string | null
    _count: AdminTransactionCountAggregateOutputType | null
    _avg: AdminTransactionAvgAggregateOutputType | null
    _sum: AdminTransactionSumAggregateOutputType | null
    _min: AdminTransactionMinAggregateOutputType | null
    _max: AdminTransactionMaxAggregateOutputType | null
  }

  type GetAdminTransactionGroupByPayload<T extends AdminTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminTransactionGroupByOutputType[P]>
        }
      >
    >


  export type AdminTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    zones?: boolean
    adminId?: boolean
    amount?: boolean
    archived?: boolean
    description?: boolean
    name?: boolean
    subscriptionTime?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    transactionRef?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
    redeemCode?: boolean | AdminTransaction$redeemCodeArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    zones?: boolean
    adminId?: boolean
    amount?: boolean
    archived?: boolean
    description?: boolean
    name?: boolean
    subscriptionTime?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    transactionRef?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    zones?: boolean
    adminId?: boolean
    amount?: boolean
    archived?: boolean
    description?: boolean
    name?: boolean
    subscriptionTime?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    transactionRef?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quantity?: boolean
    zones?: boolean
    adminId?: boolean
    amount?: boolean
    archived?: boolean
    description?: boolean
    name?: boolean
    subscriptionTime?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    transactionRef?: boolean
    status?: boolean
    processedAt?: boolean
    processedById?: boolean
  }

  export type AdminTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "quantity" | "zones" | "adminId" | "amount" | "archived" | "description" | "name" | "subscriptionTime" | "transactionImageId" | "transactionImageUrl" | "transactionRef" | "status" | "processedAt" | "processedById", ExtArgs["result"]["adminTransaction"]>
  export type AdminTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
    redeemCode?: boolean | AdminTransaction$redeemCodeArgs<ExtArgs>
  }
  export type AdminTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }
  export type AdminTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }

  export type $AdminTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminTransaction"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      processedBy: Prisma.$AdminPayload<ExtArgs> | null
      redeemCode: Prisma.$RedeemCodePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      quantity: number
      zones: string[]
      adminId: string
      amount: number
      archived: boolean
      description: string | null
      name: string
      subscriptionTime: number
      transactionImageId: string | null
      transactionImageUrl: string | null
      transactionRef: string | null
      status: $Enums.Transaction
      processedAt: Date | null
      processedById: string | null
    }, ExtArgs["result"]["adminTransaction"]>
    composites: {}
  }

  type AdminTransactionGetPayload<S extends boolean | null | undefined | AdminTransactionDefaultArgs> = $Result.GetResult<Prisma.$AdminTransactionPayload, S>

  type AdminTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminTransactionCountAggregateInputType | true
    }

  export interface AdminTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminTransaction'], meta: { name: 'AdminTransaction' } }
    /**
     * Find zero or one AdminTransaction that matches the filter.
     * @param {AdminTransactionFindUniqueArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminTransactionFindUniqueArgs>(args: SelectSubset<T, AdminTransactionFindUniqueArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminTransactionFindUniqueOrThrowArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindFirstArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminTransactionFindFirstArgs>(args?: SelectSubset<T, AdminTransactionFindFirstArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindFirstOrThrowArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminTransactions
     * const adminTransactions = await prisma.adminTransaction.findMany()
     * 
     * // Get first 10 AdminTransactions
     * const adminTransactions = await prisma.adminTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminTransactionFindManyArgs>(args?: SelectSubset<T, AdminTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminTransaction.
     * @param {AdminTransactionCreateArgs} args - Arguments to create a AdminTransaction.
     * @example
     * // Create one AdminTransaction
     * const AdminTransaction = await prisma.adminTransaction.create({
     *   data: {
     *     // ... data to create a AdminTransaction
     *   }
     * })
     * 
     */
    create<T extends AdminTransactionCreateArgs>(args: SelectSubset<T, AdminTransactionCreateArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminTransactions.
     * @param {AdminTransactionCreateManyArgs} args - Arguments to create many AdminTransactions.
     * @example
     * // Create many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminTransactionCreateManyArgs>(args?: SelectSubset<T, AdminTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminTransactions and returns the data saved in the database.
     * @param {AdminTransactionCreateManyAndReturnArgs} args - Arguments to create many AdminTransactions.
     * @example
     * // Create many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminTransactions and only return the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminTransaction.
     * @param {AdminTransactionDeleteArgs} args - Arguments to delete one AdminTransaction.
     * @example
     * // Delete one AdminTransaction
     * const AdminTransaction = await prisma.adminTransaction.delete({
     *   where: {
     *     // ... filter to delete one AdminTransaction
     *   }
     * })
     * 
     */
    delete<T extends AdminTransactionDeleteArgs>(args: SelectSubset<T, AdminTransactionDeleteArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminTransaction.
     * @param {AdminTransactionUpdateArgs} args - Arguments to update one AdminTransaction.
     * @example
     * // Update one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminTransactionUpdateArgs>(args: SelectSubset<T, AdminTransactionUpdateArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminTransactions.
     * @param {AdminTransactionDeleteManyArgs} args - Arguments to filter AdminTransactions to delete.
     * @example
     * // Delete a few AdminTransactions
     * const { count } = await prisma.adminTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminTransactionDeleteManyArgs>(args?: SelectSubset<T, AdminTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminTransactionUpdateManyArgs>(args: SelectSubset<T, AdminTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactions and returns the data updated in the database.
     * @param {AdminTransactionUpdateManyAndReturnArgs} args - Arguments to update many AdminTransactions.
     * @example
     * // Update many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminTransactions and only return the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminTransaction.
     * @param {AdminTransactionUpsertArgs} args - Arguments to update or create a AdminTransaction.
     * @example
     * // Update or create a AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.upsert({
     *   create: {
     *     // ... data to create a AdminTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminTransaction we want to update
     *   }
     * })
     */
    upsert<T extends AdminTransactionUpsertArgs>(args: SelectSubset<T, AdminTransactionUpsertArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionCountArgs} args - Arguments to filter AdminTransactions to count.
     * @example
     * // Count the number of AdminTransactions
     * const count = await prisma.adminTransaction.count({
     *   where: {
     *     // ... the filter for the AdminTransactions we want to count
     *   }
     * })
    **/
    count<T extends AdminTransactionCountArgs>(
      args?: Subset<T, AdminTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminTransactionAggregateArgs>(args: Subset<T, AdminTransactionAggregateArgs>): Prisma.PrismaPromise<GetAdminTransactionAggregateType<T>>

    /**
     * Group by AdminTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminTransactionGroupByArgs['orderBy'] }
        : { orderBy?: AdminTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminTransaction model
   */
  readonly fields: AdminTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends AdminTransaction$processedByArgs<ExtArgs> = {}>(args?: Subset<T, AdminTransaction$processedByArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    redeemCode<T extends AdminTransaction$redeemCodeArgs<ExtArgs> = {}>(args?: Subset<T, AdminTransaction$redeemCodeArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminTransaction model
   */
  interface AdminTransactionFieldRefs {
    readonly id: FieldRef<"AdminTransaction", 'String'>
    readonly createdAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly quantity: FieldRef<"AdminTransaction", 'Int'>
    readonly zones: FieldRef<"AdminTransaction", 'String[]'>
    readonly adminId: FieldRef<"AdminTransaction", 'String'>
    readonly amount: FieldRef<"AdminTransaction", 'Int'>
    readonly archived: FieldRef<"AdminTransaction", 'Boolean'>
    readonly description: FieldRef<"AdminTransaction", 'String'>
    readonly name: FieldRef<"AdminTransaction", 'String'>
    readonly subscriptionTime: FieldRef<"AdminTransaction", 'Int'>
    readonly transactionImageId: FieldRef<"AdminTransaction", 'String'>
    readonly transactionImageUrl: FieldRef<"AdminTransaction", 'String'>
    readonly transactionRef: FieldRef<"AdminTransaction", 'String'>
    readonly status: FieldRef<"AdminTransaction", 'Transaction'>
    readonly processedAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly processedById: FieldRef<"AdminTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminTransaction findUnique
   */
  export type AdminTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction findUniqueOrThrow
   */
  export type AdminTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction findFirst
   */
  export type AdminTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactions.
     */
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction findFirstOrThrow
   */
  export type AdminTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactions.
     */
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction findMany
   */
  export type AdminTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactions to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction create
   */
  export type AdminTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminTransaction.
     */
    data: XOR<AdminTransactionCreateInput, AdminTransactionUncheckedCreateInput>
  }

  /**
   * AdminTransaction createMany
   */
  export type AdminTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminTransactions.
     */
    data: AdminTransactionCreateManyInput | AdminTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminTransaction createManyAndReturn
   */
  export type AdminTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminTransactions.
     */
    data: AdminTransactionCreateManyInput | AdminTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransaction update
   */
  export type AdminTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminTransaction.
     */
    data: XOR<AdminTransactionUpdateInput, AdminTransactionUncheckedUpdateInput>
    /**
     * Choose, which AdminTransaction to update.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction updateMany
   */
  export type AdminTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminTransactions.
     */
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactions to update
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to update.
     */
    limit?: number
  }

  /**
   * AdminTransaction updateManyAndReturn
   */
  export type AdminTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * The data used to update AdminTransactions.
     */
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactions to update
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransaction upsert
   */
  export type AdminTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminTransaction to update in case it exists.
     */
    where: AdminTransactionWhereUniqueInput
    /**
     * In case the AdminTransaction found by the `where` argument doesn't exist, create a new AdminTransaction with this data.
     */
    create: XOR<AdminTransactionCreateInput, AdminTransactionUncheckedCreateInput>
    /**
     * In case the AdminTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminTransactionUpdateInput, AdminTransactionUncheckedUpdateInput>
  }

  /**
   * AdminTransaction delete
   */
  export type AdminTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter which AdminTransaction to delete.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction deleteMany
   */
  export type AdminTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransactions to delete
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to delete.
     */
    limit?: number
  }

  /**
   * AdminTransaction.processedBy
   */
  export type AdminTransaction$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * AdminTransaction.redeemCode
   */
  export type AdminTransaction$redeemCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    where?: RedeemCodeWhereInput
  }

  /**
   * AdminTransaction without action
   */
  export type AdminTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
  }


  /**
   * Model RedeemCode
   */

  export type AggregateRedeemCode = {
    _count: RedeemCodeCountAggregateOutputType | null
    _avg: RedeemCodeAvgAggregateOutputType | null
    _sum: RedeemCodeSumAggregateOutputType | null
    _min: RedeemCodeMinAggregateOutputType | null
    _max: RedeemCodeMaxAggregateOutputType | null
  }

  export type RedeemCodeAvgAggregateOutputType = {
    currentAmount: number | null
    maxAmount: number | null
  }

  export type RedeemCodeSumAggregateOutputType = {
    currentAmount: number | null
    maxAmount: number | null
  }

  export type RedeemCodeMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    adminId: string | null
    code: string | null
    expiredAt: Date | null
    currentAmount: number | null
    maxAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    suspend: boolean | null
  }

  export type RedeemCodeMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    adminId: string | null
    code: string | null
    expiredAt: Date | null
    currentAmount: number | null
    maxAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    suspend: boolean | null
  }

  export type RedeemCodeCountAggregateOutputType = {
    id: number
    transactionId: number
    adminId: number
    code: number
    expiredAt: number
    currentAmount: number
    maxAmount: number
    data: number
    createdAt: number
    updatedAt: number
    suspend: number
    _all: number
  }


  export type RedeemCodeAvgAggregateInputType = {
    currentAmount?: true
    maxAmount?: true
  }

  export type RedeemCodeSumAggregateInputType = {
    currentAmount?: true
    maxAmount?: true
  }

  export type RedeemCodeMinAggregateInputType = {
    id?: true
    transactionId?: true
    adminId?: true
    code?: true
    expiredAt?: true
    currentAmount?: true
    maxAmount?: true
    createdAt?: true
    updatedAt?: true
    suspend?: true
  }

  export type RedeemCodeMaxAggregateInputType = {
    id?: true
    transactionId?: true
    adminId?: true
    code?: true
    expiredAt?: true
    currentAmount?: true
    maxAmount?: true
    createdAt?: true
    updatedAt?: true
    suspend?: true
  }

  export type RedeemCodeCountAggregateInputType = {
    id?: true
    transactionId?: true
    adminId?: true
    code?: true
    expiredAt?: true
    currentAmount?: true
    maxAmount?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    suspend?: true
    _all?: true
  }

  export type RedeemCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCode to aggregate.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedeemCodes
    **/
    _count?: true | RedeemCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedeemCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedeemCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedeemCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedeemCodeMaxAggregateInputType
  }

  export type GetRedeemCodeAggregateType<T extends RedeemCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemCode[P]>
      : GetScalarType<T[P], AggregateRedeemCode[P]>
  }




  export type RedeemCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeWhereInput
    orderBy?: RedeemCodeOrderByWithAggregationInput | RedeemCodeOrderByWithAggregationInput[]
    by: RedeemCodeScalarFieldEnum[] | RedeemCodeScalarFieldEnum
    having?: RedeemCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedeemCodeCountAggregateInputType | true
    _avg?: RedeemCodeAvgAggregateInputType
    _sum?: RedeemCodeSumAggregateInputType
    _min?: RedeemCodeMinAggregateInputType
    _max?: RedeemCodeMaxAggregateInputType
  }

  export type RedeemCodeGroupByOutputType = {
    id: string
    transactionId: string
    adminId: string
    code: string
    expiredAt: Date | null
    currentAmount: number
    maxAmount: number
    data: string[]
    createdAt: Date
    updatedAt: Date
    suspend: boolean
    _count: RedeemCodeCountAggregateOutputType | null
    _avg: RedeemCodeAvgAggregateOutputType | null
    _sum: RedeemCodeSumAggregateOutputType | null
    _min: RedeemCodeMinAggregateOutputType | null
    _max: RedeemCodeMaxAggregateOutputType | null
  }

  type GetRedeemCodeGroupByPayload<T extends RedeemCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedeemCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedeemCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedeemCodeGroupByOutputType[P]>
            : GetScalarType<T[P], RedeemCodeGroupByOutputType[P]>
        }
      >
    >


  export type RedeemCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspend?: boolean
    redeemers?: boolean | RedeemCode$redeemersArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    _count?: boolean | RedeemCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspend?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspend?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectScalar = {
    id?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suspend?: boolean
  }

  export type RedeemCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "adminId" | "code" | "expiredAt" | "currentAmount" | "maxAmount" | "data" | "createdAt" | "updatedAt" | "suspend", ExtArgs["result"]["redeemCode"]>
  export type RedeemCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redeemers?: boolean | RedeemCode$redeemersArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    _count?: boolean | RedeemCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RedeemCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
  }
  export type RedeemCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
  }

  export type $RedeemCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedeemCode"
    objects: {
      redeemers: Prisma.$CodeRedeemerPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>
      transaction: Prisma.$AdminTransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      adminId: string
      code: string
      expiredAt: Date | null
      currentAmount: number
      maxAmount: number
      data: string[]
      createdAt: Date
      updatedAt: Date
      suspend: boolean
    }, ExtArgs["result"]["redeemCode"]>
    composites: {}
  }

  type RedeemCodeGetPayload<S extends boolean | null | undefined | RedeemCodeDefaultArgs> = $Result.GetResult<Prisma.$RedeemCodePayload, S>

  type RedeemCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedeemCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedeemCodeCountAggregateInputType | true
    }

  export interface RedeemCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedeemCode'], meta: { name: 'RedeemCode' } }
    /**
     * Find zero or one RedeemCode that matches the filter.
     * @param {RedeemCodeFindUniqueArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedeemCodeFindUniqueArgs>(args: SelectSubset<T, RedeemCodeFindUniqueArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RedeemCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedeemCodeFindUniqueOrThrowArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedeemCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, RedeemCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindFirstArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedeemCodeFindFirstArgs>(args?: SelectSubset<T, RedeemCodeFindFirstArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindFirstOrThrowArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedeemCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, RedeemCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RedeemCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedeemCodes
     * const redeemCodes = await prisma.redeemCode.findMany()
     * 
     * // Get first 10 RedeemCodes
     * const redeemCodes = await prisma.redeemCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedeemCodeFindManyArgs>(args?: SelectSubset<T, RedeemCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RedeemCode.
     * @param {RedeemCodeCreateArgs} args - Arguments to create a RedeemCode.
     * @example
     * // Create one RedeemCode
     * const RedeemCode = await prisma.redeemCode.create({
     *   data: {
     *     // ... data to create a RedeemCode
     *   }
     * })
     * 
     */
    create<T extends RedeemCodeCreateArgs>(args: SelectSubset<T, RedeemCodeCreateArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RedeemCodes.
     * @param {RedeemCodeCreateManyArgs} args - Arguments to create many RedeemCodes.
     * @example
     * // Create many RedeemCodes
     * const redeemCode = await prisma.redeemCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedeemCodeCreateManyArgs>(args?: SelectSubset<T, RedeemCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RedeemCodes and returns the data saved in the database.
     * @param {RedeemCodeCreateManyAndReturnArgs} args - Arguments to create many RedeemCodes.
     * @example
     * // Create many RedeemCodes
     * const redeemCode = await prisma.redeemCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RedeemCodes and only return the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedeemCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, RedeemCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RedeemCode.
     * @param {RedeemCodeDeleteArgs} args - Arguments to delete one RedeemCode.
     * @example
     * // Delete one RedeemCode
     * const RedeemCode = await prisma.redeemCode.delete({
     *   where: {
     *     // ... filter to delete one RedeemCode
     *   }
     * })
     * 
     */
    delete<T extends RedeemCodeDeleteArgs>(args: SelectSubset<T, RedeemCodeDeleteArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RedeemCode.
     * @param {RedeemCodeUpdateArgs} args - Arguments to update one RedeemCode.
     * @example
     * // Update one RedeemCode
     * const redeemCode = await prisma.redeemCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedeemCodeUpdateArgs>(args: SelectSubset<T, RedeemCodeUpdateArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RedeemCodes.
     * @param {RedeemCodeDeleteManyArgs} args - Arguments to filter RedeemCodes to delete.
     * @example
     * // Delete a few RedeemCodes
     * const { count } = await prisma.redeemCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedeemCodeDeleteManyArgs>(args?: SelectSubset<T, RedeemCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedeemCodes
     * const redeemCode = await prisma.redeemCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedeemCodeUpdateManyArgs>(args: SelectSubset<T, RedeemCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodes and returns the data updated in the database.
     * @param {RedeemCodeUpdateManyAndReturnArgs} args - Arguments to update many RedeemCodes.
     * @example
     * // Update many RedeemCodes
     * const redeemCode = await prisma.redeemCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RedeemCodes and only return the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RedeemCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, RedeemCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RedeemCode.
     * @param {RedeemCodeUpsertArgs} args - Arguments to update or create a RedeemCode.
     * @example
     * // Update or create a RedeemCode
     * const redeemCode = await prisma.redeemCode.upsert({
     *   create: {
     *     // ... data to create a RedeemCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedeemCode we want to update
     *   }
     * })
     */
    upsert<T extends RedeemCodeUpsertArgs>(args: SelectSubset<T, RedeemCodeUpsertArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RedeemCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeCountArgs} args - Arguments to filter RedeemCodes to count.
     * @example
     * // Count the number of RedeemCodes
     * const count = await prisma.redeemCode.count({
     *   where: {
     *     // ... the filter for the RedeemCodes we want to count
     *   }
     * })
    **/
    count<T extends RedeemCodeCountArgs>(
      args?: Subset<T, RedeemCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedeemCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedeemCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedeemCodeAggregateArgs>(args: Subset<T, RedeemCodeAggregateArgs>): Prisma.PrismaPromise<GetRedeemCodeAggregateType<T>>

    /**
     * Group by RedeemCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedeemCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedeemCodeGroupByArgs['orderBy'] }
        : { orderBy?: RedeemCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedeemCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedeemCode model
   */
  readonly fields: RedeemCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedeemCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedeemCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    redeemers<T extends RedeemCode$redeemersArgs<ExtArgs> = {}>(args?: Subset<T, RedeemCode$redeemersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends AdminTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminTransactionDefaultArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedeemCode model
   */
  interface RedeemCodeFieldRefs {
    readonly id: FieldRef<"RedeemCode", 'String'>
    readonly transactionId: FieldRef<"RedeemCode", 'String'>
    readonly adminId: FieldRef<"RedeemCode", 'String'>
    readonly code: FieldRef<"RedeemCode", 'String'>
    readonly expiredAt: FieldRef<"RedeemCode", 'DateTime'>
    readonly currentAmount: FieldRef<"RedeemCode", 'Int'>
    readonly maxAmount: FieldRef<"RedeemCode", 'Int'>
    readonly data: FieldRef<"RedeemCode", 'String[]'>
    readonly createdAt: FieldRef<"RedeemCode", 'DateTime'>
    readonly updatedAt: FieldRef<"RedeemCode", 'DateTime'>
    readonly suspend: FieldRef<"RedeemCode", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RedeemCode findUnique
   */
  export type RedeemCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode findUniqueOrThrow
   */
  export type RedeemCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode findFirst
   */
  export type RedeemCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodes.
     */
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode findFirstOrThrow
   */
  export type RedeemCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodes.
     */
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode findMany
   */
  export type RedeemCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodes to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode create
   */
  export type RedeemCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a RedeemCode.
     */
    data: XOR<RedeemCodeCreateInput, RedeemCodeUncheckedCreateInput>
  }

  /**
   * RedeemCode createMany
   */
  export type RedeemCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedeemCodes.
     */
    data: RedeemCodeCreateManyInput | RedeemCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedeemCode createManyAndReturn
   */
  export type RedeemCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * The data used to create many RedeemCodes.
     */
    data: RedeemCodeCreateManyInput | RedeemCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemCode update
   */
  export type RedeemCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a RedeemCode.
     */
    data: XOR<RedeemCodeUpdateInput, RedeemCodeUncheckedUpdateInput>
    /**
     * Choose, which RedeemCode to update.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode updateMany
   */
  export type RedeemCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedeemCodes.
     */
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodes to update
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to update.
     */
    limit?: number
  }

  /**
   * RedeemCode updateManyAndReturn
   */
  export type RedeemCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * The data used to update RedeemCodes.
     */
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodes to update
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemCode upsert
   */
  export type RedeemCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the RedeemCode to update in case it exists.
     */
    where: RedeemCodeWhereUniqueInput
    /**
     * In case the RedeemCode found by the `where` argument doesn't exist, create a new RedeemCode with this data.
     */
    create: XOR<RedeemCodeCreateInput, RedeemCodeUncheckedCreateInput>
    /**
     * In case the RedeemCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedeemCodeUpdateInput, RedeemCodeUncheckedUpdateInput>
  }

  /**
   * RedeemCode delete
   */
  export type RedeemCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter which RedeemCode to delete.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode deleteMany
   */
  export type RedeemCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCodes to delete
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to delete.
     */
    limit?: number
  }

  /**
   * RedeemCode.redeemers
   */
  export type RedeemCode$redeemersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    where?: CodeRedeemerWhereInput
    orderBy?: CodeRedeemerOrderByWithRelationInput | CodeRedeemerOrderByWithRelationInput[]
    cursor?: CodeRedeemerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeRedeemerScalarFieldEnum | CodeRedeemerScalarFieldEnum[]
  }

  /**
   * RedeemCode without action
   */
  export type RedeemCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
  }


  /**
   * Model CodeRedeemer
   */

  export type AggregateCodeRedeemer = {
    _count: CodeRedeemerCountAggregateOutputType | null
    _min: CodeRedeemerMinAggregateOutputType | null
    _max: CodeRedeemerMaxAggregateOutputType | null
  }

  export type CodeRedeemerMinAggregateOutputType = {
    id: string | null
    banned: boolean | null
    userId: string | null
    codeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeRedeemerMaxAggregateOutputType = {
    id: string | null
    banned: boolean | null
    userId: string | null
    codeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeRedeemerCountAggregateOutputType = {
    id: number
    banned: number
    userId: number
    codeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodeRedeemerMinAggregateInputType = {
    id?: true
    banned?: true
    userId?: true
    codeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeRedeemerMaxAggregateInputType = {
    id?: true
    banned?: true
    userId?: true
    codeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeRedeemerCountAggregateInputType = {
    id?: true
    banned?: true
    userId?: true
    codeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodeRedeemerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeRedeemer to aggregate.
     */
    where?: CodeRedeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedeemers to fetch.
     */
    orderBy?: CodeRedeemerOrderByWithRelationInput | CodeRedeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeRedeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedeemers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeRedeemers
    **/
    _count?: true | CodeRedeemerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeRedeemerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeRedeemerMaxAggregateInputType
  }

  export type GetCodeRedeemerAggregateType<T extends CodeRedeemerAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeRedeemer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeRedeemer[P]>
      : GetScalarType<T[P], AggregateCodeRedeemer[P]>
  }




  export type CodeRedeemerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeRedeemerWhereInput
    orderBy?: CodeRedeemerOrderByWithAggregationInput | CodeRedeemerOrderByWithAggregationInput[]
    by: CodeRedeemerScalarFieldEnum[] | CodeRedeemerScalarFieldEnum
    having?: CodeRedeemerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeRedeemerCountAggregateInputType | true
    _min?: CodeRedeemerMinAggregateInputType
    _max?: CodeRedeemerMaxAggregateInputType
  }

  export type CodeRedeemerGroupByOutputType = {
    id: string
    banned: boolean
    userId: string
    codeId: string
    createdAt: Date
    updatedAt: Date
    _count: CodeRedeemerCountAggregateOutputType | null
    _min: CodeRedeemerMinAggregateOutputType | null
    _max: CodeRedeemerMaxAggregateOutputType | null
  }

  type GetCodeRedeemerGroupByPayload<T extends CodeRedeemerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodeRedeemerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeRedeemerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeRedeemerGroupByOutputType[P]>
            : GetScalarType<T[P], CodeRedeemerGroupByOutputType[P]>
        }
      >
    >


  export type CodeRedeemerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeRedeemer"]>

  export type CodeRedeemerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeRedeemer"]>

  export type CodeRedeemerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeRedeemer"]>

  export type CodeRedeemerSelectScalar = {
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CodeRedeemerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "banned" | "userId" | "codeId" | "createdAt" | "updatedAt", ExtArgs["result"]["codeRedeemer"]>
  export type CodeRedeemerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CodeRedeemerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CodeRedeemerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CodeRedeemerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodeRedeemer"
    objects: {
      code: Prisma.$RedeemCodePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      banned: boolean
      userId: string
      codeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["codeRedeemer"]>
    composites: {}
  }

  type CodeRedeemerGetPayload<S extends boolean | null | undefined | CodeRedeemerDefaultArgs> = $Result.GetResult<Prisma.$CodeRedeemerPayload, S>

  type CodeRedeemerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CodeRedeemerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CodeRedeemerCountAggregateInputType | true
    }

  export interface CodeRedeemerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodeRedeemer'], meta: { name: 'CodeRedeemer' } }
    /**
     * Find zero or one CodeRedeemer that matches the filter.
     * @param {CodeRedeemerFindUniqueArgs} args - Arguments to find a CodeRedeemer
     * @example
     * // Get one CodeRedeemer
     * const codeRedeemer = await prisma.codeRedeemer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodeRedeemerFindUniqueArgs>(args: SelectSubset<T, CodeRedeemerFindUniqueArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CodeRedeemer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CodeRedeemerFindUniqueOrThrowArgs} args - Arguments to find a CodeRedeemer
     * @example
     * // Get one CodeRedeemer
     * const codeRedeemer = await prisma.codeRedeemer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodeRedeemerFindUniqueOrThrowArgs>(args: SelectSubset<T, CodeRedeemerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeRedeemer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerFindFirstArgs} args - Arguments to find a CodeRedeemer
     * @example
     * // Get one CodeRedeemer
     * const codeRedeemer = await prisma.codeRedeemer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodeRedeemerFindFirstArgs>(args?: SelectSubset<T, CodeRedeemerFindFirstArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeRedeemer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerFindFirstOrThrowArgs} args - Arguments to find a CodeRedeemer
     * @example
     * // Get one CodeRedeemer
     * const codeRedeemer = await prisma.codeRedeemer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodeRedeemerFindFirstOrThrowArgs>(args?: SelectSubset<T, CodeRedeemerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CodeRedeemers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeRedeemers
     * const codeRedeemers = await prisma.codeRedeemer.findMany()
     * 
     * // Get first 10 CodeRedeemers
     * const codeRedeemers = await prisma.codeRedeemer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeRedeemerWithIdOnly = await prisma.codeRedeemer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CodeRedeemerFindManyArgs>(args?: SelectSubset<T, CodeRedeemerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CodeRedeemer.
     * @param {CodeRedeemerCreateArgs} args - Arguments to create a CodeRedeemer.
     * @example
     * // Create one CodeRedeemer
     * const CodeRedeemer = await prisma.codeRedeemer.create({
     *   data: {
     *     // ... data to create a CodeRedeemer
     *   }
     * })
     * 
     */
    create<T extends CodeRedeemerCreateArgs>(args: SelectSubset<T, CodeRedeemerCreateArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CodeRedeemers.
     * @param {CodeRedeemerCreateManyArgs} args - Arguments to create many CodeRedeemers.
     * @example
     * // Create many CodeRedeemers
     * const codeRedeemer = await prisma.codeRedeemer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodeRedeemerCreateManyArgs>(args?: SelectSubset<T, CodeRedeemerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CodeRedeemers and returns the data saved in the database.
     * @param {CodeRedeemerCreateManyAndReturnArgs} args - Arguments to create many CodeRedeemers.
     * @example
     * // Create many CodeRedeemers
     * const codeRedeemer = await prisma.codeRedeemer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CodeRedeemers and only return the `id`
     * const codeRedeemerWithIdOnly = await prisma.codeRedeemer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CodeRedeemerCreateManyAndReturnArgs>(args?: SelectSubset<T, CodeRedeemerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CodeRedeemer.
     * @param {CodeRedeemerDeleteArgs} args - Arguments to delete one CodeRedeemer.
     * @example
     * // Delete one CodeRedeemer
     * const CodeRedeemer = await prisma.codeRedeemer.delete({
     *   where: {
     *     // ... filter to delete one CodeRedeemer
     *   }
     * })
     * 
     */
    delete<T extends CodeRedeemerDeleteArgs>(args: SelectSubset<T, CodeRedeemerDeleteArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CodeRedeemer.
     * @param {CodeRedeemerUpdateArgs} args - Arguments to update one CodeRedeemer.
     * @example
     * // Update one CodeRedeemer
     * const codeRedeemer = await prisma.codeRedeemer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodeRedeemerUpdateArgs>(args: SelectSubset<T, CodeRedeemerUpdateArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CodeRedeemers.
     * @param {CodeRedeemerDeleteManyArgs} args - Arguments to filter CodeRedeemers to delete.
     * @example
     * // Delete a few CodeRedeemers
     * const { count } = await prisma.codeRedeemer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodeRedeemerDeleteManyArgs>(args?: SelectSubset<T, CodeRedeemerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeRedeemers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeRedeemers
     * const codeRedeemer = await prisma.codeRedeemer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodeRedeemerUpdateManyArgs>(args: SelectSubset<T, CodeRedeemerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeRedeemers and returns the data updated in the database.
     * @param {CodeRedeemerUpdateManyAndReturnArgs} args - Arguments to update many CodeRedeemers.
     * @example
     * // Update many CodeRedeemers
     * const codeRedeemer = await prisma.codeRedeemer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CodeRedeemers and only return the `id`
     * const codeRedeemerWithIdOnly = await prisma.codeRedeemer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CodeRedeemerUpdateManyAndReturnArgs>(args: SelectSubset<T, CodeRedeemerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CodeRedeemer.
     * @param {CodeRedeemerUpsertArgs} args - Arguments to update or create a CodeRedeemer.
     * @example
     * // Update or create a CodeRedeemer
     * const codeRedeemer = await prisma.codeRedeemer.upsert({
     *   create: {
     *     // ... data to create a CodeRedeemer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeRedeemer we want to update
     *   }
     * })
     */
    upsert<T extends CodeRedeemerUpsertArgs>(args: SelectSubset<T, CodeRedeemerUpsertArgs<ExtArgs>>): Prisma__CodeRedeemerClient<$Result.GetResult<Prisma.$CodeRedeemerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CodeRedeemers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerCountArgs} args - Arguments to filter CodeRedeemers to count.
     * @example
     * // Count the number of CodeRedeemers
     * const count = await prisma.codeRedeemer.count({
     *   where: {
     *     // ... the filter for the CodeRedeemers we want to count
     *   }
     * })
    **/
    count<T extends CodeRedeemerCountArgs>(
      args?: Subset<T, CodeRedeemerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeRedeemerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeRedeemer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeRedeemerAggregateArgs>(args: Subset<T, CodeRedeemerAggregateArgs>): Prisma.PrismaPromise<GetCodeRedeemerAggregateType<T>>

    /**
     * Group by CodeRedeemer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedeemerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeRedeemerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeRedeemerGroupByArgs['orderBy'] }
        : { orderBy?: CodeRedeemerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeRedeemerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeRedeemerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodeRedeemer model
   */
  readonly fields: CodeRedeemerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeRedeemer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodeRedeemerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    code<T extends RedeemCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RedeemCodeDefaultArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodeRedeemer model
   */
  interface CodeRedeemerFieldRefs {
    readonly id: FieldRef<"CodeRedeemer", 'String'>
    readonly banned: FieldRef<"CodeRedeemer", 'Boolean'>
    readonly userId: FieldRef<"CodeRedeemer", 'String'>
    readonly codeId: FieldRef<"CodeRedeemer", 'String'>
    readonly createdAt: FieldRef<"CodeRedeemer", 'DateTime'>
    readonly updatedAt: FieldRef<"CodeRedeemer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CodeRedeemer findUnique
   */
  export type CodeRedeemerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedeemer to fetch.
     */
    where: CodeRedeemerWhereUniqueInput
  }

  /**
   * CodeRedeemer findUniqueOrThrow
   */
  export type CodeRedeemerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedeemer to fetch.
     */
    where: CodeRedeemerWhereUniqueInput
  }

  /**
   * CodeRedeemer findFirst
   */
  export type CodeRedeemerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedeemer to fetch.
     */
    where?: CodeRedeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedeemers to fetch.
     */
    orderBy?: CodeRedeemerOrderByWithRelationInput | CodeRedeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeRedeemers.
     */
    cursor?: CodeRedeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedeemers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeRedeemers.
     */
    distinct?: CodeRedeemerScalarFieldEnum | CodeRedeemerScalarFieldEnum[]
  }

  /**
   * CodeRedeemer findFirstOrThrow
   */
  export type CodeRedeemerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedeemer to fetch.
     */
    where?: CodeRedeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedeemers to fetch.
     */
    orderBy?: CodeRedeemerOrderByWithRelationInput | CodeRedeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeRedeemers.
     */
    cursor?: CodeRedeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedeemers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeRedeemers.
     */
    distinct?: CodeRedeemerScalarFieldEnum | CodeRedeemerScalarFieldEnum[]
  }

  /**
   * CodeRedeemer findMany
   */
  export type CodeRedeemerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedeemers to fetch.
     */
    where?: CodeRedeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedeemers to fetch.
     */
    orderBy?: CodeRedeemerOrderByWithRelationInput | CodeRedeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeRedeemers.
     */
    cursor?: CodeRedeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedeemers.
     */
    skip?: number
    distinct?: CodeRedeemerScalarFieldEnum | CodeRedeemerScalarFieldEnum[]
  }

  /**
   * CodeRedeemer create
   */
  export type CodeRedeemerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * The data needed to create a CodeRedeemer.
     */
    data: XOR<CodeRedeemerCreateInput, CodeRedeemerUncheckedCreateInput>
  }

  /**
   * CodeRedeemer createMany
   */
  export type CodeRedeemerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodeRedeemers.
     */
    data: CodeRedeemerCreateManyInput | CodeRedeemerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodeRedeemer createManyAndReturn
   */
  export type CodeRedeemerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * The data used to create many CodeRedeemers.
     */
    data: CodeRedeemerCreateManyInput | CodeRedeemerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeRedeemer update
   */
  export type CodeRedeemerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * The data needed to update a CodeRedeemer.
     */
    data: XOR<CodeRedeemerUpdateInput, CodeRedeemerUncheckedUpdateInput>
    /**
     * Choose, which CodeRedeemer to update.
     */
    where: CodeRedeemerWhereUniqueInput
  }

  /**
   * CodeRedeemer updateMany
   */
  export type CodeRedeemerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodeRedeemers.
     */
    data: XOR<CodeRedeemerUpdateManyMutationInput, CodeRedeemerUncheckedUpdateManyInput>
    /**
     * Filter which CodeRedeemers to update
     */
    where?: CodeRedeemerWhereInput
    /**
     * Limit how many CodeRedeemers to update.
     */
    limit?: number
  }

  /**
   * CodeRedeemer updateManyAndReturn
   */
  export type CodeRedeemerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * The data used to update CodeRedeemers.
     */
    data: XOR<CodeRedeemerUpdateManyMutationInput, CodeRedeemerUncheckedUpdateManyInput>
    /**
     * Filter which CodeRedeemers to update
     */
    where?: CodeRedeemerWhereInput
    /**
     * Limit how many CodeRedeemers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeRedeemer upsert
   */
  export type CodeRedeemerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * The filter to search for the CodeRedeemer to update in case it exists.
     */
    where: CodeRedeemerWhereUniqueInput
    /**
     * In case the CodeRedeemer found by the `where` argument doesn't exist, create a new CodeRedeemer with this data.
     */
    create: XOR<CodeRedeemerCreateInput, CodeRedeemerUncheckedCreateInput>
    /**
     * In case the CodeRedeemer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeRedeemerUpdateInput, CodeRedeemerUncheckedUpdateInput>
  }

  /**
   * CodeRedeemer delete
   */
  export type CodeRedeemerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
    /**
     * Filter which CodeRedeemer to delete.
     */
    where: CodeRedeemerWhereUniqueInput
  }

  /**
   * CodeRedeemer deleteMany
   */
  export type CodeRedeemerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeRedeemers to delete
     */
    where?: CodeRedeemerWhereInput
    /**
     * Limit how many CodeRedeemers to delete.
     */
    limit?: number
  }

  /**
   * CodeRedeemer without action
   */
  export type CodeRedeemerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedeemer
     */
    select?: CodeRedeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedeemer
     */
    omit?: CodeRedeemerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedeemerInclude<ExtArgs> | null
  }


  /**
   * Model ChampionshipMatch
   */

  export type AggregateChampionshipMatch = {
    _count: ChampionshipMatchCountAggregateOutputType | null
    _avg: ChampionshipMatchAvgAggregateOutputType | null
    _sum: ChampionshipMatchSumAggregateOutputType | null
    _min: ChampionshipMatchMinAggregateOutputType | null
    _max: ChampionshipMatchMaxAggregateOutputType | null
  }

  export type ChampionshipMatchAvgAggregateOutputType = {
    max: number | null
    endTime: number | null
    currentMember: number | null
  }

  export type ChampionshipMatchSumAggregateOutputType = {
    max: number | null
    endTime: number | null
    currentMember: number | null
  }

  export type ChampionshipMatchMinAggregateOutputType = {
    id: string | null
    max: number | null
    zoneInGameId: string | null
    gameplayId: string | null
    botOwner: string | null
    mode: $Enums.MatchMode | null
    endTime: number | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    currentMember: number | null
  }

  export type ChampionshipMatchMaxAggregateOutputType = {
    id: string | null
    max: number | null
    zoneInGameId: string | null
    gameplayId: string | null
    botOwner: string | null
    mode: $Enums.MatchMode | null
    endTime: number | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    currentMember: number | null
  }

  export type ChampionshipMatchCountAggregateOutputType = {
    id: number
    max: number
    zoneInGameId: number
    gameplayId: number
    botOwner: number
    mode: number
    endTime: number
    startedAt: number
    endedAt: number
    expiredAt: number
    isStarted: number
    isEnded: number
    createdAt: number
    updatedAt: number
    currentMember: number
    _all: number
  }


  export type ChampionshipMatchAvgAggregateInputType = {
    max?: true
    endTime?: true
    currentMember?: true
  }

  export type ChampionshipMatchSumAggregateInputType = {
    max?: true
    endTime?: true
    currentMember?: true
  }

  export type ChampionshipMatchMinAggregateInputType = {
    id?: true
    max?: true
    zoneInGameId?: true
    gameplayId?: true
    botOwner?: true
    mode?: true
    endTime?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
  }

  export type ChampionshipMatchMaxAggregateInputType = {
    id?: true
    max?: true
    zoneInGameId?: true
    gameplayId?: true
    botOwner?: true
    mode?: true
    endTime?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
  }

  export type ChampionshipMatchCountAggregateInputType = {
    id?: true
    max?: true
    zoneInGameId?: true
    gameplayId?: true
    botOwner?: true
    mode?: true
    endTime?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
    _all?: true
  }

  export type ChampionshipMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipMatch to aggregate.
     */
    where?: ChampionshipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipMatches to fetch.
     */
    orderBy?: ChampionshipMatchOrderByWithRelationInput | ChampionshipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChampionshipMatches
    **/
    _count?: true | ChampionshipMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChampionshipMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChampionshipMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipMatchMaxAggregateInputType
  }

  export type GetChampionshipMatchAggregateType<T extends ChampionshipMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionshipMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionshipMatch[P]>
      : GetScalarType<T[P], AggregateChampionshipMatch[P]>
  }




  export type ChampionshipMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipMatchWhereInput
    orderBy?: ChampionshipMatchOrderByWithAggregationInput | ChampionshipMatchOrderByWithAggregationInput[]
    by: ChampionshipMatchScalarFieldEnum[] | ChampionshipMatchScalarFieldEnum
    having?: ChampionshipMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipMatchCountAggregateInputType | true
    _avg?: ChampionshipMatchAvgAggregateInputType
    _sum?: ChampionshipMatchSumAggregateInputType
    _min?: ChampionshipMatchMinAggregateInputType
    _max?: ChampionshipMatchMaxAggregateInputType
  }

  export type ChampionshipMatchGroupByOutputType = {
    id: string
    max: number
    zoneInGameId: string
    gameplayId: string
    botOwner: string | null
    mode: $Enums.MatchMode
    endTime: number
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean
    isEnded: boolean
    createdAt: Date
    updatedAt: Date
    currentMember: number
    _count: ChampionshipMatchCountAggregateOutputType | null
    _avg: ChampionshipMatchAvgAggregateOutputType | null
    _sum: ChampionshipMatchSumAggregateOutputType | null
    _min: ChampionshipMatchMinAggregateOutputType | null
    _max: ChampionshipMatchMaxAggregateOutputType | null
  }

  type GetChampionshipMatchGroupByPayload<T extends ChampionshipMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipMatchGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipMatchGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
    members?: boolean | ChampionshipMatch$membersArgs<ExtArgs>
    _count?: boolean | ChampionshipMatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipMatch"]>

  export type ChampionshipMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }, ExtArgs["result"]["championshipMatch"]>

  export type ChampionshipMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }, ExtArgs["result"]["championshipMatch"]>

  export type ChampionshipMatchSelectScalar = {
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }

  export type ChampionshipMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "max" | "zoneInGameId" | "gameplayId" | "botOwner" | "mode" | "endTime" | "startedAt" | "endedAt" | "expiredAt" | "isStarted" | "isEnded" | "createdAt" | "updatedAt" | "currentMember", ExtArgs["result"]["championshipMatch"]>
  export type ChampionshipMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChampionshipMatch$membersArgs<ExtArgs>
    _count?: boolean | ChampionshipMatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChampionshipMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChampionshipMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChampionshipMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChampionshipMatch"
    objects: {
      members: Prisma.$MatchMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      zoneInGameId: string
      gameplayId: string
      botOwner: string | null
      mode: $Enums.MatchMode
      endTime: number
      startedAt: Date | null
      endedAt: Date | null
      expiredAt: Date | null
      isStarted: boolean
      isEnded: boolean
      createdAt: Date
      updatedAt: Date
      currentMember: number
    }, ExtArgs["result"]["championshipMatch"]>
    composites: {}
  }

  type ChampionshipMatchGetPayload<S extends boolean | null | undefined | ChampionshipMatchDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipMatchPayload, S>

  type ChampionshipMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipMatchCountAggregateInputType | true
    }

  export interface ChampionshipMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChampionshipMatch'], meta: { name: 'ChampionshipMatch' } }
    /**
     * Find zero or one ChampionshipMatch that matches the filter.
     * @param {ChampionshipMatchFindUniqueArgs} args - Arguments to find a ChampionshipMatch
     * @example
     * // Get one ChampionshipMatch
     * const championshipMatch = await prisma.championshipMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipMatchFindUniqueArgs>(args: SelectSubset<T, ChampionshipMatchFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChampionshipMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipMatchFindUniqueOrThrowArgs} args - Arguments to find a ChampionshipMatch
     * @example
     * // Get one ChampionshipMatch
     * const championshipMatch = await prisma.championshipMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchFindFirstArgs} args - Arguments to find a ChampionshipMatch
     * @example
     * // Get one ChampionshipMatch
     * const championshipMatch = await prisma.championshipMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipMatchFindFirstArgs>(args?: SelectSubset<T, ChampionshipMatchFindFirstArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchFindFirstOrThrowArgs} args - Arguments to find a ChampionshipMatch
     * @example
     * // Get one ChampionshipMatch
     * const championshipMatch = await prisma.championshipMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChampionshipMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChampionshipMatches
     * const championshipMatches = await prisma.championshipMatch.findMany()
     * 
     * // Get first 10 ChampionshipMatches
     * const championshipMatches = await prisma.championshipMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipMatchWithIdOnly = await prisma.championshipMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipMatchFindManyArgs>(args?: SelectSubset<T, ChampionshipMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChampionshipMatch.
     * @param {ChampionshipMatchCreateArgs} args - Arguments to create a ChampionshipMatch.
     * @example
     * // Create one ChampionshipMatch
     * const ChampionshipMatch = await prisma.championshipMatch.create({
     *   data: {
     *     // ... data to create a ChampionshipMatch
     *   }
     * })
     * 
     */
    create<T extends ChampionshipMatchCreateArgs>(args: SelectSubset<T, ChampionshipMatchCreateArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChampionshipMatches.
     * @param {ChampionshipMatchCreateManyArgs} args - Arguments to create many ChampionshipMatches.
     * @example
     * // Create many ChampionshipMatches
     * const championshipMatch = await prisma.championshipMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipMatchCreateManyArgs>(args?: SelectSubset<T, ChampionshipMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChampionshipMatches and returns the data saved in the database.
     * @param {ChampionshipMatchCreateManyAndReturnArgs} args - Arguments to create many ChampionshipMatches.
     * @example
     * // Create many ChampionshipMatches
     * const championshipMatch = await prisma.championshipMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChampionshipMatches and only return the `id`
     * const championshipMatchWithIdOnly = await prisma.championshipMatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChampionshipMatch.
     * @param {ChampionshipMatchDeleteArgs} args - Arguments to delete one ChampionshipMatch.
     * @example
     * // Delete one ChampionshipMatch
     * const ChampionshipMatch = await prisma.championshipMatch.delete({
     *   where: {
     *     // ... filter to delete one ChampionshipMatch
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipMatchDeleteArgs>(args: SelectSubset<T, ChampionshipMatchDeleteArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChampionshipMatch.
     * @param {ChampionshipMatchUpdateArgs} args - Arguments to update one ChampionshipMatch.
     * @example
     * // Update one ChampionshipMatch
     * const championshipMatch = await prisma.championshipMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipMatchUpdateArgs>(args: SelectSubset<T, ChampionshipMatchUpdateArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChampionshipMatches.
     * @param {ChampionshipMatchDeleteManyArgs} args - Arguments to filter ChampionshipMatches to delete.
     * @example
     * // Delete a few ChampionshipMatches
     * const { count } = await prisma.championshipMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipMatchDeleteManyArgs>(args?: SelectSubset<T, ChampionshipMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChampionshipMatches
     * const championshipMatch = await prisma.championshipMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipMatchUpdateManyArgs>(args: SelectSubset<T, ChampionshipMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipMatches and returns the data updated in the database.
     * @param {ChampionshipMatchUpdateManyAndReturnArgs} args - Arguments to update many ChampionshipMatches.
     * @example
     * // Update many ChampionshipMatches
     * const championshipMatch = await prisma.championshipMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChampionshipMatches and only return the `id`
     * const championshipMatchWithIdOnly = await prisma.championshipMatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChampionshipMatch.
     * @param {ChampionshipMatchUpsertArgs} args - Arguments to update or create a ChampionshipMatch.
     * @example
     * // Update or create a ChampionshipMatch
     * const championshipMatch = await prisma.championshipMatch.upsert({
     *   create: {
     *     // ... data to create a ChampionshipMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChampionshipMatch we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipMatchUpsertArgs>(args: SelectSubset<T, ChampionshipMatchUpsertArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChampionshipMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchCountArgs} args - Arguments to filter ChampionshipMatches to count.
     * @example
     * // Count the number of ChampionshipMatches
     * const count = await prisma.championshipMatch.count({
     *   where: {
     *     // ... the filter for the ChampionshipMatches we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipMatchCountArgs>(
      args?: Subset<T, ChampionshipMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChampionshipMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipMatchAggregateArgs>(args: Subset<T, ChampionshipMatchAggregateArgs>): Prisma.PrismaPromise<GetChampionshipMatchAggregateType<T>>

    /**
     * Group by ChampionshipMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipMatchGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChampionshipMatch model
   */
  readonly fields: ChampionshipMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChampionshipMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends ChampionshipMatch$membersArgs<ExtArgs> = {}>(args?: Subset<T, ChampionshipMatch$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChampionshipMatch model
   */
  interface ChampionshipMatchFieldRefs {
    readonly id: FieldRef<"ChampionshipMatch", 'String'>
    readonly max: FieldRef<"ChampionshipMatch", 'Int'>
    readonly zoneInGameId: FieldRef<"ChampionshipMatch", 'String'>
    readonly gameplayId: FieldRef<"ChampionshipMatch", 'String'>
    readonly botOwner: FieldRef<"ChampionshipMatch", 'String'>
    readonly mode: FieldRef<"ChampionshipMatch", 'MatchMode'>
    readonly endTime: FieldRef<"ChampionshipMatch", 'Int'>
    readonly startedAt: FieldRef<"ChampionshipMatch", 'DateTime'>
    readonly endedAt: FieldRef<"ChampionshipMatch", 'DateTime'>
    readonly expiredAt: FieldRef<"ChampionshipMatch", 'DateTime'>
    readonly isStarted: FieldRef<"ChampionshipMatch", 'Boolean'>
    readonly isEnded: FieldRef<"ChampionshipMatch", 'Boolean'>
    readonly createdAt: FieldRef<"ChampionshipMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"ChampionshipMatch", 'DateTime'>
    readonly currentMember: FieldRef<"ChampionshipMatch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChampionshipMatch findUnique
   */
  export type ChampionshipMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipMatch to fetch.
     */
    where: ChampionshipMatchWhereUniqueInput
  }

  /**
   * ChampionshipMatch findUniqueOrThrow
   */
  export type ChampionshipMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipMatch to fetch.
     */
    where: ChampionshipMatchWhereUniqueInput
  }

  /**
   * ChampionshipMatch findFirst
   */
  export type ChampionshipMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipMatch to fetch.
     */
    where?: ChampionshipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipMatches to fetch.
     */
    orderBy?: ChampionshipMatchOrderByWithRelationInput | ChampionshipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipMatches.
     */
    cursor?: ChampionshipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipMatches.
     */
    distinct?: ChampionshipMatchScalarFieldEnum | ChampionshipMatchScalarFieldEnum[]
  }

  /**
   * ChampionshipMatch findFirstOrThrow
   */
  export type ChampionshipMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipMatch to fetch.
     */
    where?: ChampionshipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipMatches to fetch.
     */
    orderBy?: ChampionshipMatchOrderByWithRelationInput | ChampionshipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipMatches.
     */
    cursor?: ChampionshipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipMatches.
     */
    distinct?: ChampionshipMatchScalarFieldEnum | ChampionshipMatchScalarFieldEnum[]
  }

  /**
   * ChampionshipMatch findMany
   */
  export type ChampionshipMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipMatches to fetch.
     */
    where?: ChampionshipMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipMatches to fetch.
     */
    orderBy?: ChampionshipMatchOrderByWithRelationInput | ChampionshipMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChampionshipMatches.
     */
    cursor?: ChampionshipMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipMatches.
     */
    skip?: number
    distinct?: ChampionshipMatchScalarFieldEnum | ChampionshipMatchScalarFieldEnum[]
  }

  /**
   * ChampionshipMatch create
   */
  export type ChampionshipMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ChampionshipMatch.
     */
    data: XOR<ChampionshipMatchCreateInput, ChampionshipMatchUncheckedCreateInput>
  }

  /**
   * ChampionshipMatch createMany
   */
  export type ChampionshipMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChampionshipMatches.
     */
    data: ChampionshipMatchCreateManyInput | ChampionshipMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipMatch createManyAndReturn
   */
  export type ChampionshipMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * The data used to create many ChampionshipMatches.
     */
    data: ChampionshipMatchCreateManyInput | ChampionshipMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipMatch update
   */
  export type ChampionshipMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ChampionshipMatch.
     */
    data: XOR<ChampionshipMatchUpdateInput, ChampionshipMatchUncheckedUpdateInput>
    /**
     * Choose, which ChampionshipMatch to update.
     */
    where: ChampionshipMatchWhereUniqueInput
  }

  /**
   * ChampionshipMatch updateMany
   */
  export type ChampionshipMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChampionshipMatches.
     */
    data: XOR<ChampionshipMatchUpdateManyMutationInput, ChampionshipMatchUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipMatches to update
     */
    where?: ChampionshipMatchWhereInput
    /**
     * Limit how many ChampionshipMatches to update.
     */
    limit?: number
  }

  /**
   * ChampionshipMatch updateManyAndReturn
   */
  export type ChampionshipMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * The data used to update ChampionshipMatches.
     */
    data: XOR<ChampionshipMatchUpdateManyMutationInput, ChampionshipMatchUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipMatches to update
     */
    where?: ChampionshipMatchWhereInput
    /**
     * Limit how many ChampionshipMatches to update.
     */
    limit?: number
  }

  /**
   * ChampionshipMatch upsert
   */
  export type ChampionshipMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ChampionshipMatch to update in case it exists.
     */
    where: ChampionshipMatchWhereUniqueInput
    /**
     * In case the ChampionshipMatch found by the `where` argument doesn't exist, create a new ChampionshipMatch with this data.
     */
    create: XOR<ChampionshipMatchCreateInput, ChampionshipMatchUncheckedCreateInput>
    /**
     * In case the ChampionshipMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipMatchUpdateInput, ChampionshipMatchUncheckedUpdateInput>
  }

  /**
   * ChampionshipMatch delete
   */
  export type ChampionshipMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
    /**
     * Filter which ChampionshipMatch to delete.
     */
    where: ChampionshipMatchWhereUniqueInput
  }

  /**
   * ChampionshipMatch deleteMany
   */
  export type ChampionshipMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipMatches to delete
     */
    where?: ChampionshipMatchWhereInput
    /**
     * Limit how many ChampionshipMatches to delete.
     */
    limit?: number
  }

  /**
   * ChampionshipMatch.members
   */
  export type ChampionshipMatch$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    where?: MatchMemberWhereInput
    orderBy?: MatchMemberOrderByWithRelationInput | MatchMemberOrderByWithRelationInput[]
    cursor?: MatchMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchMemberScalarFieldEnum | MatchMemberScalarFieldEnum[]
  }

  /**
   * ChampionshipMatch without action
   */
  export type ChampionshipMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipMatch
     */
    select?: ChampionshipMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipMatch
     */
    omit?: ChampionshipMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipMatchInclude<ExtArgs> | null
  }


  /**
   * Model MatchMember
   */

  export type AggregateMatchMember = {
    _count: MatchMemberCountAggregateOutputType | null
    _avg: MatchMemberAvgAggregateOutputType | null
    _sum: MatchMemberSumAggregateOutputType | null
    _min: MatchMemberMinAggregateOutputType | null
    _max: MatchMemberMaxAggregateOutputType | null
  }

  export type MatchMemberAvgAggregateOutputType = {
    slot: number | null
    answerPoint: number | null
    point: number | null
    bonusPoint: number | null
  }

  export type MatchMemberSumAggregateOutputType = {
    slot: number | null
    answerPoint: number | null
    point: number | null
    bonusPoint: number | null
  }

  export type MatchMemberMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    slot: number | null
    status: $Enums.MatchStatus | null
    answerPoint: number | null
    point: number | null
    bonusPoint: number | null
    teamType: $Enums.TeamType | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MatchMemberMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    slot: number | null
    status: $Enums.MatchStatus | null
    answerPoint: number | null
    point: number | null
    bonusPoint: number | null
    teamType: $Enums.TeamType | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MatchMemberCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    slot: number
    status: number
    answerPoint: number
    point: number
    bonusPoint: number
    teamType: number
    isReady: number
    isComplete: number
    isBot: number
    joinedAt: number
    finishedAt: number
    isDisconnect: number
    _all: number
  }


  export type MatchMemberAvgAggregateInputType = {
    slot?: true
    answerPoint?: true
    point?: true
    bonusPoint?: true
  }

  export type MatchMemberSumAggregateInputType = {
    slot?: true
    answerPoint?: true
    point?: true
    bonusPoint?: true
  }

  export type MatchMemberMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    slot?: true
    status?: true
    answerPoint?: true
    point?: true
    bonusPoint?: true
    teamType?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MatchMemberMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    slot?: true
    status?: true
    answerPoint?: true
    point?: true
    bonusPoint?: true
    teamType?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MatchMemberCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    slot?: true
    status?: true
    answerPoint?: true
    point?: true
    bonusPoint?: true
    teamType?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
    _all?: true
  }

  export type MatchMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchMember to aggregate.
     */
    where?: MatchMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMembers to fetch.
     */
    orderBy?: MatchMemberOrderByWithRelationInput | MatchMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchMembers
    **/
    _count?: true | MatchMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMemberMaxAggregateInputType
  }

  export type GetMatchMemberAggregateType<T extends MatchMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchMember[P]>
      : GetScalarType<T[P], AggregateMatchMember[P]>
  }




  export type MatchMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMemberWhereInput
    orderBy?: MatchMemberOrderByWithAggregationInput | MatchMemberOrderByWithAggregationInput[]
    by: MatchMemberScalarFieldEnum[] | MatchMemberScalarFieldEnum
    having?: MatchMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchMemberCountAggregateInputType | true
    _avg?: MatchMemberAvgAggregateInputType
    _sum?: MatchMemberSumAggregateInputType
    _min?: MatchMemberMinAggregateInputType
    _max?: MatchMemberMaxAggregateInputType
  }

  export type MatchMemberGroupByOutputType = {
    id: string
    roomId: string
    userId: string
    slot: number
    status: $Enums.MatchStatus
    answerPoint: number
    point: number
    bonusPoint: number
    teamType: $Enums.TeamType
    isReady: boolean
    isComplete: boolean
    isBot: boolean
    joinedAt: Date
    finishedAt: Date | null
    isDisconnect: boolean
    _count: MatchMemberCountAggregateOutputType | null
    _avg: MatchMemberAvgAggregateOutputType | null
    _sum: MatchMemberSumAggregateOutputType | null
    _min: MatchMemberMinAggregateOutputType | null
    _max: MatchMemberMaxAggregateOutputType | null
  }

  type GetMatchMemberGroupByPayload<T extends MatchMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchMemberGroupByOutputType[P]>
            : GetScalarType<T[P], MatchMemberGroupByOutputType[P]>
        }
      >
    >


  export type MatchMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    answerPoint?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    room?: boolean | ChampionshipMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchMember"]>

  export type MatchMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    answerPoint?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    room?: boolean | ChampionshipMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchMember"]>

  export type MatchMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    answerPoint?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    room?: boolean | ChampionshipMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchMember"]>

  export type MatchMemberSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    answerPoint?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
  }

  export type MatchMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "slot" | "status" | "answerPoint" | "point" | "bonusPoint" | "teamType" | "isReady" | "isComplete" | "isBot" | "joinedAt" | "finishedAt" | "isDisconnect", ExtArgs["result"]["matchMember"]>
  export type MatchMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChampionshipMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChampionshipMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChampionshipMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchMember"
    objects: {
      room: Prisma.$ChampionshipMatchPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string
      slot: number
      status: $Enums.MatchStatus
      answerPoint: number
      point: number
      bonusPoint: number
      teamType: $Enums.TeamType
      isReady: boolean
      isComplete: boolean
      isBot: boolean
      joinedAt: Date
      finishedAt: Date | null
      isDisconnect: boolean
    }, ExtArgs["result"]["matchMember"]>
    composites: {}
  }

  type MatchMemberGetPayload<S extends boolean | null | undefined | MatchMemberDefaultArgs> = $Result.GetResult<Prisma.$MatchMemberPayload, S>

  type MatchMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchMemberCountAggregateInputType | true
    }

  export interface MatchMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchMember'], meta: { name: 'MatchMember' } }
    /**
     * Find zero or one MatchMember that matches the filter.
     * @param {MatchMemberFindUniqueArgs} args - Arguments to find a MatchMember
     * @example
     * // Get one MatchMember
     * const matchMember = await prisma.matchMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchMemberFindUniqueArgs>(args: SelectSubset<T, MatchMemberFindUniqueArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchMemberFindUniqueOrThrowArgs} args - Arguments to find a MatchMember
     * @example
     * // Get one MatchMember
     * const matchMember = await prisma.matchMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberFindFirstArgs} args - Arguments to find a MatchMember
     * @example
     * // Get one MatchMember
     * const matchMember = await prisma.matchMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchMemberFindFirstArgs>(args?: SelectSubset<T, MatchMemberFindFirstArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberFindFirstOrThrowArgs} args - Arguments to find a MatchMember
     * @example
     * // Get one MatchMember
     * const matchMember = await prisma.matchMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchMembers
     * const matchMembers = await prisma.matchMember.findMany()
     * 
     * // Get first 10 MatchMembers
     * const matchMembers = await prisma.matchMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchMemberWithIdOnly = await prisma.matchMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchMemberFindManyArgs>(args?: SelectSubset<T, MatchMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchMember.
     * @param {MatchMemberCreateArgs} args - Arguments to create a MatchMember.
     * @example
     * // Create one MatchMember
     * const MatchMember = await prisma.matchMember.create({
     *   data: {
     *     // ... data to create a MatchMember
     *   }
     * })
     * 
     */
    create<T extends MatchMemberCreateArgs>(args: SelectSubset<T, MatchMemberCreateArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchMembers.
     * @param {MatchMemberCreateManyArgs} args - Arguments to create many MatchMembers.
     * @example
     * // Create many MatchMembers
     * const matchMember = await prisma.matchMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchMemberCreateManyArgs>(args?: SelectSubset<T, MatchMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchMembers and returns the data saved in the database.
     * @param {MatchMemberCreateManyAndReturnArgs} args - Arguments to create many MatchMembers.
     * @example
     * // Create many MatchMembers
     * const matchMember = await prisma.matchMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchMembers and only return the `id`
     * const matchMemberWithIdOnly = await prisma.matchMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchMember.
     * @param {MatchMemberDeleteArgs} args - Arguments to delete one MatchMember.
     * @example
     * // Delete one MatchMember
     * const MatchMember = await prisma.matchMember.delete({
     *   where: {
     *     // ... filter to delete one MatchMember
     *   }
     * })
     * 
     */
    delete<T extends MatchMemberDeleteArgs>(args: SelectSubset<T, MatchMemberDeleteArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchMember.
     * @param {MatchMemberUpdateArgs} args - Arguments to update one MatchMember.
     * @example
     * // Update one MatchMember
     * const matchMember = await prisma.matchMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchMemberUpdateArgs>(args: SelectSubset<T, MatchMemberUpdateArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchMembers.
     * @param {MatchMemberDeleteManyArgs} args - Arguments to filter MatchMembers to delete.
     * @example
     * // Delete a few MatchMembers
     * const { count } = await prisma.matchMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchMemberDeleteManyArgs>(args?: SelectSubset<T, MatchMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchMembers
     * const matchMember = await prisma.matchMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchMemberUpdateManyArgs>(args: SelectSubset<T, MatchMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchMembers and returns the data updated in the database.
     * @param {MatchMemberUpdateManyAndReturnArgs} args - Arguments to update many MatchMembers.
     * @example
     * // Update many MatchMembers
     * const matchMember = await prisma.matchMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchMembers and only return the `id`
     * const matchMemberWithIdOnly = await prisma.matchMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchMember.
     * @param {MatchMemberUpsertArgs} args - Arguments to update or create a MatchMember.
     * @example
     * // Update or create a MatchMember
     * const matchMember = await prisma.matchMember.upsert({
     *   create: {
     *     // ... data to create a MatchMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchMember we want to update
     *   }
     * })
     */
    upsert<T extends MatchMemberUpsertArgs>(args: SelectSubset<T, MatchMemberUpsertArgs<ExtArgs>>): Prisma__MatchMemberClient<$Result.GetResult<Prisma.$MatchMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberCountArgs} args - Arguments to filter MatchMembers to count.
     * @example
     * // Count the number of MatchMembers
     * const count = await prisma.matchMember.count({
     *   where: {
     *     // ... the filter for the MatchMembers we want to count
     *   }
     * })
    **/
    count<T extends MatchMemberCountArgs>(
      args?: Subset<T, MatchMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchMemberAggregateArgs>(args: Subset<T, MatchMemberAggregateArgs>): Prisma.PrismaPromise<GetMatchMemberAggregateType<T>>

    /**
     * Group by MatchMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchMemberGroupByArgs['orderBy'] }
        : { orderBy?: MatchMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchMember model
   */
  readonly fields: MatchMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends ChampionshipMatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChampionshipMatchDefaultArgs<ExtArgs>>): Prisma__ChampionshipMatchClient<$Result.GetResult<Prisma.$ChampionshipMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchMember model
   */
  interface MatchMemberFieldRefs {
    readonly id: FieldRef<"MatchMember", 'String'>
    readonly roomId: FieldRef<"MatchMember", 'String'>
    readonly userId: FieldRef<"MatchMember", 'String'>
    readonly slot: FieldRef<"MatchMember", 'Int'>
    readonly status: FieldRef<"MatchMember", 'MatchStatus'>
    readonly answerPoint: FieldRef<"MatchMember", 'Int'>
    readonly point: FieldRef<"MatchMember", 'Int'>
    readonly bonusPoint: FieldRef<"MatchMember", 'Int'>
    readonly teamType: FieldRef<"MatchMember", 'TeamType'>
    readonly isReady: FieldRef<"MatchMember", 'Boolean'>
    readonly isComplete: FieldRef<"MatchMember", 'Boolean'>
    readonly isBot: FieldRef<"MatchMember", 'Boolean'>
    readonly joinedAt: FieldRef<"MatchMember", 'DateTime'>
    readonly finishedAt: FieldRef<"MatchMember", 'DateTime'>
    readonly isDisconnect: FieldRef<"MatchMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MatchMember findUnique
   */
  export type MatchMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchMember to fetch.
     */
    where: MatchMemberWhereUniqueInput
  }

  /**
   * MatchMember findUniqueOrThrow
   */
  export type MatchMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchMember to fetch.
     */
    where: MatchMemberWhereUniqueInput
  }

  /**
   * MatchMember findFirst
   */
  export type MatchMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchMember to fetch.
     */
    where?: MatchMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMembers to fetch.
     */
    orderBy?: MatchMemberOrderByWithRelationInput | MatchMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchMembers.
     */
    cursor?: MatchMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchMembers.
     */
    distinct?: MatchMemberScalarFieldEnum | MatchMemberScalarFieldEnum[]
  }

  /**
   * MatchMember findFirstOrThrow
   */
  export type MatchMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchMember to fetch.
     */
    where?: MatchMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMembers to fetch.
     */
    orderBy?: MatchMemberOrderByWithRelationInput | MatchMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchMembers.
     */
    cursor?: MatchMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchMembers.
     */
    distinct?: MatchMemberScalarFieldEnum | MatchMemberScalarFieldEnum[]
  }

  /**
   * MatchMember findMany
   */
  export type MatchMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchMembers to fetch.
     */
    where?: MatchMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMembers to fetch.
     */
    orderBy?: MatchMemberOrderByWithRelationInput | MatchMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchMembers.
     */
    cursor?: MatchMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMembers.
     */
    skip?: number
    distinct?: MatchMemberScalarFieldEnum | MatchMemberScalarFieldEnum[]
  }

  /**
   * MatchMember create
   */
  export type MatchMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchMember.
     */
    data: XOR<MatchMemberCreateInput, MatchMemberUncheckedCreateInput>
  }

  /**
   * MatchMember createMany
   */
  export type MatchMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchMembers.
     */
    data: MatchMemberCreateManyInput | MatchMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchMember createManyAndReturn
   */
  export type MatchMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * The data used to create many MatchMembers.
     */
    data: MatchMemberCreateManyInput | MatchMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchMember update
   */
  export type MatchMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchMember.
     */
    data: XOR<MatchMemberUpdateInput, MatchMemberUncheckedUpdateInput>
    /**
     * Choose, which MatchMember to update.
     */
    where: MatchMemberWhereUniqueInput
  }

  /**
   * MatchMember updateMany
   */
  export type MatchMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchMembers.
     */
    data: XOR<MatchMemberUpdateManyMutationInput, MatchMemberUncheckedUpdateManyInput>
    /**
     * Filter which MatchMembers to update
     */
    where?: MatchMemberWhereInput
    /**
     * Limit how many MatchMembers to update.
     */
    limit?: number
  }

  /**
   * MatchMember updateManyAndReturn
   */
  export type MatchMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * The data used to update MatchMembers.
     */
    data: XOR<MatchMemberUpdateManyMutationInput, MatchMemberUncheckedUpdateManyInput>
    /**
     * Filter which MatchMembers to update
     */
    where?: MatchMemberWhereInput
    /**
     * Limit how many MatchMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchMember upsert
   */
  export type MatchMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchMember to update in case it exists.
     */
    where: MatchMemberWhereUniqueInput
    /**
     * In case the MatchMember found by the `where` argument doesn't exist, create a new MatchMember with this data.
     */
    create: XOR<MatchMemberCreateInput, MatchMemberUncheckedCreateInput>
    /**
     * In case the MatchMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchMemberUpdateInput, MatchMemberUncheckedUpdateInput>
  }

  /**
   * MatchMember delete
   */
  export type MatchMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
    /**
     * Filter which MatchMember to delete.
     */
    where: MatchMemberWhereUniqueInput
  }

  /**
   * MatchMember deleteMany
   */
  export type MatchMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchMembers to delete
     */
    where?: MatchMemberWhereInput
    /**
     * Limit how many MatchMembers to delete.
     */
    limit?: number
  }

  /**
   * MatchMember without action
   */
  export type MatchMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMember
     */
    select?: MatchMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchMember
     */
    omit?: MatchMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMemberInclude<ExtArgs> | null
  }


  /**
   * Model ChampionshipHistory
   */

  export type AggregateChampionshipHistory = {
    _count: ChampionshipHistoryCountAggregateOutputType | null
    _avg: ChampionshipHistoryAvgAggregateOutputType | null
    _sum: ChampionshipHistorySumAggregateOutputType | null
    _min: ChampionshipHistoryMinAggregateOutputType | null
    _max: ChampionshipHistoryMaxAggregateOutputType | null
  }

  export type ChampionshipHistoryAvgAggregateOutputType = {
    max: number | null
    currentPoint: number | null
    endTime: number | null
    currentMember: number | null
  }

  export type ChampionshipHistorySumAggregateOutputType = {
    max: number | null
    currentPoint: number[]
    endTime: number | null
    currentMember: number | null
  }

  export type ChampionshipHistoryMinAggregateOutputType = {
    id: string | null
    max: number | null
    zoneInGameId: string | null
    gameplayId: string | null
    botOwner: string | null
    mode: $Enums.MatchMode | null
    endTime: number | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    currentMember: number | null
  }

  export type ChampionshipHistoryMaxAggregateOutputType = {
    id: string | null
    max: number | null
    zoneInGameId: string | null
    gameplayId: string | null
    botOwner: string | null
    mode: $Enums.MatchMode | null
    endTime: number | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    currentMember: number | null
  }

  export type ChampionshipHistoryCountAggregateOutputType = {
    id: number
    max: number
    zoneInGameId: number
    gameplayId: number
    botOwner: number
    currentPoint: number
    mode: number
    endTime: number
    startedAt: number
    endedAt: number
    expiredAt: number
    isStarted: number
    isEnded: number
    createdAt: number
    updatedAt: number
    currentMember: number
    _all: number
  }


  export type ChampionshipHistoryAvgAggregateInputType = {
    max?: true
    currentPoint?: true
    endTime?: true
    currentMember?: true
  }

  export type ChampionshipHistorySumAggregateInputType = {
    max?: true
    currentPoint?: true
    endTime?: true
    currentMember?: true
  }

  export type ChampionshipHistoryMinAggregateInputType = {
    id?: true
    max?: true
    zoneInGameId?: true
    gameplayId?: true
    botOwner?: true
    mode?: true
    endTime?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
  }

  export type ChampionshipHistoryMaxAggregateInputType = {
    id?: true
    max?: true
    zoneInGameId?: true
    gameplayId?: true
    botOwner?: true
    mode?: true
    endTime?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
  }

  export type ChampionshipHistoryCountAggregateInputType = {
    id?: true
    max?: true
    zoneInGameId?: true
    gameplayId?: true
    botOwner?: true
    currentPoint?: true
    mode?: true
    endTime?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
    _all?: true
  }

  export type ChampionshipHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipHistory to aggregate.
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipHistories to fetch.
     */
    orderBy?: ChampionshipHistoryOrderByWithRelationInput | ChampionshipHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChampionshipHistories
    **/
    _count?: true | ChampionshipHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChampionshipHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChampionshipHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipHistoryMaxAggregateInputType
  }

  export type GetChampionshipHistoryAggregateType<T extends ChampionshipHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionshipHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionshipHistory[P]>
      : GetScalarType<T[P], AggregateChampionshipHistory[P]>
  }




  export type ChampionshipHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipHistoryWhereInput
    orderBy?: ChampionshipHistoryOrderByWithAggregationInput | ChampionshipHistoryOrderByWithAggregationInput[]
    by: ChampionshipHistoryScalarFieldEnum[] | ChampionshipHistoryScalarFieldEnum
    having?: ChampionshipHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipHistoryCountAggregateInputType | true
    _avg?: ChampionshipHistoryAvgAggregateInputType
    _sum?: ChampionshipHistorySumAggregateInputType
    _min?: ChampionshipHistoryMinAggregateInputType
    _max?: ChampionshipHistoryMaxAggregateInputType
  }

  export type ChampionshipHistoryGroupByOutputType = {
    id: string
    max: number
    zoneInGameId: string
    gameplayId: string
    botOwner: string | null
    currentPoint: number[]
    mode: $Enums.MatchMode
    endTime: number
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean
    isEnded: boolean
    createdAt: Date
    updatedAt: Date
    currentMember: number
    _count: ChampionshipHistoryCountAggregateOutputType | null
    _avg: ChampionshipHistoryAvgAggregateOutputType | null
    _sum: ChampionshipHistorySumAggregateOutputType | null
    _min: ChampionshipHistoryMinAggregateOutputType | null
    _max: ChampionshipHistoryMaxAggregateOutputType | null
  }

  type GetChampionshipHistoryGroupByPayload<T extends ChampionshipHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    currentPoint?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
    members?: boolean | ChampionshipHistory$membersArgs<ExtArgs>
    _count?: boolean | ChampionshipHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipHistory"]>

  export type ChampionshipHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    currentPoint?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }, ExtArgs["result"]["championshipHistory"]>

  export type ChampionshipHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    currentPoint?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }, ExtArgs["result"]["championshipHistory"]>

  export type ChampionshipHistorySelectScalar = {
    id?: boolean
    max?: boolean
    zoneInGameId?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    currentPoint?: boolean
    mode?: boolean
    endTime?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }

  export type ChampionshipHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "max" | "zoneInGameId" | "gameplayId" | "botOwner" | "currentPoint" | "mode" | "endTime" | "startedAt" | "endedAt" | "expiredAt" | "isStarted" | "isEnded" | "createdAt" | "updatedAt" | "currentMember", ExtArgs["result"]["championshipHistory"]>
  export type ChampionshipHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChampionshipHistory$membersArgs<ExtArgs>
    _count?: boolean | ChampionshipHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChampionshipHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChampionshipHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChampionshipHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChampionshipHistory"
    objects: {
      members: Prisma.$MatchHistoryMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      zoneInGameId: string
      gameplayId: string
      botOwner: string | null
      currentPoint: number[]
      mode: $Enums.MatchMode
      endTime: number
      startedAt: Date | null
      endedAt: Date | null
      expiredAt: Date | null
      isStarted: boolean
      isEnded: boolean
      createdAt: Date
      updatedAt: Date
      currentMember: number
    }, ExtArgs["result"]["championshipHistory"]>
    composites: {}
  }

  type ChampionshipHistoryGetPayload<S extends boolean | null | undefined | ChampionshipHistoryDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipHistoryPayload, S>

  type ChampionshipHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipHistoryCountAggregateInputType | true
    }

  export interface ChampionshipHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChampionshipHistory'], meta: { name: 'ChampionshipHistory' } }
    /**
     * Find zero or one ChampionshipHistory that matches the filter.
     * @param {ChampionshipHistoryFindUniqueArgs} args - Arguments to find a ChampionshipHistory
     * @example
     * // Get one ChampionshipHistory
     * const championshipHistory = await prisma.championshipHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipHistoryFindUniqueArgs>(args: SelectSubset<T, ChampionshipHistoryFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChampionshipHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipHistoryFindUniqueOrThrowArgs} args - Arguments to find a ChampionshipHistory
     * @example
     * // Get one ChampionshipHistory
     * const championshipHistory = await prisma.championshipHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryFindFirstArgs} args - Arguments to find a ChampionshipHistory
     * @example
     * // Get one ChampionshipHistory
     * const championshipHistory = await prisma.championshipHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipHistoryFindFirstArgs>(args?: SelectSubset<T, ChampionshipHistoryFindFirstArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryFindFirstOrThrowArgs} args - Arguments to find a ChampionshipHistory
     * @example
     * // Get one ChampionshipHistory
     * const championshipHistory = await prisma.championshipHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChampionshipHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChampionshipHistories
     * const championshipHistories = await prisma.championshipHistory.findMany()
     * 
     * // Get first 10 ChampionshipHistories
     * const championshipHistories = await prisma.championshipHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipHistoryWithIdOnly = await prisma.championshipHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipHistoryFindManyArgs>(args?: SelectSubset<T, ChampionshipHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChampionshipHistory.
     * @param {ChampionshipHistoryCreateArgs} args - Arguments to create a ChampionshipHistory.
     * @example
     * // Create one ChampionshipHistory
     * const ChampionshipHistory = await prisma.championshipHistory.create({
     *   data: {
     *     // ... data to create a ChampionshipHistory
     *   }
     * })
     * 
     */
    create<T extends ChampionshipHistoryCreateArgs>(args: SelectSubset<T, ChampionshipHistoryCreateArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChampionshipHistories.
     * @param {ChampionshipHistoryCreateManyArgs} args - Arguments to create many ChampionshipHistories.
     * @example
     * // Create many ChampionshipHistories
     * const championshipHistory = await prisma.championshipHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipHistoryCreateManyArgs>(args?: SelectSubset<T, ChampionshipHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChampionshipHistories and returns the data saved in the database.
     * @param {ChampionshipHistoryCreateManyAndReturnArgs} args - Arguments to create many ChampionshipHistories.
     * @example
     * // Create many ChampionshipHistories
     * const championshipHistory = await prisma.championshipHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChampionshipHistories and only return the `id`
     * const championshipHistoryWithIdOnly = await prisma.championshipHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChampionshipHistory.
     * @param {ChampionshipHistoryDeleteArgs} args - Arguments to delete one ChampionshipHistory.
     * @example
     * // Delete one ChampionshipHistory
     * const ChampionshipHistory = await prisma.championshipHistory.delete({
     *   where: {
     *     // ... filter to delete one ChampionshipHistory
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipHistoryDeleteArgs>(args: SelectSubset<T, ChampionshipHistoryDeleteArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChampionshipHistory.
     * @param {ChampionshipHistoryUpdateArgs} args - Arguments to update one ChampionshipHistory.
     * @example
     * // Update one ChampionshipHistory
     * const championshipHistory = await prisma.championshipHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipHistoryUpdateArgs>(args: SelectSubset<T, ChampionshipHistoryUpdateArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChampionshipHistories.
     * @param {ChampionshipHistoryDeleteManyArgs} args - Arguments to filter ChampionshipHistories to delete.
     * @example
     * // Delete a few ChampionshipHistories
     * const { count } = await prisma.championshipHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipHistoryDeleteManyArgs>(args?: SelectSubset<T, ChampionshipHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChampionshipHistories
     * const championshipHistory = await prisma.championshipHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipHistoryUpdateManyArgs>(args: SelectSubset<T, ChampionshipHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipHistories and returns the data updated in the database.
     * @param {ChampionshipHistoryUpdateManyAndReturnArgs} args - Arguments to update many ChampionshipHistories.
     * @example
     * // Update many ChampionshipHistories
     * const championshipHistory = await prisma.championshipHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChampionshipHistories and only return the `id`
     * const championshipHistoryWithIdOnly = await prisma.championshipHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChampionshipHistory.
     * @param {ChampionshipHistoryUpsertArgs} args - Arguments to update or create a ChampionshipHistory.
     * @example
     * // Update or create a ChampionshipHistory
     * const championshipHistory = await prisma.championshipHistory.upsert({
     *   create: {
     *     // ... data to create a ChampionshipHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChampionshipHistory we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipHistoryUpsertArgs>(args: SelectSubset<T, ChampionshipHistoryUpsertArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChampionshipHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryCountArgs} args - Arguments to filter ChampionshipHistories to count.
     * @example
     * // Count the number of ChampionshipHistories
     * const count = await prisma.championshipHistory.count({
     *   where: {
     *     // ... the filter for the ChampionshipHistories we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipHistoryCountArgs>(
      args?: Subset<T, ChampionshipHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChampionshipHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipHistoryAggregateArgs>(args: Subset<T, ChampionshipHistoryAggregateArgs>): Prisma.PrismaPromise<GetChampionshipHistoryAggregateType<T>>

    /**
     * Group by ChampionshipHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChampionshipHistory model
   */
  readonly fields: ChampionshipHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChampionshipHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends ChampionshipHistory$membersArgs<ExtArgs> = {}>(args?: Subset<T, ChampionshipHistory$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChampionshipHistory model
   */
  interface ChampionshipHistoryFieldRefs {
    readonly id: FieldRef<"ChampionshipHistory", 'String'>
    readonly max: FieldRef<"ChampionshipHistory", 'Int'>
    readonly zoneInGameId: FieldRef<"ChampionshipHistory", 'String'>
    readonly gameplayId: FieldRef<"ChampionshipHistory", 'String'>
    readonly botOwner: FieldRef<"ChampionshipHistory", 'String'>
    readonly currentPoint: FieldRef<"ChampionshipHistory", 'Int[]'>
    readonly mode: FieldRef<"ChampionshipHistory", 'MatchMode'>
    readonly endTime: FieldRef<"ChampionshipHistory", 'Int'>
    readonly startedAt: FieldRef<"ChampionshipHistory", 'DateTime'>
    readonly endedAt: FieldRef<"ChampionshipHistory", 'DateTime'>
    readonly expiredAt: FieldRef<"ChampionshipHistory", 'DateTime'>
    readonly isStarted: FieldRef<"ChampionshipHistory", 'Boolean'>
    readonly isEnded: FieldRef<"ChampionshipHistory", 'Boolean'>
    readonly createdAt: FieldRef<"ChampionshipHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"ChampionshipHistory", 'DateTime'>
    readonly currentMember: FieldRef<"ChampionshipHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChampionshipHistory findUnique
   */
  export type ChampionshipHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipHistory to fetch.
     */
    where: ChampionshipHistoryWhereUniqueInput
  }

  /**
   * ChampionshipHistory findUniqueOrThrow
   */
  export type ChampionshipHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipHistory to fetch.
     */
    where: ChampionshipHistoryWhereUniqueInput
  }

  /**
   * ChampionshipHistory findFirst
   */
  export type ChampionshipHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipHistory to fetch.
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipHistories to fetch.
     */
    orderBy?: ChampionshipHistoryOrderByWithRelationInput | ChampionshipHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipHistories.
     */
    cursor?: ChampionshipHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipHistories.
     */
    distinct?: ChampionshipHistoryScalarFieldEnum | ChampionshipHistoryScalarFieldEnum[]
  }

  /**
   * ChampionshipHistory findFirstOrThrow
   */
  export type ChampionshipHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipHistory to fetch.
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipHistories to fetch.
     */
    orderBy?: ChampionshipHistoryOrderByWithRelationInput | ChampionshipHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipHistories.
     */
    cursor?: ChampionshipHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipHistories.
     */
    distinct?: ChampionshipHistoryScalarFieldEnum | ChampionshipHistoryScalarFieldEnum[]
  }

  /**
   * ChampionshipHistory findMany
   */
  export type ChampionshipHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipHistories to fetch.
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipHistories to fetch.
     */
    orderBy?: ChampionshipHistoryOrderByWithRelationInput | ChampionshipHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChampionshipHistories.
     */
    cursor?: ChampionshipHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipHistories.
     */
    skip?: number
    distinct?: ChampionshipHistoryScalarFieldEnum | ChampionshipHistoryScalarFieldEnum[]
  }

  /**
   * ChampionshipHistory create
   */
  export type ChampionshipHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ChampionshipHistory.
     */
    data: XOR<ChampionshipHistoryCreateInput, ChampionshipHistoryUncheckedCreateInput>
  }

  /**
   * ChampionshipHistory createMany
   */
  export type ChampionshipHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChampionshipHistories.
     */
    data: ChampionshipHistoryCreateManyInput | ChampionshipHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipHistory createManyAndReturn
   */
  export type ChampionshipHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ChampionshipHistories.
     */
    data: ChampionshipHistoryCreateManyInput | ChampionshipHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipHistory update
   */
  export type ChampionshipHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ChampionshipHistory.
     */
    data: XOR<ChampionshipHistoryUpdateInput, ChampionshipHistoryUncheckedUpdateInput>
    /**
     * Choose, which ChampionshipHistory to update.
     */
    where: ChampionshipHistoryWhereUniqueInput
  }

  /**
   * ChampionshipHistory updateMany
   */
  export type ChampionshipHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChampionshipHistories.
     */
    data: XOR<ChampionshipHistoryUpdateManyMutationInput, ChampionshipHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipHistories to update
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * Limit how many ChampionshipHistories to update.
     */
    limit?: number
  }

  /**
   * ChampionshipHistory updateManyAndReturn
   */
  export type ChampionshipHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ChampionshipHistories.
     */
    data: XOR<ChampionshipHistoryUpdateManyMutationInput, ChampionshipHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipHistories to update
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * Limit how many ChampionshipHistories to update.
     */
    limit?: number
  }

  /**
   * ChampionshipHistory upsert
   */
  export type ChampionshipHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ChampionshipHistory to update in case it exists.
     */
    where: ChampionshipHistoryWhereUniqueInput
    /**
     * In case the ChampionshipHistory found by the `where` argument doesn't exist, create a new ChampionshipHistory with this data.
     */
    create: XOR<ChampionshipHistoryCreateInput, ChampionshipHistoryUncheckedCreateInput>
    /**
     * In case the ChampionshipHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipHistoryUpdateInput, ChampionshipHistoryUncheckedUpdateInput>
  }

  /**
   * ChampionshipHistory delete
   */
  export type ChampionshipHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
    /**
     * Filter which ChampionshipHistory to delete.
     */
    where: ChampionshipHistoryWhereUniqueInput
  }

  /**
   * ChampionshipHistory deleteMany
   */
  export type ChampionshipHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipHistories to delete
     */
    where?: ChampionshipHistoryWhereInput
    /**
     * Limit how many ChampionshipHistories to delete.
     */
    limit?: number
  }

  /**
   * ChampionshipHistory.members
   */
  export type ChampionshipHistory$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    where?: MatchHistoryMemberWhereInput
    orderBy?: MatchHistoryMemberOrderByWithRelationInput | MatchHistoryMemberOrderByWithRelationInput[]
    cursor?: MatchHistoryMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchHistoryMemberScalarFieldEnum | MatchHistoryMemberScalarFieldEnum[]
  }

  /**
   * ChampionshipHistory without action
   */
  export type ChampionshipHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipHistory
     */
    select?: ChampionshipHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipHistory
     */
    omit?: ChampionshipHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MatchHistoryMember
   */

  export type AggregateMatchHistoryMember = {
    _count: MatchHistoryMemberCountAggregateOutputType | null
    _avg: MatchHistoryMemberAvgAggregateOutputType | null
    _sum: MatchHistoryMemberSumAggregateOutputType | null
    _min: MatchHistoryMemberMinAggregateOutputType | null
    _max: MatchHistoryMemberMaxAggregateOutputType | null
  }

  export type MatchHistoryMemberAvgAggregateOutputType = {
    slot: number | null
    point: number | null
    bonusPoint: number | null
  }

  export type MatchHistoryMemberSumAggregateOutputType = {
    slot: number | null
    point: number | null
    bonusPoint: number | null
  }

  export type MatchHistoryMemberMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    slot: number | null
    status: $Enums.MatchStatus | null
    point: number | null
    bonusPoint: number | null
    teamType: $Enums.TeamType | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MatchHistoryMemberMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    slot: number | null
    status: $Enums.MatchStatus | null
    point: number | null
    bonusPoint: number | null
    teamType: $Enums.TeamType | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MatchHistoryMemberCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    slot: number
    status: number
    point: number
    bonusPoint: number
    teamType: number
    isReady: number
    isComplete: number
    isBot: number
    joinedAt: number
    finishedAt: number
    isDisconnect: number
    _all: number
  }


  export type MatchHistoryMemberAvgAggregateInputType = {
    slot?: true
    point?: true
    bonusPoint?: true
  }

  export type MatchHistoryMemberSumAggregateInputType = {
    slot?: true
    point?: true
    bonusPoint?: true
  }

  export type MatchHistoryMemberMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    slot?: true
    status?: true
    point?: true
    bonusPoint?: true
    teamType?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MatchHistoryMemberMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    slot?: true
    status?: true
    point?: true
    bonusPoint?: true
    teamType?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MatchHistoryMemberCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    slot?: true
    status?: true
    point?: true
    bonusPoint?: true
    teamType?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
    _all?: true
  }

  export type MatchHistoryMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchHistoryMember to aggregate.
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchHistoryMembers to fetch.
     */
    orderBy?: MatchHistoryMemberOrderByWithRelationInput | MatchHistoryMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchHistoryMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchHistoryMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchHistoryMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchHistoryMembers
    **/
    _count?: true | MatchHistoryMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchHistoryMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchHistoryMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchHistoryMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchHistoryMemberMaxAggregateInputType
  }

  export type GetMatchHistoryMemberAggregateType<T extends MatchHistoryMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchHistoryMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchHistoryMember[P]>
      : GetScalarType<T[P], AggregateMatchHistoryMember[P]>
  }




  export type MatchHistoryMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchHistoryMemberWhereInput
    orderBy?: MatchHistoryMemberOrderByWithAggregationInput | MatchHistoryMemberOrderByWithAggregationInput[]
    by: MatchHistoryMemberScalarFieldEnum[] | MatchHistoryMemberScalarFieldEnum
    having?: MatchHistoryMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchHistoryMemberCountAggregateInputType | true
    _avg?: MatchHistoryMemberAvgAggregateInputType
    _sum?: MatchHistoryMemberSumAggregateInputType
    _min?: MatchHistoryMemberMinAggregateInputType
    _max?: MatchHistoryMemberMaxAggregateInputType
  }

  export type MatchHistoryMemberGroupByOutputType = {
    id: string
    roomId: string
    userId: string
    slot: number
    status: $Enums.MatchStatus
    point: number
    bonusPoint: number
    teamType: $Enums.TeamType
    isReady: boolean
    isComplete: boolean
    isBot: boolean
    joinedAt: Date
    finishedAt: Date | null
    isDisconnect: boolean
    _count: MatchHistoryMemberCountAggregateOutputType | null
    _avg: MatchHistoryMemberAvgAggregateOutputType | null
    _sum: MatchHistoryMemberSumAggregateOutputType | null
    _min: MatchHistoryMemberMinAggregateOutputType | null
    _max: MatchHistoryMemberMaxAggregateOutputType | null
  }

  type GetMatchHistoryMemberGroupByPayload<T extends MatchHistoryMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchHistoryMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchHistoryMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchHistoryMemberGroupByOutputType[P]>
            : GetScalarType<T[P], MatchHistoryMemberGroupByOutputType[P]>
        }
      >
    >


  export type MatchHistoryMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    room?: boolean | ChampionshipHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchHistoryMember"]>

  export type MatchHistoryMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    room?: boolean | ChampionshipHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchHistoryMember"]>

  export type MatchHistoryMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    room?: boolean | ChampionshipHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchHistoryMember"]>

  export type MatchHistoryMemberSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    slot?: boolean
    status?: boolean
    point?: boolean
    bonusPoint?: boolean
    teamType?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "slot" | "status" | "point" | "bonusPoint" | "teamType" | "isReady" | "isComplete" | "isBot" | "joinedAt" | "finishedAt" | "isDisconnect", ExtArgs["result"]["matchHistoryMember"]>
  export type MatchHistoryMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChampionshipHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchHistoryMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChampionshipHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchHistoryMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChampionshipHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchHistoryMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchHistoryMember"
    objects: {
      room: Prisma.$ChampionshipHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string
      slot: number
      status: $Enums.MatchStatus
      point: number
      bonusPoint: number
      teamType: $Enums.TeamType
      isReady: boolean
      isComplete: boolean
      isBot: boolean
      joinedAt: Date
      finishedAt: Date | null
      isDisconnect: boolean
    }, ExtArgs["result"]["matchHistoryMember"]>
    composites: {}
  }

  type MatchHistoryMemberGetPayload<S extends boolean | null | undefined | MatchHistoryMemberDefaultArgs> = $Result.GetResult<Prisma.$MatchHistoryMemberPayload, S>

  type MatchHistoryMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchHistoryMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchHistoryMemberCountAggregateInputType | true
    }

  export interface MatchHistoryMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchHistoryMember'], meta: { name: 'MatchHistoryMember' } }
    /**
     * Find zero or one MatchHistoryMember that matches the filter.
     * @param {MatchHistoryMemberFindUniqueArgs} args - Arguments to find a MatchHistoryMember
     * @example
     * // Get one MatchHistoryMember
     * const matchHistoryMember = await prisma.matchHistoryMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchHistoryMemberFindUniqueArgs>(args: SelectSubset<T, MatchHistoryMemberFindUniqueArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchHistoryMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchHistoryMemberFindUniqueOrThrowArgs} args - Arguments to find a MatchHistoryMember
     * @example
     * // Get one MatchHistoryMember
     * const matchHistoryMember = await prisma.matchHistoryMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchHistoryMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchHistoryMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchHistoryMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberFindFirstArgs} args - Arguments to find a MatchHistoryMember
     * @example
     * // Get one MatchHistoryMember
     * const matchHistoryMember = await prisma.matchHistoryMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchHistoryMemberFindFirstArgs>(args?: SelectSubset<T, MatchHistoryMemberFindFirstArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchHistoryMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberFindFirstOrThrowArgs} args - Arguments to find a MatchHistoryMember
     * @example
     * // Get one MatchHistoryMember
     * const matchHistoryMember = await prisma.matchHistoryMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchHistoryMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchHistoryMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchHistoryMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchHistoryMembers
     * const matchHistoryMembers = await prisma.matchHistoryMember.findMany()
     * 
     * // Get first 10 MatchHistoryMembers
     * const matchHistoryMembers = await prisma.matchHistoryMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchHistoryMemberWithIdOnly = await prisma.matchHistoryMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchHistoryMemberFindManyArgs>(args?: SelectSubset<T, MatchHistoryMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchHistoryMember.
     * @param {MatchHistoryMemberCreateArgs} args - Arguments to create a MatchHistoryMember.
     * @example
     * // Create one MatchHistoryMember
     * const MatchHistoryMember = await prisma.matchHistoryMember.create({
     *   data: {
     *     // ... data to create a MatchHistoryMember
     *   }
     * })
     * 
     */
    create<T extends MatchHistoryMemberCreateArgs>(args: SelectSubset<T, MatchHistoryMemberCreateArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchHistoryMembers.
     * @param {MatchHistoryMemberCreateManyArgs} args - Arguments to create many MatchHistoryMembers.
     * @example
     * // Create many MatchHistoryMembers
     * const matchHistoryMember = await prisma.matchHistoryMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchHistoryMemberCreateManyArgs>(args?: SelectSubset<T, MatchHistoryMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchHistoryMembers and returns the data saved in the database.
     * @param {MatchHistoryMemberCreateManyAndReturnArgs} args - Arguments to create many MatchHistoryMembers.
     * @example
     * // Create many MatchHistoryMembers
     * const matchHistoryMember = await prisma.matchHistoryMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchHistoryMembers and only return the `id`
     * const matchHistoryMemberWithIdOnly = await prisma.matchHistoryMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchHistoryMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchHistoryMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchHistoryMember.
     * @param {MatchHistoryMemberDeleteArgs} args - Arguments to delete one MatchHistoryMember.
     * @example
     * // Delete one MatchHistoryMember
     * const MatchHistoryMember = await prisma.matchHistoryMember.delete({
     *   where: {
     *     // ... filter to delete one MatchHistoryMember
     *   }
     * })
     * 
     */
    delete<T extends MatchHistoryMemberDeleteArgs>(args: SelectSubset<T, MatchHistoryMemberDeleteArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchHistoryMember.
     * @param {MatchHistoryMemberUpdateArgs} args - Arguments to update one MatchHistoryMember.
     * @example
     * // Update one MatchHistoryMember
     * const matchHistoryMember = await prisma.matchHistoryMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchHistoryMemberUpdateArgs>(args: SelectSubset<T, MatchHistoryMemberUpdateArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchHistoryMembers.
     * @param {MatchHistoryMemberDeleteManyArgs} args - Arguments to filter MatchHistoryMembers to delete.
     * @example
     * // Delete a few MatchHistoryMembers
     * const { count } = await prisma.matchHistoryMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchHistoryMemberDeleteManyArgs>(args?: SelectSubset<T, MatchHistoryMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchHistoryMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchHistoryMembers
     * const matchHistoryMember = await prisma.matchHistoryMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchHistoryMemberUpdateManyArgs>(args: SelectSubset<T, MatchHistoryMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchHistoryMembers and returns the data updated in the database.
     * @param {MatchHistoryMemberUpdateManyAndReturnArgs} args - Arguments to update many MatchHistoryMembers.
     * @example
     * // Update many MatchHistoryMembers
     * const matchHistoryMember = await prisma.matchHistoryMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchHistoryMembers and only return the `id`
     * const matchHistoryMemberWithIdOnly = await prisma.matchHistoryMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchHistoryMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchHistoryMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchHistoryMember.
     * @param {MatchHistoryMemberUpsertArgs} args - Arguments to update or create a MatchHistoryMember.
     * @example
     * // Update or create a MatchHistoryMember
     * const matchHistoryMember = await prisma.matchHistoryMember.upsert({
     *   create: {
     *     // ... data to create a MatchHistoryMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchHistoryMember we want to update
     *   }
     * })
     */
    upsert<T extends MatchHistoryMemberUpsertArgs>(args: SelectSubset<T, MatchHistoryMemberUpsertArgs<ExtArgs>>): Prisma__MatchHistoryMemberClient<$Result.GetResult<Prisma.$MatchHistoryMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchHistoryMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberCountArgs} args - Arguments to filter MatchHistoryMembers to count.
     * @example
     * // Count the number of MatchHistoryMembers
     * const count = await prisma.matchHistoryMember.count({
     *   where: {
     *     // ... the filter for the MatchHistoryMembers we want to count
     *   }
     * })
    **/
    count<T extends MatchHistoryMemberCountArgs>(
      args?: Subset<T, MatchHistoryMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchHistoryMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchHistoryMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchHistoryMemberAggregateArgs>(args: Subset<T, MatchHistoryMemberAggregateArgs>): Prisma.PrismaPromise<GetMatchHistoryMemberAggregateType<T>>

    /**
     * Group by MatchHistoryMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchHistoryMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchHistoryMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchHistoryMemberGroupByArgs['orderBy'] }
        : { orderBy?: MatchHistoryMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchHistoryMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchHistoryMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchHistoryMember model
   */
  readonly fields: MatchHistoryMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchHistoryMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchHistoryMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends ChampionshipHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChampionshipHistoryDefaultArgs<ExtArgs>>): Prisma__ChampionshipHistoryClient<$Result.GetResult<Prisma.$ChampionshipHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchHistoryMember model
   */
  interface MatchHistoryMemberFieldRefs {
    readonly id: FieldRef<"MatchHistoryMember", 'String'>
    readonly roomId: FieldRef<"MatchHistoryMember", 'String'>
    readonly userId: FieldRef<"MatchHistoryMember", 'String'>
    readonly slot: FieldRef<"MatchHistoryMember", 'Int'>
    readonly status: FieldRef<"MatchHistoryMember", 'MatchStatus'>
    readonly point: FieldRef<"MatchHistoryMember", 'Int'>
    readonly bonusPoint: FieldRef<"MatchHistoryMember", 'Int'>
    readonly teamType: FieldRef<"MatchHistoryMember", 'TeamType'>
    readonly isReady: FieldRef<"MatchHistoryMember", 'Boolean'>
    readonly isComplete: FieldRef<"MatchHistoryMember", 'Boolean'>
    readonly isBot: FieldRef<"MatchHistoryMember", 'Boolean'>
    readonly joinedAt: FieldRef<"MatchHistoryMember", 'DateTime'>
    readonly finishedAt: FieldRef<"MatchHistoryMember", 'DateTime'>
    readonly isDisconnect: FieldRef<"MatchHistoryMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MatchHistoryMember findUnique
   */
  export type MatchHistoryMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchHistoryMember to fetch.
     */
    where: MatchHistoryMemberWhereUniqueInput
  }

  /**
   * MatchHistoryMember findUniqueOrThrow
   */
  export type MatchHistoryMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchHistoryMember to fetch.
     */
    where: MatchHistoryMemberWhereUniqueInput
  }

  /**
   * MatchHistoryMember findFirst
   */
  export type MatchHistoryMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchHistoryMember to fetch.
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchHistoryMembers to fetch.
     */
    orderBy?: MatchHistoryMemberOrderByWithRelationInput | MatchHistoryMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchHistoryMembers.
     */
    cursor?: MatchHistoryMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchHistoryMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchHistoryMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchHistoryMembers.
     */
    distinct?: MatchHistoryMemberScalarFieldEnum | MatchHistoryMemberScalarFieldEnum[]
  }

  /**
   * MatchHistoryMember findFirstOrThrow
   */
  export type MatchHistoryMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchHistoryMember to fetch.
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchHistoryMembers to fetch.
     */
    orderBy?: MatchHistoryMemberOrderByWithRelationInput | MatchHistoryMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchHistoryMembers.
     */
    cursor?: MatchHistoryMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchHistoryMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchHistoryMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchHistoryMembers.
     */
    distinct?: MatchHistoryMemberScalarFieldEnum | MatchHistoryMemberScalarFieldEnum[]
  }

  /**
   * MatchHistoryMember findMany
   */
  export type MatchHistoryMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * Filter, which MatchHistoryMembers to fetch.
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchHistoryMembers to fetch.
     */
    orderBy?: MatchHistoryMemberOrderByWithRelationInput | MatchHistoryMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchHistoryMembers.
     */
    cursor?: MatchHistoryMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchHistoryMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchHistoryMembers.
     */
    skip?: number
    distinct?: MatchHistoryMemberScalarFieldEnum | MatchHistoryMemberScalarFieldEnum[]
  }

  /**
   * MatchHistoryMember create
   */
  export type MatchHistoryMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchHistoryMember.
     */
    data: XOR<MatchHistoryMemberCreateInput, MatchHistoryMemberUncheckedCreateInput>
  }

  /**
   * MatchHistoryMember createMany
   */
  export type MatchHistoryMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchHistoryMembers.
     */
    data: MatchHistoryMemberCreateManyInput | MatchHistoryMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchHistoryMember createManyAndReturn
   */
  export type MatchHistoryMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * The data used to create many MatchHistoryMembers.
     */
    data: MatchHistoryMemberCreateManyInput | MatchHistoryMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchHistoryMember update
   */
  export type MatchHistoryMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchHistoryMember.
     */
    data: XOR<MatchHistoryMemberUpdateInput, MatchHistoryMemberUncheckedUpdateInput>
    /**
     * Choose, which MatchHistoryMember to update.
     */
    where: MatchHistoryMemberWhereUniqueInput
  }

  /**
   * MatchHistoryMember updateMany
   */
  export type MatchHistoryMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchHistoryMembers.
     */
    data: XOR<MatchHistoryMemberUpdateManyMutationInput, MatchHistoryMemberUncheckedUpdateManyInput>
    /**
     * Filter which MatchHistoryMembers to update
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * Limit how many MatchHistoryMembers to update.
     */
    limit?: number
  }

  /**
   * MatchHistoryMember updateManyAndReturn
   */
  export type MatchHistoryMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * The data used to update MatchHistoryMembers.
     */
    data: XOR<MatchHistoryMemberUpdateManyMutationInput, MatchHistoryMemberUncheckedUpdateManyInput>
    /**
     * Filter which MatchHistoryMembers to update
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * Limit how many MatchHistoryMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchHistoryMember upsert
   */
  export type MatchHistoryMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchHistoryMember to update in case it exists.
     */
    where: MatchHistoryMemberWhereUniqueInput
    /**
     * In case the MatchHistoryMember found by the `where` argument doesn't exist, create a new MatchHistoryMember with this data.
     */
    create: XOR<MatchHistoryMemberCreateInput, MatchHistoryMemberUncheckedCreateInput>
    /**
     * In case the MatchHistoryMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchHistoryMemberUpdateInput, MatchHistoryMemberUncheckedUpdateInput>
  }

  /**
   * MatchHistoryMember delete
   */
  export type MatchHistoryMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
    /**
     * Filter which MatchHistoryMember to delete.
     */
    where: MatchHistoryMemberWhereUniqueInput
  }

  /**
   * MatchHistoryMember deleteMany
   */
  export type MatchHistoryMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchHistoryMembers to delete
     */
    where?: MatchHistoryMemberWhereInput
    /**
     * Limit how many MatchHistoryMembers to delete.
     */
    limit?: number
  }

  /**
   * MatchHistoryMember without action
   */
  export type MatchHistoryMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchHistoryMember
     */
    select?: MatchHistoryMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchHistoryMember
     */
    omit?: MatchHistoryMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchHistoryMemberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProvinceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    provinceId: 'provinceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const SubdistrictScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    provinceId: 'provinceId',
    cityId: 'cityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubdistrictScalarFieldEnum = (typeof SubdistrictScalarFieldEnum)[keyof typeof SubdistrictScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    identity: 'identity',
    level: 'level',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    cityId: 'cityId',
    provinceId: 'provinceId',
    subdistrictId: 'subdistrictId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    email: 'email',
    role: 'role',
    suspend: 'suspend',
    accountType: 'accountType',
    firstTest: 'firstTest',
    fullname: 'fullname',
    birthDate: 'birthDate',
    grade: 'grade',
    lastGradeUpdateAt: 'lastGradeUpdateAt',
    schoolIdentity: 'schoolIdentity',
    loginAt: 'loginAt',
    logoutAt: 'logoutAt',
    playTime: 'playTime',
    characterUsed: 'characterUsed',
    inventory: 'inventory',
    schoolId: 'schoolId',
    cityId: 'cityId',
    provinceId: 'provinceId',
    subdistrictId: 'subdistrictId',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    lastIdZoneUnlocked: 'lastIdZoneUnlocked',
    lastIdZonePosition: 'lastIdZonePosition'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    lastLevelId: 'lastLevelId',
    lastSubLevelId: 'lastSubLevelId',
    lastInnerLevelId: 'lastInnerLevelId',
    lastLevelUnlock: 'lastLevelUnlock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inGameId: 'inGameId',
    posttest: 'posttest',
    posttestTryCount: 'posttestTryCount',
    pretest: 'pretest',
    pretestTryCount: 'pretestTryCount'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inGameId: 'inGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const SubLevelScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inGameId: 'inGameId',
    levelInGameId: 'levelInGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId'
  };

  export type SubLevelScalarFieldEnum = (typeof SubLevelScalarFieldEnum)[keyof typeof SubLevelScalarFieldEnum]


  export const InnerLevelScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    correctAttempt: 'correctAttempt',
    playTime: 'playTime',
    point: 'point',
    played: 'played',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inGameId: 'inGameId',
    levelInGameId: 'levelInGameId',
    subLevelInGameId: 'subLevelInGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId'
  };

  export type InnerLevelScalarFieldEnum = (typeof InnerLevelScalarFieldEnum)[keyof typeof InnerLevelScalarFieldEnum]


  export const GempoScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inGameId: 'inGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId'
  };

  export type GempoScalarFieldEnum = (typeof GempoScalarFieldEnum)[keyof typeof GempoScalarFieldEnum]


  export const ChampionshipScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    inGameId: 'inGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId'
  };

  export type ChampionshipScalarFieldEnum = (typeof ChampionshipScalarFieldEnum)[keyof typeof ChampionshipScalarFieldEnum]


  export const GempoRecordScalarFieldEnum: {
    id: 'id',
    played: 'played',
    point: 'point',
    highestPoint: 'highestPoint',
    lastPlayedAt: 'lastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gempoInGameId: 'gempoInGameId',
    inGameId: 'inGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId',
    correctAttempt: 'correctAttempt'
  };

  export type GempoRecordScalarFieldEnum = (typeof GempoRecordScalarFieldEnum)[keyof typeof GempoRecordScalarFieldEnum]


  export const ChampionshipRecordScalarFieldEnum: {
    id: 'id',
    teamWin: 'teamWin',
    teamLose: 'teamLose',
    teamPlayed: 'teamPlayed',
    teamPoint: 'teamPoint',
    teamLastPlayedAt: 'teamLastPlayedAt',
    soloWin: 'soloWin',
    soloLose: 'soloLose',
    soloPlayed: 'soloPlayed',
    soloPoint: 'soloPoint',
    soloLastPlayedAt: 'soloLastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    championshipInGameId: 'championshipInGameId',
    inGameId: 'inGameId',
    userId: 'userId',
    zoneInGameId: 'zoneInGameId'
  };

  export type ChampionshipRecordScalarFieldEnum = (typeof ChampionshipRecordScalarFieldEnum)[keyof typeof ChampionshipRecordScalarFieldEnum]


  export const UserLoginScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    loginDate: 'loginDate',
    logoutDate: 'logoutDate'
  };

  export type UserLoginScalarFieldEnum = (typeof UserLoginScalarFieldEnum)[keyof typeof UserLoginScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    email: 'email',
    name: 'name',
    suspend: 'suspend',
    role: 'role',
    provinceId: 'provinceId',
    cityId: 'cityId',
    subdistrictId: 'subdistrictId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authenticatorEnabled: 'authenticatorEnabled',
    authenticatorQrUrl: 'authenticatorQrUrl',
    authenticatorSecret: 'authenticatorSecret'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminLogScalarFieldEnum: {
    id: 'id',
    ipAddress: 'ipAddress',
    old: 'old',
    new: 'new',
    adminId: 'adminId',
    table: 'table',
    operation: 'operation',
    createdAt: 'createdAt'
  };

  export type AdminLogScalarFieldEnum = (typeof AdminLogScalarFieldEnum)[keyof typeof AdminLogScalarFieldEnum]


  export const AdminOperationHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    adminId: 'adminId',
    opAdminId: 'opAdminId',
    operation: 'operation'
  };

  export type AdminOperationHistoryScalarFieldEnum = (typeof AdminOperationHistoryScalarFieldEnum)[keyof typeof AdminOperationHistoryScalarFieldEnum]


  export const AdminAuthorityScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    provinceId: 'provinceId',
    grades: 'grades'
  };

  export type AdminAuthorityScalarFieldEnum = (typeof AdminAuthorityScalarFieldEnum)[keyof typeof AdminAuthorityScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    thumbnail: 'thumbnail',
    link: 'link',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    isHide: 'isHide',
    lastBroadcastedAt: 'lastBroadcastedAt',
    adminId: 'adminId',
    thumbnailId: 'thumbnailId'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const BannerVisitorScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    traffic: 'traffic'
  };

  export type BannerVisitorScalarFieldEnum = (typeof BannerVisitorScalarFieldEnum)[keyof typeof BannerVisitorScalarFieldEnum]


  export const TestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    question: 'question',
    duration: 'duration',
    passedPoint: 'passedPoint',
    remidialCount: 'remidialCount',
    type: 'type',
    quota: 'quota',
    currentQuota: 'currentQuota',
    code: 'code',
    zoneId: 'zoneId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    adminId: 'adminId'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const TestParticipantScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    highscore: 'highscore'
  };

  export type TestParticipantScalarFieldEnum = (typeof TestParticipantScalarFieldEnum)[keyof typeof TestParticipantScalarFieldEnum]


  export const TestParticipantRecordScalarFieldEnum: {
    id: 'id',
    participantId: 'participantId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    answers: 'answers'
  };

  export type TestParticipantRecordScalarFieldEnum = (typeof TestParticipantRecordScalarFieldEnum)[keyof typeof TestParticipantRecordScalarFieldEnum]


  export const BackgroundScalarFieldEnum: {
    id: 'id',
    name: 'name',
    thumbnail: 'thumbnail',
    isUse: 'isUse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    thumbnailId: 'thumbnailId'
  };

  export type BackgroundScalarFieldEnum = (typeof BackgroundScalarFieldEnum)[keyof typeof BackgroundScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const AdminTransactionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    quantity: 'quantity',
    zones: 'zones',
    adminId: 'adminId',
    amount: 'amount',
    archived: 'archived',
    description: 'description',
    name: 'name',
    subscriptionTime: 'subscriptionTime',
    transactionImageId: 'transactionImageId',
    transactionImageUrl: 'transactionImageUrl',
    transactionRef: 'transactionRef',
    status: 'status',
    processedAt: 'processedAt',
    processedById: 'processedById'
  };

  export type AdminTransactionScalarFieldEnum = (typeof AdminTransactionScalarFieldEnum)[keyof typeof AdminTransactionScalarFieldEnum]


  export const RedeemCodeScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    adminId: 'adminId',
    code: 'code',
    expiredAt: 'expiredAt',
    currentAmount: 'currentAmount',
    maxAmount: 'maxAmount',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    suspend: 'suspend'
  };

  export type RedeemCodeScalarFieldEnum = (typeof RedeemCodeScalarFieldEnum)[keyof typeof RedeemCodeScalarFieldEnum]


  export const CodeRedeemerScalarFieldEnum: {
    id: 'id',
    banned: 'banned',
    userId: 'userId',
    codeId: 'codeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodeRedeemerScalarFieldEnum = (typeof CodeRedeemerScalarFieldEnum)[keyof typeof CodeRedeemerScalarFieldEnum]


  export const ChampionshipMatchScalarFieldEnum: {
    id: 'id',
    max: 'max',
    zoneInGameId: 'zoneInGameId',
    gameplayId: 'gameplayId',
    botOwner: 'botOwner',
    mode: 'mode',
    endTime: 'endTime',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    expiredAt: 'expiredAt',
    isStarted: 'isStarted',
    isEnded: 'isEnded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currentMember: 'currentMember'
  };

  export type ChampionshipMatchScalarFieldEnum = (typeof ChampionshipMatchScalarFieldEnum)[keyof typeof ChampionshipMatchScalarFieldEnum]


  export const MatchMemberScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    slot: 'slot',
    status: 'status',
    answerPoint: 'answerPoint',
    point: 'point',
    bonusPoint: 'bonusPoint',
    teamType: 'teamType',
    isReady: 'isReady',
    isComplete: 'isComplete',
    isBot: 'isBot',
    joinedAt: 'joinedAt',
    finishedAt: 'finishedAt',
    isDisconnect: 'isDisconnect'
  };

  export type MatchMemberScalarFieldEnum = (typeof MatchMemberScalarFieldEnum)[keyof typeof MatchMemberScalarFieldEnum]


  export const ChampionshipHistoryScalarFieldEnum: {
    id: 'id',
    max: 'max',
    zoneInGameId: 'zoneInGameId',
    gameplayId: 'gameplayId',
    botOwner: 'botOwner',
    currentPoint: 'currentPoint',
    mode: 'mode',
    endTime: 'endTime',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    expiredAt: 'expiredAt',
    isStarted: 'isStarted',
    isEnded: 'isEnded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currentMember: 'currentMember'
  };

  export type ChampionshipHistoryScalarFieldEnum = (typeof ChampionshipHistoryScalarFieldEnum)[keyof typeof ChampionshipHistoryScalarFieldEnum]


  export const MatchHistoryMemberScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    slot: 'slot',
    status: 'status',
    point: 'point',
    bonusPoint: 'bonusPoint',
    teamType: 'teamType',
    isReady: 'isReady',
    isComplete: 'isComplete',
    isBot: 'isBot',
    joinedAt: 'joinedAt',
    finishedAt: 'finishedAt',
    isDisconnect: 'isDisconnect'
  };

  export type MatchHistoryMemberScalarFieldEnum = (typeof MatchHistoryMemberScalarFieldEnum)[keyof typeof MatchHistoryMemberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'EducationLevel'
   */
  export type EnumEducationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EducationLevel'>
    


  /**
   * Reference to a field of type 'EducationLevel[]'
   */
  export type ListEnumEducationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EducationLevel[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Operation'
   */
  export type EnumOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Operation'>
    


  /**
   * Reference to a field of type 'Operation[]'
   */
  export type ListEnumOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Operation[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'TestType'
   */
  export type EnumTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestType'>
    


  /**
   * Reference to a field of type 'TestType[]'
   */
  export type ListEnumTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestType[]'>
    


  /**
   * Reference to a field of type 'Transaction'
   */
  export type EnumTransactionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Transaction'>
    


  /**
   * Reference to a field of type 'Transaction[]'
   */
  export type ListEnumTransactionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Transaction[]'>
    


  /**
   * Reference to a field of type 'MatchMode'
   */
  export type EnumMatchModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchMode'>
    


  /**
   * Reference to a field of type 'MatchMode[]'
   */
  export type ListEnumMatchModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchMode[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'TeamType'
   */
  export type EnumTeamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamType'>
    


  /**
   * Reference to a field of type 'TeamType[]'
   */
  export type ListEnumTeamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamType[]'>
    
  /**
   * Deep Input Types
   */


  export type ProvinceWhereInput = {
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    id?: StringFilter<"Province"> | string
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
    admin?: AdminListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    banners?: BannerListRelationFilter
  }

  export type ProvinceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    cities?: CityOrderByRelationAggregateInput
    schools?: SchoolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    subdistricts?: SubdistrictOrderByRelationAggregateInput
    banners?: BannerOrderByRelationAggregateInput
  }

  export type ProvinceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
    admin?: AdminListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    banners?: BannerListRelationFilter
  }, "id">

  export type ProvinceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProvinceCountOrderByAggregateInput
    _avg?: ProvinceAvgOrderByAggregateInput
    _max?: ProvinceMaxOrderByAggregateInput
    _min?: ProvinceMinOrderByAggregateInput
    _sum?: ProvinceSumOrderByAggregateInput
  }

  export type ProvinceScalarWhereWithAggregatesInput = {
    AND?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    OR?: ProvinceScalarWhereWithAggregatesInput[]
    NOT?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Province"> | string
    name?: StringWithAggregatesFilter<"Province"> | string
    longitude?: FloatWithAggregatesFilter<"Province"> | number
    latitude?: FloatWithAggregatesFilter<"Province"> | number
    geoId?: StringWithAggregatesFilter<"Province"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Province"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Province"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    admin?: AdminListRelationFilter
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    schools?: SchoolListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    banners?: BannerListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByRelationAggregateInput
    province?: ProvinceOrderByWithRelationInput
    schools?: SchoolOrderByRelationAggregateInput
    subdistricts?: SubdistrictOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    banners?: BannerOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    admin?: AdminListRelationFilter
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    schools?: SchoolListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    banners?: BannerListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    longitude?: FloatWithAggregatesFilter<"City"> | number
    latitude?: FloatWithAggregatesFilter<"City"> | number
    geoId?: StringWithAggregatesFilter<"City"> | string
    provinceId?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type SubdistrictWhereInput = {
    AND?: SubdistrictWhereInput | SubdistrictWhereInput[]
    OR?: SubdistrictWhereInput[]
    NOT?: SubdistrictWhereInput | SubdistrictWhereInput[]
    id?: StringFilter<"Subdistrict"> | string
    name?: StringFilter<"Subdistrict"> | string
    longitude?: FloatFilter<"Subdistrict"> | number
    latitude?: FloatFilter<"Subdistrict"> | number
    geoId?: StringFilter<"Subdistrict"> | string
    provinceId?: StringFilter<"Subdistrict"> | string
    cityId?: StringFilter<"Subdistrict"> | string
    createdAt?: DateTimeFilter<"Subdistrict"> | Date | string
    updatedAt?: DateTimeFilter<"Subdistrict"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    admins?: AdminListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    banners?: BannerListRelationFilter
  }

  export type SubdistrictOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    province?: ProvinceOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    schools?: SchoolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    admins?: AdminOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    banners?: BannerOrderByRelationAggregateInput
  }

  export type SubdistrictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubdistrictWhereInput | SubdistrictWhereInput[]
    OR?: SubdistrictWhereInput[]
    NOT?: SubdistrictWhereInput | SubdistrictWhereInput[]
    name?: StringFilter<"Subdistrict"> | string
    longitude?: FloatFilter<"Subdistrict"> | number
    latitude?: FloatFilter<"Subdistrict"> | number
    geoId?: StringFilter<"Subdistrict"> | string
    provinceId?: StringFilter<"Subdistrict"> | string
    cityId?: StringFilter<"Subdistrict"> | string
    createdAt?: DateTimeFilter<"Subdistrict"> | Date | string
    updatedAt?: DateTimeFilter<"Subdistrict"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    admins?: AdminListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    banners?: BannerListRelationFilter
  }, "id">

  export type SubdistrictOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubdistrictCountOrderByAggregateInput
    _avg?: SubdistrictAvgOrderByAggregateInput
    _max?: SubdistrictMaxOrderByAggregateInput
    _min?: SubdistrictMinOrderByAggregateInput
    _sum?: SubdistrictSumOrderByAggregateInput
  }

  export type SubdistrictScalarWhereWithAggregatesInput = {
    AND?: SubdistrictScalarWhereWithAggregatesInput | SubdistrictScalarWhereWithAggregatesInput[]
    OR?: SubdistrictScalarWhereWithAggregatesInput[]
    NOT?: SubdistrictScalarWhereWithAggregatesInput | SubdistrictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subdistrict"> | string
    name?: StringWithAggregatesFilter<"Subdistrict"> | string
    longitude?: FloatWithAggregatesFilter<"Subdistrict"> | number
    latitude?: FloatWithAggregatesFilter<"Subdistrict"> | number
    geoId?: StringWithAggregatesFilter<"Subdistrict"> | string
    provinceId?: StringWithAggregatesFilter<"Subdistrict"> | string
    cityId?: StringWithAggregatesFilter<"Subdistrict"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subdistrict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subdistrict"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    identity?: StringFilter<"School"> | string
    level?: EnumEducationLevelFilter<"School"> | $Enums.EducationLevel
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringNullableFilter<"School"> | string | null
    provinceId?: StringNullableFilter<"School"> | string | null
    subdistrictId?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    admin?: AdminListRelationFilter
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    subdistrict?: XOR<SubdistrictNullableScalarRelationFilter, SubdistrictWhereInput> | null
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    identity?: SortOrder
    level?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    subdistrictId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByRelationAggregateInput
    city?: CityOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    subdistrict?: SubdistrictOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identity?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    level?: EnumEducationLevelFilter<"School"> | $Enums.EducationLevel
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringNullableFilter<"School"> | string | null
    provinceId?: StringNullableFilter<"School"> | string | null
    subdistrictId?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    admin?: AdminListRelationFilter
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    subdistrict?: XOR<SubdistrictNullableScalarRelationFilter, SubdistrictWhereInput> | null
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
  }, "id" | "identity">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    identity?: SortOrder
    level?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    subdistrictId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    identity?: StringWithAggregatesFilter<"School"> | string
    level?: EnumEducationLevelWithAggregatesFilter<"School"> | $Enums.EducationLevel
    name?: StringWithAggregatesFilter<"School"> | string
    longitude?: FloatWithAggregatesFilter<"School"> | number
    latitude?: FloatWithAggregatesFilter<"School"> | number
    cityId?: StringNullableWithAggregatesFilter<"School"> | string | null
    provinceId?: StringNullableWithAggregatesFilter<"School"> | string | null
    subdistrictId?: StringNullableWithAggregatesFilter<"School"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    authId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: StringFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    subdistrictId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
    bannerVisitor?: BannerVisitorListRelationFilter
    championships?: ChampionshipListRelationFilter
    championshipRecords?: ChampionshipRecordListRelationFilter
    redeemedCodes?: CodeRedeemerListRelationFilter
    gempos?: GempoListRelationFilter
    gempoRecords?: GempoRecordListRelationFilter
    innerLevels?: InnerLevelListRelationFilter
    levels?: LevelListRelationFilter
    matchMembers?: MatchMemberListRelationFilter
    historyMatchMembers?: MatchHistoryMemberListRelationFilter
    subLevels?: SubLevelListRelationFilter
    testParticipant?: TestParticipantListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    subdistrict?: XOR<SubdistrictNullableScalarRelationFilter, SubdistrictWhereInput> | null
    userLogin?: UserLoginListRelationFilter
    zones?: ZoneListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrderInput | SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrderInput | SortOrder
    logoutAt?: SortOrderInput | SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    subdistrictId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
    bannerVisitor?: BannerVisitorOrderByRelationAggregateInput
    championships?: ChampionshipOrderByRelationAggregateInput
    championshipRecords?: ChampionshipRecordOrderByRelationAggregateInput
    redeemedCodes?: CodeRedeemerOrderByRelationAggregateInput
    gempos?: GempoOrderByRelationAggregateInput
    gempoRecords?: GempoRecordOrderByRelationAggregateInput
    innerLevels?: InnerLevelOrderByRelationAggregateInput
    levels?: LevelOrderByRelationAggregateInput
    matchMembers?: MatchMemberOrderByRelationAggregateInput
    historyMatchMembers?: MatchHistoryMemberOrderByRelationAggregateInput
    subLevels?: SubLevelOrderByRelationAggregateInput
    testParticipant?: TestParticipantOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    subdistrict?: SubdistrictOrderByWithRelationInput
    userLogin?: UserLoginOrderByRelationAggregateInput
    zones?: ZoneOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    schoolIdentity?: string
    adminId?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: StringFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    subdistrictId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
    bannerVisitor?: BannerVisitorListRelationFilter
    championships?: ChampionshipListRelationFilter
    championshipRecords?: ChampionshipRecordListRelationFilter
    redeemedCodes?: CodeRedeemerListRelationFilter
    gempos?: GempoListRelationFilter
    gempoRecords?: GempoRecordListRelationFilter
    innerLevels?: InnerLevelListRelationFilter
    levels?: LevelListRelationFilter
    matchMembers?: MatchMemberListRelationFilter
    historyMatchMembers?: MatchHistoryMemberListRelationFilter
    subLevels?: SubLevelListRelationFilter
    testParticipant?: TestParticipantListRelationFilter
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    subdistrict?: XOR<SubdistrictNullableScalarRelationFilter, SubdistrictWhereInput> | null
    userLogin?: UserLoginListRelationFilter
    zones?: ZoneListRelationFilter
  }, "id" | "authId" | "email" | "schoolIdentity" | "adminId" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrderInput | SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrderInput | SortOrder
    logoutAt?: SortOrderInput | SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    subdistrictId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    authId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    suspend?: BoolWithAggregatesFilter<"User"> | boolean
    accountType?: EnumAccountTypeWithAggregatesFilter<"User"> | $Enums.AccountType
    firstTest?: BoolWithAggregatesFilter<"User"> | boolean
    fullname?: StringWithAggregatesFilter<"User"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    grade?: IntWithAggregatesFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    schoolIdentity?: StringWithAggregatesFilter<"User"> | string
    loginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    playTime?: IntWithAggregatesFilter<"User"> | number
    characterUsed?: StringWithAggregatesFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    provinceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subdistrictId?: StringNullableWithAggregatesFilter<"User"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringWithAggregatesFilter<"User"> | string
    lastIdZoneUnlocked?: StringWithAggregatesFilter<"User"> | string
    lastIdZonePosition?: StringWithAggregatesFilter<"User"> | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    inGameId?: StringFilter<"Zone"> | string
    posttest?: IntFilter<"Zone"> | number
    posttestTryCount?: IntFilter<"Zone"> | number
    pretest?: IntFilter<"Zone"> | number
    pretestTryCount?: IntFilter<"Zone"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: ZoneUserIdInGameIdCompoundUniqueInput
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    inGameId?: StringFilter<"Zone"> | string
    posttest?: IntFilter<"Zone"> | number
    posttestTryCount?: IntFilter<"Zone"> | number
    pretest?: IntFilter<"Zone"> | number
    pretestTryCount?: IntFilter<"Zone"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    userId?: StringWithAggregatesFilter<"Zone"> | string
    isComplete?: BoolWithAggregatesFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Zone"> | Date | string | null
    lastLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastSubLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastInnerLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastLevelUnlock?: StringWithAggregatesFilter<"Zone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    inGameId?: StringWithAggregatesFilter<"Zone"> | string
    posttest?: IntWithAggregatesFilter<"Zone"> | number
    posttestTryCount?: IntWithAggregatesFilter<"Zone"> | number
    pretest?: IntWithAggregatesFilter<"Zone"> | number
    pretestTryCount?: IntWithAggregatesFilter<"Zone"> | number
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    inGameId?: StringFilter<"Level"> | string
    userId?: StringFilter<"Level"> | string
    zoneInGameId?: StringFilter<"Level"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: LevelUserIdInGameIdCompoundUniqueInput
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    inGameId?: StringFilter<"Level"> | string
    userId?: StringFilter<"Level"> | string
    zoneInGameId?: StringFilter<"Level"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    isUnlock?: BoolWithAggregatesFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"Level"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    inGameId?: StringWithAggregatesFilter<"Level"> | string
    userId?: StringWithAggregatesFilter<"Level"> | string
    zoneInGameId?: StringWithAggregatesFilter<"Level"> | string
  }

  export type SubLevelWhereInput = {
    AND?: SubLevelWhereInput | SubLevelWhereInput[]
    OR?: SubLevelWhereInput[]
    NOT?: SubLevelWhereInput | SubLevelWhereInput[]
    id?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    inGameId?: StringFilter<"SubLevel"> | string
    levelInGameId?: StringFilter<"SubLevel"> | string
    userId?: StringFilter<"SubLevel"> | string
    zoneInGameId?: StringFilter<"SubLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubLevelOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: SubLevelUserIdInGameIdCompoundUniqueInput
    AND?: SubLevelWhereInput | SubLevelWhereInput[]
    OR?: SubLevelWhereInput[]
    NOT?: SubLevelWhereInput | SubLevelWhereInput[]
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    inGameId?: StringFilter<"SubLevel"> | string
    levelInGameId?: StringFilter<"SubLevel"> | string
    userId?: StringFilter<"SubLevel"> | string
    zoneInGameId?: StringFilter<"SubLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type SubLevelOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    _count?: SubLevelCountOrderByAggregateInput
    _max?: SubLevelMaxOrderByAggregateInput
    _min?: SubLevelMinOrderByAggregateInput
  }

  export type SubLevelScalarWhereWithAggregatesInput = {
    AND?: SubLevelScalarWhereWithAggregatesInput | SubLevelScalarWhereWithAggregatesInput[]
    OR?: SubLevelScalarWhereWithAggregatesInput[]
    NOT?: SubLevelScalarWhereWithAggregatesInput | SubLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubLevel"> | string
    isUnlock?: BoolWithAggregatesFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubLevel"> | Date | string
    inGameId?: StringWithAggregatesFilter<"SubLevel"> | string
    levelInGameId?: StringWithAggregatesFilter<"SubLevel"> | string
    userId?: StringWithAggregatesFilter<"SubLevel"> | string
    zoneInGameId?: StringWithAggregatesFilter<"SubLevel"> | string
  }

  export type InnerLevelWhereInput = {
    AND?: InnerLevelWhereInput | InnerLevelWhereInput[]
    OR?: InnerLevelWhereInput[]
    NOT?: InnerLevelWhereInput | InnerLevelWhereInput[]
    id?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatFilter<"InnerLevel"> | number
    playTime?: IntFilter<"InnerLevel"> | number
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    inGameId?: StringFilter<"InnerLevel"> | string
    levelInGameId?: StringFilter<"InnerLevel"> | string
    subLevelInGameId?: StringFilter<"InnerLevel"> | string
    userId?: StringFilter<"InnerLevel"> | string
    zoneInGameId?: StringFilter<"InnerLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InnerLevelOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InnerLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: InnerLevelUserIdInGameIdCompoundUniqueInput
    AND?: InnerLevelWhereInput | InnerLevelWhereInput[]
    OR?: InnerLevelWhereInput[]
    NOT?: InnerLevelWhereInput | InnerLevelWhereInput[]
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatFilter<"InnerLevel"> | number
    playTime?: IntFilter<"InnerLevel"> | number
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    inGameId?: StringFilter<"InnerLevel"> | string
    levelInGameId?: StringFilter<"InnerLevel"> | string
    subLevelInGameId?: StringFilter<"InnerLevel"> | string
    userId?: StringFilter<"InnerLevel"> | string
    zoneInGameId?: StringFilter<"InnerLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type InnerLevelOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    _count?: InnerLevelCountOrderByAggregateInput
    _avg?: InnerLevelAvgOrderByAggregateInput
    _max?: InnerLevelMaxOrderByAggregateInput
    _min?: InnerLevelMinOrderByAggregateInput
    _sum?: InnerLevelSumOrderByAggregateInput
  }

  export type InnerLevelScalarWhereWithAggregatesInput = {
    AND?: InnerLevelScalarWhereWithAggregatesInput | InnerLevelScalarWhereWithAggregatesInput[]
    OR?: InnerLevelScalarWhereWithAggregatesInput[]
    NOT?: InnerLevelScalarWhereWithAggregatesInput | InnerLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InnerLevel"> | string
    isUnlock?: BoolWithAggregatesFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatWithAggregatesFilter<"InnerLevel"> | number
    playTime?: IntWithAggregatesFilter<"InnerLevel"> | number
    point?: IntWithAggregatesFilter<"InnerLevel"> | number
    played?: IntWithAggregatesFilter<"InnerLevel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InnerLevel"> | Date | string
    inGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    levelInGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    subLevelInGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    userId?: StringWithAggregatesFilter<"InnerLevel"> | string
    zoneInGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
  }

  export type GempoWhereInput = {
    AND?: GempoWhereInput | GempoWhereInput[]
    OR?: GempoWhereInput[]
    NOT?: GempoWhereInput | GempoWhereInput[]
    id?: StringFilter<"Gempo"> | string
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    inGameId?: StringFilter<"Gempo"> | string
    userId?: StringFilter<"Gempo"> | string
    zoneInGameId?: StringFilter<"Gempo"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GempoOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GempoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: GempoUserIdInGameIdCompoundUniqueInput
    AND?: GempoWhereInput | GempoWhereInput[]
    OR?: GempoWhereInput[]
    NOT?: GempoWhereInput | GempoWhereInput[]
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    inGameId?: StringFilter<"Gempo"> | string
    userId?: StringFilter<"Gempo"> | string
    zoneInGameId?: StringFilter<"Gempo"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type GempoOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    _count?: GempoCountOrderByAggregateInput
    _max?: GempoMaxOrderByAggregateInput
    _min?: GempoMinOrderByAggregateInput
  }

  export type GempoScalarWhereWithAggregatesInput = {
    AND?: GempoScalarWhereWithAggregatesInput | GempoScalarWhereWithAggregatesInput[]
    OR?: GempoScalarWhereWithAggregatesInput[]
    NOT?: GempoScalarWhereWithAggregatesInput | GempoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gempo"> | string
    isUnlock?: BoolWithAggregatesFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Gempo"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gempo"> | Date | string
    inGameId?: StringWithAggregatesFilter<"Gempo"> | string
    userId?: StringWithAggregatesFilter<"Gempo"> | string
    zoneInGameId?: StringWithAggregatesFilter<"Gempo"> | string
  }

  export type ChampionshipWhereInput = {
    AND?: ChampionshipWhereInput | ChampionshipWhereInput[]
    OR?: ChampionshipWhereInput[]
    NOT?: ChampionshipWhereInput | ChampionshipWhereInput[]
    id?: StringFilter<"Championship"> | string
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    inGameId?: StringFilter<"Championship"> | string
    userId?: StringFilter<"Championship"> | string
    zoneInGameId?: StringFilter<"Championship"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChampionshipOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChampionshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: ChampionshipUserIdInGameIdCompoundUniqueInput
    AND?: ChampionshipWhereInput | ChampionshipWhereInput[]
    OR?: ChampionshipWhereInput[]
    NOT?: ChampionshipWhereInput | ChampionshipWhereInput[]
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    inGameId?: StringFilter<"Championship"> | string
    userId?: StringFilter<"Championship"> | string
    zoneInGameId?: StringFilter<"Championship"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type ChampionshipOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    _count?: ChampionshipCountOrderByAggregateInput
    _max?: ChampionshipMaxOrderByAggregateInput
    _min?: ChampionshipMinOrderByAggregateInput
  }

  export type ChampionshipScalarWhereWithAggregatesInput = {
    AND?: ChampionshipScalarWhereWithAggregatesInput | ChampionshipScalarWhereWithAggregatesInput[]
    OR?: ChampionshipScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipScalarWhereWithAggregatesInput | ChampionshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Championship"> | string
    isUnlock?: BoolWithAggregatesFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Championship"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Championship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Championship"> | Date | string
    inGameId?: StringWithAggregatesFilter<"Championship"> | string
    userId?: StringWithAggregatesFilter<"Championship"> | string
    zoneInGameId?: StringWithAggregatesFilter<"Championship"> | string
  }

  export type GempoRecordWhereInput = {
    AND?: GempoRecordWhereInput | GempoRecordWhereInput[]
    OR?: GempoRecordWhereInput[]
    NOT?: GempoRecordWhereInput | GempoRecordWhereInput[]
    id?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    highestPoint?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    gempoInGameId?: StringFilter<"GempoRecord"> | string
    inGameId?: StringFilter<"GempoRecord"> | string
    userId?: StringFilter<"GempoRecord"> | string
    zoneInGameId?: StringFilter<"GempoRecord"> | string
    correctAttempt?: FloatFilter<"GempoRecord"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GempoRecordOrderByWithRelationInput = {
    id?: SortOrder
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gempoInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    correctAttempt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GempoRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: GempoRecordUserIdInGameIdCompoundUniqueInput
    AND?: GempoRecordWhereInput | GempoRecordWhereInput[]
    OR?: GempoRecordWhereInput[]
    NOT?: GempoRecordWhereInput | GempoRecordWhereInput[]
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    highestPoint?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    gempoInGameId?: StringFilter<"GempoRecord"> | string
    inGameId?: StringFilter<"GempoRecord"> | string
    userId?: StringFilter<"GempoRecord"> | string
    zoneInGameId?: StringFilter<"GempoRecord"> | string
    correctAttempt?: FloatFilter<"GempoRecord"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type GempoRecordOrderByWithAggregationInput = {
    id?: SortOrder
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gempoInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    correctAttempt?: SortOrder
    _count?: GempoRecordCountOrderByAggregateInput
    _avg?: GempoRecordAvgOrderByAggregateInput
    _max?: GempoRecordMaxOrderByAggregateInput
    _min?: GempoRecordMinOrderByAggregateInput
    _sum?: GempoRecordSumOrderByAggregateInput
  }

  export type GempoRecordScalarWhereWithAggregatesInput = {
    AND?: GempoRecordScalarWhereWithAggregatesInput | GempoRecordScalarWhereWithAggregatesInput[]
    OR?: GempoRecordScalarWhereWithAggregatesInput[]
    NOT?: GempoRecordScalarWhereWithAggregatesInput | GempoRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GempoRecord"> | string
    played?: IntWithAggregatesFilter<"GempoRecord"> | number
    point?: IntWithAggregatesFilter<"GempoRecord"> | number
    highestPoint?: IntWithAggregatesFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GempoRecord"> | Date | string
    gempoInGameId?: StringWithAggregatesFilter<"GempoRecord"> | string
    inGameId?: StringWithAggregatesFilter<"GempoRecord"> | string
    userId?: StringWithAggregatesFilter<"GempoRecord"> | string
    zoneInGameId?: StringWithAggregatesFilter<"GempoRecord"> | string
    correctAttempt?: FloatWithAggregatesFilter<"GempoRecord"> | number
  }

  export type ChampionshipRecordWhereInput = {
    AND?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    OR?: ChampionshipRecordWhereInput[]
    NOT?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    id?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    championshipInGameId?: StringFilter<"ChampionshipRecord"> | string
    inGameId?: StringFilter<"ChampionshipRecord"> | string
    userId?: StringFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringFilter<"ChampionshipRecord"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChampionshipRecordOrderByWithRelationInput = {
    id?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrderInput | SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    championshipInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChampionshipRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: ChampionshipRecordUserIdInGameIdCompoundUniqueInput
    AND?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    OR?: ChampionshipRecordWhereInput[]
    NOT?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    championshipInGameId?: StringFilter<"ChampionshipRecord"> | string
    inGameId?: StringFilter<"ChampionshipRecord"> | string
    userId?: StringFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringFilter<"ChampionshipRecord"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type ChampionshipRecordOrderByWithAggregationInput = {
    id?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrderInput | SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    championshipInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    _count?: ChampionshipRecordCountOrderByAggregateInput
    _avg?: ChampionshipRecordAvgOrderByAggregateInput
    _max?: ChampionshipRecordMaxOrderByAggregateInput
    _min?: ChampionshipRecordMinOrderByAggregateInput
    _sum?: ChampionshipRecordSumOrderByAggregateInput
  }

  export type ChampionshipRecordScalarWhereWithAggregatesInput = {
    AND?: ChampionshipRecordScalarWhereWithAggregatesInput | ChampionshipRecordScalarWhereWithAggregatesInput[]
    OR?: ChampionshipRecordScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipRecordScalarWhereWithAggregatesInput | ChampionshipRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    teamWin?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamLose?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamPoint?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloLose?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloPoint?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChampionshipRecord"> | Date | string
    championshipInGameId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    inGameId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    userId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
  }

  export type UserLoginWhereInput = {
    AND?: UserLoginWhereInput | UserLoginWhereInput[]
    OR?: UserLoginWhereInput[]
    NOT?: UserLoginWhereInput | UserLoginWhereInput[]
    id?: StringFilter<"UserLogin"> | string
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLoginOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLoginWhereInput | UserLoginWhereInput[]
    OR?: UserLoginWhereInput[]
    NOT?: UserLoginWhereInput | UserLoginWhereInput[]
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserLoginOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrderInput | SortOrder
    _count?: UserLoginCountOrderByAggregateInput
    _max?: UserLoginMaxOrderByAggregateInput
    _min?: UserLoginMinOrderByAggregateInput
  }

  export type UserLoginScalarWhereWithAggregatesInput = {
    AND?: UserLoginScalarWhereWithAggregatesInput | UserLoginScalarWhereWithAggregatesInput[]
    OR?: UserLoginScalarWhereWithAggregatesInput[]
    NOT?: UserLoginScalarWhereWithAggregatesInput | UserLoginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLogin"> | string
    userId?: StringWithAggregatesFilter<"UserLogin"> | string
    loginDate?: DateTimeWithAggregatesFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableWithAggregatesFilter<"UserLogin"> | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    authId?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    suspend?: BoolFilter<"Admin"> | boolean
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableFilter<"Admin"> | string | null
    cityId?: StringNullableFilter<"Admin"> | string | null
    subdistrictId?: StringNullableFilter<"Admin"> | string | null
    schoolId?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    authenticatorEnabled?: BoolFilter<"Admin"> | boolean
    authenticatorQrUrl?: StringNullableFilter<"Admin"> | string | null
    authenticatorSecret?: StringNullableFilter<"Admin"> | string | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    subdistrict?: XOR<SubdistrictNullableScalarRelationFilter, SubdistrictWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    authority?: AdminAuthorityListRelationFilter
    logs?: AdminLogListRelationFilter
    operationHistories?: AdminOperationHistoryListRelationFilter
    operations?: AdminOperationHistoryListRelationFilter
    transactions?: AdminTransactionListRelationFilter
    transactionProcessed?: AdminTransactionListRelationFilter
    banner?: BannerListRelationFilter
    redeemCodes?: RedeemCodeListRelationFilter
    tests?: TestListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    subdistrictId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authenticatorEnabled?: SortOrder
    authenticatorQrUrl?: SortOrderInput | SortOrder
    authenticatorSecret?: SortOrderInput | SortOrder
    province?: ProvinceOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    subdistrict?: SubdistrictOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    authority?: AdminAuthorityOrderByRelationAggregateInput
    logs?: AdminLogOrderByRelationAggregateInput
    operationHistories?: AdminOperationHistoryOrderByRelationAggregateInput
    operations?: AdminOperationHistoryOrderByRelationAggregateInput
    transactions?: AdminTransactionOrderByRelationAggregateInput
    transactionProcessed?: AdminTransactionOrderByRelationAggregateInput
    banner?: BannerOrderByRelationAggregateInput
    redeemCodes?: RedeemCodeOrderByRelationAggregateInput
    tests?: TestOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    suspend?: BoolFilter<"Admin"> | boolean
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableFilter<"Admin"> | string | null
    cityId?: StringNullableFilter<"Admin"> | string | null
    subdistrictId?: StringNullableFilter<"Admin"> | string | null
    schoolId?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    authenticatorEnabled?: BoolFilter<"Admin"> | boolean
    authenticatorQrUrl?: StringNullableFilter<"Admin"> | string | null
    authenticatorSecret?: StringNullableFilter<"Admin"> | string | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    subdistrict?: XOR<SubdistrictNullableScalarRelationFilter, SubdistrictWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    authority?: AdminAuthorityListRelationFilter
    logs?: AdminLogListRelationFilter
    operationHistories?: AdminOperationHistoryListRelationFilter
    operations?: AdminOperationHistoryListRelationFilter
    transactions?: AdminTransactionListRelationFilter
    transactionProcessed?: AdminTransactionListRelationFilter
    banner?: BannerListRelationFilter
    redeemCodes?: RedeemCodeListRelationFilter
    tests?: TestListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "authId" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    subdistrictId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authenticatorEnabled?: SortOrder
    authenticatorQrUrl?: SortOrderInput | SortOrder
    authenticatorSecret?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    authId?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    suspend?: BoolWithAggregatesFilter<"Admin"> | boolean
    role?: EnumRoleNullableWithAggregatesFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    subdistrictId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    authenticatorEnabled?: BoolWithAggregatesFilter<"Admin"> | boolean
    authenticatorQrUrl?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    authenticatorSecret?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type AdminLogWhereInput = {
    AND?: AdminLogWhereInput | AdminLogWhereInput[]
    OR?: AdminLogWhereInput[]
    NOT?: AdminLogWhereInput | AdminLogWhereInput[]
    id?: StringFilter<"AdminLog"> | string
    ipAddress?: StringNullableFilter<"AdminLog"> | string | null
    old?: JsonNullableFilter<"AdminLog">
    new?: JsonNullableFilter<"AdminLog">
    adminId?: StringFilter<"AdminLog"> | string
    table?: StringNullableFilter<"AdminLog"> | string | null
    operation?: StringNullableFilter<"AdminLog"> | string | null
    createdAt?: DateTimeFilter<"AdminLog"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminLogOrderByWithRelationInput = {
    id?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    old?: SortOrderInput | SortOrder
    new?: SortOrderInput | SortOrder
    adminId?: SortOrder
    table?: SortOrderInput | SortOrder
    operation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type AdminLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminLogWhereInput | AdminLogWhereInput[]
    OR?: AdminLogWhereInput[]
    NOT?: AdminLogWhereInput | AdminLogWhereInput[]
    ipAddress?: StringNullableFilter<"AdminLog"> | string | null
    old?: JsonNullableFilter<"AdminLog">
    new?: JsonNullableFilter<"AdminLog">
    adminId?: StringFilter<"AdminLog"> | string
    table?: StringNullableFilter<"AdminLog"> | string | null
    operation?: StringNullableFilter<"AdminLog"> | string | null
    createdAt?: DateTimeFilter<"AdminLog"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminLogOrderByWithAggregationInput = {
    id?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    old?: SortOrderInput | SortOrder
    new?: SortOrderInput | SortOrder
    adminId?: SortOrder
    table?: SortOrderInput | SortOrder
    operation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminLogCountOrderByAggregateInput
    _max?: AdminLogMaxOrderByAggregateInput
    _min?: AdminLogMinOrderByAggregateInput
  }

  export type AdminLogScalarWhereWithAggregatesInput = {
    AND?: AdminLogScalarWhereWithAggregatesInput | AdminLogScalarWhereWithAggregatesInput[]
    OR?: AdminLogScalarWhereWithAggregatesInput[]
    NOT?: AdminLogScalarWhereWithAggregatesInput | AdminLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"AdminLog"> | string | null
    old?: JsonNullableWithAggregatesFilter<"AdminLog">
    new?: JsonNullableWithAggregatesFilter<"AdminLog">
    adminId?: StringWithAggregatesFilter<"AdminLog"> | string
    table?: StringNullableWithAggregatesFilter<"AdminLog"> | string | null
    operation?: StringNullableWithAggregatesFilter<"AdminLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminLog"> | Date | string
  }

  export type AdminOperationHistoryWhereInput = {
    AND?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    OR?: AdminOperationHistoryWhereInput[]
    NOT?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    opAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminOperationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
    admin?: AdminOrderByWithRelationInput
    opAdmin?: AdminOrderByWithRelationInput
  }

  export type AdminOperationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id_createdAt?: AdminOperationHistoryIdCreatedAtCompoundUniqueInput
    AND?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    OR?: AdminOperationHistoryWhereInput[]
    NOT?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    opAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id_createdAt">

  export type AdminOperationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
    _count?: AdminOperationHistoryCountOrderByAggregateInput
    _max?: AdminOperationHistoryMaxOrderByAggregateInput
    _min?: AdminOperationHistoryMinOrderByAggregateInput
  }

  export type AdminOperationHistoryScalarWhereWithAggregatesInput = {
    AND?: AdminOperationHistoryScalarWhereWithAggregatesInput | AdminOperationHistoryScalarWhereWithAggregatesInput[]
    OR?: AdminOperationHistoryScalarWhereWithAggregatesInput[]
    NOT?: AdminOperationHistoryScalarWhereWithAggregatesInput | AdminOperationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    opAdminId?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationWithAggregatesFilter<"AdminOperationHistory"> | $Enums.Operation
  }

  export type AdminAuthorityWhereInput = {
    AND?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    OR?: AdminAuthorityWhereInput[]
    NOT?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    id?: StringFilter<"AdminAuthority"> | string
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    schools?: SchoolListRelationFilter
  }

  export type AdminAuthorityOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
    admin?: AdminOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
    subdistricts?: SubdistrictOrderByRelationAggregateInput
    schools?: SchoolOrderByRelationAggregateInput
  }

  export type AdminAuthorityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    OR?: AdminAuthorityWhereInput[]
    NOT?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    schools?: SchoolListRelationFilter
  }, "id">

  export type AdminAuthorityOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
    _count?: AdminAuthorityCountOrderByAggregateInput
    _avg?: AdminAuthorityAvgOrderByAggregateInput
    _max?: AdminAuthorityMaxOrderByAggregateInput
    _min?: AdminAuthorityMinOrderByAggregateInput
    _sum?: AdminAuthoritySumOrderByAggregateInput
  }

  export type AdminAuthorityScalarWhereWithAggregatesInput = {
    AND?: AdminAuthorityScalarWhereWithAggregatesInput | AdminAuthorityScalarWhereWithAggregatesInput[]
    OR?: AdminAuthorityScalarWhereWithAggregatesInput[]
    NOT?: AdminAuthorityScalarWhereWithAggregatesInput | AdminAuthorityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuthority"> | string
    adminId?: StringWithAggregatesFilter<"AdminAuthority"> | string
    provinceId?: StringWithAggregatesFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    lastBroadcastedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    adminId?: StringFilter<"Banner"> | string
    thumbnailId?: StringFilter<"Banner"> | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    provincies?: ProvinceListRelationFilter
    cities?: CityListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    visitors?: BannerVisitorListRelationFilter
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    isHide?: SortOrder
    lastBroadcastedAt?: SortOrderInput | SortOrder
    adminId?: SortOrder
    thumbnailId?: SortOrder
    admin?: AdminOrderByWithRelationInput
    provincies?: ProvinceOrderByRelationAggregateInput
    cities?: CityOrderByRelationAggregateInput
    subdistricts?: SubdistrictOrderByRelationAggregateInput
    visitors?: BannerVisitorOrderByRelationAggregateInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    lastBroadcastedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    adminId?: StringFilter<"Banner"> | string
    thumbnailId?: StringFilter<"Banner"> | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    provincies?: ProvinceListRelationFilter
    cities?: CityListRelationFilter
    subdistricts?: SubdistrictListRelationFilter
    visitors?: BannerVisitorListRelationFilter
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    isHide?: SortOrder
    lastBroadcastedAt?: SortOrderInput | SortOrder
    adminId?: SortOrder
    thumbnailId?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    thumbnail?: StringWithAggregatesFilter<"Banner"> | string
    link?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    isHide?: BoolWithAggregatesFilter<"Banner"> | boolean
    lastBroadcastedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    adminId?: StringWithAggregatesFilter<"Banner"> | string
    thumbnailId?: StringWithAggregatesFilter<"Banner"> | string
  }

  export type BannerVisitorWhereInput = {
    AND?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    OR?: BannerVisitorWhereInput[]
    NOT?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    id?: StringFilter<"BannerVisitor"> | string
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BannerVisitorOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
    banner?: BannerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BannerVisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bannerId_userId?: BannerVisitorBannerIdUserIdCompoundUniqueInput
    AND?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    OR?: BannerVisitorWhereInput[]
    NOT?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bannerId_userId">

  export type BannerVisitorOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
    _count?: BannerVisitorCountOrderByAggregateInput
    _avg?: BannerVisitorAvgOrderByAggregateInput
    _max?: BannerVisitorMaxOrderByAggregateInput
    _min?: BannerVisitorMinOrderByAggregateInput
    _sum?: BannerVisitorSumOrderByAggregateInput
  }

  export type BannerVisitorScalarWhereWithAggregatesInput = {
    AND?: BannerVisitorScalarWhereWithAggregatesInput | BannerVisitorScalarWhereWithAggregatesInput[]
    OR?: BannerVisitorScalarWhereWithAggregatesInput[]
    NOT?: BannerVisitorScalarWhereWithAggregatesInput | BannerVisitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerVisitor"> | string
    bannerId?: StringWithAggregatesFilter<"BannerVisitor"> | string
    userId?: StringWithAggregatesFilter<"BannerVisitor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BannerVisitor"> | Date | string
    traffic?: IntWithAggregatesFilter<"BannerVisitor"> | number
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    id?: StringFilter<"Test"> | string
    name?: StringFilter<"Test"> | string
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    category?: EnumRoleFilter<"Test"> | $Enums.Role
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    adminId?: StringFilter<"Test"> | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    participants?: TestParticipantListRelationFilter
  }

  export type TestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    admin?: AdminOrderByWithRelationInput
    participants?: TestParticipantOrderByRelationAggregateInput
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    name?: StringFilter<"Test"> | string
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    category?: EnumRoleFilter<"Test"> | $Enums.Role
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    adminId?: StringFilter<"Test"> | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    participants?: TestParticipantListRelationFilter
  }, "id">

  export type TestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Test"> | string
    name?: StringWithAggregatesFilter<"Test"> | string
    question?: EnumQuestionTypeWithAggregatesFilter<"Test"> | $Enums.QuestionType
    duration?: IntWithAggregatesFilter<"Test"> | number
    passedPoint?: IntWithAggregatesFilter<"Test"> | number
    remidialCount?: IntWithAggregatesFilter<"Test"> | number
    type?: EnumTestTypeWithAggregatesFilter<"Test"> | $Enums.TestType
    quota?: IntWithAggregatesFilter<"Test"> | number
    currentQuota?: IntWithAggregatesFilter<"Test"> | number
    code?: StringNullableWithAggregatesFilter<"Test"> | string | null
    zoneId?: StringNullableWithAggregatesFilter<"Test"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Test"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Test"> | string | null
    category?: EnumRoleWithAggregatesFilter<"Test"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    adminId?: StringWithAggregatesFilter<"Test"> | string
  }

  export type TestParticipantWhereInput = {
    AND?: TestParticipantWhereInput | TestParticipantWhereInput[]
    OR?: TestParticipantWhereInput[]
    NOT?: TestParticipantWhereInput | TestParticipantWhereInput[]
    id?: StringFilter<"TestParticipant"> | string
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    records?: TestParticipantRecordListRelationFilter
  }

  export type TestParticipantOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    test?: TestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    records?: TestParticipantRecordOrderByRelationAggregateInput
  }

  export type TestParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    testId_userId?: TestParticipantTestIdUserIdCompoundUniqueInput
    AND?: TestParticipantWhereInput | TestParticipantWhereInput[]
    OR?: TestParticipantWhereInput[]
    NOT?: TestParticipantWhereInput | TestParticipantWhereInput[]
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    records?: TestParticipantRecordListRelationFilter
  }, "id" | "testId_userId">

  export type TestParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    _count?: TestParticipantCountOrderByAggregateInput
    _avg?: TestParticipantAvgOrderByAggregateInput
    _max?: TestParticipantMaxOrderByAggregateInput
    _min?: TestParticipantMinOrderByAggregateInput
    _sum?: TestParticipantSumOrderByAggregateInput
  }

  export type TestParticipantScalarWhereWithAggregatesInput = {
    AND?: TestParticipantScalarWhereWithAggregatesInput | TestParticipantScalarWhereWithAggregatesInput[]
    OR?: TestParticipantScalarWhereWithAggregatesInput[]
    NOT?: TestParticipantScalarWhereWithAggregatesInput | TestParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParticipant"> | string
    testId?: StringWithAggregatesFilter<"TestParticipant"> | string
    userId?: StringWithAggregatesFilter<"TestParticipant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParticipant"> | Date | string
    highscore?: FloatWithAggregatesFilter<"TestParticipant"> | number
  }

  export type TestParticipantRecordWhereInput = {
    AND?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    OR?: TestParticipantRecordWhereInput[]
    NOT?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    id?: StringFilter<"TestParticipantRecord"> | string
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonFilter<"TestParticipantRecord">
    participant?: XOR<TestParticipantScalarRelationFilter, TestParticipantWhereInput>
  }

  export type TestParticipantRecordOrderByWithRelationInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answers?: SortOrder
    participant?: TestParticipantOrderByWithRelationInput
  }

  export type TestParticipantRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    OR?: TestParticipantRecordWhereInput[]
    NOT?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonFilter<"TestParticipantRecord">
    participant?: XOR<TestParticipantScalarRelationFilter, TestParticipantWhereInput>
  }, "id">

  export type TestParticipantRecordOrderByWithAggregationInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answers?: SortOrder
    _count?: TestParticipantRecordCountOrderByAggregateInput
    _avg?: TestParticipantRecordAvgOrderByAggregateInput
    _max?: TestParticipantRecordMaxOrderByAggregateInput
    _min?: TestParticipantRecordMinOrderByAggregateInput
    _sum?: TestParticipantRecordSumOrderByAggregateInput
  }

  export type TestParticipantRecordScalarWhereWithAggregatesInput = {
    AND?: TestParticipantRecordScalarWhereWithAggregatesInput | TestParticipantRecordScalarWhereWithAggregatesInput[]
    OR?: TestParticipantRecordScalarWhereWithAggregatesInput[]
    NOT?: TestParticipantRecordScalarWhereWithAggregatesInput | TestParticipantRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    participantId?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatWithAggregatesFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonWithAggregatesFilter<"TestParticipantRecord">
  }

  export type BackgroundWhereInput = {
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    id?: StringFilter<"Background"> | string
    name?: StringFilter<"Background"> | string
    thumbnail?: StringFilter<"Background"> | string
    isUse?: BoolFilter<"Background"> | boolean
    createdAt?: DateTimeFilter<"Background"> | Date | string
    updatedAt?: DateTimeFilter<"Background"> | Date | string
    thumbnailId?: StringFilter<"Background"> | string
  }

  export type BackgroundOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailId?: SortOrder
  }

  export type BackgroundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    name?: StringFilter<"Background"> | string
    thumbnail?: StringFilter<"Background"> | string
    isUse?: BoolFilter<"Background"> | boolean
    createdAt?: DateTimeFilter<"Background"> | Date | string
    updatedAt?: DateTimeFilter<"Background"> | Date | string
    thumbnailId?: StringFilter<"Background"> | string
  }, "id">

  export type BackgroundOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailId?: SortOrder
    _count?: BackgroundCountOrderByAggregateInput
    _max?: BackgroundMaxOrderByAggregateInput
    _min?: BackgroundMinOrderByAggregateInput
  }

  export type BackgroundScalarWhereWithAggregatesInput = {
    AND?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    OR?: BackgroundScalarWhereWithAggregatesInput[]
    NOT?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Background"> | string
    name?: StringWithAggregatesFilter<"Background"> | string
    thumbnail?: StringWithAggregatesFilter<"Background"> | string
    isUse?: BoolWithAggregatesFilter<"Background"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Background"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Background"> | Date | string
    thumbnailId?: StringWithAggregatesFilter<"Background"> | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    name?: StringFilter<"Setting"> | string
    title?: StringFilter<"Setting"> | string
    content?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    name?: StringFilter<"Setting"> | string
    title?: StringFilter<"Setting"> | string
    content?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    name?: StringWithAggregatesFilter<"Setting"> | string
    title?: StringWithAggregatesFilter<"Setting"> | string
    content?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type AdminTransactionWhereInput = {
    AND?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    OR?: AdminTransactionWhereInput[]
    NOT?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    id?: StringFilter<"AdminTransaction"> | string
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    quantity?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    adminId?: StringFilter<"AdminTransaction"> | string
    amount?: IntFilter<"AdminTransaction"> | number
    archived?: BoolFilter<"AdminTransaction"> | boolean
    description?: StringNullableFilter<"AdminTransaction"> | string | null
    name?: StringFilter<"AdminTransaction"> | string
    subscriptionTime?: IntFilter<"AdminTransaction"> | number
    transactionImageId?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionRef?: StringNullableFilter<"AdminTransaction"> | string | null
    status?: EnumTransactionFilter<"AdminTransaction"> | $Enums.Transaction
    processedAt?: DateTimeNullableFilter<"AdminTransaction"> | Date | string | null
    processedById?: StringNullableFilter<"AdminTransaction"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    processedBy?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    redeemCode?: XOR<RedeemCodeNullableScalarRelationFilter, RedeemCodeWhereInput> | null
  }

  export type AdminTransactionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    adminId?: SortOrder
    amount?: SortOrder
    archived?: SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrder
    subscriptionTime?: SortOrder
    transactionImageId?: SortOrderInput | SortOrder
    transactionImageUrl?: SortOrderInput | SortOrder
    transactionRef?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    processedBy?: AdminOrderByWithRelationInput
    redeemCode?: RedeemCodeOrderByWithRelationInput
  }

  export type AdminTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    OR?: AdminTransactionWhereInput[]
    NOT?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    quantity?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    adminId?: StringFilter<"AdminTransaction"> | string
    amount?: IntFilter<"AdminTransaction"> | number
    archived?: BoolFilter<"AdminTransaction"> | boolean
    description?: StringNullableFilter<"AdminTransaction"> | string | null
    name?: StringFilter<"AdminTransaction"> | string
    subscriptionTime?: IntFilter<"AdminTransaction"> | number
    transactionImageId?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionRef?: StringNullableFilter<"AdminTransaction"> | string | null
    status?: EnumTransactionFilter<"AdminTransaction"> | $Enums.Transaction
    processedAt?: DateTimeNullableFilter<"AdminTransaction"> | Date | string | null
    processedById?: StringNullableFilter<"AdminTransaction"> | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    processedBy?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    redeemCode?: XOR<RedeemCodeNullableScalarRelationFilter, RedeemCodeWhereInput> | null
  }, "id">

  export type AdminTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    adminId?: SortOrder
    amount?: SortOrder
    archived?: SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrder
    subscriptionTime?: SortOrder
    transactionImageId?: SortOrderInput | SortOrder
    transactionImageUrl?: SortOrderInput | SortOrder
    transactionRef?: SortOrderInput | SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    _count?: AdminTransactionCountOrderByAggregateInput
    _avg?: AdminTransactionAvgOrderByAggregateInput
    _max?: AdminTransactionMaxOrderByAggregateInput
    _min?: AdminTransactionMinOrderByAggregateInput
    _sum?: AdminTransactionSumOrderByAggregateInput
  }

  export type AdminTransactionScalarWhereWithAggregatesInput = {
    AND?: AdminTransactionScalarWhereWithAggregatesInput | AdminTransactionScalarWhereWithAggregatesInput[]
    OR?: AdminTransactionScalarWhereWithAggregatesInput[]
    NOT?: AdminTransactionScalarWhereWithAggregatesInput | AdminTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    quantity?: IntWithAggregatesFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    adminId?: StringWithAggregatesFilter<"AdminTransaction"> | string
    amount?: IntWithAggregatesFilter<"AdminTransaction"> | number
    archived?: BoolWithAggregatesFilter<"AdminTransaction"> | boolean
    description?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    name?: StringWithAggregatesFilter<"AdminTransaction"> | string
    subscriptionTime?: IntWithAggregatesFilter<"AdminTransaction"> | number
    transactionImageId?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    transactionRef?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    status?: EnumTransactionWithAggregatesFilter<"AdminTransaction"> | $Enums.Transaction
    processedAt?: DateTimeNullableWithAggregatesFilter<"AdminTransaction"> | Date | string | null
    processedById?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
  }

  export type RedeemCodeWhereInput = {
    AND?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    OR?: RedeemCodeWhereInput[]
    NOT?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    id?: StringFilter<"RedeemCode"> | string
    transactionId?: StringFilter<"RedeemCode"> | string
    adminId?: StringFilter<"RedeemCode"> | string
    code?: StringFilter<"RedeemCode"> | string
    expiredAt?: DateTimeNullableFilter<"RedeemCode"> | Date | string | null
    currentAmount?: IntFilter<"RedeemCode"> | number
    maxAmount?: IntFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeFilter<"RedeemCode"> | Date | string
    suspend?: BoolFilter<"RedeemCode"> | boolean
    redeemers?: CodeRedeemerListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    transaction?: XOR<AdminTransactionScalarRelationFilter, AdminTransactionWhereInput>
  }

  export type RedeemCodeOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspend?: SortOrder
    redeemers?: CodeRedeemerOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    transaction?: AdminTransactionOrderByWithRelationInput
  }

  export type RedeemCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    code?: string
    AND?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    OR?: RedeemCodeWhereInput[]
    NOT?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    adminId?: StringFilter<"RedeemCode"> | string
    expiredAt?: DateTimeNullableFilter<"RedeemCode"> | Date | string | null
    currentAmount?: IntFilter<"RedeemCode"> | number
    maxAmount?: IntFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeFilter<"RedeemCode"> | Date | string
    suspend?: BoolFilter<"RedeemCode"> | boolean
    redeemers?: CodeRedeemerListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    transaction?: XOR<AdminTransactionScalarRelationFilter, AdminTransactionWhereInput>
  }, "id" | "transactionId" | "code">

  export type RedeemCodeOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspend?: SortOrder
    _count?: RedeemCodeCountOrderByAggregateInput
    _avg?: RedeemCodeAvgOrderByAggregateInput
    _max?: RedeemCodeMaxOrderByAggregateInput
    _min?: RedeemCodeMinOrderByAggregateInput
    _sum?: RedeemCodeSumOrderByAggregateInput
  }

  export type RedeemCodeScalarWhereWithAggregatesInput = {
    AND?: RedeemCodeScalarWhereWithAggregatesInput | RedeemCodeScalarWhereWithAggregatesInput[]
    OR?: RedeemCodeScalarWhereWithAggregatesInput[]
    NOT?: RedeemCodeScalarWhereWithAggregatesInput | RedeemCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RedeemCode"> | string
    transactionId?: StringWithAggregatesFilter<"RedeemCode"> | string
    adminId?: StringWithAggregatesFilter<"RedeemCode"> | string
    code?: StringWithAggregatesFilter<"RedeemCode"> | string
    expiredAt?: DateTimeNullableWithAggregatesFilter<"RedeemCode"> | Date | string | null
    currentAmount?: IntWithAggregatesFilter<"RedeemCode"> | number
    maxAmount?: IntWithAggregatesFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeWithAggregatesFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RedeemCode"> | Date | string
    suspend?: BoolWithAggregatesFilter<"RedeemCode"> | boolean
  }

  export type CodeRedeemerWhereInput = {
    AND?: CodeRedeemerWhereInput | CodeRedeemerWhereInput[]
    OR?: CodeRedeemerWhereInput[]
    NOT?: CodeRedeemerWhereInput | CodeRedeemerWhereInput[]
    id?: StringFilter<"CodeRedeemer"> | string
    banned?: BoolFilter<"CodeRedeemer"> | boolean
    userId?: StringFilter<"CodeRedeemer"> | string
    codeId?: StringFilter<"CodeRedeemer"> | string
    createdAt?: DateTimeFilter<"CodeRedeemer"> | Date | string
    updatedAt?: DateTimeFilter<"CodeRedeemer"> | Date | string
    code?: XOR<RedeemCodeScalarRelationFilter, RedeemCodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CodeRedeemerOrderByWithRelationInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: RedeemCodeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CodeRedeemerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_userId?: CodeRedeemerIdUserIdCompoundUniqueInput
    codeId_userId?: CodeRedeemerCodeIdUserIdCompoundUniqueInput
    AND?: CodeRedeemerWhereInput | CodeRedeemerWhereInput[]
    OR?: CodeRedeemerWhereInput[]
    NOT?: CodeRedeemerWhereInput | CodeRedeemerWhereInput[]
    banned?: BoolFilter<"CodeRedeemer"> | boolean
    userId?: StringFilter<"CodeRedeemer"> | string
    codeId?: StringFilter<"CodeRedeemer"> | string
    createdAt?: DateTimeFilter<"CodeRedeemer"> | Date | string
    updatedAt?: DateTimeFilter<"CodeRedeemer"> | Date | string
    code?: XOR<RedeemCodeScalarRelationFilter, RedeemCodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id_userId" | "codeId_userId">

  export type CodeRedeemerOrderByWithAggregationInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodeRedeemerCountOrderByAggregateInput
    _max?: CodeRedeemerMaxOrderByAggregateInput
    _min?: CodeRedeemerMinOrderByAggregateInput
  }

  export type CodeRedeemerScalarWhereWithAggregatesInput = {
    AND?: CodeRedeemerScalarWhereWithAggregatesInput | CodeRedeemerScalarWhereWithAggregatesInput[]
    OR?: CodeRedeemerScalarWhereWithAggregatesInput[]
    NOT?: CodeRedeemerScalarWhereWithAggregatesInput | CodeRedeemerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CodeRedeemer"> | string
    banned?: BoolWithAggregatesFilter<"CodeRedeemer"> | boolean
    userId?: StringWithAggregatesFilter<"CodeRedeemer"> | string
    codeId?: StringWithAggregatesFilter<"CodeRedeemer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CodeRedeemer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CodeRedeemer"> | Date | string
  }

  export type ChampionshipMatchWhereInput = {
    AND?: ChampionshipMatchWhereInput | ChampionshipMatchWhereInput[]
    OR?: ChampionshipMatchWhereInput[]
    NOT?: ChampionshipMatchWhereInput | ChampionshipMatchWhereInput[]
    id?: StringFilter<"ChampionshipMatch"> | string
    max?: IntFilter<"ChampionshipMatch"> | number
    zoneInGameId?: StringFilter<"ChampionshipMatch"> | string
    gameplayId?: StringFilter<"ChampionshipMatch"> | string
    botOwner?: StringNullableFilter<"ChampionshipMatch"> | string | null
    mode?: EnumMatchModeFilter<"ChampionshipMatch"> | $Enums.MatchMode
    endTime?: IntFilter<"ChampionshipMatch"> | number
    startedAt?: DateTimeNullableFilter<"ChampionshipMatch"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"ChampionshipMatch"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"ChampionshipMatch"> | Date | string | null
    isStarted?: BoolFilter<"ChampionshipMatch"> | boolean
    isEnded?: BoolFilter<"ChampionshipMatch"> | boolean
    createdAt?: DateTimeFilter<"ChampionshipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipMatch"> | Date | string
    currentMember?: IntFilter<"ChampionshipMatch"> | number
    members?: MatchMemberListRelationFilter
  }

  export type ChampionshipMatchOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrderInput | SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
    members?: MatchMemberOrderByRelationAggregateInput
  }

  export type ChampionshipMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChampionshipMatchWhereInput | ChampionshipMatchWhereInput[]
    OR?: ChampionshipMatchWhereInput[]
    NOT?: ChampionshipMatchWhereInput | ChampionshipMatchWhereInput[]
    max?: IntFilter<"ChampionshipMatch"> | number
    zoneInGameId?: StringFilter<"ChampionshipMatch"> | string
    gameplayId?: StringFilter<"ChampionshipMatch"> | string
    botOwner?: StringNullableFilter<"ChampionshipMatch"> | string | null
    mode?: EnumMatchModeFilter<"ChampionshipMatch"> | $Enums.MatchMode
    endTime?: IntFilter<"ChampionshipMatch"> | number
    startedAt?: DateTimeNullableFilter<"ChampionshipMatch"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"ChampionshipMatch"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"ChampionshipMatch"> | Date | string | null
    isStarted?: BoolFilter<"ChampionshipMatch"> | boolean
    isEnded?: BoolFilter<"ChampionshipMatch"> | boolean
    createdAt?: DateTimeFilter<"ChampionshipMatch"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipMatch"> | Date | string
    currentMember?: IntFilter<"ChampionshipMatch"> | number
    members?: MatchMemberListRelationFilter
  }, "id">

  export type ChampionshipMatchOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrderInput | SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
    _count?: ChampionshipMatchCountOrderByAggregateInput
    _avg?: ChampionshipMatchAvgOrderByAggregateInput
    _max?: ChampionshipMatchMaxOrderByAggregateInput
    _min?: ChampionshipMatchMinOrderByAggregateInput
    _sum?: ChampionshipMatchSumOrderByAggregateInput
  }

  export type ChampionshipMatchScalarWhereWithAggregatesInput = {
    AND?: ChampionshipMatchScalarWhereWithAggregatesInput | ChampionshipMatchScalarWhereWithAggregatesInput[]
    OR?: ChampionshipMatchScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipMatchScalarWhereWithAggregatesInput | ChampionshipMatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChampionshipMatch"> | string
    max?: IntWithAggregatesFilter<"ChampionshipMatch"> | number
    zoneInGameId?: StringWithAggregatesFilter<"ChampionshipMatch"> | string
    gameplayId?: StringWithAggregatesFilter<"ChampionshipMatch"> | string
    botOwner?: StringNullableWithAggregatesFilter<"ChampionshipMatch"> | string | null
    mode?: EnumMatchModeWithAggregatesFilter<"ChampionshipMatch"> | $Enums.MatchMode
    endTime?: IntWithAggregatesFilter<"ChampionshipMatch"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipMatch"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipMatch"> | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipMatch"> | Date | string | null
    isStarted?: BoolWithAggregatesFilter<"ChampionshipMatch"> | boolean
    isEnded?: BoolWithAggregatesFilter<"ChampionshipMatch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChampionshipMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChampionshipMatch"> | Date | string
    currentMember?: IntWithAggregatesFilter<"ChampionshipMatch"> | number
  }

  export type MatchMemberWhereInput = {
    AND?: MatchMemberWhereInput | MatchMemberWhereInput[]
    OR?: MatchMemberWhereInput[]
    NOT?: MatchMemberWhereInput | MatchMemberWhereInput[]
    id?: StringFilter<"MatchMember"> | string
    roomId?: StringFilter<"MatchMember"> | string
    userId?: StringFilter<"MatchMember"> | string
    slot?: IntFilter<"MatchMember"> | number
    status?: EnumMatchStatusFilter<"MatchMember"> | $Enums.MatchStatus
    answerPoint?: IntFilter<"MatchMember"> | number
    point?: IntFilter<"MatchMember"> | number
    bonusPoint?: IntFilter<"MatchMember"> | number
    teamType?: EnumTeamTypeFilter<"MatchMember"> | $Enums.TeamType
    isReady?: BoolFilter<"MatchMember"> | boolean
    isComplete?: BoolFilter<"MatchMember"> | boolean
    isBot?: BoolFilter<"MatchMember"> | boolean
    joinedAt?: DateTimeFilter<"MatchMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MatchMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MatchMember"> | boolean
    room?: XOR<ChampionshipMatchScalarRelationFilter, ChampionshipMatchWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MatchMemberOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    room?: ChampionshipMatchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MatchMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_slot?: MatchMemberRoomIdSlotCompoundUniqueInput
    roomId_userId?: MatchMemberRoomIdUserIdCompoundUniqueInput
    AND?: MatchMemberWhereInput | MatchMemberWhereInput[]
    OR?: MatchMemberWhereInput[]
    NOT?: MatchMemberWhereInput | MatchMemberWhereInput[]
    roomId?: StringFilter<"MatchMember"> | string
    userId?: StringFilter<"MatchMember"> | string
    slot?: IntFilter<"MatchMember"> | number
    status?: EnumMatchStatusFilter<"MatchMember"> | $Enums.MatchStatus
    answerPoint?: IntFilter<"MatchMember"> | number
    point?: IntFilter<"MatchMember"> | number
    bonusPoint?: IntFilter<"MatchMember"> | number
    teamType?: EnumTeamTypeFilter<"MatchMember"> | $Enums.TeamType
    isReady?: BoolFilter<"MatchMember"> | boolean
    isComplete?: BoolFilter<"MatchMember"> | boolean
    isBot?: BoolFilter<"MatchMember"> | boolean
    joinedAt?: DateTimeFilter<"MatchMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MatchMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MatchMember"> | boolean
    room?: XOR<ChampionshipMatchScalarRelationFilter, ChampionshipMatchWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "roomId_slot" | "roomId_userId">

  export type MatchMemberOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    _count?: MatchMemberCountOrderByAggregateInput
    _avg?: MatchMemberAvgOrderByAggregateInput
    _max?: MatchMemberMaxOrderByAggregateInput
    _min?: MatchMemberMinOrderByAggregateInput
    _sum?: MatchMemberSumOrderByAggregateInput
  }

  export type MatchMemberScalarWhereWithAggregatesInput = {
    AND?: MatchMemberScalarWhereWithAggregatesInput | MatchMemberScalarWhereWithAggregatesInput[]
    OR?: MatchMemberScalarWhereWithAggregatesInput[]
    NOT?: MatchMemberScalarWhereWithAggregatesInput | MatchMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchMember"> | string
    roomId?: StringWithAggregatesFilter<"MatchMember"> | string
    userId?: StringWithAggregatesFilter<"MatchMember"> | string
    slot?: IntWithAggregatesFilter<"MatchMember"> | number
    status?: EnumMatchStatusWithAggregatesFilter<"MatchMember"> | $Enums.MatchStatus
    answerPoint?: IntWithAggregatesFilter<"MatchMember"> | number
    point?: IntWithAggregatesFilter<"MatchMember"> | number
    bonusPoint?: IntWithAggregatesFilter<"MatchMember"> | number
    teamType?: EnumTeamTypeWithAggregatesFilter<"MatchMember"> | $Enums.TeamType
    isReady?: BoolWithAggregatesFilter<"MatchMember"> | boolean
    isComplete?: BoolWithAggregatesFilter<"MatchMember"> | boolean
    isBot?: BoolWithAggregatesFilter<"MatchMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"MatchMember"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"MatchMember"> | Date | string | null
    isDisconnect?: BoolWithAggregatesFilter<"MatchMember"> | boolean
  }

  export type ChampionshipHistoryWhereInput = {
    AND?: ChampionshipHistoryWhereInput | ChampionshipHistoryWhereInput[]
    OR?: ChampionshipHistoryWhereInput[]
    NOT?: ChampionshipHistoryWhereInput | ChampionshipHistoryWhereInput[]
    id?: StringFilter<"ChampionshipHistory"> | string
    max?: IntFilter<"ChampionshipHistory"> | number
    zoneInGameId?: StringFilter<"ChampionshipHistory"> | string
    gameplayId?: StringFilter<"ChampionshipHistory"> | string
    botOwner?: StringNullableFilter<"ChampionshipHistory"> | string | null
    currentPoint?: IntNullableListFilter<"ChampionshipHistory">
    mode?: EnumMatchModeFilter<"ChampionshipHistory"> | $Enums.MatchMode
    endTime?: IntFilter<"ChampionshipHistory"> | number
    startedAt?: DateTimeNullableFilter<"ChampionshipHistory"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"ChampionshipHistory"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"ChampionshipHistory"> | Date | string | null
    isStarted?: BoolFilter<"ChampionshipHistory"> | boolean
    isEnded?: BoolFilter<"ChampionshipHistory"> | boolean
    createdAt?: DateTimeFilter<"ChampionshipHistory"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipHistory"> | Date | string
    currentMember?: IntFilter<"ChampionshipHistory"> | number
    members?: MatchHistoryMemberListRelationFilter
  }

  export type ChampionshipHistoryOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrderInput | SortOrder
    currentPoint?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
    members?: MatchHistoryMemberOrderByRelationAggregateInput
  }

  export type ChampionshipHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChampionshipHistoryWhereInput | ChampionshipHistoryWhereInput[]
    OR?: ChampionshipHistoryWhereInput[]
    NOT?: ChampionshipHistoryWhereInput | ChampionshipHistoryWhereInput[]
    max?: IntFilter<"ChampionshipHistory"> | number
    zoneInGameId?: StringFilter<"ChampionshipHistory"> | string
    gameplayId?: StringFilter<"ChampionshipHistory"> | string
    botOwner?: StringNullableFilter<"ChampionshipHistory"> | string | null
    currentPoint?: IntNullableListFilter<"ChampionshipHistory">
    mode?: EnumMatchModeFilter<"ChampionshipHistory"> | $Enums.MatchMode
    endTime?: IntFilter<"ChampionshipHistory"> | number
    startedAt?: DateTimeNullableFilter<"ChampionshipHistory"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"ChampionshipHistory"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"ChampionshipHistory"> | Date | string | null
    isStarted?: BoolFilter<"ChampionshipHistory"> | boolean
    isEnded?: BoolFilter<"ChampionshipHistory"> | boolean
    createdAt?: DateTimeFilter<"ChampionshipHistory"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipHistory"> | Date | string
    currentMember?: IntFilter<"ChampionshipHistory"> | number
    members?: MatchHistoryMemberListRelationFilter
  }, "id">

  export type ChampionshipHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrderInput | SortOrder
    currentPoint?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
    _count?: ChampionshipHistoryCountOrderByAggregateInput
    _avg?: ChampionshipHistoryAvgOrderByAggregateInput
    _max?: ChampionshipHistoryMaxOrderByAggregateInput
    _min?: ChampionshipHistoryMinOrderByAggregateInput
    _sum?: ChampionshipHistorySumOrderByAggregateInput
  }

  export type ChampionshipHistoryScalarWhereWithAggregatesInput = {
    AND?: ChampionshipHistoryScalarWhereWithAggregatesInput | ChampionshipHistoryScalarWhereWithAggregatesInput[]
    OR?: ChampionshipHistoryScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipHistoryScalarWhereWithAggregatesInput | ChampionshipHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChampionshipHistory"> | string
    max?: IntWithAggregatesFilter<"ChampionshipHistory"> | number
    zoneInGameId?: StringWithAggregatesFilter<"ChampionshipHistory"> | string
    gameplayId?: StringWithAggregatesFilter<"ChampionshipHistory"> | string
    botOwner?: StringNullableWithAggregatesFilter<"ChampionshipHistory"> | string | null
    currentPoint?: IntNullableListFilter<"ChampionshipHistory">
    mode?: EnumMatchModeWithAggregatesFilter<"ChampionshipHistory"> | $Enums.MatchMode
    endTime?: IntWithAggregatesFilter<"ChampionshipHistory"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipHistory"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipHistory"> | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipHistory"> | Date | string | null
    isStarted?: BoolWithAggregatesFilter<"ChampionshipHistory"> | boolean
    isEnded?: BoolWithAggregatesFilter<"ChampionshipHistory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChampionshipHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChampionshipHistory"> | Date | string
    currentMember?: IntWithAggregatesFilter<"ChampionshipHistory"> | number
  }

  export type MatchHistoryMemberWhereInput = {
    AND?: MatchHistoryMemberWhereInput | MatchHistoryMemberWhereInput[]
    OR?: MatchHistoryMemberWhereInput[]
    NOT?: MatchHistoryMemberWhereInput | MatchHistoryMemberWhereInput[]
    id?: StringFilter<"MatchHistoryMember"> | string
    roomId?: StringFilter<"MatchHistoryMember"> | string
    userId?: StringFilter<"MatchHistoryMember"> | string
    slot?: IntFilter<"MatchHistoryMember"> | number
    status?: EnumMatchStatusFilter<"MatchHistoryMember"> | $Enums.MatchStatus
    point?: IntFilter<"MatchHistoryMember"> | number
    bonusPoint?: IntFilter<"MatchHistoryMember"> | number
    teamType?: EnumTeamTypeFilter<"MatchHistoryMember"> | $Enums.TeamType
    isReady?: BoolFilter<"MatchHistoryMember"> | boolean
    isComplete?: BoolFilter<"MatchHistoryMember"> | boolean
    isBot?: BoolFilter<"MatchHistoryMember"> | boolean
    joinedAt?: DateTimeFilter<"MatchHistoryMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MatchHistoryMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MatchHistoryMember"> | boolean
    room?: XOR<ChampionshipHistoryScalarRelationFilter, ChampionshipHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MatchHistoryMemberOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    room?: ChampionshipHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MatchHistoryMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchHistoryMemberWhereInput | MatchHistoryMemberWhereInput[]
    OR?: MatchHistoryMemberWhereInput[]
    NOT?: MatchHistoryMemberWhereInput | MatchHistoryMemberWhereInput[]
    roomId?: StringFilter<"MatchHistoryMember"> | string
    userId?: StringFilter<"MatchHistoryMember"> | string
    slot?: IntFilter<"MatchHistoryMember"> | number
    status?: EnumMatchStatusFilter<"MatchHistoryMember"> | $Enums.MatchStatus
    point?: IntFilter<"MatchHistoryMember"> | number
    bonusPoint?: IntFilter<"MatchHistoryMember"> | number
    teamType?: EnumTeamTypeFilter<"MatchHistoryMember"> | $Enums.TeamType
    isReady?: BoolFilter<"MatchHistoryMember"> | boolean
    isComplete?: BoolFilter<"MatchHistoryMember"> | boolean
    isBot?: BoolFilter<"MatchHistoryMember"> | boolean
    joinedAt?: DateTimeFilter<"MatchHistoryMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MatchHistoryMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MatchHistoryMember"> | boolean
    room?: XOR<ChampionshipHistoryScalarRelationFilter, ChampionshipHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MatchHistoryMemberOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    _count?: MatchHistoryMemberCountOrderByAggregateInput
    _avg?: MatchHistoryMemberAvgOrderByAggregateInput
    _max?: MatchHistoryMemberMaxOrderByAggregateInput
    _min?: MatchHistoryMemberMinOrderByAggregateInput
    _sum?: MatchHistoryMemberSumOrderByAggregateInput
  }

  export type MatchHistoryMemberScalarWhereWithAggregatesInput = {
    AND?: MatchHistoryMemberScalarWhereWithAggregatesInput | MatchHistoryMemberScalarWhereWithAggregatesInput[]
    OR?: MatchHistoryMemberScalarWhereWithAggregatesInput[]
    NOT?: MatchHistoryMemberScalarWhereWithAggregatesInput | MatchHistoryMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchHistoryMember"> | string
    roomId?: StringWithAggregatesFilter<"MatchHistoryMember"> | string
    userId?: StringWithAggregatesFilter<"MatchHistoryMember"> | string
    slot?: IntWithAggregatesFilter<"MatchHistoryMember"> | number
    status?: EnumMatchStatusWithAggregatesFilter<"MatchHistoryMember"> | $Enums.MatchStatus
    point?: IntWithAggregatesFilter<"MatchHistoryMember"> | number
    bonusPoint?: IntWithAggregatesFilter<"MatchHistoryMember"> | number
    teamType?: EnumTeamTypeWithAggregatesFilter<"MatchHistoryMember"> | $Enums.TeamType
    isReady?: BoolWithAggregatesFilter<"MatchHistoryMember"> | boolean
    isComplete?: BoolWithAggregatesFilter<"MatchHistoryMember"> | boolean
    isBot?: BoolWithAggregatesFilter<"MatchHistoryMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"MatchHistoryMember"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"MatchHistoryMember"> | Date | string | null
    isDisconnect?: BoolWithAggregatesFilter<"MatchHistoryMember"> | boolean
  }

  export type ProvinceCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProvinceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProvinceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdistrictCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    city: CityCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdistrictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdistrictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutSchoolInput
    city?: CityCreateNestedOneWithoutSchoolsInput
    province?: ProvinceCreateNestedOneWithoutSchoolsInput
    subdistrict?: SubdistrictCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutSchoolNestedInput
    city?: CityUpdateOneWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneWithoutSchoolsNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type ZoneCreateInput = {
    id?: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    posttest?: number
    posttestTryCount?: number
    pretest?: number
    pretestTryCount?: number
    user: UserCreateNestedOneWithoutZonesInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    posttest?: number
    posttestTryCount?: number
    pretest?: number
    pretestTryCount?: number
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutZonesNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
  }

  export type ZoneCreateManyInput = {
    id?: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    posttest?: number
    posttestTryCount?: number
    pretest?: number
    pretestTryCount?: number
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
  }

  export type LevelCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
    user: UserCreateNestedOneWithoutLevelsInput
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type LevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutLevelsNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type LevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    zoneInGameId: string
    user: UserCreateNestedOneWithoutSubLevelsInput
  }

  export type SubLevelUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    userId: string
    zoneInGameId: string
  }

  export type SubLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSubLevelsNestedInput
  }

  export type SubLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    userId: string
    zoneInGameId: string
  }

  export type SubLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    zoneInGameId: string
    user: UserCreateNestedOneWithoutInnerLevelsInput
  }

  export type InnerLevelUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    userId: string
    zoneInGameId: string
  }

  export type InnerLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInnerLevelsNestedInput
  }

  export type InnerLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    userId: string
    zoneInGameId: string
  }

  export type InnerLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
    user: UserCreateNestedOneWithoutGemposInput
  }

  export type GempoUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type GempoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutGemposNestedInput
  }

  export type GempoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type GempoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
    user: UserCreateNestedOneWithoutChampionshipsInput
  }

  export type ChampionshipUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type ChampionshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutChampionshipsNestedInput
  }

  export type ChampionshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type ChampionshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoRecordCreateInput = {
    id?: string
    played?: number
    point?: number
    highestPoint?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempoInGameId: string
    inGameId: string
    zoneInGameId: string
    correctAttempt?: number
    user: UserCreateNestedOneWithoutGempoRecordsInput
  }

  export type GempoRecordUncheckedCreateInput = {
    id?: string
    played?: number
    point?: number
    highestPoint?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempoInGameId: string
    inGameId: string
    userId: string
    zoneInGameId: string
    correctAttempt?: number
  }

  export type GempoRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutGempoRecordsNestedInput
  }

  export type GempoRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
  }

  export type GempoRecordCreateManyInput = {
    id?: string
    played?: number
    point?: number
    highestPoint?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempoInGameId: string
    inGameId: string
    userId: string
    zoneInGameId: string
    correctAttempt?: number
  }

  export type GempoRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
  }

  export type GempoRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
  }

  export type ChampionshipRecordCreateInput = {
    id?: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championshipInGameId: string
    inGameId: string
    zoneInGameId: string
    user: UserCreateNestedOneWithoutChampionshipRecordsInput
  }

  export type ChampionshipRecordUncheckedCreateInput = {
    id?: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championshipInGameId: string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type ChampionshipRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutChampionshipRecordsNestedInput
  }

  export type ChampionshipRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordCreateManyInput = {
    id?: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championshipInGameId: string
    inGameId: string
    userId: string
    zoneInGameId: string
  }

  export type ChampionshipRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLoginCreateInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
    user: UserCreateNestedOneWithoutUserLoginInput
  }

  export type UserLoginUncheckedCreateInput = {
    id?: string
    userId: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserLoginNestedInput
  }

  export type UserLoginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginCreateManyInput = {
    id?: string
    userId: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminLogCreateInput = {
    id?: string
    ipAddress?: string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: string | null
    operation?: string | null
    createdAt?: Date | string
    admin: AdminCreateNestedOneWithoutLogsInput
  }

  export type AdminLogUncheckedCreateInput = {
    id?: string
    ipAddress?: string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    adminId: string
    table?: string | null
    operation?: string | null
    createdAt?: Date | string
  }

  export type AdminLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutLogsNestedInput
  }

  export type AdminLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    adminId?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLogCreateManyInput = {
    id?: string
    ipAddress?: string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    adminId: string
    table?: string | null
    operation?: string | null
    createdAt?: Date | string
  }

  export type AdminLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    adminId?: StringFieldUpdateOperationsInput | string
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOperationHistoryCreateInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    admin: AdminCreateNestedOneWithoutOperationHistoriesInput
    opAdmin: AdminCreateNestedOneWithoutOperationsInput
  }

  export type AdminOperationHistoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    admin?: AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput
    opAdmin?: AdminUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminAuthorityCreateInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityCreateManyInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type AdminAuthorityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminAuthorityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerCreateInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    admin: AdminCreateNestedOneWithoutBannerInput
    provincies?: ProvinceCreateNestedManyWithoutBannersInput
    cities?: CityCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    adminId: string
    thumbnailId: string
    provincies?: ProvinceUncheckedCreateNestedManyWithoutBannersInput
    cities?: CityUncheckedCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    provincies?: ProvinceUpdateManyWithoutBannersNestedInput
    cities?: CityUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    provincies?: ProvinceUncheckedUpdateManyWithoutBannersNestedInput
    cities?: CityUncheckedUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerCreateManyInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    adminId: string
    thumbnailId: string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerVisitorCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    banner: BannerCreateNestedOneWithoutVisitorsInput
    user: UserCreateNestedOneWithoutBannerVisitorInput
  }

  export type BannerVisitorUncheckedCreateInput = {
    id?: string
    bannerId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    banner?: BannerUpdateOneRequiredWithoutVisitorsNestedInput
    user?: UserUpdateOneRequiredWithoutBannerVisitorNestedInput
  }

  export type BannerVisitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorCreateManyInput = {
    id?: string
    bannerId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutTestsInput
    participants?: TestParticipantCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
    participants?: TestParticipantUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutTestsNestedInput
    participants?: TestParticipantUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    participants?: TestParticipantUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCreateManyInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
  }

  export type TestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type TestParticipantCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTestParticipantInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateInput = {
    id?: string
    testId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantCreateManyInput = {
    id?: string
    testId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type TestParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantRecordCreateInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    participant: TestParticipantCreateNestedOneWithoutRecordsInput
  }

  export type TestParticipantRecordUncheckedCreateInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    participant?: TestParticipantUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type TestParticipantRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateManyInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type BackgroundCreateInput = {
    id?: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    thumbnailId: string
  }

  export type BackgroundUncheckedCreateInput = {
    id?: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    thumbnailId: string
  }

  export type BackgroundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type BackgroundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type BackgroundCreateManyInput = {
    id?: string
    name: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    thumbnailId: string
  }

  export type BackgroundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type BackgroundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type SettingCreateInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminTransactionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutTransactionsInput
    processedBy?: AdminCreateNestedOneWithoutTransactionProcessedInput
    redeemCode?: RedeemCodeCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    adminId: string
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    processedById?: string | null
    redeemCode?: RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutTransactionsNestedInput
    processedBy?: AdminUpdateOneWithoutTransactionProcessedNestedInput
    redeemCode?: RedeemCodeUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    adminId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    redeemCode?: RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    adminId: string
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    processedById?: string | null
  }

  export type AdminTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    adminId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RedeemCodeCreateInput = {
    id?: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    redeemers?: CodeRedeemerCreateNestedManyWithoutCodeInput
    admin: AdminCreateNestedOneWithoutRedeemCodesInput
    transaction: AdminTransactionCreateNestedOneWithoutRedeemCodeInput
  }

  export type RedeemCodeUncheckedCreateInput = {
    id?: string
    transactionId: string
    adminId: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    redeemers?: CodeRedeemerUncheckedCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    redeemers?: CodeRedeemerUpdateManyWithoutCodeNestedInput
    admin?: AdminUpdateOneRequiredWithoutRedeemCodesNestedInput
    transaction?: AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    redeemers?: CodeRedeemerUncheckedUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeCreateManyInput = {
    id?: string
    transactionId: string
    adminId: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
  }

  export type RedeemCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RedeemCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CodeRedeemerCreateInput = {
    id?: string
    banned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: RedeemCodeCreateNestedOneWithoutRedeemersInput
    user: UserCreateNestedOneWithoutRedeemedCodesInput
  }

  export type CodeRedeemerUncheckedCreateInput = {
    id?: string
    banned?: boolean
    userId: string
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedeemerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: RedeemCodeUpdateOneRequiredWithoutRedeemersNestedInput
    user?: UserUpdateOneRequiredWithoutRedeemedCodesNestedInput
  }

  export type CodeRedeemerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedeemerCreateManyInput = {
    id?: string
    banned?: boolean
    userId: string
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedeemerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedeemerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipMatchCreateInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
    members?: MatchMemberCreateNestedManyWithoutRoomInput
  }

  export type ChampionshipMatchUncheckedCreateInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
    members?: MatchMemberUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChampionshipMatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
    members?: MatchMemberUpdateManyWithoutRoomNestedInput
  }

  export type ChampionshipMatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
    members?: MatchMemberUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChampionshipMatchCreateManyInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type ChampionshipMatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type ChampionshipMatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type MatchMemberCreateInput = {
    id?: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    room: ChampionshipMatchCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMatchMembersInput
  }

  export type MatchMemberUncheckedCreateInput = {
    id?: string
    roomId: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    room?: ChampionshipMatchUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMatchMembersNestedInput
  }

  export type MatchMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchMemberCreateManyInput = {
    id?: string
    roomId: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChampionshipHistoryCreateInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    currentPoint?: ChampionshipHistoryCreatecurrentPointInput | number[]
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
    members?: MatchHistoryMemberCreateNestedManyWithoutRoomInput
  }

  export type ChampionshipHistoryUncheckedCreateInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    currentPoint?: ChampionshipHistoryCreatecurrentPointInput | number[]
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
    members?: MatchHistoryMemberUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChampionshipHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    currentPoint?: ChampionshipHistoryUpdatecurrentPointInput | number[]
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
    members?: MatchHistoryMemberUpdateManyWithoutRoomNestedInput
  }

  export type ChampionshipHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    currentPoint?: ChampionshipHistoryUpdatecurrentPointInput | number[]
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
    members?: MatchHistoryMemberUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChampionshipHistoryCreateManyInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    currentPoint?: ChampionshipHistoryCreatecurrentPointInput | number[]
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type ChampionshipHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    currentPoint?: ChampionshipHistoryUpdatecurrentPointInput | number[]
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type ChampionshipHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    currentPoint?: ChampionshipHistoryUpdatecurrentPointInput | number[]
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type MatchHistoryMemberCreateInput = {
    id?: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    room: ChampionshipHistoryCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutHistoryMatchMembersInput
  }

  export type MatchHistoryMemberUncheckedCreateInput = {
    id?: string
    roomId: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    room?: ChampionshipHistoryUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutHistoryMatchMembersNestedInput
  }

  export type MatchHistoryMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchHistoryMemberCreateManyInput = {
    id?: string
    roomId: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchHistoryMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type AdminAuthorityListRelationFilter = {
    every?: AdminAuthorityWhereInput
    some?: AdminAuthorityWhereInput
    none?: AdminAuthorityWhereInput
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SubdistrictListRelationFilter = {
    every?: SubdistrictWhereInput
    some?: SubdistrictWhereInput
    none?: SubdistrictWhereInput
  }

  export type BannerListRelationFilter = {
    every?: BannerWhereInput
    some?: BannerWhereInput
    none?: BannerWhereInput
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuthorityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubdistrictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type ProvinceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProvinceScalarRelationFilter = {
    is?: ProvinceWhereInput
    isNot?: ProvinceWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type SubdistrictCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdistrictAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type SubdistrictMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdistrictMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdistrictSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type EnumEducationLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumEducationLevelFilter<$PrismaModel> | $Enums.EducationLevel
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CityNullableScalarRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type ProvinceNullableScalarRelationFilter = {
    is?: ProvinceWhereInput | null
    isNot?: ProvinceWhereInput | null
  }

  export type SubdistrictNullableScalarRelationFilter = {
    is?: SubdistrictWhereInput | null
    isNot?: SubdistrictWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    level?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    subdistrictId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    level?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    subdistrictId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    level?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    subdistrictId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type EnumEducationLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumEducationLevelWithAggregatesFilter<$PrismaModel> | $Enums.EducationLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEducationLevelFilter<$PrismaModel>
    _max?: NestedEnumEducationLevelFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BannerVisitorListRelationFilter = {
    every?: BannerVisitorWhereInput
    some?: BannerVisitorWhereInput
    none?: BannerVisitorWhereInput
  }

  export type ChampionshipListRelationFilter = {
    every?: ChampionshipWhereInput
    some?: ChampionshipWhereInput
    none?: ChampionshipWhereInput
  }

  export type ChampionshipRecordListRelationFilter = {
    every?: ChampionshipRecordWhereInput
    some?: ChampionshipRecordWhereInput
    none?: ChampionshipRecordWhereInput
  }

  export type CodeRedeemerListRelationFilter = {
    every?: CodeRedeemerWhereInput
    some?: CodeRedeemerWhereInput
    none?: CodeRedeemerWhereInput
  }

  export type GempoListRelationFilter = {
    every?: GempoWhereInput
    some?: GempoWhereInput
    none?: GempoWhereInput
  }

  export type GempoRecordListRelationFilter = {
    every?: GempoRecordWhereInput
    some?: GempoRecordWhereInput
    none?: GempoRecordWhereInput
  }

  export type InnerLevelListRelationFilter = {
    every?: InnerLevelWhereInput
    some?: InnerLevelWhereInput
    none?: InnerLevelWhereInput
  }

  export type LevelListRelationFilter = {
    every?: LevelWhereInput
    some?: LevelWhereInput
    none?: LevelWhereInput
  }

  export type MatchMemberListRelationFilter = {
    every?: MatchMemberWhereInput
    some?: MatchMemberWhereInput
    none?: MatchMemberWhereInput
  }

  export type MatchHistoryMemberListRelationFilter = {
    every?: MatchHistoryMemberWhereInput
    some?: MatchHistoryMemberWhereInput
    none?: MatchHistoryMemberWhereInput
  }

  export type SubLevelListRelationFilter = {
    every?: SubLevelWhereInput
    some?: SubLevelWhereInput
    none?: SubLevelWhereInput
  }

  export type TestParticipantListRelationFilter = {
    every?: TestParticipantWhereInput
    some?: TestParticipantWhereInput
    none?: TestParticipantWhereInput
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type UserLoginListRelationFilter = {
    every?: UserLoginWhereInput
    some?: UserLoginWhereInput
    none?: UserLoginWhereInput
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type BannerVisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChampionshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChampionshipRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeRedeemerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GempoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GempoRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InnerLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchHistoryMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    subdistrictId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    grade?: SortOrder
    playTime?: SortOrder
    inventory?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    subdistrictId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    subdistrictId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    grade?: SortOrder
    playTime?: SortOrder
    inventory?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ZoneUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    posttest?: SortOrder
    posttestTryCount?: SortOrder
    pretest?: SortOrder
    pretestTryCount?: SortOrder
  }

  export type LevelUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type SubLevelUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type SubLevelCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type SubLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type SubLevelMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type InnerLevelUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type InnerLevelCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type InnerLevelAvgOrderByAggregateInput = {
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
  }

  export type InnerLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type InnerLevelMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type InnerLevelSumOrderByAggregateInput = {
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
  }

  export type GempoUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type GempoCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type GempoMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type GempoMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type ChampionshipUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type ChampionshipCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type ChampionshipMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type ChampionshipMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type GempoRecordUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type GempoRecordCountOrderByAggregateInput = {
    id?: SortOrder
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gempoInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    correctAttempt?: SortOrder
  }

  export type GempoRecordAvgOrderByAggregateInput = {
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    correctAttempt?: SortOrder
  }

  export type GempoRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gempoInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    correctAttempt?: SortOrder
  }

  export type GempoRecordMinOrderByAggregateInput = {
    id?: SortOrder
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gempoInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
    correctAttempt?: SortOrder
  }

  export type GempoRecordSumOrderByAggregateInput = {
    played?: SortOrder
    point?: SortOrder
    highestPoint?: SortOrder
    correctAttempt?: SortOrder
  }

  export type ChampionshipRecordUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type ChampionshipRecordCountOrderByAggregateInput = {
    id?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    championshipInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type ChampionshipRecordAvgOrderByAggregateInput = {
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
  }

  export type ChampionshipRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    championshipInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type ChampionshipRecordMinOrderByAggregateInput = {
    id?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    championshipInGameId?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    zoneInGameId?: SortOrder
  }

  export type ChampionshipRecordSumOrderByAggregateInput = {
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
  }

  export type UserLoginCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type UserLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type UserLoginMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type AdminLogListRelationFilter = {
    every?: AdminLogWhereInput
    some?: AdminLogWhereInput
    none?: AdminLogWhereInput
  }

  export type AdminOperationHistoryListRelationFilter = {
    every?: AdminOperationHistoryWhereInput
    some?: AdminOperationHistoryWhereInput
    none?: AdminOperationHistoryWhereInput
  }

  export type AdminTransactionListRelationFilter = {
    every?: AdminTransactionWhereInput
    some?: AdminTransactionWhereInput
    none?: AdminTransactionWhereInput
  }

  export type RedeemCodeListRelationFilter = {
    every?: RedeemCodeWhereInput
    some?: RedeemCodeWhereInput
    none?: RedeemCodeWhereInput
  }

  export type TestListRelationFilter = {
    every?: TestWhereInput
    some?: TestWhereInput
    none?: TestWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AdminLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOperationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedeemCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    subdistrictId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authenticatorEnabled?: SortOrder
    authenticatorQrUrl?: SortOrder
    authenticatorSecret?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    subdistrictId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authenticatorEnabled?: SortOrder
    authenticatorQrUrl?: SortOrder
    authenticatorSecret?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    subdistrictId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authenticatorEnabled?: SortOrder
    authenticatorQrUrl?: SortOrder
    authenticatorSecret?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AdminLogCountOrderByAggregateInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    old?: SortOrder
    new?: SortOrder
    adminId?: SortOrder
    table?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminLogMaxOrderByAggregateInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    adminId?: SortOrder
    table?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminLogMinOrderByAggregateInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    adminId?: SortOrder
    table?: SortOrder
    operation?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationFilter<$PrismaModel> | $Enums.Operation
  }

  export type AdminOperationHistoryIdCreatedAtCompoundUniqueInput = {
    id: string
    createdAt: Date | string
  }

  export type AdminOperationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type AdminOperationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type AdminOperationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type EnumOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationWithAggregatesFilter<$PrismaModel> | $Enums.Operation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationFilter<$PrismaModel>
    _max?: NestedEnumOperationFilter<$PrismaModel>
  }

  export type AdminAuthorityCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
  }

  export type AdminAuthorityAvgOrderByAggregateInput = {
    grades?: SortOrder
  }

  export type AdminAuthorityMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
  }

  export type AdminAuthorityMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
  }

  export type AdminAuthoritySumOrderByAggregateInput = {
    grades?: SortOrder
  }

  export type ProvinceListRelationFilter = {
    every?: ProvinceWhereInput
    some?: ProvinceWhereInput
    none?: ProvinceWhereInput
  }

  export type ProvinceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    lastBroadcastedAt?: SortOrder
    adminId?: SortOrder
    thumbnailId?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    lastBroadcastedAt?: SortOrder
    adminId?: SortOrder
    thumbnailId?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    lastBroadcastedAt?: SortOrder
    adminId?: SortOrder
    thumbnailId?: SortOrder
  }

  export type BannerScalarRelationFilter = {
    is?: BannerWhereInput
    isNot?: BannerWhereInput
  }

  export type BannerVisitorBannerIdUserIdCompoundUniqueInput = {
    bannerId: string
    userId: string
  }

  export type BannerVisitorCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorAvgOrderByAggregateInput = {
    traffic?: SortOrder
  }

  export type BannerVisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorSumOrderByAggregateInput = {
    traffic?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type EnumTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeFilter<$PrismaModel> | $Enums.TestType
  }

  export type TestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type EnumTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.TestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestTypeFilter<$PrismaModel>
    _max?: NestedEnumTestTypeFilter<$PrismaModel>
  }

  export type TestScalarRelationFilter = {
    is?: TestWhereInput
    isNot?: TestWhereInput
  }

  export type TestParticipantRecordListRelationFilter = {
    every?: TestParticipantRecordWhereInput
    some?: TestParticipantRecordWhereInput
    none?: TestParticipantRecordWhereInput
  }

  export type TestParticipantRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParticipantTestIdUserIdCompoundUniqueInput = {
    testId: string
    userId: string
  }

  export type TestParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
  }

  export type TestParticipantAvgOrderByAggregateInput = {
    highscore?: SortOrder
  }

  export type TestParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
  }

  export type TestParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
  }

  export type TestParticipantSumOrderByAggregateInput = {
    highscore?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TestParticipantScalarRelationFilter = {
    is?: TestParticipantWhereInput
    isNot?: TestParticipantWhereInput
  }

  export type TestParticipantRecordCountOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answers?: SortOrder
  }

  export type TestParticipantRecordAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TestParticipantRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestParticipantRecordMinOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestParticipantRecordSumOrderByAggregateInput = {
    score?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BackgroundCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailId?: SortOrder
  }

  export type BackgroundMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailId?: SortOrder
  }

  export type BackgroundMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailId?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumTransactionFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFilter<$PrismaModel> | $Enums.Transaction
  }

  export type RedeemCodeNullableScalarRelationFilter = {
    is?: RedeemCodeWhereInput | null
    isNot?: RedeemCodeWhereInput | null
  }

  export type AdminTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    zones?: SortOrder
    adminId?: SortOrder
    amount?: SortOrder
    archived?: SortOrder
    description?: SortOrder
    name?: SortOrder
    subscriptionTime?: SortOrder
    transactionImageId?: SortOrder
    transactionImageUrl?: SortOrder
    transactionRef?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
  }

  export type AdminTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    amount?: SortOrder
    subscriptionTime?: SortOrder
  }

  export type AdminTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    adminId?: SortOrder
    amount?: SortOrder
    archived?: SortOrder
    description?: SortOrder
    name?: SortOrder
    subscriptionTime?: SortOrder
    transactionImageId?: SortOrder
    transactionImageUrl?: SortOrder
    transactionRef?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
  }

  export type AdminTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quantity?: SortOrder
    adminId?: SortOrder
    amount?: SortOrder
    archived?: SortOrder
    description?: SortOrder
    name?: SortOrder
    subscriptionTime?: SortOrder
    transactionImageId?: SortOrder
    transactionImageUrl?: SortOrder
    transactionRef?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
  }

  export type AdminTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
    amount?: SortOrder
    subscriptionTime?: SortOrder
  }

  export type EnumTransactionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionWithAggregatesFilter<$PrismaModel> | $Enums.Transaction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionFilter<$PrismaModel>
    _max?: NestedEnumTransactionFilter<$PrismaModel>
  }

  export type AdminTransactionScalarRelationFilter = {
    is?: AdminTransactionWhereInput
    isNot?: AdminTransactionWhereInput
  }

  export type RedeemCodeCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspend?: SortOrder
  }

  export type RedeemCodeAvgOrderByAggregateInput = {
    currentAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type RedeemCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspend?: SortOrder
  }

  export type RedeemCodeMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suspend?: SortOrder
  }

  export type RedeemCodeSumOrderByAggregateInput = {
    currentAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type RedeemCodeScalarRelationFilter = {
    is?: RedeemCodeWhereInput
    isNot?: RedeemCodeWhereInput
  }

  export type CodeRedeemerIdUserIdCompoundUniqueInput = {
    id: string
    userId: string
  }

  export type CodeRedeemerCodeIdUserIdCompoundUniqueInput = {
    codeId: string
    userId: string
  }

  export type CodeRedeemerCountOrderByAggregateInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeRedeemerMaxOrderByAggregateInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeRedeemerMinOrderByAggregateInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMatchModeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchMode | EnumMatchModeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchModeFilter<$PrismaModel> | $Enums.MatchMode
  }

  export type ChampionshipMatchCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipMatchAvgOrderByAggregateInput = {
    max?: SortOrder
    endTime?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipMatchMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipMatchSumOrderByAggregateInput = {
    max?: SortOrder
    endTime?: SortOrder
    currentMember?: SortOrder
  }

  export type EnumMatchModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchMode | EnumMatchModeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchModeWithAggregatesFilter<$PrismaModel> | $Enums.MatchMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchModeFilter<$PrismaModel>
    _max?: NestedEnumMatchModeFilter<$PrismaModel>
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type EnumTeamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamType | EnumTeamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamTypeFilter<$PrismaModel> | $Enums.TeamType
  }

  export type ChampionshipMatchScalarRelationFilter = {
    is?: ChampionshipMatchWhereInput
    isNot?: ChampionshipMatchWhereInput
  }

  export type MatchMemberRoomIdSlotCompoundUniqueInput = {
    roomId: string
    slot: number
  }

  export type MatchMemberRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type MatchMemberCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MatchMemberAvgOrderByAggregateInput = {
    slot?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type MatchMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MatchMemberMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MatchMemberSumOrderByAggregateInput = {
    slot?: SortOrder
    answerPoint?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type EnumTeamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamType | EnumTeamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamTypeWithAggregatesFilter<$PrismaModel> | $Enums.TeamType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamTypeFilter<$PrismaModel>
    _max?: NestedEnumTeamTypeFilter<$PrismaModel>
  }

  export type ChampionshipHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    currentPoint?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipHistoryAvgOrderByAggregateInput = {
    max?: SortOrder
    currentPoint?: SortOrder
    endTime?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    zoneInGameId?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    mode?: SortOrder
    endTime?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipHistorySumOrderByAggregateInput = {
    max?: SortOrder
    currentPoint?: SortOrder
    endTime?: SortOrder
    currentMember?: SortOrder
  }

  export type ChampionshipHistoryScalarRelationFilter = {
    is?: ChampionshipHistoryWhereInput
    isNot?: ChampionshipHistoryWhereInput
  }

  export type MatchHistoryMemberCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MatchHistoryMemberAvgOrderByAggregateInput = {
    slot?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type MatchHistoryMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MatchHistoryMemberMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    teamType?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MatchHistoryMemberSumOrderByAggregateInput = {
    slot?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type AdminCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type CityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SubdistrictCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SubdistrictCreateWithoutProvinceInput, SubdistrictUncheckedCreateWithoutProvinceInput> | SubdistrictCreateWithoutProvinceInput[] | SubdistrictUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutProvinceInput | SubdistrictCreateOrConnectWithoutProvinceInput[]
    createMany?: SubdistrictCreateManyProvinceInputEnvelope
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type BannerCreateNestedManyWithoutProvinciesInput = {
    create?: XOR<BannerCreateWithoutProvinciesInput, BannerUncheckedCreateWithoutProvinciesInput> | BannerCreateWithoutProvinciesInput[] | BannerUncheckedCreateWithoutProvinciesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutProvinciesInput | BannerCreateOrConnectWithoutProvinciesInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SubdistrictUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SubdistrictCreateWithoutProvinceInput, SubdistrictUncheckedCreateWithoutProvinceInput> | SubdistrictCreateWithoutProvinceInput[] | SubdistrictUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutProvinceInput | SubdistrictCreateOrConnectWithoutProvinceInput[]
    createMany?: SubdistrictCreateManyProvinceInputEnvelope
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type BannerUncheckedCreateNestedManyWithoutProvinciesInput = {
    create?: XOR<BannerCreateWithoutProvinciesInput, BannerUncheckedCreateWithoutProvinciesInput> | BannerCreateWithoutProvinciesInput[] | BannerUncheckedCreateWithoutProvinciesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutProvinciesInput | BannerCreateOrConnectWithoutProvinciesInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutProvinceInput | AdminUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutProvinceInput | AdminUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutProvinceInput | AdminUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutProvinceInput | AdminAuthorityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type CityUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutProvinceInput | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutProvinceInput | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: CityUpdateManyWithWhereWithoutProvinceInput | CityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutProvinceInput | SchoolUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutProvinceInput | SchoolUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutProvinceInput | SchoolUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProvinceInput | UserUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProvinceInput | UserUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProvinceInput | UserUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SubdistrictUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SubdistrictCreateWithoutProvinceInput, SubdistrictUncheckedCreateWithoutProvinceInput> | SubdistrictCreateWithoutProvinceInput[] | SubdistrictUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutProvinceInput | SubdistrictCreateOrConnectWithoutProvinceInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutProvinceInput | SubdistrictUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SubdistrictCreateManyProvinceInputEnvelope
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutProvinceInput | SubdistrictUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutProvinceInput | SubdistrictUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type BannerUpdateManyWithoutProvinciesNestedInput = {
    create?: XOR<BannerCreateWithoutProvinciesInput, BannerUncheckedCreateWithoutProvinciesInput> | BannerCreateWithoutProvinciesInput[] | BannerUncheckedCreateWithoutProvinciesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutProvinciesInput | BannerCreateOrConnectWithoutProvinciesInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutProvinciesInput | BannerUpsertWithWhereUniqueWithoutProvinciesInput[]
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutProvinciesInput | BannerUpdateWithWhereUniqueWithoutProvinciesInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutProvinciesInput | BannerUpdateManyWithWhereWithoutProvinciesInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutProvinceInput | AdminUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutProvinceInput | AdminUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutProvinceInput | AdminUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutProvinceInput | AdminAuthorityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutProvinceInput | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutProvinceInput | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: CityUpdateManyWithWhereWithoutProvinceInput | CityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutProvinceInput | SchoolUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutProvinceInput | SchoolUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutProvinceInput | SchoolUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProvinceInput | UserUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProvinceInput | UserUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProvinceInput | UserUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SubdistrictCreateWithoutProvinceInput, SubdistrictUncheckedCreateWithoutProvinceInput> | SubdistrictCreateWithoutProvinceInput[] | SubdistrictUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutProvinceInput | SubdistrictCreateOrConnectWithoutProvinceInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutProvinceInput | SubdistrictUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SubdistrictCreateManyProvinceInputEnvelope
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutProvinceInput | SubdistrictUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutProvinceInput | SubdistrictUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type BannerUncheckedUpdateManyWithoutProvinciesNestedInput = {
    create?: XOR<BannerCreateWithoutProvinciesInput, BannerUncheckedCreateWithoutProvinciesInput> | BannerCreateWithoutProvinciesInput[] | BannerUncheckedCreateWithoutProvinciesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutProvinciesInput | BannerCreateOrConnectWithoutProvinciesInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutProvinciesInput | BannerUpsertWithWhereUniqueWithoutProvinciesInput[]
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutProvinciesInput | BannerUpdateWithWhereUniqueWithoutProvinciesInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutProvinciesInput | BannerUpdateManyWithWhereWithoutProvinciesInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminCreateNestedManyWithoutCityInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type ProvinceCreateNestedOneWithoutCitiesInput = {
    create?: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCitiesInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutCityInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SubdistrictCreateNestedManyWithoutCityInput = {
    create?: XOR<SubdistrictCreateWithoutCityInput, SubdistrictUncheckedCreateWithoutCityInput> | SubdistrictCreateWithoutCityInput[] | SubdistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutCityInput | SubdistrictCreateOrConnectWithoutCityInput[]
    createMany?: SubdistrictCreateManyCityInputEnvelope
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutCitiesInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerCreateNestedManyWithoutCitiesInput = {
    create?: XOR<BannerCreateWithoutCitiesInput, BannerUncheckedCreateWithoutCitiesInput> | BannerCreateWithoutCitiesInput[] | BannerUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutCitiesInput | BannerCreateOrConnectWithoutCitiesInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type SubdistrictUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<SubdistrictCreateWithoutCityInput, SubdistrictUncheckedCreateWithoutCityInput> | SubdistrictCreateWithoutCityInput[] | SubdistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutCityInput | SubdistrictCreateOrConnectWithoutCityInput[]
    createMany?: SubdistrictCreateManyCityInputEnvelope
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<BannerCreateWithoutCitiesInput, BannerUncheckedCreateWithoutCitiesInput> | BannerCreateWithoutCitiesInput[] | BannerUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutCitiesInput | BannerCreateOrConnectWithoutCitiesInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCityInput | AdminUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCityInput | AdminUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCityInput | AdminUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type ProvinceUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCitiesInput
    upsert?: ProvinceUpsertWithoutCitiesInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutCitiesInput, ProvinceUpdateWithoutCitiesInput>, ProvinceUncheckedUpdateWithoutCitiesInput>
  }

  export type SchoolUpdateManyWithoutCityNestedInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCityInput | SchoolUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCityInput | SchoolUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCityInput | SchoolUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SubdistrictUpdateManyWithoutCityNestedInput = {
    create?: XOR<SubdistrictCreateWithoutCityInput, SubdistrictUncheckedCreateWithoutCityInput> | SubdistrictCreateWithoutCityInput[] | SubdistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutCityInput | SubdistrictCreateOrConnectWithoutCityInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutCityInput | SubdistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SubdistrictCreateManyCityInputEnvelope
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutCityInput | SubdistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutCityInput | SubdistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutCitiesInput | AdminAuthorityUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<BannerCreateWithoutCitiesInput, BannerUncheckedCreateWithoutCitiesInput> | BannerCreateWithoutCitiesInput[] | BannerUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutCitiesInput | BannerCreateOrConnectWithoutCitiesInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutCitiesInput | BannerUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutCitiesInput | BannerUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutCitiesInput | BannerUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCityInput | AdminUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCityInput | AdminUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCityInput | AdminUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCityInput | SchoolUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCityInput | SchoolUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCityInput | SchoolUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type SubdistrictUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<SubdistrictCreateWithoutCityInput, SubdistrictUncheckedCreateWithoutCityInput> | SubdistrictCreateWithoutCityInput[] | SubdistrictUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutCityInput | SubdistrictCreateOrConnectWithoutCityInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutCityInput | SubdistrictUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SubdistrictCreateManyCityInputEnvelope
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutCityInput | SubdistrictUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutCityInput | SubdistrictUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutCitiesInput | AdminAuthorityUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<BannerCreateWithoutCitiesInput, BannerUncheckedCreateWithoutCitiesInput> | BannerCreateWithoutCitiesInput[] | BannerUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutCitiesInput | BannerCreateOrConnectWithoutCitiesInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutCitiesInput | BannerUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutCitiesInput | BannerUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutCitiesInput | BannerUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type ProvinceCreateNestedOneWithoutSubdistrictsInput = {
    create?: XOR<ProvinceCreateWithoutSubdistrictsInput, ProvinceUncheckedCreateWithoutSubdistrictsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSubdistrictsInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutSubdistrictsInput = {
    create?: XOR<CityCreateWithoutSubdistrictsInput, CityUncheckedCreateWithoutSubdistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSubdistrictsInput
    connect?: CityWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutSubdistrictInput = {
    create?: XOR<SchoolCreateWithoutSubdistrictInput, SchoolUncheckedCreateWithoutSubdistrictInput> | SchoolCreateWithoutSubdistrictInput[] | SchoolUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutSubdistrictInput | SchoolCreateOrConnectWithoutSubdistrictInput[]
    createMany?: SchoolCreateManySubdistrictInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutSubdistrictInput = {
    create?: XOR<UserCreateWithoutSubdistrictInput, UserUncheckedCreateWithoutSubdistrictInput> | UserCreateWithoutSubdistrictInput[] | UserUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubdistrictInput | UserCreateOrConnectWithoutSubdistrictInput[]
    createMany?: UserCreateManySubdistrictInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutSubdistrictInput = {
    create?: XOR<AdminCreateWithoutSubdistrictInput, AdminUncheckedCreateWithoutSubdistrictInput> | AdminCreateWithoutSubdistrictInput[] | AdminUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSubdistrictInput | AdminCreateOrConnectWithoutSubdistrictInput[]
    createMany?: AdminCreateManySubdistrictInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutSubdistrictsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSubdistrictsInput, AdminAuthorityUncheckedCreateWithoutSubdistrictsInput> | AdminAuthorityCreateWithoutSubdistrictsInput[] | AdminAuthorityUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSubdistrictsInput | AdminAuthorityCreateOrConnectWithoutSubdistrictsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerCreateNestedManyWithoutSubdistrictsInput = {
    create?: XOR<BannerCreateWithoutSubdistrictsInput, BannerUncheckedCreateWithoutSubdistrictsInput> | BannerCreateWithoutSubdistrictsInput[] | BannerUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutSubdistrictsInput | BannerCreateOrConnectWithoutSubdistrictsInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutSubdistrictInput = {
    create?: XOR<SchoolCreateWithoutSubdistrictInput, SchoolUncheckedCreateWithoutSubdistrictInput> | SchoolCreateWithoutSubdistrictInput[] | SchoolUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutSubdistrictInput | SchoolCreateOrConnectWithoutSubdistrictInput[]
    createMany?: SchoolCreateManySubdistrictInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSubdistrictInput = {
    create?: XOR<UserCreateWithoutSubdistrictInput, UserUncheckedCreateWithoutSubdistrictInput> | UserCreateWithoutSubdistrictInput[] | UserUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubdistrictInput | UserCreateOrConnectWithoutSubdistrictInput[]
    createMany?: UserCreateManySubdistrictInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutSubdistrictInput = {
    create?: XOR<AdminCreateWithoutSubdistrictInput, AdminUncheckedCreateWithoutSubdistrictInput> | AdminCreateWithoutSubdistrictInput[] | AdminUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSubdistrictInput | AdminCreateOrConnectWithoutSubdistrictInput[]
    createMany?: AdminCreateManySubdistrictInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSubdistrictsInput, AdminAuthorityUncheckedCreateWithoutSubdistrictsInput> | AdminAuthorityCreateWithoutSubdistrictsInput[] | AdminAuthorityUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSubdistrictsInput | AdminAuthorityCreateOrConnectWithoutSubdistrictsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerUncheckedCreateNestedManyWithoutSubdistrictsInput = {
    create?: XOR<BannerCreateWithoutSubdistrictsInput, BannerUncheckedCreateWithoutSubdistrictsInput> | BannerCreateWithoutSubdistrictsInput[] | BannerUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutSubdistrictsInput | BannerCreateOrConnectWithoutSubdistrictsInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput = {
    create?: XOR<ProvinceCreateWithoutSubdistrictsInput, ProvinceUncheckedCreateWithoutSubdistrictsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSubdistrictsInput
    upsert?: ProvinceUpsertWithoutSubdistrictsInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutSubdistrictsInput, ProvinceUpdateWithoutSubdistrictsInput>, ProvinceUncheckedUpdateWithoutSubdistrictsInput>
  }

  export type CityUpdateOneRequiredWithoutSubdistrictsNestedInput = {
    create?: XOR<CityCreateWithoutSubdistrictsInput, CityUncheckedCreateWithoutSubdistrictsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSubdistrictsInput
    upsert?: CityUpsertWithoutSubdistrictsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutSubdistrictsInput, CityUpdateWithoutSubdistrictsInput>, CityUncheckedUpdateWithoutSubdistrictsInput>
  }

  export type SchoolUpdateManyWithoutSubdistrictNestedInput = {
    create?: XOR<SchoolCreateWithoutSubdistrictInput, SchoolUncheckedCreateWithoutSubdistrictInput> | SchoolCreateWithoutSubdistrictInput[] | SchoolUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutSubdistrictInput | SchoolCreateOrConnectWithoutSubdistrictInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutSubdistrictInput | SchoolUpsertWithWhereUniqueWithoutSubdistrictInput[]
    createMany?: SchoolCreateManySubdistrictInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutSubdistrictInput | SchoolUpdateWithWhereUniqueWithoutSubdistrictInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutSubdistrictInput | SchoolUpdateManyWithWhereWithoutSubdistrictInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutSubdistrictNestedInput = {
    create?: XOR<UserCreateWithoutSubdistrictInput, UserUncheckedCreateWithoutSubdistrictInput> | UserCreateWithoutSubdistrictInput[] | UserUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubdistrictInput | UserCreateOrConnectWithoutSubdistrictInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubdistrictInput | UserUpsertWithWhereUniqueWithoutSubdistrictInput[]
    createMany?: UserCreateManySubdistrictInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubdistrictInput | UserUpdateWithWhereUniqueWithoutSubdistrictInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubdistrictInput | UserUpdateManyWithWhereWithoutSubdistrictInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutSubdistrictNestedInput = {
    create?: XOR<AdminCreateWithoutSubdistrictInput, AdminUncheckedCreateWithoutSubdistrictInput> | AdminCreateWithoutSubdistrictInput[] | AdminUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSubdistrictInput | AdminCreateOrConnectWithoutSubdistrictInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSubdistrictInput | AdminUpsertWithWhereUniqueWithoutSubdistrictInput[]
    createMany?: AdminCreateManySubdistrictInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSubdistrictInput | AdminUpdateWithWhereUniqueWithoutSubdistrictInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSubdistrictInput | AdminUpdateManyWithWhereWithoutSubdistrictInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSubdistrictsInput, AdminAuthorityUncheckedCreateWithoutSubdistrictsInput> | AdminAuthorityCreateWithoutSubdistrictsInput[] | AdminAuthorityUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSubdistrictsInput | AdminAuthorityCreateOrConnectWithoutSubdistrictsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSubdistrictsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSubdistrictsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSubdistrictsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSubdistrictsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSubdistrictsInput | AdminAuthorityUpdateManyWithWhereWithoutSubdistrictsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerUpdateManyWithoutSubdistrictsNestedInput = {
    create?: XOR<BannerCreateWithoutSubdistrictsInput, BannerUncheckedCreateWithoutSubdistrictsInput> | BannerCreateWithoutSubdistrictsInput[] | BannerUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutSubdistrictsInput | BannerCreateOrConnectWithoutSubdistrictsInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutSubdistrictsInput | BannerUpsertWithWhereUniqueWithoutSubdistrictsInput[]
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutSubdistrictsInput | BannerUpdateWithWhereUniqueWithoutSubdistrictsInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutSubdistrictsInput | BannerUpdateManyWithWhereWithoutSubdistrictsInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput = {
    create?: XOR<SchoolCreateWithoutSubdistrictInput, SchoolUncheckedCreateWithoutSubdistrictInput> | SchoolCreateWithoutSubdistrictInput[] | SchoolUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutSubdistrictInput | SchoolCreateOrConnectWithoutSubdistrictInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutSubdistrictInput | SchoolUpsertWithWhereUniqueWithoutSubdistrictInput[]
    createMany?: SchoolCreateManySubdistrictInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutSubdistrictInput | SchoolUpdateWithWhereUniqueWithoutSubdistrictInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutSubdistrictInput | SchoolUpdateManyWithWhereWithoutSubdistrictInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSubdistrictNestedInput = {
    create?: XOR<UserCreateWithoutSubdistrictInput, UserUncheckedCreateWithoutSubdistrictInput> | UserCreateWithoutSubdistrictInput[] | UserUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSubdistrictInput | UserCreateOrConnectWithoutSubdistrictInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSubdistrictInput | UserUpsertWithWhereUniqueWithoutSubdistrictInput[]
    createMany?: UserCreateManySubdistrictInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSubdistrictInput | UserUpdateWithWhereUniqueWithoutSubdistrictInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSubdistrictInput | UserUpdateManyWithWhereWithoutSubdistrictInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutSubdistrictNestedInput = {
    create?: XOR<AdminCreateWithoutSubdistrictInput, AdminUncheckedCreateWithoutSubdistrictInput> | AdminCreateWithoutSubdistrictInput[] | AdminUncheckedCreateWithoutSubdistrictInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSubdistrictInput | AdminCreateOrConnectWithoutSubdistrictInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSubdistrictInput | AdminUpsertWithWhereUniqueWithoutSubdistrictInput[]
    createMany?: AdminCreateManySubdistrictInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSubdistrictInput | AdminUpdateWithWhereUniqueWithoutSubdistrictInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSubdistrictInput | AdminUpdateManyWithWhereWithoutSubdistrictInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSubdistrictsInput, AdminAuthorityUncheckedCreateWithoutSubdistrictsInput> | AdminAuthorityCreateWithoutSubdistrictsInput[] | AdminAuthorityUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSubdistrictsInput | AdminAuthorityCreateOrConnectWithoutSubdistrictsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSubdistrictsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSubdistrictsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSubdistrictsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSubdistrictsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSubdistrictsInput | AdminAuthorityUpdateManyWithWhereWithoutSubdistrictsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput = {
    create?: XOR<BannerCreateWithoutSubdistrictsInput, BannerUncheckedCreateWithoutSubdistrictsInput> | BannerCreateWithoutSubdistrictsInput[] | BannerUncheckedCreateWithoutSubdistrictsInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutSubdistrictsInput | BannerCreateOrConnectWithoutSubdistrictsInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutSubdistrictsInput | BannerUpsertWithWhereUniqueWithoutSubdistrictsInput[]
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutSubdistrictsInput | BannerUpdateWithWhereUniqueWithoutSubdistrictsInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutSubdistrictsInput | BannerUpdateManyWithWhereWithoutSubdistrictsInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type CityCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolsInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSchoolsInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SubdistrictCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<SubdistrictCreateWithoutSchoolsInput, SubdistrictUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: SubdistrictCreateOrConnectWithoutSchoolsInput
    connect?: SubdistrictWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type EnumEducationLevelFieldUpdateOperationsInput = {
    set?: $Enums.EducationLevel
  }

  export type AdminUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSchoolInput | AdminUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSchoolInput | AdminUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSchoolInput | AdminUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type CityUpdateOneWithoutSchoolsNestedInput = {
    create?: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolsInput
    upsert?: CityUpsertWithoutSchoolsInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutSchoolsInput, CityUpdateWithoutSchoolsInput>, CityUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProvinceUpdateOneWithoutSchoolsNestedInput = {
    create?: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSchoolsInput
    upsert?: ProvinceUpsertWithoutSchoolsInput
    disconnect?: ProvinceWhereInput | boolean
    delete?: ProvinceWhereInput | boolean
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutSchoolsInput, ProvinceUpdateWithoutSchoolsInput>, ProvinceUncheckedUpdateWithoutSchoolsInput>
  }

  export type SubdistrictUpdateOneWithoutSchoolsNestedInput = {
    create?: XOR<SubdistrictCreateWithoutSchoolsInput, SubdistrictUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: SubdistrictCreateOrConnectWithoutSchoolsInput
    upsert?: SubdistrictUpsertWithoutSchoolsInput
    disconnect?: SubdistrictWhereInput | boolean
    delete?: SubdistrictWhereInput | boolean
    connect?: SubdistrictWhereUniqueInput
    update?: XOR<XOR<SubdistrictUpdateToOneWithWhereWithoutSchoolsInput, SubdistrictUpdateWithoutSchoolsInput>, SubdistrictUncheckedUpdateWithoutSchoolsInput>
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput | AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdminUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSchoolInput | AdminUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSchoolInput | AdminUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSchoolInput | AdminUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput | AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type UserCreateinventoryInput = {
    set: number[]
  }

  export type BannerVisitorCreateNestedManyWithoutUserInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type ChampionshipCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
  }

  export type ChampionshipRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
  }

  export type CodeRedeemerCreateNestedManyWithoutUserInput = {
    create?: XOR<CodeRedeemerCreateWithoutUserInput, CodeRedeemerUncheckedCreateWithoutUserInput> | CodeRedeemerCreateWithoutUserInput[] | CodeRedeemerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutUserInput | CodeRedeemerCreateOrConnectWithoutUserInput[]
    createMany?: CodeRedeemerCreateManyUserInputEnvelope
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
  }

  export type GempoCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
  }

  export type GempoRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
  }

  export type InnerLevelCreateNestedManyWithoutUserInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
  }

  export type LevelCreateNestedManyWithoutUserInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type MatchMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchMemberCreateWithoutUserInput, MatchMemberUncheckedCreateWithoutUserInput> | MatchMemberCreateWithoutUserInput[] | MatchMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutUserInput | MatchMemberCreateOrConnectWithoutUserInput[]
    createMany?: MatchMemberCreateManyUserInputEnvelope
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
  }

  export type MatchHistoryMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutUserInput, MatchHistoryMemberUncheckedCreateWithoutUserInput> | MatchHistoryMemberCreateWithoutUserInput[] | MatchHistoryMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutUserInput | MatchHistoryMemberCreateOrConnectWithoutUserInput[]
    createMany?: MatchHistoryMemberCreateManyUserInputEnvelope
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
  }

  export type SubLevelCreateNestedManyWithoutUserInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
  }

  export type TestParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUsersInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type SubdistrictCreateNestedOneWithoutUsersInput = {
    create?: XOR<SubdistrictCreateWithoutUsersInput, SubdistrictUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubdistrictCreateOrConnectWithoutUsersInput
    connect?: SubdistrictWhereUniqueInput
  }

  export type UserLoginCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
  }

  export type ZoneCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type BannerVisitorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type ChampionshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
  }

  export type ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
  }

  export type CodeRedeemerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CodeRedeemerCreateWithoutUserInput, CodeRedeemerUncheckedCreateWithoutUserInput> | CodeRedeemerCreateWithoutUserInput[] | CodeRedeemerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutUserInput | CodeRedeemerCreateOrConnectWithoutUserInput[]
    createMany?: CodeRedeemerCreateManyUserInputEnvelope
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
  }

  export type GempoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
  }

  export type GempoRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
  }

  export type InnerLevelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
  }

  export type LevelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type MatchMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchMemberCreateWithoutUserInput, MatchMemberUncheckedCreateWithoutUserInput> | MatchMemberCreateWithoutUserInput[] | MatchMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutUserInput | MatchMemberCreateOrConnectWithoutUserInput[]
    createMany?: MatchMemberCreateManyUserInputEnvelope
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
  }

  export type MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutUserInput, MatchHistoryMemberUncheckedCreateWithoutUserInput> | MatchHistoryMemberCreateWithoutUserInput[] | MatchHistoryMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutUserInput | MatchHistoryMemberCreateOrConnectWithoutUserInput[]
    createMany?: MatchHistoryMemberCreateManyUserInputEnvelope
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
  }

  export type SubLevelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
  }

  export type TestParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type UserLoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateinventoryInput = {
    set?: number[]
    push?: number | number[]
  }

  export type BannerVisitorUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutUserInput | BannerVisitorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutUserInput | BannerVisitorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutUserInput | BannerVisitorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type ChampionshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipUpsertWithWhereUniqueWithoutUserInput | ChampionshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    set?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    disconnect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    delete?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    update?: ChampionshipUpdateWithWhereUniqueWithoutUserInput | ChampionshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipUpdateManyWithWhereWithoutUserInput | ChampionshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
  }

  export type ChampionshipRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput | ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    set?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    disconnect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    delete?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    update?: ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput | ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipRecordUpdateManyWithWhereWithoutUserInput | ChampionshipRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
  }

  export type CodeRedeemerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CodeRedeemerCreateWithoutUserInput, CodeRedeemerUncheckedCreateWithoutUserInput> | CodeRedeemerCreateWithoutUserInput[] | CodeRedeemerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutUserInput | CodeRedeemerCreateOrConnectWithoutUserInput[]
    upsert?: CodeRedeemerUpsertWithWhereUniqueWithoutUserInput | CodeRedeemerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CodeRedeemerCreateManyUserInputEnvelope
    set?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    disconnect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    delete?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    update?: CodeRedeemerUpdateWithWhereUniqueWithoutUserInput | CodeRedeemerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CodeRedeemerUpdateManyWithWhereWithoutUserInput | CodeRedeemerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CodeRedeemerScalarWhereInput | CodeRedeemerScalarWhereInput[]
  }

  export type GempoUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    upsert?: GempoUpsertWithWhereUniqueWithoutUserInput | GempoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    set?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    disconnect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    delete?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    update?: GempoUpdateWithWhereUniqueWithoutUserInput | GempoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoUpdateManyWithWhereWithoutUserInput | GempoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoScalarWhereInput | GempoScalarWhereInput[]
  }

  export type GempoRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    upsert?: GempoRecordUpsertWithWhereUniqueWithoutUserInput | GempoRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    set?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    disconnect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    delete?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    update?: GempoRecordUpdateWithWhereUniqueWithoutUserInput | GempoRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoRecordUpdateManyWithWhereWithoutUserInput | GempoRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
  }

  export type InnerLevelUpdateManyWithoutUserNestedInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    upsert?: InnerLevelUpsertWithWhereUniqueWithoutUserInput | InnerLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    set?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    disconnect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    delete?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    update?: InnerLevelUpdateWithWhereUniqueWithoutUserInput | InnerLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InnerLevelUpdateManyWithWhereWithoutUserInput | InnerLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
  }

  export type LevelUpdateManyWithoutUserNestedInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutUserInput | LevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutUserInput | LevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutUserInput | LevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type MatchMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchMemberCreateWithoutUserInput, MatchMemberUncheckedCreateWithoutUserInput> | MatchMemberCreateWithoutUserInput[] | MatchMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutUserInput | MatchMemberCreateOrConnectWithoutUserInput[]
    upsert?: MatchMemberUpsertWithWhereUniqueWithoutUserInput | MatchMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchMemberCreateManyUserInputEnvelope
    set?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    disconnect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    delete?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    update?: MatchMemberUpdateWithWhereUniqueWithoutUserInput | MatchMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchMemberUpdateManyWithWhereWithoutUserInput | MatchMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchMemberScalarWhereInput | MatchMemberScalarWhereInput[]
  }

  export type MatchHistoryMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutUserInput, MatchHistoryMemberUncheckedCreateWithoutUserInput> | MatchHistoryMemberCreateWithoutUserInput[] | MatchHistoryMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutUserInput | MatchHistoryMemberCreateOrConnectWithoutUserInput[]
    upsert?: MatchHistoryMemberUpsertWithWhereUniqueWithoutUserInput | MatchHistoryMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchHistoryMemberCreateManyUserInputEnvelope
    set?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    disconnect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    delete?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    update?: MatchHistoryMemberUpdateWithWhereUniqueWithoutUserInput | MatchHistoryMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchHistoryMemberUpdateManyWithWhereWithoutUserInput | MatchHistoryMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchHistoryMemberScalarWhereInput | MatchHistoryMemberScalarWhereInput[]
  }

  export type SubLevelUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    upsert?: SubLevelUpsertWithWhereUniqueWithoutUserInput | SubLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    set?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    disconnect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    delete?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    update?: SubLevelUpdateWithWhereUniqueWithoutUserInput | SubLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubLevelUpdateManyWithWhereWithoutUserInput | SubLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
  }

  export type TestParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutUserInput | TestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutUserInput | TestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutUserInput | TestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type CityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutUsersInput, CityUpdateWithoutUsersInput>, CityUncheckedUpdateWithoutUsersInput>
  }

  export type ProvinceUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUsersInput
    upsert?: ProvinceUpsertWithoutUsersInput
    disconnect?: ProvinceWhereInput | boolean
    delete?: ProvinceWhereInput | boolean
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutUsersInput, ProvinceUpdateWithoutUsersInput>, ProvinceUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SubdistrictUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SubdistrictCreateWithoutUsersInput, SubdistrictUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubdistrictCreateOrConnectWithoutUsersInput
    upsert?: SubdistrictUpsertWithoutUsersInput
    disconnect?: SubdistrictWhereInput | boolean
    delete?: SubdistrictWhereInput | boolean
    connect?: SubdistrictWhereUniqueInput
    update?: XOR<XOR<SubdistrictUpdateToOneWithWhereWithoutUsersInput, SubdistrictUpdateWithoutUsersInput>, SubdistrictUncheckedUpdateWithoutUsersInput>
  }

  export type UserLoginUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginUpsertWithWhereUniqueWithoutUserInput | UserLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    set?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    disconnect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    delete?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    update?: UserLoginUpdateWithWhereUniqueWithoutUserInput | UserLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginUpdateManyWithWhereWithoutUserInput | UserLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
  }

  export type ZoneUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUserInput | ZoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUserInput | ZoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUserInput | ZoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type BannerVisitorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutUserInput | BannerVisitorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutUserInput | BannerVisitorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutUserInput | BannerVisitorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type ChampionshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipUpsertWithWhereUniqueWithoutUserInput | ChampionshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    set?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    disconnect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    delete?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    update?: ChampionshipUpdateWithWhereUniqueWithoutUserInput | ChampionshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipUpdateManyWithWhereWithoutUserInput | ChampionshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
  }

  export type ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput | ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    set?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    disconnect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    delete?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    update?: ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput | ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipRecordUpdateManyWithWhereWithoutUserInput | ChampionshipRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
  }

  export type CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CodeRedeemerCreateWithoutUserInput, CodeRedeemerUncheckedCreateWithoutUserInput> | CodeRedeemerCreateWithoutUserInput[] | CodeRedeemerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutUserInput | CodeRedeemerCreateOrConnectWithoutUserInput[]
    upsert?: CodeRedeemerUpsertWithWhereUniqueWithoutUserInput | CodeRedeemerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CodeRedeemerCreateManyUserInputEnvelope
    set?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    disconnect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    delete?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    update?: CodeRedeemerUpdateWithWhereUniqueWithoutUserInput | CodeRedeemerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CodeRedeemerUpdateManyWithWhereWithoutUserInput | CodeRedeemerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CodeRedeemerScalarWhereInput | CodeRedeemerScalarWhereInput[]
  }

  export type GempoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    upsert?: GempoUpsertWithWhereUniqueWithoutUserInput | GempoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    set?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    disconnect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    delete?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    update?: GempoUpdateWithWhereUniqueWithoutUserInput | GempoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoUpdateManyWithWhereWithoutUserInput | GempoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoScalarWhereInput | GempoScalarWhereInput[]
  }

  export type GempoRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    upsert?: GempoRecordUpsertWithWhereUniqueWithoutUserInput | GempoRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    set?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    disconnect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    delete?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    update?: GempoRecordUpdateWithWhereUniqueWithoutUserInput | GempoRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoRecordUpdateManyWithWhereWithoutUserInput | GempoRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
  }

  export type InnerLevelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    upsert?: InnerLevelUpsertWithWhereUniqueWithoutUserInput | InnerLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    set?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    disconnect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    delete?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    update?: InnerLevelUpdateWithWhereUniqueWithoutUserInput | InnerLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InnerLevelUpdateManyWithWhereWithoutUserInput | InnerLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
  }

  export type LevelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutUserInput | LevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutUserInput | LevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutUserInput | LevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type MatchMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchMemberCreateWithoutUserInput, MatchMemberUncheckedCreateWithoutUserInput> | MatchMemberCreateWithoutUserInput[] | MatchMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutUserInput | MatchMemberCreateOrConnectWithoutUserInput[]
    upsert?: MatchMemberUpsertWithWhereUniqueWithoutUserInput | MatchMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchMemberCreateManyUserInputEnvelope
    set?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    disconnect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    delete?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    update?: MatchMemberUpdateWithWhereUniqueWithoutUserInput | MatchMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchMemberUpdateManyWithWhereWithoutUserInput | MatchMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchMemberScalarWhereInput | MatchMemberScalarWhereInput[]
  }

  export type MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutUserInput, MatchHistoryMemberUncheckedCreateWithoutUserInput> | MatchHistoryMemberCreateWithoutUserInput[] | MatchHistoryMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutUserInput | MatchHistoryMemberCreateOrConnectWithoutUserInput[]
    upsert?: MatchHistoryMemberUpsertWithWhereUniqueWithoutUserInput | MatchHistoryMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchHistoryMemberCreateManyUserInputEnvelope
    set?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    disconnect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    delete?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    update?: MatchHistoryMemberUpdateWithWhereUniqueWithoutUserInput | MatchHistoryMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchHistoryMemberUpdateManyWithWhereWithoutUserInput | MatchHistoryMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchHistoryMemberScalarWhereInput | MatchHistoryMemberScalarWhereInput[]
  }

  export type SubLevelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    upsert?: SubLevelUpsertWithWhereUniqueWithoutUserInput | SubLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    set?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    disconnect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    delete?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    update?: SubLevelUpdateWithWhereUniqueWithoutUserInput | SubLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubLevelUpdateManyWithWhereWithoutUserInput | SubLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
  }

  export type TestParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutUserInput | TestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutUserInput | TestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutUserInput | TestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type UserLoginUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginUpsertWithWhereUniqueWithoutUserInput | UserLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    set?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    disconnect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    delete?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    update?: UserLoginUpdateWithWhereUniqueWithoutUserInput | UserLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginUpdateManyWithWhereWithoutUserInput | UserLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUserInput | ZoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUserInput | ZoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUserInput | ZoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutZonesInput = {
    create?: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutZonesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutZonesInput
    upsert?: UserUpsertWithoutZonesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZonesInput, UserUpdateWithoutZonesInput>, UserUncheckedUpdateWithoutZonesInput>
  }

  export type UserCreateNestedOneWithoutLevelsInput = {
    create?: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLevelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLevelsInput
    upsert?: UserUpsertWithoutLevelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLevelsInput, UserUpdateWithoutLevelsInput>, UserUncheckedUpdateWithoutLevelsInput>
  }

  export type UserCreateNestedOneWithoutSubLevelsInput = {
    create?: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubLevelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubLevelsNestedInput = {
    create?: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubLevelsInput
    upsert?: UserUpsertWithoutSubLevelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubLevelsInput, UserUpdateWithoutSubLevelsInput>, UserUncheckedUpdateWithoutSubLevelsInput>
  }

  export type UserCreateNestedOneWithoutInnerLevelsInput = {
    create?: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInnerLevelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInnerLevelsNestedInput = {
    create?: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInnerLevelsInput
    upsert?: UserUpsertWithoutInnerLevelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInnerLevelsInput, UserUpdateWithoutInnerLevelsInput>, UserUncheckedUpdateWithoutInnerLevelsInput>
  }

  export type UserCreateNestedOneWithoutGemposInput = {
    create?: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
    connectOrCreate?: UserCreateOrConnectWithoutGemposInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGemposNestedInput = {
    create?: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
    connectOrCreate?: UserCreateOrConnectWithoutGemposInput
    upsert?: UserUpsertWithoutGemposInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGemposInput, UserUpdateWithoutGemposInput>, UserUncheckedUpdateWithoutGemposInput>
  }

  export type UserCreateNestedOneWithoutChampionshipsInput = {
    create?: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChampionshipsNestedInput = {
    create?: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipsInput
    upsert?: UserUpsertWithoutChampionshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChampionshipsInput, UserUpdateWithoutChampionshipsInput>, UserUncheckedUpdateWithoutChampionshipsInput>
  }

  export type UserCreateNestedOneWithoutGempoRecordsInput = {
    create?: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGempoRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGempoRecordsNestedInput = {
    create?: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGempoRecordsInput
    upsert?: UserUpsertWithoutGempoRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGempoRecordsInput, UserUpdateWithoutGempoRecordsInput>, UserUncheckedUpdateWithoutGempoRecordsInput>
  }

  export type UserCreateNestedOneWithoutChampionshipRecordsInput = {
    create?: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChampionshipRecordsNestedInput = {
    create?: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipRecordsInput
    upsert?: UserUpsertWithoutChampionshipRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChampionshipRecordsInput, UserUpdateWithoutChampionshipRecordsInput>, UserUncheckedUpdateWithoutChampionshipRecordsInput>
  }

  export type UserCreateNestedOneWithoutUserLoginInput = {
    create?: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLoginNestedInput = {
    create?: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginInput
    upsert?: UserUpsertWithoutUserLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLoginInput, UserUpdateWithoutUserLoginInput>, UserUncheckedUpdateWithoutUserLoginInput>
  }

  export type ProvinceCreateNestedOneWithoutAdminInput = {
    create?: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAdminInput = {
    create?: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdminInput
    connect?: CityWhereUniqueInput
  }

  export type SubdistrictCreateNestedOneWithoutAdminsInput = {
    create?: XOR<SubdistrictCreateWithoutAdminsInput, SubdistrictUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: SubdistrictCreateOrConnectWithoutAdminsInput
    connect?: SubdistrictWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutAdminInput = {
    create?: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminInput
    connect?: SchoolWhereUniqueInput
  }

  export type AdminAuthorityCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
  }

  export type AdminOperationHistoryCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminOperationHistoryCreateNestedManyWithoutOpAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminTransactionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type AdminTransactionCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type BannerCreateNestedManyWithoutAdminInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type RedeemCodeCreateNestedManyWithoutAdminInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
  }

  export type TestCreateNestedManyWithoutAdminInput = {
    create?: XOR<TestCreateWithoutAdminInput, TestUncheckedCreateWithoutAdminInput> | TestCreateWithoutAdminInput[] | TestUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TestCreateOrConnectWithoutAdminInput | TestCreateOrConnectWithoutAdminInput[]
    createMany?: TestCreateManyAdminInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
  }

  export type AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminTransactionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type BannerUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type RedeemCodeUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
  }

  export type TestUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<TestCreateWithoutAdminInput, TestUncheckedCreateWithoutAdminInput> | TestCreateWithoutAdminInput[] | TestUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TestCreateOrConnectWithoutAdminInput | TestCreateOrConnectWithoutAdminInput[]
    createMany?: TestCreateManyAdminInputEnvelope
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type ProvinceUpdateOneWithoutAdminNestedInput = {
    create?: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminInput
    upsert?: ProvinceUpsertWithoutAdminInput
    disconnect?: ProvinceWhereInput | boolean
    delete?: ProvinceWhereInput | boolean
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutAdminInput, ProvinceUpdateWithoutAdminInput>, ProvinceUncheckedUpdateWithoutAdminInput>
  }

  export type CityUpdateOneWithoutAdminNestedInput = {
    create?: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdminInput
    upsert?: CityUpsertWithoutAdminInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAdminInput, CityUpdateWithoutAdminInput>, CityUncheckedUpdateWithoutAdminInput>
  }

  export type SubdistrictUpdateOneWithoutAdminsNestedInput = {
    create?: XOR<SubdistrictCreateWithoutAdminsInput, SubdistrictUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: SubdistrictCreateOrConnectWithoutAdminsInput
    upsert?: SubdistrictUpsertWithoutAdminsInput
    disconnect?: SubdistrictWhereInput | boolean
    delete?: SubdistrictWhereInput | boolean
    connect?: SubdistrictWhereUniqueInput
    update?: XOR<XOR<SubdistrictUpdateToOneWithWhereWithoutAdminsInput, SubdistrictUpdateWithoutAdminsInput>, SubdistrictUncheckedUpdateWithoutAdminsInput>
  }

  export type SchoolUpdateOneWithoutAdminNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminInput
    upsert?: SchoolUpsertWithoutAdminInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAdminInput, SchoolUpdateWithoutAdminInput>, SchoolUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput | AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput | AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutAdminInput | AdminAuthorityUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminLogUpsertWithWhereUniqueWithoutAdminInput | AdminLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    set?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    disconnect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    delete?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    update?: AdminLogUpdateWithWhereUniqueWithoutAdminInput | AdminLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminLogUpdateManyWithWhereWithoutAdminInput | AdminLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
  }

  export type AdminOperationHistoryUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminTransactionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutAdminInput | AdminTransactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutAdminInput | AdminTransactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutAdminInput | AdminTransactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type AdminTransactionUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutProcessedByInput | AdminTransactionUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type BannerUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutAdminInput | BannerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutAdminInput | BannerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutAdminInput | BannerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type RedeemCodeUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    upsert?: RedeemCodeUpsertWithWhereUniqueWithoutAdminInput | RedeemCodeUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    set?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    disconnect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    delete?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    update?: RedeemCodeUpdateWithWhereUniqueWithoutAdminInput | RedeemCodeUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RedeemCodeUpdateManyWithWhereWithoutAdminInput | RedeemCodeUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
  }

  export type TestUpdateManyWithoutAdminNestedInput = {
    create?: XOR<TestCreateWithoutAdminInput, TestUncheckedCreateWithoutAdminInput> | TestCreateWithoutAdminInput[] | TestUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TestCreateOrConnectWithoutAdminInput | TestCreateOrConnectWithoutAdminInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutAdminInput | TestUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: TestCreateManyAdminInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutAdminInput | TestUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: TestUpdateManyWithWhereWithoutAdminInput | TestUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput | AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput | AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutAdminInput | AdminAuthorityUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput> | AdminLogCreateWithoutAdminInput[] | AdminLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLogCreateOrConnectWithoutAdminInput | AdminLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminLogUpsertWithWhereUniqueWithoutAdminInput | AdminLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminLogCreateManyAdminInputEnvelope
    set?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    disconnect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    delete?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    connect?: AdminLogWhereUniqueInput | AdminLogWhereUniqueInput[]
    update?: AdminLogUpdateWithWhereUniqueWithoutAdminInput | AdminLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminLogUpdateManyWithWhereWithoutAdminInput | AdminLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutAdminInput | AdminTransactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutAdminInput | AdminTransactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutAdminInput | AdminTransactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutProcessedByInput | AdminTransactionUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type BannerUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutAdminInput | BannerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutAdminInput | BannerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutAdminInput | BannerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    upsert?: RedeemCodeUpsertWithWhereUniqueWithoutAdminInput | RedeemCodeUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    set?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    disconnect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    delete?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    update?: RedeemCodeUpdateWithWhereUniqueWithoutAdminInput | RedeemCodeUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RedeemCodeUpdateManyWithWhereWithoutAdminInput | RedeemCodeUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
  }

  export type TestUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<TestCreateWithoutAdminInput, TestUncheckedCreateWithoutAdminInput> | TestCreateWithoutAdminInput[] | TestUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TestCreateOrConnectWithoutAdminInput | TestCreateOrConnectWithoutAdminInput[]
    upsert?: TestUpsertWithWhereUniqueWithoutAdminInput | TestUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: TestCreateManyAdminInputEnvelope
    set?: TestWhereUniqueInput | TestWhereUniqueInput[]
    disconnect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    delete?: TestWhereUniqueInput | TestWhereUniqueInput[]
    connect?: TestWhereUniqueInput | TestWhereUniqueInput[]
    update?: TestUpdateWithWhereUniqueWithoutAdminInput | TestUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: TestUpdateManyWithWhereWithoutAdminInput | TestUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: TestScalarWhereInput | TestScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AdminCreateNestedOneWithoutLogsInput = {
    create?: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLogsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLogsInput
    upsert?: AdminUpsertWithoutLogsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutLogsInput, AdminUpdateWithoutLogsInput>, AdminUncheckedUpdateWithoutLogsInput>
  }

  export type AdminCreateNestedOneWithoutOperationHistoriesInput = {
    create?: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationHistoriesInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutOperationsInput = {
    create?: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumOperationFieldUpdateOperationsInput = {
    set?: $Enums.Operation
  }

  export type AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput = {
    create?: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationHistoriesInput
    upsert?: AdminUpsertWithoutOperationHistoriesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOperationHistoriesInput, AdminUpdateWithoutOperationHistoriesInput>, AdminUncheckedUpdateWithoutOperationHistoriesInput>
  }

  export type AdminUpdateOneRequiredWithoutOperationsNestedInput = {
    create?: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationsInput
    upsert?: AdminUpsertWithoutOperationsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOperationsInput, AdminUpdateWithoutOperationsInput>, AdminUncheckedUpdateWithoutOperationsInput>
  }

  export type AdminAuthorityCreategradesInput = {
    set: number[]
  }

  export type AdminCreateNestedOneWithoutAuthorityInput = {
    create?: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthorityInput
    connect?: AdminWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutAdminAuthorityInput = {
    create?: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminAuthorityInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SubdistrictCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SubdistrictCreateWithoutAdminAuthorityInput, SubdistrictUncheckedCreateWithoutAdminAuthorityInput> | SubdistrictCreateWithoutAdminAuthorityInput[] | SubdistrictUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutAdminAuthorityInput | SubdistrictCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type SchoolCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SubdistrictUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SubdistrictCreateWithoutAdminAuthorityInput, SubdistrictUncheckedCreateWithoutAdminAuthorityInput> | SubdistrictCreateWithoutAdminAuthorityInput[] | SubdistrictUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutAdminAuthorityInput | SubdistrictCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type AdminAuthorityUpdategradesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AdminUpdateOneRequiredWithoutAuthorityNestedInput = {
    create?: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthorityInput
    upsert?: AdminUpsertWithoutAuthorityInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuthorityInput, AdminUpdateWithoutAuthorityInput>, AdminUncheckedUpdateWithoutAuthorityInput>
  }

  export type ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput = {
    create?: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminAuthorityInput
    upsert?: ProvinceUpsertWithoutAdminAuthorityInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutAdminAuthorityInput, ProvinceUpdateWithoutAdminAuthorityInput>, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type CityUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutAdminAuthorityInput | CityUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutAdminAuthorityInput | CityUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: CityUpdateManyWithWhereWithoutAdminAuthorityInput | CityUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SubdistrictUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SubdistrictCreateWithoutAdminAuthorityInput, SubdistrictUncheckedCreateWithoutAdminAuthorityInput> | SubdistrictCreateWithoutAdminAuthorityInput[] | SubdistrictUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutAdminAuthorityInput | SubdistrictCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutAdminAuthorityInput | SubdistrictUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutAdminAuthorityInput | SubdistrictUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutAdminAuthorityInput | SubdistrictUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type SchoolUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAdminAuthorityInput | SchoolUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutAdminAuthorityInput | CityUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutAdminAuthorityInput | CityUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: CityUpdateManyWithWhereWithoutAdminAuthorityInput | CityUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SubdistrictUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SubdistrictCreateWithoutAdminAuthorityInput, SubdistrictUncheckedCreateWithoutAdminAuthorityInput> | SubdistrictCreateWithoutAdminAuthorityInput[] | SubdistrictUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutAdminAuthorityInput | SubdistrictCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutAdminAuthorityInput | SubdistrictUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutAdminAuthorityInput | SubdistrictUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutAdminAuthorityInput | SubdistrictUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAdminAuthorityInput | SchoolUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutBannerInput = {
    create?: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    connectOrCreate?: AdminCreateOrConnectWithoutBannerInput
    connect?: AdminWhereUniqueInput
  }

  export type ProvinceCreateNestedManyWithoutBannersInput = {
    create?: XOR<ProvinceCreateWithoutBannersInput, ProvinceUncheckedCreateWithoutBannersInput> | ProvinceCreateWithoutBannersInput[] | ProvinceUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannersInput | ProvinceCreateOrConnectWithoutBannersInput[]
    connect?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
  }

  export type CityCreateNestedManyWithoutBannersInput = {
    create?: XOR<CityCreateWithoutBannersInput, CityUncheckedCreateWithoutBannersInput> | CityCreateWithoutBannersInput[] | CityUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannersInput | CityCreateOrConnectWithoutBannersInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SubdistrictCreateNestedManyWithoutBannersInput = {
    create?: XOR<SubdistrictCreateWithoutBannersInput, SubdistrictUncheckedCreateWithoutBannersInput> | SubdistrictCreateWithoutBannersInput[] | SubdistrictUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutBannersInput | SubdistrictCreateOrConnectWithoutBannersInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type BannerVisitorCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type ProvinceUncheckedCreateNestedManyWithoutBannersInput = {
    create?: XOR<ProvinceCreateWithoutBannersInput, ProvinceUncheckedCreateWithoutBannersInput> | ProvinceCreateWithoutBannersInput[] | ProvinceUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannersInput | ProvinceCreateOrConnectWithoutBannersInput[]
    connect?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutBannersInput = {
    create?: XOR<CityCreateWithoutBannersInput, CityUncheckedCreateWithoutBannersInput> | CityCreateWithoutBannersInput[] | CityUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannersInput | CityCreateOrConnectWithoutBannersInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SubdistrictUncheckedCreateNestedManyWithoutBannersInput = {
    create?: XOR<SubdistrictCreateWithoutBannersInput, SubdistrictUncheckedCreateWithoutBannersInput> | SubdistrictCreateWithoutBannersInput[] | SubdistrictUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutBannersInput | SubdistrictCreateOrConnectWithoutBannersInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
  }

  export type BannerVisitorUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutBannerNestedInput = {
    create?: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    connectOrCreate?: AdminCreateOrConnectWithoutBannerInput
    upsert?: AdminUpsertWithoutBannerInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutBannerInput, AdminUpdateWithoutBannerInput>, AdminUncheckedUpdateWithoutBannerInput>
  }

  export type ProvinceUpdateManyWithoutBannersNestedInput = {
    create?: XOR<ProvinceCreateWithoutBannersInput, ProvinceUncheckedCreateWithoutBannersInput> | ProvinceCreateWithoutBannersInput[] | ProvinceUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannersInput | ProvinceCreateOrConnectWithoutBannersInput[]
    upsert?: ProvinceUpsertWithWhereUniqueWithoutBannersInput | ProvinceUpsertWithWhereUniqueWithoutBannersInput[]
    set?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    disconnect?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    delete?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    connect?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    update?: ProvinceUpdateWithWhereUniqueWithoutBannersInput | ProvinceUpdateWithWhereUniqueWithoutBannersInput[]
    updateMany?: ProvinceUpdateManyWithWhereWithoutBannersInput | ProvinceUpdateManyWithWhereWithoutBannersInput[]
    deleteMany?: ProvinceScalarWhereInput | ProvinceScalarWhereInput[]
  }

  export type CityUpdateManyWithoutBannersNestedInput = {
    create?: XOR<CityCreateWithoutBannersInput, CityUncheckedCreateWithoutBannersInput> | CityCreateWithoutBannersInput[] | CityUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannersInput | CityCreateOrConnectWithoutBannersInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutBannersInput | CityUpsertWithWhereUniqueWithoutBannersInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutBannersInput | CityUpdateWithWhereUniqueWithoutBannersInput[]
    updateMany?: CityUpdateManyWithWhereWithoutBannersInput | CityUpdateManyWithWhereWithoutBannersInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SubdistrictUpdateManyWithoutBannersNestedInput = {
    create?: XOR<SubdistrictCreateWithoutBannersInput, SubdistrictUncheckedCreateWithoutBannersInput> | SubdistrictCreateWithoutBannersInput[] | SubdistrictUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutBannersInput | SubdistrictCreateOrConnectWithoutBannersInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutBannersInput | SubdistrictUpsertWithWhereUniqueWithoutBannersInput[]
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutBannersInput | SubdistrictUpdateWithWhereUniqueWithoutBannersInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutBannersInput | SubdistrictUpdateManyWithWhereWithoutBannersInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type BannerVisitorUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutBannerInput | BannerVisitorUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutBannerInput | BannerVisitorUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutBannerInput | BannerVisitorUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type ProvinceUncheckedUpdateManyWithoutBannersNestedInput = {
    create?: XOR<ProvinceCreateWithoutBannersInput, ProvinceUncheckedCreateWithoutBannersInput> | ProvinceCreateWithoutBannersInput[] | ProvinceUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannersInput | ProvinceCreateOrConnectWithoutBannersInput[]
    upsert?: ProvinceUpsertWithWhereUniqueWithoutBannersInput | ProvinceUpsertWithWhereUniqueWithoutBannersInput[]
    set?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    disconnect?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    delete?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    connect?: ProvinceWhereUniqueInput | ProvinceWhereUniqueInput[]
    update?: ProvinceUpdateWithWhereUniqueWithoutBannersInput | ProvinceUpdateWithWhereUniqueWithoutBannersInput[]
    updateMany?: ProvinceUpdateManyWithWhereWithoutBannersInput | ProvinceUpdateManyWithWhereWithoutBannersInput[]
    deleteMany?: ProvinceScalarWhereInput | ProvinceScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutBannersNestedInput = {
    create?: XOR<CityCreateWithoutBannersInput, CityUncheckedCreateWithoutBannersInput> | CityCreateWithoutBannersInput[] | CityUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannersInput | CityCreateOrConnectWithoutBannersInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutBannersInput | CityUpsertWithWhereUniqueWithoutBannersInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutBannersInput | CityUpdateWithWhereUniqueWithoutBannersInput[]
    updateMany?: CityUpdateManyWithWhereWithoutBannersInput | CityUpdateManyWithWhereWithoutBannersInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SubdistrictUncheckedUpdateManyWithoutBannersNestedInput = {
    create?: XOR<SubdistrictCreateWithoutBannersInput, SubdistrictUncheckedCreateWithoutBannersInput> | SubdistrictCreateWithoutBannersInput[] | SubdistrictUncheckedCreateWithoutBannersInput[]
    connectOrCreate?: SubdistrictCreateOrConnectWithoutBannersInput | SubdistrictCreateOrConnectWithoutBannersInput[]
    upsert?: SubdistrictUpsertWithWhereUniqueWithoutBannersInput | SubdistrictUpsertWithWhereUniqueWithoutBannersInput[]
    set?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    disconnect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    delete?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    connect?: SubdistrictWhereUniqueInput | SubdistrictWhereUniqueInput[]
    update?: SubdistrictUpdateWithWhereUniqueWithoutBannersInput | SubdistrictUpdateWithWhereUniqueWithoutBannersInput[]
    updateMany?: SubdistrictUpdateManyWithWhereWithoutBannersInput | SubdistrictUpdateManyWithWhereWithoutBannersInput[]
    deleteMany?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
  }

  export type BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutBannerInput | BannerVisitorUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutBannerInput | BannerVisitorUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutBannerInput | BannerVisitorUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type BannerCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutVisitorsInput
    connect?: BannerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBannerVisitorInput = {
    create?: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannerVisitorInput
    connect?: UserWhereUniqueInput
  }

  export type BannerUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutVisitorsInput
    upsert?: BannerUpsertWithoutVisitorsInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutVisitorsInput, BannerUpdateWithoutVisitorsInput>, BannerUncheckedUpdateWithoutVisitorsInput>
  }

  export type UserUpdateOneRequiredWithoutBannerVisitorNestedInput = {
    create?: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannerVisitorInput
    upsert?: UserUpsertWithoutBannerVisitorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBannerVisitorInput, UserUpdateWithoutBannerVisitorInput>, UserUncheckedUpdateWithoutBannerVisitorInput>
  }

  export type AdminCreateNestedOneWithoutTestsInput = {
    create?: XOR<AdminCreateWithoutTestsInput, AdminUncheckedCreateWithoutTestsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTestsInput
    connect?: AdminWhereUniqueInput
  }

  export type TestParticipantCreateNestedManyWithoutTestInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type TestParticipantUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type EnumTestTypeFieldUpdateOperationsInput = {
    set?: $Enums.TestType
  }

  export type AdminUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<AdminCreateWithoutTestsInput, AdminUncheckedCreateWithoutTestsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTestsInput
    upsert?: AdminUpsertWithoutTestsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutTestsInput, AdminUpdateWithoutTestsInput>, AdminUncheckedUpdateWithoutTestsInput>
  }

  export type TestParticipantUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutTestInput | TestParticipantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutTestInput | TestParticipantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutTestInput | TestParticipantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type TestParticipantUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutTestInput | TestParticipantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutTestInput | TestParticipantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutTestInput | TestParticipantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type TestCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TestCreateOrConnectWithoutParticipantsInput
    connect?: TestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestParticipantInput = {
    create?: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type TestParticipantRecordCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type TestUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TestCreateOrConnectWithoutParticipantsInput
    upsert?: TestUpsertWithoutParticipantsInput
    connect?: TestWhereUniqueInput
    update?: XOR<XOR<TestUpdateToOneWithWhereWithoutParticipantsInput, TestUpdateWithoutParticipantsInput>, TestUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTestParticipantNestedInput = {
    create?: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestParticipantInput
    upsert?: UserUpsertWithoutTestParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestParticipantInput, UserUpdateWithoutTestParticipantInput>, UserUncheckedUpdateWithoutTestParticipantInput>
  }

  export type TestParticipantRecordUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput | TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput | TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type TestParticipantCreateNestedOneWithoutRecordsInput = {
    create?: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TestParticipantCreateOrConnectWithoutRecordsInput
    connect?: TestParticipantWhereUniqueInput
  }

  export type TestParticipantUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TestParticipantCreateOrConnectWithoutRecordsInput
    upsert?: TestParticipantUpsertWithoutRecordsInput
    connect?: TestParticipantWhereUniqueInput
    update?: XOR<XOR<TestParticipantUpdateToOneWithWhereWithoutRecordsInput, TestParticipantUpdateWithoutRecordsInput>, TestParticipantUncheckedUpdateWithoutRecordsInput>
  }

  export type AdminTransactionCreatezonesInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutTransactionProcessedInput = {
    create?: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionProcessedInput
    connect?: AdminWhereUniqueInput
  }

  export type RedeemCodeCreateNestedOneWithoutTransactionInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type AdminTransactionUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTransactionFieldUpdateOperationsInput = {
    set?: $Enums.Transaction
  }

  export type AdminUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionsInput
    upsert?: AdminUpsertWithoutTransactionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutTransactionsInput, AdminUpdateWithoutTransactionsInput>, AdminUncheckedUpdateWithoutTransactionsInput>
  }

  export type AdminUpdateOneWithoutTransactionProcessedNestedInput = {
    create?: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionProcessedInput
    upsert?: AdminUpsertWithoutTransactionProcessedInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutTransactionProcessedInput, AdminUpdateWithoutTransactionProcessedInput>, AdminUncheckedUpdateWithoutTransactionProcessedInput>
  }

  export type RedeemCodeUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    upsert?: RedeemCodeUpsertWithoutTransactionInput
    disconnect?: RedeemCodeWhereInput | boolean
    delete?: RedeemCodeWhereInput | boolean
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutTransactionInput, RedeemCodeUpdateWithoutTransactionInput>, RedeemCodeUncheckedUpdateWithoutTransactionInput>
  }

  export type RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    upsert?: RedeemCodeUpsertWithoutTransactionInput
    disconnect?: RedeemCodeWhereInput | boolean
    delete?: RedeemCodeWhereInput | boolean
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutTransactionInput, RedeemCodeUpdateWithoutTransactionInput>, RedeemCodeUncheckedUpdateWithoutTransactionInput>
  }

  export type RedeemCodeCreatedataInput = {
    set: string[]
  }

  export type CodeRedeemerCreateNestedManyWithoutCodeInput = {
    create?: XOR<CodeRedeemerCreateWithoutCodeInput, CodeRedeemerUncheckedCreateWithoutCodeInput> | CodeRedeemerCreateWithoutCodeInput[] | CodeRedeemerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutCodeInput | CodeRedeemerCreateOrConnectWithoutCodeInput[]
    createMany?: CodeRedeemerCreateManyCodeInputEnvelope
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutRedeemCodesInput = {
    create?: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRedeemCodesInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminTransactionCreateNestedOneWithoutRedeemCodeInput = {
    create?: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutRedeemCodeInput
    connect?: AdminTransactionWhereUniqueInput
  }

  export type CodeRedeemerUncheckedCreateNestedManyWithoutCodeInput = {
    create?: XOR<CodeRedeemerCreateWithoutCodeInput, CodeRedeemerUncheckedCreateWithoutCodeInput> | CodeRedeemerCreateWithoutCodeInput[] | CodeRedeemerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutCodeInput | CodeRedeemerCreateOrConnectWithoutCodeInput[]
    createMany?: CodeRedeemerCreateManyCodeInputEnvelope
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
  }

  export type RedeemCodeUpdatedataInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CodeRedeemerUpdateManyWithoutCodeNestedInput = {
    create?: XOR<CodeRedeemerCreateWithoutCodeInput, CodeRedeemerUncheckedCreateWithoutCodeInput> | CodeRedeemerCreateWithoutCodeInput[] | CodeRedeemerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutCodeInput | CodeRedeemerCreateOrConnectWithoutCodeInput[]
    upsert?: CodeRedeemerUpsertWithWhereUniqueWithoutCodeInput | CodeRedeemerUpsertWithWhereUniqueWithoutCodeInput[]
    createMany?: CodeRedeemerCreateManyCodeInputEnvelope
    set?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    disconnect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    delete?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    update?: CodeRedeemerUpdateWithWhereUniqueWithoutCodeInput | CodeRedeemerUpdateWithWhereUniqueWithoutCodeInput[]
    updateMany?: CodeRedeemerUpdateManyWithWhereWithoutCodeInput | CodeRedeemerUpdateManyWithWhereWithoutCodeInput[]
    deleteMany?: CodeRedeemerScalarWhereInput | CodeRedeemerScalarWhereInput[]
  }

  export type AdminUpdateOneRequiredWithoutRedeemCodesNestedInput = {
    create?: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRedeemCodesInput
    upsert?: AdminUpsertWithoutRedeemCodesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutRedeemCodesInput, AdminUpdateWithoutRedeemCodesInput>, AdminUncheckedUpdateWithoutRedeemCodesInput>
  }

  export type AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutRedeemCodeInput
    upsert?: AdminTransactionUpsertWithoutRedeemCodeInput
    connect?: AdminTransactionWhereUniqueInput
    update?: XOR<XOR<AdminTransactionUpdateToOneWithWhereWithoutRedeemCodeInput, AdminTransactionUpdateWithoutRedeemCodeInput>, AdminTransactionUncheckedUpdateWithoutRedeemCodeInput>
  }

  export type CodeRedeemerUncheckedUpdateManyWithoutCodeNestedInput = {
    create?: XOR<CodeRedeemerCreateWithoutCodeInput, CodeRedeemerUncheckedCreateWithoutCodeInput> | CodeRedeemerCreateWithoutCodeInput[] | CodeRedeemerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedeemerCreateOrConnectWithoutCodeInput | CodeRedeemerCreateOrConnectWithoutCodeInput[]
    upsert?: CodeRedeemerUpsertWithWhereUniqueWithoutCodeInput | CodeRedeemerUpsertWithWhereUniqueWithoutCodeInput[]
    createMany?: CodeRedeemerCreateManyCodeInputEnvelope
    set?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    disconnect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    delete?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    connect?: CodeRedeemerWhereUniqueInput | CodeRedeemerWhereUniqueInput[]
    update?: CodeRedeemerUpdateWithWhereUniqueWithoutCodeInput | CodeRedeemerUpdateWithWhereUniqueWithoutCodeInput[]
    updateMany?: CodeRedeemerUpdateManyWithWhereWithoutCodeInput | CodeRedeemerUpdateManyWithWhereWithoutCodeInput[]
    deleteMany?: CodeRedeemerScalarWhereInput | CodeRedeemerScalarWhereInput[]
  }

  export type RedeemCodeCreateNestedOneWithoutRedeemersInput = {
    create?: XOR<RedeemCodeCreateWithoutRedeemersInput, RedeemCodeUncheckedCreateWithoutRedeemersInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutRedeemersInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRedeemedCodesInput = {
    create?: XOR<UserCreateWithoutRedeemedCodesInput, UserUncheckedCreateWithoutRedeemedCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedCodesInput
    connect?: UserWhereUniqueInput
  }

  export type RedeemCodeUpdateOneRequiredWithoutRedeemersNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutRedeemersInput, RedeemCodeUncheckedCreateWithoutRedeemersInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutRedeemersInput
    upsert?: RedeemCodeUpsertWithoutRedeemersInput
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutRedeemersInput, RedeemCodeUpdateWithoutRedeemersInput>, RedeemCodeUncheckedUpdateWithoutRedeemersInput>
  }

  export type UserUpdateOneRequiredWithoutRedeemedCodesNestedInput = {
    create?: XOR<UserCreateWithoutRedeemedCodesInput, UserUncheckedCreateWithoutRedeemedCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedeemedCodesInput
    upsert?: UserUpsertWithoutRedeemedCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRedeemedCodesInput, UserUpdateWithoutRedeemedCodesInput>, UserUncheckedUpdateWithoutRedeemedCodesInput>
  }

  export type MatchMemberCreateNestedManyWithoutRoomInput = {
    create?: XOR<MatchMemberCreateWithoutRoomInput, MatchMemberUncheckedCreateWithoutRoomInput> | MatchMemberCreateWithoutRoomInput[] | MatchMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutRoomInput | MatchMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MatchMemberCreateManyRoomInputEnvelope
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
  }

  export type MatchMemberUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MatchMemberCreateWithoutRoomInput, MatchMemberUncheckedCreateWithoutRoomInput> | MatchMemberCreateWithoutRoomInput[] | MatchMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutRoomInput | MatchMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MatchMemberCreateManyRoomInputEnvelope
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
  }

  export type EnumMatchModeFieldUpdateOperationsInput = {
    set?: $Enums.MatchMode
  }

  export type MatchMemberUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MatchMemberCreateWithoutRoomInput, MatchMemberUncheckedCreateWithoutRoomInput> | MatchMemberCreateWithoutRoomInput[] | MatchMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutRoomInput | MatchMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MatchMemberUpsertWithWhereUniqueWithoutRoomInput | MatchMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MatchMemberCreateManyRoomInputEnvelope
    set?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    disconnect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    delete?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    update?: MatchMemberUpdateWithWhereUniqueWithoutRoomInput | MatchMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MatchMemberUpdateManyWithWhereWithoutRoomInput | MatchMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MatchMemberScalarWhereInput | MatchMemberScalarWhereInput[]
  }

  export type MatchMemberUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MatchMemberCreateWithoutRoomInput, MatchMemberUncheckedCreateWithoutRoomInput> | MatchMemberCreateWithoutRoomInput[] | MatchMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchMemberCreateOrConnectWithoutRoomInput | MatchMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MatchMemberUpsertWithWhereUniqueWithoutRoomInput | MatchMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MatchMemberCreateManyRoomInputEnvelope
    set?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    disconnect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    delete?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    connect?: MatchMemberWhereUniqueInput | MatchMemberWhereUniqueInput[]
    update?: MatchMemberUpdateWithWhereUniqueWithoutRoomInput | MatchMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MatchMemberUpdateManyWithWhereWithoutRoomInput | MatchMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MatchMemberScalarWhereInput | MatchMemberScalarWhereInput[]
  }

  export type ChampionshipMatchCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChampionshipMatchCreateWithoutMembersInput, ChampionshipMatchUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChampionshipMatchCreateOrConnectWithoutMembersInput
    connect?: ChampionshipMatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchMembersInput = {
    create?: XOR<UserCreateWithoutMatchMembersInput, UserUncheckedCreateWithoutMatchMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type EnumTeamTypeFieldUpdateOperationsInput = {
    set?: $Enums.TeamType
  }

  export type ChampionshipMatchUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChampionshipMatchCreateWithoutMembersInput, ChampionshipMatchUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChampionshipMatchCreateOrConnectWithoutMembersInput
    upsert?: ChampionshipMatchUpsertWithoutMembersInput
    connect?: ChampionshipMatchWhereUniqueInput
    update?: XOR<XOR<ChampionshipMatchUpdateToOneWithWhereWithoutMembersInput, ChampionshipMatchUpdateWithoutMembersInput>, ChampionshipMatchUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMatchMembersNestedInput = {
    create?: XOR<UserCreateWithoutMatchMembersInput, UserUncheckedCreateWithoutMatchMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchMembersInput
    upsert?: UserUpsertWithoutMatchMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchMembersInput, UserUpdateWithoutMatchMembersInput>, UserUncheckedUpdateWithoutMatchMembersInput>
  }

  export type ChampionshipHistoryCreatecurrentPointInput = {
    set: number[]
  }

  export type MatchHistoryMemberCreateNestedManyWithoutRoomInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutRoomInput, MatchHistoryMemberUncheckedCreateWithoutRoomInput> | MatchHistoryMemberCreateWithoutRoomInput[] | MatchHistoryMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutRoomInput | MatchHistoryMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MatchHistoryMemberCreateManyRoomInputEnvelope
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
  }

  export type MatchHistoryMemberUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutRoomInput, MatchHistoryMemberUncheckedCreateWithoutRoomInput> | MatchHistoryMemberCreateWithoutRoomInput[] | MatchHistoryMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutRoomInput | MatchHistoryMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MatchHistoryMemberCreateManyRoomInputEnvelope
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
  }

  export type ChampionshipHistoryUpdatecurrentPointInput = {
    set?: number[]
    push?: number | number[]
  }

  export type MatchHistoryMemberUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutRoomInput, MatchHistoryMemberUncheckedCreateWithoutRoomInput> | MatchHistoryMemberCreateWithoutRoomInput[] | MatchHistoryMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutRoomInput | MatchHistoryMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MatchHistoryMemberUpsertWithWhereUniqueWithoutRoomInput | MatchHistoryMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MatchHistoryMemberCreateManyRoomInputEnvelope
    set?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    disconnect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    delete?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    update?: MatchHistoryMemberUpdateWithWhereUniqueWithoutRoomInput | MatchHistoryMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MatchHistoryMemberUpdateManyWithWhereWithoutRoomInput | MatchHistoryMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MatchHistoryMemberScalarWhereInput | MatchHistoryMemberScalarWhereInput[]
  }

  export type MatchHistoryMemberUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MatchHistoryMemberCreateWithoutRoomInput, MatchHistoryMemberUncheckedCreateWithoutRoomInput> | MatchHistoryMemberCreateWithoutRoomInput[] | MatchHistoryMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatchHistoryMemberCreateOrConnectWithoutRoomInput | MatchHistoryMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MatchHistoryMemberUpsertWithWhereUniqueWithoutRoomInput | MatchHistoryMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MatchHistoryMemberCreateManyRoomInputEnvelope
    set?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    disconnect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    delete?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    connect?: MatchHistoryMemberWhereUniqueInput | MatchHistoryMemberWhereUniqueInput[]
    update?: MatchHistoryMemberUpdateWithWhereUniqueWithoutRoomInput | MatchHistoryMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MatchHistoryMemberUpdateManyWithWhereWithoutRoomInput | MatchHistoryMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MatchHistoryMemberScalarWhereInput | MatchHistoryMemberScalarWhereInput[]
  }

  export type ChampionshipHistoryCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChampionshipHistoryCreateWithoutMembersInput, ChampionshipHistoryUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChampionshipHistoryCreateOrConnectWithoutMembersInput
    connect?: ChampionshipHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHistoryMatchMembersInput = {
    create?: XOR<UserCreateWithoutHistoryMatchMembersInput, UserUncheckedCreateWithoutHistoryMatchMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoryMatchMembersInput
    connect?: UserWhereUniqueInput
  }

  export type ChampionshipHistoryUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChampionshipHistoryCreateWithoutMembersInput, ChampionshipHistoryUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChampionshipHistoryCreateOrConnectWithoutMembersInput
    upsert?: ChampionshipHistoryUpsertWithoutMembersInput
    connect?: ChampionshipHistoryWhereUniqueInput
    update?: XOR<XOR<ChampionshipHistoryUpdateToOneWithWhereWithoutMembersInput, ChampionshipHistoryUpdateWithoutMembersInput>, ChampionshipHistoryUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutHistoryMatchMembersNestedInput = {
    create?: XOR<UserCreateWithoutHistoryMatchMembersInput, UserUncheckedCreateWithoutHistoryMatchMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoryMatchMembersInput
    upsert?: UserUpsertWithoutHistoryMatchMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHistoryMatchMembersInput, UserUpdateWithoutHistoryMatchMembersInput>, UserUncheckedUpdateWithoutHistoryMatchMembersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumEducationLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumEducationLevelFilter<$PrismaModel> | $Enums.EducationLevel
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumEducationLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EducationLevel | EnumEducationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.EducationLevel[] | ListEnumEducationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumEducationLevelWithAggregatesFilter<$PrismaModel> | $Enums.EducationLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEducationLevelFilter<$PrismaModel>
    _max?: NestedEnumEducationLevelFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationFilter<$PrismaModel> | $Enums.Operation
  }

  export type NestedEnumOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationWithAggregatesFilter<$PrismaModel> | $Enums.Operation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationFilter<$PrismaModel>
    _max?: NestedEnumOperationFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeFilter<$PrismaModel> | $Enums.TestType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.TestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestTypeFilter<$PrismaModel>
    _max?: NestedEnumTestTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTransactionFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFilter<$PrismaModel> | $Enums.Transaction
  }

  export type NestedEnumTransactionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionWithAggregatesFilter<$PrismaModel> | $Enums.Transaction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionFilter<$PrismaModel>
    _max?: NestedEnumTransactionFilter<$PrismaModel>
  }

  export type NestedEnumMatchModeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchMode | EnumMatchModeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchModeFilter<$PrismaModel> | $Enums.MatchMode
  }

  export type NestedEnumMatchModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchMode | EnumMatchModeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchMode[] | ListEnumMatchModeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchModeWithAggregatesFilter<$PrismaModel> | $Enums.MatchMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchModeFilter<$PrismaModel>
    _max?: NestedEnumMatchModeFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumTeamTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamType | EnumTeamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamTypeFilter<$PrismaModel> | $Enums.TeamType
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumTeamTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamType | EnumTeamTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamType[] | ListEnumTeamTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamTypeWithAggregatesFilter<$PrismaModel> | $Enums.TeamType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamTypeFilter<$PrismaModel>
    _max?: NestedEnumTeamTypeFilter<$PrismaModel>
  }

  export type AdminCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutProvinceInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput>
  }

  export type AdminCreateManyProvinceInputEnvelope = {
    data: AdminCreateManyProvinceInput | AdminCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutProvinceInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutProvinceInput = {
    id?: string
    adminId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput>
  }

  export type AdminAuthorityCreateManyProvinceInputEnvelope = {
    data: AdminAuthorityCreateManyProvinceInput | AdminAuthorityCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutProvinceInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityCreateManyProvinceInputEnvelope = {
    data: CityCreateManyProvinceInput | CityCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutProvinceInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutSchoolInput
    city?: CityCreateNestedOneWithoutSchoolsInput
    subdistrict?: SubdistrictCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutProvinceInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput>
  }

  export type SchoolCreateManyProvinceInputEnvelope = {
    data: SchoolCreateManyProvinceInput | SchoolCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProvinceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput>
  }

  export type UserCreateManyProvinceInputEnvelope = {
    data: UserCreateManyProvinceInput | UserCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type SubdistrictCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutProvinceInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutProvinceInput, SubdistrictUncheckedCreateWithoutProvinceInput>
  }

  export type SubdistrictCreateManyProvinceInputEnvelope = {
    data: SubdistrictCreateManyProvinceInput | SubdistrictCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type BannerCreateWithoutProvinciesInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    admin: AdminCreateNestedOneWithoutBannerInput
    cities?: CityCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutProvinciesInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    adminId: string
    thumbnailId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutProvinciesInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutProvinciesInput, BannerUncheckedCreateWithoutProvinciesInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutProvinceInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutProvinceInput, AdminUncheckedUpdateWithoutProvinceInput>
    create: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutProvinceInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutProvinceInput, AdminUncheckedUpdateWithoutProvinceInput>
  }

  export type AdminUpdateManyWithWhereWithoutProvinceInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutProvinceInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    authId?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    suspend?: BoolFilter<"Admin"> | boolean
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableFilter<"Admin"> | string | null
    cityId?: StringNullableFilter<"Admin"> | string | null
    subdistrictId?: StringNullableFilter<"Admin"> | string | null
    schoolId?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    authenticatorEnabled?: BoolFilter<"Admin"> | boolean
    authenticatorQrUrl?: StringNullableFilter<"Admin"> | string | null
    authenticatorSecret?: StringNullableFilter<"Admin"> | string | null
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutProvinceInput, AdminAuthorityUncheckedUpdateWithoutProvinceInput>
    create: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutProvinceInput, AdminAuthorityUncheckedUpdateWithoutProvinceInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutProvinceInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutProvinceInput>
  }

  export type AdminAuthorityScalarWhereInput = {
    AND?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
    OR?: AdminAuthorityScalarWhereInput[]
    NOT?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
    id?: StringFilter<"AdminAuthority"> | string
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
  }

  export type CityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
  }

  export type CityUpdateManyWithWhereWithoutProvinceInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutProvinceInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
  }

  export type SchoolUpsertWithWhereUniqueWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutProvinceInput, SchoolUncheckedUpdateWithoutProvinceInput>
    create: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutProvinceInput, SchoolUncheckedUpdateWithoutProvinceInput>
  }

  export type SchoolUpdateManyWithWhereWithoutProvinceInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutProvinceInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: StringFilter<"School"> | string
    identity?: StringFilter<"School"> | string
    level?: EnumEducationLevelFilter<"School"> | $Enums.EducationLevel
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringNullableFilter<"School"> | string | null
    provinceId?: StringNullableFilter<"School"> | string | null
    subdistrictId?: StringNullableFilter<"School"> | string | null
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutProvinceInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProvinceInput, UserUncheckedUpdateWithoutProvinceInput>
    create: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProvinceInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProvinceInput, UserUncheckedUpdateWithoutProvinceInput>
  }

  export type UserUpdateManyWithWhereWithoutProvinceInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProvinceInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    authId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: StringFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    subdistrictId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
  }

  export type SubdistrictUpsertWithWhereUniqueWithoutProvinceInput = {
    where: SubdistrictWhereUniqueInput
    update: XOR<SubdistrictUpdateWithoutProvinceInput, SubdistrictUncheckedUpdateWithoutProvinceInput>
    create: XOR<SubdistrictCreateWithoutProvinceInput, SubdistrictUncheckedCreateWithoutProvinceInput>
  }

  export type SubdistrictUpdateWithWhereUniqueWithoutProvinceInput = {
    where: SubdistrictWhereUniqueInput
    data: XOR<SubdistrictUpdateWithoutProvinceInput, SubdistrictUncheckedUpdateWithoutProvinceInput>
  }

  export type SubdistrictUpdateManyWithWhereWithoutProvinceInput = {
    where: SubdistrictScalarWhereInput
    data: XOR<SubdistrictUpdateManyMutationInput, SubdistrictUncheckedUpdateManyWithoutProvinceInput>
  }

  export type SubdistrictScalarWhereInput = {
    AND?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
    OR?: SubdistrictScalarWhereInput[]
    NOT?: SubdistrictScalarWhereInput | SubdistrictScalarWhereInput[]
    id?: StringFilter<"Subdistrict"> | string
    name?: StringFilter<"Subdistrict"> | string
    longitude?: FloatFilter<"Subdistrict"> | number
    latitude?: FloatFilter<"Subdistrict"> | number
    geoId?: StringFilter<"Subdistrict"> | string
    provinceId?: StringFilter<"Subdistrict"> | string
    cityId?: StringFilter<"Subdistrict"> | string
    createdAt?: DateTimeFilter<"Subdistrict"> | Date | string
    updatedAt?: DateTimeFilter<"Subdistrict"> | Date | string
  }

  export type BannerUpsertWithWhereUniqueWithoutProvinciesInput = {
    where: BannerWhereUniqueInput
    update: XOR<BannerUpdateWithoutProvinciesInput, BannerUncheckedUpdateWithoutProvinciesInput>
    create: XOR<BannerCreateWithoutProvinciesInput, BannerUncheckedCreateWithoutProvinciesInput>
  }

  export type BannerUpdateWithWhereUniqueWithoutProvinciesInput = {
    where: BannerWhereUniqueInput
    data: XOR<BannerUpdateWithoutProvinciesInput, BannerUncheckedUpdateWithoutProvinciesInput>
  }

  export type BannerUpdateManyWithWhereWithoutProvinciesInput = {
    where: BannerScalarWhereInput
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyWithoutProvinciesInput>
  }

  export type BannerScalarWhereInput = {
    AND?: BannerScalarWhereInput | BannerScalarWhereInput[]
    OR?: BannerScalarWhereInput[]
    NOT?: BannerScalarWhereInput | BannerScalarWhereInput[]
    id?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    lastBroadcastedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    adminId?: StringFilter<"Banner"> | string
    thumbnailId?: StringFilter<"Banner"> | string
  }

  export type AdminCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCityInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput>
  }

  export type AdminCreateManyCityInputEnvelope = {
    data: AdminCreateManyCityInput | AdminCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type ProvinceCreateWithoutCitiesInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceCreateOrConnectWithoutCitiesInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
  }

  export type SchoolCreateWithoutCityInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutSchoolInput
    province?: ProvinceCreateNestedOneWithoutSchoolsInput
    subdistrict?: SubdistrictCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutCityInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutCityInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput>
  }

  export type SchoolCreateManyCityInputEnvelope = {
    data: SchoolCreateManyCityInput | SchoolCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type SubdistrictCreateWithoutCityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutCityInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutCityInput, SubdistrictUncheckedCreateWithoutCityInput>
  }

  export type SubdistrictCreateManyCityInputEnvelope = {
    data: SubdistrictCreateManyCityInput | SubdistrictCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutCitiesInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutCitiesInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput>
  }

  export type BannerCreateWithoutCitiesInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    admin: AdminCreateNestedOneWithoutBannerInput
    provincies?: ProvinceCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutCitiesInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    adminId: string
    thumbnailId: string
    provincies?: ProvinceUncheckedCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutCitiesInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutCitiesInput, BannerUncheckedCreateWithoutCitiesInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutCityInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutCityInput, AdminUncheckedUpdateWithoutCityInput>
    create: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutCityInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutCityInput, AdminUncheckedUpdateWithoutCityInput>
  }

  export type AdminUpdateManyWithWhereWithoutCityInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutCityInput>
  }

  export type ProvinceUpsertWithoutCitiesInput = {
    update: XOR<ProvinceUpdateWithoutCitiesInput, ProvinceUncheckedUpdateWithoutCitiesInput>
    create: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutCitiesInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutCitiesInput, ProvinceUncheckedUpdateWithoutCitiesInput>
  }

  export type ProvinceUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type SchoolUpsertWithWhereUniqueWithoutCityInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutCityInput, SchoolUncheckedUpdateWithoutCityInput>
    create: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutCityInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutCityInput, SchoolUncheckedUpdateWithoutCityInput>
  }

  export type SchoolUpdateManyWithWhereWithoutCityInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutCityInput>
  }

  export type SubdistrictUpsertWithWhereUniqueWithoutCityInput = {
    where: SubdistrictWhereUniqueInput
    update: XOR<SubdistrictUpdateWithoutCityInput, SubdistrictUncheckedUpdateWithoutCityInput>
    create: XOR<SubdistrictCreateWithoutCityInput, SubdistrictUncheckedCreateWithoutCityInput>
  }

  export type SubdistrictUpdateWithWhereUniqueWithoutCityInput = {
    where: SubdistrictWhereUniqueInput
    data: XOR<SubdistrictUpdateWithoutCityInput, SubdistrictUncheckedUpdateWithoutCityInput>
  }

  export type SubdistrictUpdateManyWithWhereWithoutCityInput = {
    where: SubdistrictScalarWhereInput
    data: XOR<SubdistrictUpdateManyMutationInput, SubdistrictUncheckedUpdateManyWithoutCityInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCityInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutCitiesInput, AdminAuthorityUncheckedUpdateWithoutCitiesInput>
    create: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutCitiesInput, AdminAuthorityUncheckedUpdateWithoutCitiesInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutCitiesInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type BannerUpsertWithWhereUniqueWithoutCitiesInput = {
    where: BannerWhereUniqueInput
    update: XOR<BannerUpdateWithoutCitiesInput, BannerUncheckedUpdateWithoutCitiesInput>
    create: XOR<BannerCreateWithoutCitiesInput, BannerUncheckedCreateWithoutCitiesInput>
  }

  export type BannerUpdateWithWhereUniqueWithoutCitiesInput = {
    where: BannerWhereUniqueInput
    data: XOR<BannerUpdateWithoutCitiesInput, BannerUncheckedUpdateWithoutCitiesInput>
  }

  export type BannerUpdateManyWithWhereWithoutCitiesInput = {
    where: BannerScalarWhereInput
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyWithoutCitiesInput>
  }

  export type ProvinceCreateWithoutSubdistrictsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateWithoutSubdistrictsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceCreateOrConnectWithoutSubdistrictsInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutSubdistrictsInput, ProvinceUncheckedCreateWithoutSubdistrictsInput>
  }

  export type CityCreateWithoutSubdistrictsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutSubdistrictsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutSubdistrictsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSubdistrictsInput, CityUncheckedCreateWithoutSubdistrictsInput>
  }

  export type SchoolCreateWithoutSubdistrictInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutSchoolInput
    city?: CityCreateNestedOneWithoutSchoolsInput
    province?: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutSubdistrictInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutSubdistrictInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSubdistrictInput, SchoolUncheckedCreateWithoutSubdistrictInput>
  }

  export type SchoolCreateManySubdistrictInputEnvelope = {
    data: SchoolCreateManySubdistrictInput | SchoolCreateManySubdistrictInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSubdistrictInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubdistrictInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubdistrictInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubdistrictInput, UserUncheckedCreateWithoutSubdistrictInput>
  }

  export type UserCreateManySubdistrictInputEnvelope = {
    data: UserCreateManySubdistrictInput | UserCreateManySubdistrictInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutSubdistrictInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSubdistrictInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSubdistrictInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSubdistrictInput, AdminUncheckedCreateWithoutSubdistrictInput>
  }

  export type AdminCreateManySubdistrictInputEnvelope = {
    data: AdminCreateManySubdistrictInput | AdminCreateManySubdistrictInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutSubdistrictsInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutSubdistrictsInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutSubdistrictsInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutSubdistrictsInput, AdminAuthorityUncheckedCreateWithoutSubdistrictsInput>
  }

  export type BannerCreateWithoutSubdistrictsInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    admin: AdminCreateNestedOneWithoutBannerInput
    provincies?: ProvinceCreateNestedManyWithoutBannersInput
    cities?: CityCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutSubdistrictsInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    adminId: string
    thumbnailId: string
    provincies?: ProvinceUncheckedCreateNestedManyWithoutBannersInput
    cities?: CityUncheckedCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutSubdistrictsInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutSubdistrictsInput, BannerUncheckedCreateWithoutSubdistrictsInput>
  }

  export type ProvinceUpsertWithoutSubdistrictsInput = {
    update: XOR<ProvinceUpdateWithoutSubdistrictsInput, ProvinceUncheckedUpdateWithoutSubdistrictsInput>
    create: XOR<ProvinceCreateWithoutSubdistrictsInput, ProvinceUncheckedCreateWithoutSubdistrictsInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutSubdistrictsInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutSubdistrictsInput, ProvinceUncheckedUpdateWithoutSubdistrictsInput>
  }

  export type ProvinceUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type CityUpsertWithoutSubdistrictsInput = {
    update: XOR<CityUpdateWithoutSubdistrictsInput, CityUncheckedUpdateWithoutSubdistrictsInput>
    create: XOR<CityCreateWithoutSubdistrictsInput, CityUncheckedCreateWithoutSubdistrictsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutSubdistrictsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutSubdistrictsInput, CityUncheckedUpdateWithoutSubdistrictsInput>
  }

  export type CityUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type SchoolUpsertWithWhereUniqueWithoutSubdistrictInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutSubdistrictInput, SchoolUncheckedUpdateWithoutSubdistrictInput>
    create: XOR<SchoolCreateWithoutSubdistrictInput, SchoolUncheckedCreateWithoutSubdistrictInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutSubdistrictInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutSubdistrictInput, SchoolUncheckedUpdateWithoutSubdistrictInput>
  }

  export type SchoolUpdateManyWithWhereWithoutSubdistrictInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutSubdistrictInput>
  }

  export type UserUpsertWithWhereUniqueWithoutSubdistrictInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSubdistrictInput, UserUncheckedUpdateWithoutSubdistrictInput>
    create: XOR<UserCreateWithoutSubdistrictInput, UserUncheckedCreateWithoutSubdistrictInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSubdistrictInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSubdistrictInput, UserUncheckedUpdateWithoutSubdistrictInput>
  }

  export type UserUpdateManyWithWhereWithoutSubdistrictInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSubdistrictInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutSubdistrictInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutSubdistrictInput, AdminUncheckedUpdateWithoutSubdistrictInput>
    create: XOR<AdminCreateWithoutSubdistrictInput, AdminUncheckedCreateWithoutSubdistrictInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutSubdistrictInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutSubdistrictInput, AdminUncheckedUpdateWithoutSubdistrictInput>
  }

  export type AdminUpdateManyWithWhereWithoutSubdistrictInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutSubdistrictInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutSubdistrictsInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutSubdistrictsInput, AdminAuthorityUncheckedUpdateWithoutSubdistrictsInput>
    create: XOR<AdminAuthorityCreateWithoutSubdistrictsInput, AdminAuthorityUncheckedCreateWithoutSubdistrictsInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutSubdistrictsInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutSubdistrictsInput, AdminAuthorityUncheckedUpdateWithoutSubdistrictsInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutSubdistrictsInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsInput>
  }

  export type BannerUpsertWithWhereUniqueWithoutSubdistrictsInput = {
    where: BannerWhereUniqueInput
    update: XOR<BannerUpdateWithoutSubdistrictsInput, BannerUncheckedUpdateWithoutSubdistrictsInput>
    create: XOR<BannerCreateWithoutSubdistrictsInput, BannerUncheckedCreateWithoutSubdistrictsInput>
  }

  export type BannerUpdateWithWhereUniqueWithoutSubdistrictsInput = {
    where: BannerWhereUniqueInput
    data: XOR<BannerUpdateWithoutSubdistrictsInput, BannerUncheckedUpdateWithoutSubdistrictsInput>
  }

  export type BannerUpdateManyWithWhereWithoutSubdistrictsInput = {
    where: BannerScalarWhereInput
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyWithoutSubdistrictsInput>
  }

  export type AdminCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSchoolInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput>
  }

  export type AdminCreateManySchoolInputEnvelope = {
    data: AdminCreateManySchoolInput | AdminCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    province: ProvinceCreateNestedOneWithoutCitiesInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutSchoolsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
  }

  export type ProvinceCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceCreateOrConnectWithoutSchoolsInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
  }

  export type SubdistrictCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    city: CityCreateNestedOneWithoutSubdistrictsInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutSchoolsInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutSchoolsInput, SubdistrictUncheckedCreateWithoutSchoolsInput>
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutSchoolsInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutSchoolsInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutSchoolInput, AdminUncheckedUpdateWithoutSchoolInput>
    create: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutSchoolInput, AdminUncheckedUpdateWithoutSchoolInput>
  }

  export type AdminUpdateManyWithWhereWithoutSchoolInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutSchoolInput>
  }

  export type CityUpsertWithoutSchoolsInput = {
    update: XOR<CityUpdateWithoutSchoolsInput, CityUncheckedUpdateWithoutSchoolsInput>
    create: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutSchoolsInput, CityUncheckedUpdateWithoutSchoolsInput>
  }

  export type CityUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type ProvinceUpsertWithoutSchoolsInput = {
    update: XOR<ProvinceUpdateWithoutSchoolsInput, ProvinceUncheckedUpdateWithoutSchoolsInput>
    create: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutSchoolsInput, ProvinceUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProvinceUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type SubdistrictUpsertWithoutSchoolsInput = {
    update: XOR<SubdistrictUpdateWithoutSchoolsInput, SubdistrictUncheckedUpdateWithoutSchoolsInput>
    create: XOR<SubdistrictCreateWithoutSchoolsInput, SubdistrictUncheckedCreateWithoutSchoolsInput>
    where?: SubdistrictWhereInput
  }

  export type SubdistrictUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: SubdistrictWhereInput
    data: XOR<SubdistrictUpdateWithoutSchoolsInput, SubdistrictUncheckedUpdateWithoutSchoolsInput>
  }

  export type SubdistrictUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutSchoolsInput, AdminAuthorityUncheckedUpdateWithoutSchoolsInput>
    create: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutSchoolsInput, AdminAuthorityUncheckedUpdateWithoutSchoolsInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type BannerVisitorCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    banner: BannerCreateNestedOneWithoutVisitorsInput
  }

  export type BannerVisitorUncheckedCreateWithoutUserInput = {
    id?: string
    bannerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorCreateOrConnectWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    create: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput>
  }

  export type BannerVisitorCreateManyUserInputEnvelope = {
    data: BannerVisitorCreateManyUserInput | BannerVisitorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChampionshipCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type ChampionshipUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type ChampionshipCreateOrConnectWithoutUserInput = {
    where: ChampionshipWhereUniqueInput
    create: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipCreateManyUserInputEnvelope = {
    data: ChampionshipCreateManyUserInput | ChampionshipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChampionshipRecordCreateWithoutUserInput = {
    id?: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championshipInGameId: string
    inGameId: string
    zoneInGameId: string
  }

  export type ChampionshipRecordUncheckedCreateWithoutUserInput = {
    id?: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championshipInGameId: string
    inGameId: string
    zoneInGameId: string
  }

  export type ChampionshipRecordCreateOrConnectWithoutUserInput = {
    where: ChampionshipRecordWhereUniqueInput
    create: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipRecordCreateManyUserInputEnvelope = {
    data: ChampionshipRecordCreateManyUserInput | ChampionshipRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CodeRedeemerCreateWithoutUserInput = {
    id?: string
    banned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: RedeemCodeCreateNestedOneWithoutRedeemersInput
  }

  export type CodeRedeemerUncheckedCreateWithoutUserInput = {
    id?: string
    banned?: boolean
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedeemerCreateOrConnectWithoutUserInput = {
    where: CodeRedeemerWhereUniqueInput
    create: XOR<CodeRedeemerCreateWithoutUserInput, CodeRedeemerUncheckedCreateWithoutUserInput>
  }

  export type CodeRedeemerCreateManyUserInputEnvelope = {
    data: CodeRedeemerCreateManyUserInput | CodeRedeemerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GempoCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type GempoUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type GempoCreateOrConnectWithoutUserInput = {
    where: GempoWhereUniqueInput
    create: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput>
  }

  export type GempoCreateManyUserInputEnvelope = {
    data: GempoCreateManyUserInput | GempoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GempoRecordCreateWithoutUserInput = {
    id?: string
    played?: number
    point?: number
    highestPoint?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempoInGameId: string
    inGameId: string
    zoneInGameId: string
    correctAttempt?: number
  }

  export type GempoRecordUncheckedCreateWithoutUserInput = {
    id?: string
    played?: number
    point?: number
    highestPoint?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempoInGameId: string
    inGameId: string
    zoneInGameId: string
    correctAttempt?: number
  }

  export type GempoRecordCreateOrConnectWithoutUserInput = {
    where: GempoRecordWhereUniqueInput
    create: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput>
  }

  export type GempoRecordCreateManyUserInputEnvelope = {
    data: GempoRecordCreateManyUserInput | GempoRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InnerLevelCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    zoneInGameId: string
  }

  export type InnerLevelUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    zoneInGameId: string
  }

  export type InnerLevelCreateOrConnectWithoutUserInput = {
    where: InnerLevelWhereUniqueInput
    create: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput>
  }

  export type InnerLevelCreateManyUserInputEnvelope = {
    data: InnerLevelCreateManyUserInput | InnerLevelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LevelCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type LevelUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type LevelCreateOrConnectWithoutUserInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput>
  }

  export type LevelCreateManyUserInputEnvelope = {
    data: LevelCreateManyUserInput | LevelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchMemberCreateWithoutUserInput = {
    id?: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    room: ChampionshipMatchCreateNestedOneWithoutMembersInput
  }

  export type MatchMemberUncheckedCreateWithoutUserInput = {
    id?: string
    roomId: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchMemberCreateOrConnectWithoutUserInput = {
    where: MatchMemberWhereUniqueInput
    create: XOR<MatchMemberCreateWithoutUserInput, MatchMemberUncheckedCreateWithoutUserInput>
  }

  export type MatchMemberCreateManyUserInputEnvelope = {
    data: MatchMemberCreateManyUserInput | MatchMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatchHistoryMemberCreateWithoutUserInput = {
    id?: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    room: ChampionshipHistoryCreateNestedOneWithoutMembersInput
  }

  export type MatchHistoryMemberUncheckedCreateWithoutUserInput = {
    id?: string
    roomId: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberCreateOrConnectWithoutUserInput = {
    where: MatchHistoryMemberWhereUniqueInput
    create: XOR<MatchHistoryMemberCreateWithoutUserInput, MatchHistoryMemberUncheckedCreateWithoutUserInput>
  }

  export type MatchHistoryMemberCreateManyUserInputEnvelope = {
    data: MatchHistoryMemberCreateManyUserInput | MatchHistoryMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubLevelCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    zoneInGameId: string
  }

  export type SubLevelUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    zoneInGameId: string
  }

  export type SubLevelCreateOrConnectWithoutUserInput = {
    where: SubLevelWhereUniqueInput
    create: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput>
  }

  export type SubLevelCreateManyUserInputEnvelope = {
    data: SubLevelCreateManyUserInput | SubLevelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestParticipantCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    testId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantCreateOrConnectWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantCreateManyUserInputEnvelope = {
    data: TestParticipantCreateManyUserInput | TestParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type ProvinceCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceCreateOrConnectWithoutUsersInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutSchoolInput
    city?: CityCreateNestedOneWithoutSchoolsInput
    province?: ProvinceCreateNestedOneWithoutSchoolsInput
    subdistrict?: SubdistrictCreateNestedOneWithoutSchoolsInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type SubdistrictCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    city: CityCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutUsersInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutUsersInput, SubdistrictUncheckedCreateWithoutUsersInput>
  }

  export type UserLoginCreateWithoutUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUncheckedCreateWithoutUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginCreateOrConnectWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    create: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput>
  }

  export type UserLoginCreateManyUserInputEnvelope = {
    data: UserLoginCreateManyUserInput | UserLoginCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ZoneCreateWithoutUserInput = {
    id?: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    posttest?: number
    posttestTryCount?: number
    pretest?: number
    pretestTryCount?: number
  }

  export type ZoneUncheckedCreateWithoutUserInput = {
    id?: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    posttest?: number
    posttestTryCount?: number
    pretest?: number
    pretestTryCount?: number
  }

  export type ZoneCreateOrConnectWithoutUserInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput>
  }

  export type ZoneCreateManyUserInputEnvelope = {
    data: ZoneCreateManyUserInput | ZoneCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BannerVisitorUpsertWithWhereUniqueWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    update: XOR<BannerVisitorUpdateWithoutUserInput, BannerVisitorUncheckedUpdateWithoutUserInput>
    create: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput>
  }

  export type BannerVisitorUpdateWithWhereUniqueWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    data: XOR<BannerVisitorUpdateWithoutUserInput, BannerVisitorUncheckedUpdateWithoutUserInput>
  }

  export type BannerVisitorUpdateManyWithWhereWithoutUserInput = {
    where: BannerVisitorScalarWhereInput
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyWithoutUserInput>
  }

  export type BannerVisitorScalarWhereInput = {
    AND?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
    OR?: BannerVisitorScalarWhereInput[]
    NOT?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
    id?: StringFilter<"BannerVisitor"> | string
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
  }

  export type ChampionshipUpsertWithWhereUniqueWithoutUserInput = {
    where: ChampionshipWhereUniqueInput
    update: XOR<ChampionshipUpdateWithoutUserInput, ChampionshipUncheckedUpdateWithoutUserInput>
    create: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipUpdateWithWhereUniqueWithoutUserInput = {
    where: ChampionshipWhereUniqueInput
    data: XOR<ChampionshipUpdateWithoutUserInput, ChampionshipUncheckedUpdateWithoutUserInput>
  }

  export type ChampionshipUpdateManyWithWhereWithoutUserInput = {
    where: ChampionshipScalarWhereInput
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyWithoutUserInput>
  }

  export type ChampionshipScalarWhereInput = {
    AND?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
    OR?: ChampionshipScalarWhereInput[]
    NOT?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
    id?: StringFilter<"Championship"> | string
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    inGameId?: StringFilter<"Championship"> | string
    userId?: StringFilter<"Championship"> | string
    zoneInGameId?: StringFilter<"Championship"> | string
  }

  export type ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: ChampionshipRecordWhereUniqueInput
    update: XOR<ChampionshipRecordUpdateWithoutUserInput, ChampionshipRecordUncheckedUpdateWithoutUserInput>
    create: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: ChampionshipRecordWhereUniqueInput
    data: XOR<ChampionshipRecordUpdateWithoutUserInput, ChampionshipRecordUncheckedUpdateWithoutUserInput>
  }

  export type ChampionshipRecordUpdateManyWithWhereWithoutUserInput = {
    where: ChampionshipRecordScalarWhereInput
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type ChampionshipRecordScalarWhereInput = {
    AND?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
    OR?: ChampionshipRecordScalarWhereInput[]
    NOT?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
    id?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    championshipInGameId?: StringFilter<"ChampionshipRecord"> | string
    inGameId?: StringFilter<"ChampionshipRecord"> | string
    userId?: StringFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringFilter<"ChampionshipRecord"> | string
  }

  export type CodeRedeemerUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeRedeemerWhereUniqueInput
    update: XOR<CodeRedeemerUpdateWithoutUserInput, CodeRedeemerUncheckedUpdateWithoutUserInput>
    create: XOR<CodeRedeemerCreateWithoutUserInput, CodeRedeemerUncheckedCreateWithoutUserInput>
  }

  export type CodeRedeemerUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeRedeemerWhereUniqueInput
    data: XOR<CodeRedeemerUpdateWithoutUserInput, CodeRedeemerUncheckedUpdateWithoutUserInput>
  }

  export type CodeRedeemerUpdateManyWithWhereWithoutUserInput = {
    where: CodeRedeemerScalarWhereInput
    data: XOR<CodeRedeemerUpdateManyMutationInput, CodeRedeemerUncheckedUpdateManyWithoutUserInput>
  }

  export type CodeRedeemerScalarWhereInput = {
    AND?: CodeRedeemerScalarWhereInput | CodeRedeemerScalarWhereInput[]
    OR?: CodeRedeemerScalarWhereInput[]
    NOT?: CodeRedeemerScalarWhereInput | CodeRedeemerScalarWhereInput[]
    id?: StringFilter<"CodeRedeemer"> | string
    banned?: BoolFilter<"CodeRedeemer"> | boolean
    userId?: StringFilter<"CodeRedeemer"> | string
    codeId?: StringFilter<"CodeRedeemer"> | string
    createdAt?: DateTimeFilter<"CodeRedeemer"> | Date | string
    updatedAt?: DateTimeFilter<"CodeRedeemer"> | Date | string
  }

  export type GempoUpsertWithWhereUniqueWithoutUserInput = {
    where: GempoWhereUniqueInput
    update: XOR<GempoUpdateWithoutUserInput, GempoUncheckedUpdateWithoutUserInput>
    create: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput>
  }

  export type GempoUpdateWithWhereUniqueWithoutUserInput = {
    where: GempoWhereUniqueInput
    data: XOR<GempoUpdateWithoutUserInput, GempoUncheckedUpdateWithoutUserInput>
  }

  export type GempoUpdateManyWithWhereWithoutUserInput = {
    where: GempoScalarWhereInput
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyWithoutUserInput>
  }

  export type GempoScalarWhereInput = {
    AND?: GempoScalarWhereInput | GempoScalarWhereInput[]
    OR?: GempoScalarWhereInput[]
    NOT?: GempoScalarWhereInput | GempoScalarWhereInput[]
    id?: StringFilter<"Gempo"> | string
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    inGameId?: StringFilter<"Gempo"> | string
    userId?: StringFilter<"Gempo"> | string
    zoneInGameId?: StringFilter<"Gempo"> | string
  }

  export type GempoRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: GempoRecordWhereUniqueInput
    update: XOR<GempoRecordUpdateWithoutUserInput, GempoRecordUncheckedUpdateWithoutUserInput>
    create: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput>
  }

  export type GempoRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: GempoRecordWhereUniqueInput
    data: XOR<GempoRecordUpdateWithoutUserInput, GempoRecordUncheckedUpdateWithoutUserInput>
  }

  export type GempoRecordUpdateManyWithWhereWithoutUserInput = {
    where: GempoRecordScalarWhereInput
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type GempoRecordScalarWhereInput = {
    AND?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
    OR?: GempoRecordScalarWhereInput[]
    NOT?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
    id?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    highestPoint?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    gempoInGameId?: StringFilter<"GempoRecord"> | string
    inGameId?: StringFilter<"GempoRecord"> | string
    userId?: StringFilter<"GempoRecord"> | string
    zoneInGameId?: StringFilter<"GempoRecord"> | string
    correctAttempt?: FloatFilter<"GempoRecord"> | number
  }

  export type InnerLevelUpsertWithWhereUniqueWithoutUserInput = {
    where: InnerLevelWhereUniqueInput
    update: XOR<InnerLevelUpdateWithoutUserInput, InnerLevelUncheckedUpdateWithoutUserInput>
    create: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput>
  }

  export type InnerLevelUpdateWithWhereUniqueWithoutUserInput = {
    where: InnerLevelWhereUniqueInput
    data: XOR<InnerLevelUpdateWithoutUserInput, InnerLevelUncheckedUpdateWithoutUserInput>
  }

  export type InnerLevelUpdateManyWithWhereWithoutUserInput = {
    where: InnerLevelScalarWhereInput
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyWithoutUserInput>
  }

  export type InnerLevelScalarWhereInput = {
    AND?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
    OR?: InnerLevelScalarWhereInput[]
    NOT?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
    id?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatFilter<"InnerLevel"> | number
    playTime?: IntFilter<"InnerLevel"> | number
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    inGameId?: StringFilter<"InnerLevel"> | string
    levelInGameId?: StringFilter<"InnerLevel"> | string
    subLevelInGameId?: StringFilter<"InnerLevel"> | string
    userId?: StringFilter<"InnerLevel"> | string
    zoneInGameId?: StringFilter<"InnerLevel"> | string
  }

  export type LevelUpsertWithWhereUniqueWithoutUserInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutUserInput, LevelUncheckedUpdateWithoutUserInput>
    create: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutUserInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutUserInput, LevelUncheckedUpdateWithoutUserInput>
  }

  export type LevelUpdateManyWithWhereWithoutUserInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutUserInput>
  }

  export type LevelScalarWhereInput = {
    AND?: LevelScalarWhereInput | LevelScalarWhereInput[]
    OR?: LevelScalarWhereInput[]
    NOT?: LevelScalarWhereInput | LevelScalarWhereInput[]
    id?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    inGameId?: StringFilter<"Level"> | string
    userId?: StringFilter<"Level"> | string
    zoneInGameId?: StringFilter<"Level"> | string
  }

  export type MatchMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchMemberWhereUniqueInput
    update: XOR<MatchMemberUpdateWithoutUserInput, MatchMemberUncheckedUpdateWithoutUserInput>
    create: XOR<MatchMemberCreateWithoutUserInput, MatchMemberUncheckedCreateWithoutUserInput>
  }

  export type MatchMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchMemberWhereUniqueInput
    data: XOR<MatchMemberUpdateWithoutUserInput, MatchMemberUncheckedUpdateWithoutUserInput>
  }

  export type MatchMemberUpdateManyWithWhereWithoutUserInput = {
    where: MatchMemberScalarWhereInput
    data: XOR<MatchMemberUpdateManyMutationInput, MatchMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchMemberScalarWhereInput = {
    AND?: MatchMemberScalarWhereInput | MatchMemberScalarWhereInput[]
    OR?: MatchMemberScalarWhereInput[]
    NOT?: MatchMemberScalarWhereInput | MatchMemberScalarWhereInput[]
    id?: StringFilter<"MatchMember"> | string
    roomId?: StringFilter<"MatchMember"> | string
    userId?: StringFilter<"MatchMember"> | string
    slot?: IntFilter<"MatchMember"> | number
    status?: EnumMatchStatusFilter<"MatchMember"> | $Enums.MatchStatus
    answerPoint?: IntFilter<"MatchMember"> | number
    point?: IntFilter<"MatchMember"> | number
    bonusPoint?: IntFilter<"MatchMember"> | number
    teamType?: EnumTeamTypeFilter<"MatchMember"> | $Enums.TeamType
    isReady?: BoolFilter<"MatchMember"> | boolean
    isComplete?: BoolFilter<"MatchMember"> | boolean
    isBot?: BoolFilter<"MatchMember"> | boolean
    joinedAt?: DateTimeFilter<"MatchMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MatchMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MatchMember"> | boolean
  }

  export type MatchHistoryMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchHistoryMemberWhereUniqueInput
    update: XOR<MatchHistoryMemberUpdateWithoutUserInput, MatchHistoryMemberUncheckedUpdateWithoutUserInput>
    create: XOR<MatchHistoryMemberCreateWithoutUserInput, MatchHistoryMemberUncheckedCreateWithoutUserInput>
  }

  export type MatchHistoryMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchHistoryMemberWhereUniqueInput
    data: XOR<MatchHistoryMemberUpdateWithoutUserInput, MatchHistoryMemberUncheckedUpdateWithoutUserInput>
  }

  export type MatchHistoryMemberUpdateManyWithWhereWithoutUserInput = {
    where: MatchHistoryMemberScalarWhereInput
    data: XOR<MatchHistoryMemberUpdateManyMutationInput, MatchHistoryMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchHistoryMemberScalarWhereInput = {
    AND?: MatchHistoryMemberScalarWhereInput | MatchHistoryMemberScalarWhereInput[]
    OR?: MatchHistoryMemberScalarWhereInput[]
    NOT?: MatchHistoryMemberScalarWhereInput | MatchHistoryMemberScalarWhereInput[]
    id?: StringFilter<"MatchHistoryMember"> | string
    roomId?: StringFilter<"MatchHistoryMember"> | string
    userId?: StringFilter<"MatchHistoryMember"> | string
    slot?: IntFilter<"MatchHistoryMember"> | number
    status?: EnumMatchStatusFilter<"MatchHistoryMember"> | $Enums.MatchStatus
    point?: IntFilter<"MatchHistoryMember"> | number
    bonusPoint?: IntFilter<"MatchHistoryMember"> | number
    teamType?: EnumTeamTypeFilter<"MatchHistoryMember"> | $Enums.TeamType
    isReady?: BoolFilter<"MatchHistoryMember"> | boolean
    isComplete?: BoolFilter<"MatchHistoryMember"> | boolean
    isBot?: BoolFilter<"MatchHistoryMember"> | boolean
    joinedAt?: DateTimeFilter<"MatchHistoryMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MatchHistoryMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MatchHistoryMember"> | boolean
  }

  export type SubLevelUpsertWithWhereUniqueWithoutUserInput = {
    where: SubLevelWhereUniqueInput
    update: XOR<SubLevelUpdateWithoutUserInput, SubLevelUncheckedUpdateWithoutUserInput>
    create: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput>
  }

  export type SubLevelUpdateWithWhereUniqueWithoutUserInput = {
    where: SubLevelWhereUniqueInput
    data: XOR<SubLevelUpdateWithoutUserInput, SubLevelUncheckedUpdateWithoutUserInput>
  }

  export type SubLevelUpdateManyWithWhereWithoutUserInput = {
    where: SubLevelScalarWhereInput
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyWithoutUserInput>
  }

  export type SubLevelScalarWhereInput = {
    AND?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
    OR?: SubLevelScalarWhereInput[]
    NOT?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
    id?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    inGameId?: StringFilter<"SubLevel"> | string
    levelInGameId?: StringFilter<"SubLevel"> | string
    userId?: StringFilter<"SubLevel"> | string
    zoneInGameId?: StringFilter<"SubLevel"> | string
  }

  export type TestParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    update: XOR<TestParticipantUpdateWithoutUserInput, TestParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    data: XOR<TestParticipantUpdateWithoutUserInput, TestParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TestParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TestParticipantScalarWhereInput
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TestParticipantScalarWhereInput = {
    AND?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
    OR?: TestParticipantScalarWhereInput[]
    NOT?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
    id?: StringFilter<"TestParticipant"> | string
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutUsersInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type ProvinceUpsertWithoutUsersInput = {
    update: XOR<ProvinceUpdateWithoutUsersInput, ProvinceUncheckedUpdateWithoutUsersInput>
    create: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutUsersInput, ProvinceUncheckedUpdateWithoutUsersInput>
  }

  export type ProvinceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutSchoolNestedInput
    city?: CityUpdateOneWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneWithoutSchoolsNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutSchoolsNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SubdistrictUpsertWithoutUsersInput = {
    update: XOR<SubdistrictUpdateWithoutUsersInput, SubdistrictUncheckedUpdateWithoutUsersInput>
    create: XOR<SubdistrictCreateWithoutUsersInput, SubdistrictUncheckedCreateWithoutUsersInput>
    where?: SubdistrictWhereInput
  }

  export type SubdistrictUpdateToOneWithWhereWithoutUsersInput = {
    where?: SubdistrictWhereInput
    data: XOR<SubdistrictUpdateWithoutUsersInput, SubdistrictUncheckedUpdateWithoutUsersInput>
  }

  export type SubdistrictUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type UserLoginUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    update: XOR<UserLoginUpdateWithoutUserInput, UserLoginUncheckedUpdateWithoutUserInput>
    create: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput>
  }

  export type UserLoginUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    data: XOR<UserLoginUpdateWithoutUserInput, UserLoginUncheckedUpdateWithoutUserInput>
  }

  export type UserLoginUpdateManyWithWhereWithoutUserInput = {
    where: UserLoginScalarWhereInput
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLoginScalarWhereInput = {
    AND?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
    OR?: UserLoginScalarWhereInput[]
    NOT?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
    id?: StringFilter<"UserLogin"> | string
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
  }

  export type ZoneUpsertWithWhereUniqueWithoutUserInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutUserInput, ZoneUncheckedUpdateWithoutUserInput>
    create: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutUserInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutUserInput, ZoneUncheckedUpdateWithoutUserInput>
  }

  export type ZoneUpdateManyWithWhereWithoutUserInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutUserInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    inGameId?: StringFilter<"Zone"> | string
    posttest?: IntFilter<"Zone"> | number
    posttestTryCount?: IntFilter<"Zone"> | number
    pretest?: IntFilter<"Zone"> | number
    pretestTryCount?: IntFilter<"Zone"> | number
  }

  export type UserCreateWithoutZonesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZonesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
  }

  export type UserUpsertWithoutZonesInput = {
    update: XOR<UserUpdateWithoutZonesInput, UserUncheckedUpdateWithoutZonesInput>
    create: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZonesInput, UserUncheckedUpdateWithoutZonesInput>
  }

  export type UserUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLevelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
  }

  export type UserUpsertWithoutLevelsInput = {
    update: XOR<UserUpdateWithoutLevelsInput, UserUncheckedUpdateWithoutLevelsInput>
    create: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLevelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLevelsInput, UserUncheckedUpdateWithoutLevelsInput>
  }

  export type UserUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubLevelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
  }

  export type UserUpsertWithoutSubLevelsInput = {
    update: XOR<UserUpdateWithoutSubLevelsInput, UserUncheckedUpdateWithoutSubLevelsInput>
    create: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubLevelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubLevelsInput, UserUncheckedUpdateWithoutSubLevelsInput>
  }

  export type UserUpdateWithoutSubLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInnerLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInnerLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInnerLevelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
  }

  export type UserUpsertWithoutInnerLevelsInput = {
    update: XOR<UserUpdateWithoutInnerLevelsInput, UserUncheckedUpdateWithoutInnerLevelsInput>
    create: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInnerLevelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInnerLevelsInput, UserUncheckedUpdateWithoutInnerLevelsInput>
  }

  export type UserUpdateWithoutInnerLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInnerLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGemposInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGemposInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGemposInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
  }

  export type UserUpsertWithoutGemposInput = {
    update: XOR<UserUpdateWithoutGemposInput, UserUncheckedUpdateWithoutGemposInput>
    create: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGemposInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGemposInput, UserUncheckedUpdateWithoutGemposInput>
  }

  export type UserUpdateWithoutGemposInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGemposInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChampionshipsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChampionshipsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChampionshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
  }

  export type UserUpsertWithoutChampionshipsInput = {
    update: XOR<UserUpdateWithoutChampionshipsInput, UserUncheckedUpdateWithoutChampionshipsInput>
    create: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChampionshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChampionshipsInput, UserUncheckedUpdateWithoutChampionshipsInput>
  }

  export type UserUpdateWithoutChampionshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChampionshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGempoRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGempoRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGempoRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
  }

  export type UserUpsertWithoutGempoRecordsInput = {
    update: XOR<UserUpdateWithoutGempoRecordsInput, UserUncheckedUpdateWithoutGempoRecordsInput>
    create: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGempoRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGempoRecordsInput, UserUncheckedUpdateWithoutGempoRecordsInput>
  }

  export type UserUpdateWithoutGempoRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGempoRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChampionshipRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChampionshipRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChampionshipRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
  }

  export type UserUpsertWithoutChampionshipRecordsInput = {
    update: XOR<UserUpdateWithoutChampionshipRecordsInput, UserUncheckedUpdateWithoutChampionshipRecordsInput>
    create: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChampionshipRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChampionshipRecordsInput, UserUncheckedUpdateWithoutChampionshipRecordsInput>
  }

  export type UserUpdateWithoutChampionshipRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChampionshipRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserLoginInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLoginInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
  }

  export type UserUpsertWithoutUserLoginInput = {
    update: XOR<UserUpdateWithoutUserLoginInput, UserUncheckedUpdateWithoutUserLoginInput>
    create: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLoginInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLoginInput, UserUncheckedUpdateWithoutUserLoginInput>
  }

  export type UserUpdateWithoutUserLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProvinceCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceCreateOrConnectWithoutAdminInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
  }

  export type CityCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutAdminInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
  }

  export type SubdistrictCreateWithoutAdminsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    city: CityCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutAdminsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutAdminsInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutAdminsInput, SubdistrictUncheckedCreateWithoutAdminsInput>
  }

  export type SchoolCreateWithoutAdminInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city?: CityCreateNestedOneWithoutSchoolsInput
    province?: ProvinceCreateNestedOneWithoutSchoolsInput
    subdistrict?: SubdistrictCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutAdminInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutAdminInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityCreateWithoutAdminInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutAdminInput = {
    id?: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityCreateManyAdminInputEnvelope = {
    data: AdminAuthorityCreateManyAdminInput | AdminAuthorityCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminLogCreateWithoutAdminInput = {
    id?: string
    ipAddress?: string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: string | null
    operation?: string | null
    createdAt?: Date | string
  }

  export type AdminLogUncheckedCreateWithoutAdminInput = {
    id?: string
    ipAddress?: string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: string | null
    operation?: string | null
    createdAt?: Date | string
  }

  export type AdminLogCreateOrConnectWithoutAdminInput = {
    where: AdminLogWhereUniqueInput
    create: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminLogCreateManyAdminInputEnvelope = {
    data: AdminLogCreateManyAdminInput | AdminLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminOperationHistoryCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    opAdmin: AdminCreateNestedOneWithoutOperationsInput
  }

  export type AdminOperationHistoryUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateOrConnectWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    create: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput>
  }

  export type AdminOperationHistoryCreateManyAdminInputEnvelope = {
    data: AdminOperationHistoryCreateManyAdminInput | AdminOperationHistoryCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminOperationHistoryCreateWithoutOpAdminInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    admin: AdminCreateNestedOneWithoutOperationHistoriesInput
  }

  export type AdminOperationHistoryUncheckedCreateWithoutOpAdminInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateOrConnectWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    create: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryCreateManyOpAdminInputEnvelope = {
    data: AdminOperationHistoryCreateManyOpAdminInput | AdminOperationHistoryCreateManyOpAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    processedBy?: AdminCreateNestedOneWithoutTransactionProcessedInput
    redeemCode?: RedeemCodeCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    processedById?: string | null
    redeemCode?: RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionCreateOrConnectWithoutAdminInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput>
  }

  export type AdminTransactionCreateManyAdminInputEnvelope = {
    data: AdminTransactionCreateManyAdminInput | AdminTransactionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionCreateWithoutProcessedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutTransactionsInput
    redeemCode?: RedeemCodeCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionUncheckedCreateWithoutProcessedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    adminId: string
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    redeemCode?: RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionCreateOrConnectWithoutProcessedByInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput>
  }

  export type AdminTransactionCreateManyProcessedByInputEnvelope = {
    data: AdminTransactionCreateManyProcessedByInput | AdminTransactionCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type BannerCreateWithoutAdminInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    provincies?: ProvinceCreateNestedManyWithoutBannersInput
    cities?: CityCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutAdminInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    provincies?: ProvinceUncheckedCreateNestedManyWithoutBannersInput
    cities?: CityUncheckedCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutBannersInput
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutAdminInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput>
  }

  export type BannerCreateManyAdminInputEnvelope = {
    data: BannerCreateManyAdminInput | BannerCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type RedeemCodeCreateWithoutAdminInput = {
    id?: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    redeemers?: CodeRedeemerCreateNestedManyWithoutCodeInput
    transaction: AdminTransactionCreateNestedOneWithoutRedeemCodeInput
  }

  export type RedeemCodeUncheckedCreateWithoutAdminInput = {
    id?: string
    transactionId: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    redeemers?: CodeRedeemerUncheckedCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeCreateOrConnectWithoutAdminInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput>
  }

  export type RedeemCodeCreateManyAdminInputEnvelope = {
    data: RedeemCodeCreateManyAdminInput | RedeemCodeCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type TestCreateWithoutAdminInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TestParticipantCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateWithoutAdminInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TestParticipantUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestCreateOrConnectWithoutAdminInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutAdminInput, TestUncheckedCreateWithoutAdminInput>
  }

  export type TestCreateManyAdminInputEnvelope = {
    data: TestCreateManyAdminInput | TestCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type ProvinceUpsertWithoutAdminInput = {
    update: XOR<ProvinceUpdateWithoutAdminInput, ProvinceUncheckedUpdateWithoutAdminInput>
    create: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutAdminInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutAdminInput, ProvinceUncheckedUpdateWithoutAdminInput>
  }

  export type ProvinceUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type CityUpsertWithoutAdminInput = {
    update: XOR<CityUpdateWithoutAdminInput, CityUncheckedUpdateWithoutAdminInput>
    create: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAdminInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAdminInput, CityUncheckedUpdateWithoutAdminInput>
  }

  export type CityUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type SubdistrictUpsertWithoutAdminsInput = {
    update: XOR<SubdistrictUpdateWithoutAdminsInput, SubdistrictUncheckedUpdateWithoutAdminsInput>
    create: XOR<SubdistrictCreateWithoutAdminsInput, SubdistrictUncheckedCreateWithoutAdminsInput>
    where?: SubdistrictWhereInput
  }

  export type SubdistrictUpdateToOneWithWhereWithoutAdminsInput = {
    where?: SubdistrictWhereInput
    data: XOR<SubdistrictUpdateWithoutAdminsInput, SubdistrictUncheckedUpdateWithoutAdminsInput>
  }

  export type SubdistrictUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SchoolUpsertWithoutAdminInput = {
    update: XOR<SchoolUpdateWithoutAdminInput, SchoolUncheckedUpdateWithoutAdminInput>
    create: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAdminInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAdminInput, SchoolUncheckedUpdateWithoutAdminInput>
  }

  export type SchoolUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneWithoutSchoolsNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutAdminInput, AdminAuthorityUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutAdminInput, AdminAuthorityUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminLogWhereUniqueInput
    update: XOR<AdminLogUpdateWithoutAdminInput, AdminLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminLogCreateWithoutAdminInput, AdminLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminLogWhereUniqueInput
    data: XOR<AdminLogUpdateWithoutAdminInput, AdminLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminLogScalarWhereInput
    data: XOR<AdminLogUpdateManyMutationInput, AdminLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminLogScalarWhereInput = {
    AND?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
    OR?: AdminLogScalarWhereInput[]
    NOT?: AdminLogScalarWhereInput | AdminLogScalarWhereInput[]
    id?: StringFilter<"AdminLog"> | string
    ipAddress?: StringNullableFilter<"AdminLog"> | string | null
    old?: JsonNullableFilter<"AdminLog">
    new?: JsonNullableFilter<"AdminLog">
    adminId?: StringFilter<"AdminLog"> | string
    table?: StringNullableFilter<"AdminLog"> | string | null
    operation?: StringNullableFilter<"AdminLog"> | string | null
    createdAt?: DateTimeFilter<"AdminLog"> | Date | string
  }

  export type AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    update: XOR<AdminOperationHistoryUpdateWithoutAdminInput, AdminOperationHistoryUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput>
  }

  export type AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    data: XOR<AdminOperationHistoryUpdateWithoutAdminInput, AdminOperationHistoryUncheckedUpdateWithoutAdminInput>
  }

  export type AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput = {
    where: AdminOperationHistoryScalarWhereInput
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminOperationHistoryScalarWhereInput = {
    AND?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
    OR?: AdminOperationHistoryScalarWhereInput[]
    NOT?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
  }

  export type AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    update: XOR<AdminOperationHistoryUpdateWithoutOpAdminInput, AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput>
    create: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    data: XOR<AdminOperationHistoryUpdateWithoutOpAdminInput, AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput = {
    where: AdminOperationHistoryScalarWhereInput
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminInput>
  }

  export type AdminTransactionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminTransactionWhereUniqueInput
    update: XOR<AdminTransactionUpdateWithoutAdminInput, AdminTransactionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput>
  }

  export type AdminTransactionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminTransactionWhereUniqueInput
    data: XOR<AdminTransactionUpdateWithoutAdminInput, AdminTransactionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminTransactionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminTransactionScalarWhereInput
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminTransactionScalarWhereInput = {
    AND?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
    OR?: AdminTransactionScalarWhereInput[]
    NOT?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
    id?: StringFilter<"AdminTransaction"> | string
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    quantity?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    adminId?: StringFilter<"AdminTransaction"> | string
    amount?: IntFilter<"AdminTransaction"> | number
    archived?: BoolFilter<"AdminTransaction"> | boolean
    description?: StringNullableFilter<"AdminTransaction"> | string | null
    name?: StringFilter<"AdminTransaction"> | string
    subscriptionTime?: IntFilter<"AdminTransaction"> | number
    transactionImageId?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionRef?: StringNullableFilter<"AdminTransaction"> | string | null
    status?: EnumTransactionFilter<"AdminTransaction"> | $Enums.Transaction
    processedAt?: DateTimeNullableFilter<"AdminTransaction"> | Date | string | null
    processedById?: StringNullableFilter<"AdminTransaction"> | string | null
  }

  export type AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: AdminTransactionWhereUniqueInput
    update: XOR<AdminTransactionUpdateWithoutProcessedByInput, AdminTransactionUncheckedUpdateWithoutProcessedByInput>
    create: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput>
  }

  export type AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: AdminTransactionWhereUniqueInput
    data: XOR<AdminTransactionUpdateWithoutProcessedByInput, AdminTransactionUncheckedUpdateWithoutProcessedByInput>
  }

  export type AdminTransactionUpdateManyWithWhereWithoutProcessedByInput = {
    where: AdminTransactionScalarWhereInput
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type BannerUpsertWithWhereUniqueWithoutAdminInput = {
    where: BannerWhereUniqueInput
    update: XOR<BannerUpdateWithoutAdminInput, BannerUncheckedUpdateWithoutAdminInput>
    create: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput>
  }

  export type BannerUpdateWithWhereUniqueWithoutAdminInput = {
    where: BannerWhereUniqueInput
    data: XOR<BannerUpdateWithoutAdminInput, BannerUncheckedUpdateWithoutAdminInput>
  }

  export type BannerUpdateManyWithWhereWithoutAdminInput = {
    where: BannerScalarWhereInput
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyWithoutAdminInput>
  }

  export type RedeemCodeUpsertWithWhereUniqueWithoutAdminInput = {
    where: RedeemCodeWhereUniqueInput
    update: XOR<RedeemCodeUpdateWithoutAdminInput, RedeemCodeUncheckedUpdateWithoutAdminInput>
    create: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput>
  }

  export type RedeemCodeUpdateWithWhereUniqueWithoutAdminInput = {
    where: RedeemCodeWhereUniqueInput
    data: XOR<RedeemCodeUpdateWithoutAdminInput, RedeemCodeUncheckedUpdateWithoutAdminInput>
  }

  export type RedeemCodeUpdateManyWithWhereWithoutAdminInput = {
    where: RedeemCodeScalarWhereInput
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyWithoutAdminInput>
  }

  export type RedeemCodeScalarWhereInput = {
    AND?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
    OR?: RedeemCodeScalarWhereInput[]
    NOT?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
    id?: StringFilter<"RedeemCode"> | string
    transactionId?: StringFilter<"RedeemCode"> | string
    adminId?: StringFilter<"RedeemCode"> | string
    code?: StringFilter<"RedeemCode"> | string
    expiredAt?: DateTimeNullableFilter<"RedeemCode"> | Date | string | null
    currentAmount?: IntFilter<"RedeemCode"> | number
    maxAmount?: IntFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeFilter<"RedeemCode"> | Date | string
    suspend?: BoolFilter<"RedeemCode"> | boolean
  }

  export type TestUpsertWithWhereUniqueWithoutAdminInput = {
    where: TestWhereUniqueInput
    update: XOR<TestUpdateWithoutAdminInput, TestUncheckedUpdateWithoutAdminInput>
    create: XOR<TestCreateWithoutAdminInput, TestUncheckedCreateWithoutAdminInput>
  }

  export type TestUpdateWithWhereUniqueWithoutAdminInput = {
    where: TestWhereUniqueInput
    data: XOR<TestUpdateWithoutAdminInput, TestUncheckedUpdateWithoutAdminInput>
  }

  export type TestUpdateManyWithWhereWithoutAdminInput = {
    where: TestScalarWhereInput
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyWithoutAdminInput>
  }

  export type TestScalarWhereInput = {
    AND?: TestScalarWhereInput | TestScalarWhereInput[]
    OR?: TestScalarWhereInput[]
    NOT?: TestScalarWhereInput | TestScalarWhereInput[]
    id?: StringFilter<"Test"> | string
    name?: StringFilter<"Test"> | string
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    category?: EnumRoleFilter<"Test"> | $Enums.Role
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    adminId?: StringFilter<"Test"> | string
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminCreateWithoutLogsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutLogsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutLogsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
  }

  export type AdminUpsertWithoutLogsInput = {
    update: XOR<AdminUpdateWithoutLogsInput, AdminUncheckedUpdateWithoutLogsInput>
    create: XOR<AdminCreateWithoutLogsInput, AdminUncheckedCreateWithoutLogsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutLogsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutLogsInput, AdminUncheckedUpdateWithoutLogsInput>
  }

  export type AdminUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminCreateWithoutOperationHistoriesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutOperationHistoriesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutOperationHistoriesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
  }

  export type AdminCreateWithoutOperationsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutOperationsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutOperationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
  }

  export type AdminUpsertWithoutOperationHistoriesInput = {
    update: XOR<AdminUpdateWithoutOperationHistoriesInput, AdminUncheckedUpdateWithoutOperationHistoriesInput>
    create: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOperationHistoriesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOperationHistoriesInput, AdminUncheckedUpdateWithoutOperationHistoriesInput>
  }

  export type AdminUpdateWithoutOperationHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutOperationHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminUpsertWithoutOperationsInput = {
    update: XOR<AdminUpdateWithoutOperationsInput, AdminUncheckedUpdateWithoutOperationsInput>
    create: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOperationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOperationsInput, AdminUncheckedUpdateWithoutOperationsInput>
  }

  export type AdminUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminCreateWithoutAuthorityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAuthorityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutAuthorityInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
  }

  export type ProvinceCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
    banners?: BannerCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
    banners?: BannerUncheckedCreateNestedManyWithoutProvinciesInput
  }

  export type ProvinceCreateOrConnectWithoutAdminAuthorityInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type CityCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    banners?: BannerCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    banners?: BannerUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SubdistrictCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    city: CityCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    banners?: BannerCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    banners?: BannerUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutAdminAuthorityInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutAdminAuthorityInput, SubdistrictUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SchoolCreateWithoutAdminAuthorityInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutSchoolInput
    city?: CityCreateNestedOneWithoutSchoolsInput
    province?: ProvinceCreateNestedOneWithoutSchoolsInput
    subdistrict?: SubdistrictCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type AdminUpsertWithoutAuthorityInput = {
    update: XOR<AdminUpdateWithoutAuthorityInput, AdminUncheckedUpdateWithoutAuthorityInput>
    create: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuthorityInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuthorityInput, AdminUncheckedUpdateWithoutAuthorityInput>
  }

  export type AdminUpdateWithoutAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type ProvinceUpsertWithoutAdminAuthorityInput = {
    update: XOR<ProvinceUpdateWithoutAdminAuthorityInput, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutAdminAuthorityInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutAdminAuthorityInput, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type ProvinceUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
    banners?: BannerUpdateManyWithoutProvinciesNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
    banners?: BannerUncheckedUpdateManyWithoutProvinciesNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutAdminAuthorityInput, CityUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type CityUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutAdminAuthorityInput, CityUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type CityUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type SubdistrictUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SubdistrictWhereUniqueInput
    update: XOR<SubdistrictUpdateWithoutAdminAuthorityInput, SubdistrictUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<SubdistrictCreateWithoutAdminAuthorityInput, SubdistrictUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SubdistrictUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SubdistrictWhereUniqueInput
    data: XOR<SubdistrictUpdateWithoutAdminAuthorityInput, SubdistrictUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type SubdistrictUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: SubdistrictScalarWhereInput
    data: XOR<SubdistrictUpdateManyMutationInput, SubdistrictUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutAdminAuthorityInput, SchoolUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutAdminAuthorityInput, SchoolUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type SchoolUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type AdminCreateWithoutBannerInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutBannerInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutBannerInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
  }

  export type ProvinceCreateWithoutBannersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutBannersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutBannersInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutBannersInput, ProvinceUncheckedCreateWithoutBannersInput>
  }

  export type CityCreateWithoutBannersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedManyWithoutCityInput
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutBannersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutBannersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutBannersInput, CityUncheckedCreateWithoutBannersInput>
  }

  export type SubdistrictCreateWithoutBannersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSubdistrictsInput
    city: CityCreateNestedOneWithoutSubdistrictsInput
    schools?: SchoolCreateNestedManyWithoutSubdistrictInput
    users?: UserCreateNestedManyWithoutSubdistrictInput
    admins?: AdminCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictUncheckedCreateWithoutBannersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutSubdistrictInput
    users?: UserUncheckedCreateNestedManyWithoutSubdistrictInput
    admins?: AdminUncheckedCreateNestedManyWithoutSubdistrictInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSubdistrictsInput
  }

  export type SubdistrictCreateOrConnectWithoutBannersInput = {
    where: SubdistrictWhereUniqueInput
    create: XOR<SubdistrictCreateWithoutBannersInput, SubdistrictUncheckedCreateWithoutBannersInput>
  }

  export type BannerVisitorCreateWithoutBannerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    user: UserCreateNestedOneWithoutBannerVisitorInput
  }

  export type BannerVisitorUncheckedCreateWithoutBannerInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorCreateOrConnectWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    create: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput>
  }

  export type BannerVisitorCreateManyBannerInputEnvelope = {
    data: BannerVisitorCreateManyBannerInput | BannerVisitorCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutBannerInput = {
    update: XOR<AdminUpdateWithoutBannerInput, AdminUncheckedUpdateWithoutBannerInput>
    create: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutBannerInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutBannerInput, AdminUncheckedUpdateWithoutBannerInput>
  }

  export type AdminUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type ProvinceUpsertWithWhereUniqueWithoutBannersInput = {
    where: ProvinceWhereUniqueInput
    update: XOR<ProvinceUpdateWithoutBannersInput, ProvinceUncheckedUpdateWithoutBannersInput>
    create: XOR<ProvinceCreateWithoutBannersInput, ProvinceUncheckedCreateWithoutBannersInput>
  }

  export type ProvinceUpdateWithWhereUniqueWithoutBannersInput = {
    where: ProvinceWhereUniqueInput
    data: XOR<ProvinceUpdateWithoutBannersInput, ProvinceUncheckedUpdateWithoutBannersInput>
  }

  export type ProvinceUpdateManyWithWhereWithoutBannersInput = {
    where: ProvinceScalarWhereInput
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyWithoutBannersInput>
  }

  export type ProvinceScalarWhereInput = {
    AND?: ProvinceScalarWhereInput | ProvinceScalarWhereInput[]
    OR?: ProvinceScalarWhereInput[]
    NOT?: ProvinceScalarWhereInput | ProvinceScalarWhereInput[]
    id?: StringFilter<"Province"> | string
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
  }

  export type CityUpsertWithWhereUniqueWithoutBannersInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutBannersInput, CityUncheckedUpdateWithoutBannersInput>
    create: XOR<CityCreateWithoutBannersInput, CityUncheckedCreateWithoutBannersInput>
  }

  export type CityUpdateWithWhereUniqueWithoutBannersInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutBannersInput, CityUncheckedUpdateWithoutBannersInput>
  }

  export type CityUpdateManyWithWhereWithoutBannersInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutBannersInput>
  }

  export type SubdistrictUpsertWithWhereUniqueWithoutBannersInput = {
    where: SubdistrictWhereUniqueInput
    update: XOR<SubdistrictUpdateWithoutBannersInput, SubdistrictUncheckedUpdateWithoutBannersInput>
    create: XOR<SubdistrictCreateWithoutBannersInput, SubdistrictUncheckedCreateWithoutBannersInput>
  }

  export type SubdistrictUpdateWithWhereUniqueWithoutBannersInput = {
    where: SubdistrictWhereUniqueInput
    data: XOR<SubdistrictUpdateWithoutBannersInput, SubdistrictUncheckedUpdateWithoutBannersInput>
  }

  export type SubdistrictUpdateManyWithWhereWithoutBannersInput = {
    where: SubdistrictScalarWhereInput
    data: XOR<SubdistrictUpdateManyMutationInput, SubdistrictUncheckedUpdateManyWithoutBannersInput>
  }

  export type BannerVisitorUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    update: XOR<BannerVisitorUpdateWithoutBannerInput, BannerVisitorUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput>
  }

  export type BannerVisitorUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    data: XOR<BannerVisitorUpdateWithoutBannerInput, BannerVisitorUncheckedUpdateWithoutBannerInput>
  }

  export type BannerVisitorUpdateManyWithWhereWithoutBannerInput = {
    where: BannerVisitorScalarWhereInput
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyWithoutBannerInput>
  }

  export type BannerCreateWithoutVisitorsInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
    admin: AdminCreateNestedOneWithoutBannerInput
    provincies?: ProvinceCreateNestedManyWithoutBannersInput
    cities?: CityCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictCreateNestedManyWithoutBannersInput
  }

  export type BannerUncheckedCreateWithoutVisitorsInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    adminId: string
    thumbnailId: string
    provincies?: ProvinceUncheckedCreateNestedManyWithoutBannersInput
    cities?: CityUncheckedCreateNestedManyWithoutBannersInput
    subdistricts?: SubdistrictUncheckedCreateNestedManyWithoutBannersInput
  }

  export type BannerCreateOrConnectWithoutVisitorsInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
  }

  export type UserCreateWithoutBannerVisitorInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBannerVisitorInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBannerVisitorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
  }

  export type BannerUpsertWithoutVisitorsInput = {
    update: XOR<BannerUpdateWithoutVisitorsInput, BannerUncheckedUpdateWithoutVisitorsInput>
    create: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutVisitorsInput, BannerUncheckedUpdateWithoutVisitorsInput>
  }

  export type BannerUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    provincies?: ProvinceUpdateManyWithoutBannersNestedInput
    cities?: CityUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutBannersNestedInput
  }

  export type BannerUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    provincies?: ProvinceUncheckedUpdateManyWithoutBannersNestedInput
    cities?: CityUncheckedUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutBannersNestedInput
  }

  export type UserUpsertWithoutBannerVisitorInput = {
    update: XOR<UserUpdateWithoutBannerVisitorInput, UserUncheckedUpdateWithoutBannerVisitorInput>
    create: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBannerVisitorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBannerVisitorInput, UserUncheckedUpdateWithoutBannerVisitorInput>
  }

  export type UserUpdateWithoutBannerVisitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBannerVisitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminCreateWithoutTestsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutTestsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutTestsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutTestsInput, AdminUncheckedCreateWithoutTestsInput>
  }

  export type TestParticipantCreateWithoutTestInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    user: UserCreateNestedOneWithoutTestParticipantInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutTestInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantCreateOrConnectWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput>
  }

  export type TestParticipantCreateManyTestInputEnvelope = {
    data: TestParticipantCreateManyTestInput | TestParticipantCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutTestsInput = {
    update: XOR<AdminUpdateWithoutTestsInput, AdminUncheckedUpdateWithoutTestsInput>
    create: XOR<AdminCreateWithoutTestsInput, AdminUncheckedCreateWithoutTestsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutTestsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutTestsInput, AdminUncheckedUpdateWithoutTestsInput>
  }

  export type AdminUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type TestParticipantUpsertWithWhereUniqueWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    update: XOR<TestParticipantUpdateWithoutTestInput, TestParticipantUncheckedUpdateWithoutTestInput>
    create: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput>
  }

  export type TestParticipantUpdateWithWhereUniqueWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    data: XOR<TestParticipantUpdateWithoutTestInput, TestParticipantUncheckedUpdateWithoutTestInput>
  }

  export type TestParticipantUpdateManyWithWhereWithoutTestInput = {
    where: TestParticipantScalarWhereInput
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyWithoutTestInput>
  }

  export type TestCreateWithoutParticipantsInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutTestsInput
  }

  export type TestUncheckedCreateWithoutParticipantsInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
  }

  export type TestCreateOrConnectWithoutParticipantsInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTestParticipantInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestParticipantInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
  }

  export type TestParticipantRecordCreateWithoutParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedCreateWithoutParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateOrConnectWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    create: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput>
  }

  export type TestParticipantRecordCreateManyParticipantInputEnvelope = {
    data: TestParticipantRecordCreateManyParticipantInput | TestParticipantRecordCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TestUpsertWithoutParticipantsInput = {
    update: XOR<TestUpdateWithoutParticipantsInput, TestUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    where?: TestWhereInput
  }

  export type TestUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TestWhereInput
    data: XOR<TestUpdateWithoutParticipantsInput, TestUncheckedUpdateWithoutParticipantsInput>
  }

  export type TestUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutTestsNestedInput
  }

  export type TestUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutTestParticipantInput = {
    update: XOR<UserUpdateWithoutTestParticipantInput, UserUncheckedUpdateWithoutTestParticipantInput>
    create: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestParticipantInput, UserUncheckedUpdateWithoutTestParticipantInput>
  }

  export type UserUpdateWithoutTestParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    update: XOR<TestParticipantRecordUpdateWithoutParticipantInput, TestParticipantRecordUncheckedUpdateWithoutParticipantInput>
    create: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput>
  }

  export type TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    data: XOR<TestParticipantRecordUpdateWithoutParticipantInput, TestParticipantRecordUncheckedUpdateWithoutParticipantInput>
  }

  export type TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput = {
    where: TestParticipantRecordScalarWhereInput
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyWithoutParticipantInput>
  }

  export type TestParticipantRecordScalarWhereInput = {
    AND?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
    OR?: TestParticipantRecordScalarWhereInput[]
    NOT?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
    id?: StringFilter<"TestParticipantRecord"> | string
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonFilter<"TestParticipantRecord">
  }

  export type TestParticipantCreateWithoutRecordsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTestParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutRecordsInput = {
    id?: string
    testId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type TestParticipantCreateOrConnectWithoutRecordsInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
  }

  export type TestParticipantUpsertWithoutRecordsInput = {
    update: XOR<TestParticipantUpdateWithoutRecordsInput, TestParticipantUncheckedUpdateWithoutRecordsInput>
    create: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    where?: TestParticipantWhereInput
  }

  export type TestParticipantUpdateToOneWithWhereWithoutRecordsInput = {
    where?: TestParticipantWhereInput
    data: XOR<TestParticipantUpdateWithoutRecordsInput, TestParticipantUncheckedUpdateWithoutRecordsInput>
  }

  export type TestParticipantUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type AdminCreateWithoutTransactionsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutTransactionsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutTransactionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
  }

  export type AdminCreateWithoutTransactionProcessedInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutTransactionProcessedInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutTransactionProcessedInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
  }

  export type RedeemCodeCreateWithoutTransactionInput = {
    id?: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    redeemers?: CodeRedeemerCreateNestedManyWithoutCodeInput
    admin: AdminCreateNestedOneWithoutRedeemCodesInput
  }

  export type RedeemCodeUncheckedCreateWithoutTransactionInput = {
    id?: string
    adminId: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    redeemers?: CodeRedeemerUncheckedCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeCreateOrConnectWithoutTransactionInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
  }

  export type AdminUpsertWithoutTransactionsInput = {
    update: XOR<AdminUpdateWithoutTransactionsInput, AdminUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutTransactionsInput, AdminUncheckedUpdateWithoutTransactionsInput>
  }

  export type AdminUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminUpsertWithoutTransactionProcessedInput = {
    update: XOR<AdminUpdateWithoutTransactionProcessedInput, AdminUncheckedUpdateWithoutTransactionProcessedInput>
    create: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutTransactionProcessedInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutTransactionProcessedInput, AdminUncheckedUpdateWithoutTransactionProcessedInput>
  }

  export type AdminUpdateWithoutTransactionProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutTransactionProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type RedeemCodeUpsertWithoutTransactionInput = {
    update: XOR<RedeemCodeUpdateWithoutTransactionInput, RedeemCodeUncheckedUpdateWithoutTransactionInput>
    create: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    where?: RedeemCodeWhereInput
  }

  export type RedeemCodeUpdateToOneWithWhereWithoutTransactionInput = {
    where?: RedeemCodeWhereInput
    data: XOR<RedeemCodeUpdateWithoutTransactionInput, RedeemCodeUncheckedUpdateWithoutTransactionInput>
  }

  export type RedeemCodeUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    redeemers?: CodeRedeemerUpdateManyWithoutCodeNestedInput
    admin?: AdminUpdateOneRequiredWithoutRedeemCodesNestedInput
  }

  export type RedeemCodeUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    redeemers?: CodeRedeemerUncheckedUpdateManyWithoutCodeNestedInput
  }

  export type CodeRedeemerCreateWithoutCodeInput = {
    id?: string
    banned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRedeemedCodesInput
  }

  export type CodeRedeemerUncheckedCreateWithoutCodeInput = {
    id?: string
    banned?: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedeemerCreateOrConnectWithoutCodeInput = {
    where: CodeRedeemerWhereUniqueInput
    create: XOR<CodeRedeemerCreateWithoutCodeInput, CodeRedeemerUncheckedCreateWithoutCodeInput>
  }

  export type CodeRedeemerCreateManyCodeInputEnvelope = {
    data: CodeRedeemerCreateManyCodeInput | CodeRedeemerCreateManyCodeInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutRedeemCodesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    subdistrict?: SubdistrictCreateNestedOneWithoutAdminsInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    logs?: AdminLogCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    tests?: TestCreateNestedManyWithoutAdminInput
    user?: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutRedeemCodesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    logs?: AdminLogUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    tests?: TestUncheckedCreateNestedManyWithoutAdminInput
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutRedeemCodesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
  }

  export type AdminTransactionCreateWithoutRedeemCodeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutTransactionsInput
    processedBy?: AdminCreateNestedOneWithoutTransactionProcessedInput
  }

  export type AdminTransactionUncheckedCreateWithoutRedeemCodeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    adminId: string
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    processedById?: string | null
  }

  export type AdminTransactionCreateOrConnectWithoutRedeemCodeInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
  }

  export type CodeRedeemerUpsertWithWhereUniqueWithoutCodeInput = {
    where: CodeRedeemerWhereUniqueInput
    update: XOR<CodeRedeemerUpdateWithoutCodeInput, CodeRedeemerUncheckedUpdateWithoutCodeInput>
    create: XOR<CodeRedeemerCreateWithoutCodeInput, CodeRedeemerUncheckedCreateWithoutCodeInput>
  }

  export type CodeRedeemerUpdateWithWhereUniqueWithoutCodeInput = {
    where: CodeRedeemerWhereUniqueInput
    data: XOR<CodeRedeemerUpdateWithoutCodeInput, CodeRedeemerUncheckedUpdateWithoutCodeInput>
  }

  export type CodeRedeemerUpdateManyWithWhereWithoutCodeInput = {
    where: CodeRedeemerScalarWhereInput
    data: XOR<CodeRedeemerUpdateManyMutationInput, CodeRedeemerUncheckedUpdateManyWithoutCodeInput>
  }

  export type AdminUpsertWithoutRedeemCodesInput = {
    update: XOR<AdminUpdateWithoutRedeemCodesInput, AdminUncheckedUpdateWithoutRedeemCodesInput>
    create: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutRedeemCodesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutRedeemCodesInput, AdminUncheckedUpdateWithoutRedeemCodesInput>
  }

  export type AdminUpdateWithoutRedeemCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutRedeemCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminTransactionUpsertWithoutRedeemCodeInput = {
    update: XOR<AdminTransactionUpdateWithoutRedeemCodeInput, AdminTransactionUncheckedUpdateWithoutRedeemCodeInput>
    create: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
    where?: AdminTransactionWhereInput
  }

  export type AdminTransactionUpdateToOneWithWhereWithoutRedeemCodeInput = {
    where?: AdminTransactionWhereInput
    data: XOR<AdminTransactionUpdateWithoutRedeemCodeInput, AdminTransactionUncheckedUpdateWithoutRedeemCodeInput>
  }

  export type AdminTransactionUpdateWithoutRedeemCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutTransactionsNestedInput
    processedBy?: AdminUpdateOneWithoutTransactionProcessedNestedInput
  }

  export type AdminTransactionUncheckedUpdateWithoutRedeemCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    adminId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RedeemCodeCreateWithoutRedeemersInput = {
    id?: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
    admin: AdminCreateNestedOneWithoutRedeemCodesInput
    transaction: AdminTransactionCreateNestedOneWithoutRedeemCodeInput
  }

  export type RedeemCodeUncheckedCreateWithoutRedeemersInput = {
    id?: string
    transactionId: string
    adminId: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
  }

  export type RedeemCodeCreateOrConnectWithoutRedeemersInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutRedeemersInput, RedeemCodeUncheckedCreateWithoutRedeemersInput>
  }

  export type UserCreateWithoutRedeemedCodesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRedeemedCodesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRedeemedCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRedeemedCodesInput, UserUncheckedCreateWithoutRedeemedCodesInput>
  }

  export type RedeemCodeUpsertWithoutRedeemersInput = {
    update: XOR<RedeemCodeUpdateWithoutRedeemersInput, RedeemCodeUncheckedUpdateWithoutRedeemersInput>
    create: XOR<RedeemCodeCreateWithoutRedeemersInput, RedeemCodeUncheckedCreateWithoutRedeemersInput>
    where?: RedeemCodeWhereInput
  }

  export type RedeemCodeUpdateToOneWithWhereWithoutRedeemersInput = {
    where?: RedeemCodeWhereInput
    data: XOR<RedeemCodeUpdateWithoutRedeemersInput, RedeemCodeUncheckedUpdateWithoutRedeemersInput>
  }

  export type RedeemCodeUpdateWithoutRedeemersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutRedeemCodesNestedInput
    transaction?: AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateWithoutRedeemersInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutRedeemedCodesInput = {
    update: XOR<UserUpdateWithoutRedeemedCodesInput, UserUncheckedUpdateWithoutRedeemedCodesInput>
    create: XOR<UserCreateWithoutRedeemedCodesInput, UserUncheckedCreateWithoutRedeemedCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRedeemedCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRedeemedCodesInput, UserUncheckedUpdateWithoutRedeemedCodesInput>
  }

  export type UserUpdateWithoutRedeemedCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRedeemedCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchMemberCreateWithoutRoomInput = {
    id?: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    user: UserCreateNestedOneWithoutMatchMembersInput
  }

  export type MatchMemberUncheckedCreateWithoutRoomInput = {
    id?: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchMemberCreateOrConnectWithoutRoomInput = {
    where: MatchMemberWhereUniqueInput
    create: XOR<MatchMemberCreateWithoutRoomInput, MatchMemberUncheckedCreateWithoutRoomInput>
  }

  export type MatchMemberCreateManyRoomInputEnvelope = {
    data: MatchMemberCreateManyRoomInput | MatchMemberCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type MatchMemberUpsertWithWhereUniqueWithoutRoomInput = {
    where: MatchMemberWhereUniqueInput
    update: XOR<MatchMemberUpdateWithoutRoomInput, MatchMemberUncheckedUpdateWithoutRoomInput>
    create: XOR<MatchMemberCreateWithoutRoomInput, MatchMemberUncheckedCreateWithoutRoomInput>
  }

  export type MatchMemberUpdateWithWhereUniqueWithoutRoomInput = {
    where: MatchMemberWhereUniqueInput
    data: XOR<MatchMemberUpdateWithoutRoomInput, MatchMemberUncheckedUpdateWithoutRoomInput>
  }

  export type MatchMemberUpdateManyWithWhereWithoutRoomInput = {
    where: MatchMemberScalarWhereInput
    data: XOR<MatchMemberUpdateManyMutationInput, MatchMemberUncheckedUpdateManyWithoutRoomInput>
  }

  export type ChampionshipMatchCreateWithoutMembersInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type ChampionshipMatchUncheckedCreateWithoutMembersInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type ChampionshipMatchCreateOrConnectWithoutMembersInput = {
    where: ChampionshipMatchWhereUniqueInput
    create: XOR<ChampionshipMatchCreateWithoutMembersInput, ChampionshipMatchUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMatchMembersInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchMembersInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    historyMatchMembers?: MatchHistoryMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchMembersInput, UserUncheckedCreateWithoutMatchMembersInput>
  }

  export type ChampionshipMatchUpsertWithoutMembersInput = {
    update: XOR<ChampionshipMatchUpdateWithoutMembersInput, ChampionshipMatchUncheckedUpdateWithoutMembersInput>
    create: XOR<ChampionshipMatchCreateWithoutMembersInput, ChampionshipMatchUncheckedCreateWithoutMembersInput>
    where?: ChampionshipMatchWhereInput
  }

  export type ChampionshipMatchUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChampionshipMatchWhereInput
    data: XOR<ChampionshipMatchUpdateWithoutMembersInput, ChampionshipMatchUncheckedUpdateWithoutMembersInput>
  }

  export type ChampionshipMatchUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type ChampionshipMatchUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutMatchMembersInput = {
    update: XOR<UserUpdateWithoutMatchMembersInput, UserUncheckedUpdateWithoutMatchMembersInput>
    create: XOR<UserCreateWithoutMatchMembersInput, UserUncheckedCreateWithoutMatchMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchMembersInput, UserUncheckedUpdateWithoutMatchMembersInput>
  }

  export type UserUpdateWithoutMatchMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchHistoryMemberCreateWithoutRoomInput = {
    id?: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    user: UserCreateNestedOneWithoutHistoryMatchMembersInput
  }

  export type MatchHistoryMemberUncheckedCreateWithoutRoomInput = {
    id?: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberCreateOrConnectWithoutRoomInput = {
    where: MatchHistoryMemberWhereUniqueInput
    create: XOR<MatchHistoryMemberCreateWithoutRoomInput, MatchHistoryMemberUncheckedCreateWithoutRoomInput>
  }

  export type MatchHistoryMemberCreateManyRoomInputEnvelope = {
    data: MatchHistoryMemberCreateManyRoomInput | MatchHistoryMemberCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type MatchHistoryMemberUpsertWithWhereUniqueWithoutRoomInput = {
    where: MatchHistoryMemberWhereUniqueInput
    update: XOR<MatchHistoryMemberUpdateWithoutRoomInput, MatchHistoryMemberUncheckedUpdateWithoutRoomInput>
    create: XOR<MatchHistoryMemberCreateWithoutRoomInput, MatchHistoryMemberUncheckedCreateWithoutRoomInput>
  }

  export type MatchHistoryMemberUpdateWithWhereUniqueWithoutRoomInput = {
    where: MatchHistoryMemberWhereUniqueInput
    data: XOR<MatchHistoryMemberUpdateWithoutRoomInput, MatchHistoryMemberUncheckedUpdateWithoutRoomInput>
  }

  export type MatchHistoryMemberUpdateManyWithWhereWithoutRoomInput = {
    where: MatchHistoryMemberScalarWhereInput
    data: XOR<MatchHistoryMemberUpdateManyMutationInput, MatchHistoryMemberUncheckedUpdateManyWithoutRoomInput>
  }

  export type ChampionshipHistoryCreateWithoutMembersInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    currentPoint?: ChampionshipHistoryCreatecurrentPointInput | number[]
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type ChampionshipHistoryUncheckedCreateWithoutMembersInput = {
    id?: string
    max?: number
    zoneInGameId: string
    gameplayId: string
    botOwner?: string | null
    currentPoint?: ChampionshipHistoryCreatecurrentPointInput | number[]
    mode: $Enums.MatchMode
    endTime?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type ChampionshipHistoryCreateOrConnectWithoutMembersInput = {
    where: ChampionshipHistoryWhereUniqueInput
    create: XOR<ChampionshipHistoryCreateWithoutMembersInput, ChampionshipHistoryUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutHistoryMatchMembersInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    subdistrict?: SubdistrictCreateNestedOneWithoutUsersInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHistoryMatchMembersInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redeemedCodes?: CodeRedeemerUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    matchMembers?: MatchMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHistoryMatchMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistoryMatchMembersInput, UserUncheckedCreateWithoutHistoryMatchMembersInput>
  }

  export type ChampionshipHistoryUpsertWithoutMembersInput = {
    update: XOR<ChampionshipHistoryUpdateWithoutMembersInput, ChampionshipHistoryUncheckedUpdateWithoutMembersInput>
    create: XOR<ChampionshipHistoryCreateWithoutMembersInput, ChampionshipHistoryUncheckedCreateWithoutMembersInput>
    where?: ChampionshipHistoryWhereInput
  }

  export type ChampionshipHistoryUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChampionshipHistoryWhereInput
    data: XOR<ChampionshipHistoryUpdateWithoutMembersInput, ChampionshipHistoryUncheckedUpdateWithoutMembersInput>
  }

  export type ChampionshipHistoryUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    currentPoint?: ChampionshipHistoryUpdatecurrentPointInput | number[]
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type ChampionshipHistoryUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: NullableStringFieldUpdateOperationsInput | string | null
    currentPoint?: ChampionshipHistoryUpdatecurrentPointInput | number[]
    mode?: EnumMatchModeFieldUpdateOperationsInput | $Enums.MatchMode
    endTime?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutHistoryMatchMembersInput = {
    update: XOR<UserUpdateWithoutHistoryMatchMembersInput, UserUncheckedUpdateWithoutHistoryMatchMembersInput>
    create: XOR<UserCreateWithoutHistoryMatchMembersInput, UserUncheckedCreateWithoutHistoryMatchMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHistoryMatchMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHistoryMatchMembersInput, UserUncheckedUpdateWithoutHistoryMatchMembersInput>
  }

  export type UserUpdateWithoutHistoryMatchMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHistoryMatchMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdminCreateManyProvinceInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    cityId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
  }

  export type AdminAuthorityCreateManyProvinceInput = {
    id?: string
    adminId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type CityCreateManyProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolCreateManyProvinceInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type SubdistrictCreateManyProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuthorityUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type CityUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutSchoolNestedInput
    city?: CityUpdateOneWithoutSchoolsNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type SubdistrictUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUpdateWithoutProvinciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    cities?: CityUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutProvinciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateManyWithoutProvinciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyCityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    subdistrictId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
  }

  export type SchoolCreateManyCityInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    provinceId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdistrictCreateManyCityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId?: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutSchoolNestedInput
    province?: ProvinceUpdateOneWithoutSchoolsNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdistrictUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    provincies?: ProvinceUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    provincies?: ProvinceUncheckedUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolCreateManySubdistrictInput = {
    id?: string
    identity: string
    level?: $Enums.EducationLevel
    name: string
    longitude: number
    latitude: number
    cityId?: string | null
    provinceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManySubdistrictInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminCreateManySubdistrictInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
  }

  export type SchoolUpdateWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutSchoolNestedInput
    city?: CityUpdateOneWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutSubdistrictInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminAuthorityUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    provincies?: ProvinceUpdateManyWithoutBannersNestedInput
    cities?: CityUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    provincies?: ProvinceUncheckedUpdateManyWithoutBannersNestedInput
    cities?: CityUncheckedUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateManyWithoutSubdistrictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManySchoolInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    subdistrictId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authenticatorEnabled?: boolean
    authenticatorQrUrl?: string | null
    authenticatorSecret?: string | null
  }

  export type UserCreateManySchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    cityId?: string | null
    provinceId?: string | null
    subdistrictId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutAdminsNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
    tests?: TestUpdateManyWithoutAdminNestedInput
    user?: UserUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    logs?: AdminLogUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
    tests?: TestUncheckedUpdateManyWithoutAdminNestedInput
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authenticatorEnabled?: BoolFieldUpdateOperationsInput | boolean
    authenticatorQrUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authenticatorSecret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutUsersNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redeemedCodes?: CodeRedeemerUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    matchMembers?: MatchMemberUncheckedUpdateManyWithoutUserNestedInput
    historyMatchMembers?: MatchHistoryMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerVisitorCreateManyUserInput = {
    id?: string
    bannerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type ChampionshipCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type ChampionshipRecordCreateManyUserInput = {
    id?: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    championshipInGameId: string
    inGameId: string
    zoneInGameId: string
  }

  export type CodeRedeemerCreateManyUserInput = {
    id?: string
    banned?: boolean
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type GempoRecordCreateManyUserInput = {
    id?: string
    played?: number
    point?: number
    highestPoint?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gempoInGameId: string
    inGameId: string
    zoneInGameId: string
    correctAttempt?: number
  }

  export type InnerLevelCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    subLevelInGameId: string
    zoneInGameId: string
  }

  export type LevelCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    zoneInGameId: string
  }

  export type MatchMemberCreateManyUserInput = {
    id?: string
    roomId: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberCreateManyUserInput = {
    id?: string
    roomId: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type SubLevelCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    levelInGameId: string
    zoneInGameId: string
  }

  export type TestParticipantCreateManyUserInput = {
    id?: string
    testId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type UserLoginCreateManyUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type ZoneCreateManyUserInput = {
    id?: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inGameId: string
    posttest?: number
    posttestTryCount?: number
    pretest?: number
    pretestTryCount?: number
  }

  export type BannerVisitorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    banner?: BannerUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type BannerVisitorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type ChampionshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type CodeRedeemerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: RedeemCodeUpdateOneRequiredWithoutRedeemersNestedInput
  }

  export type CodeRedeemerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedeemerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
  }

  export type GempoRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
  }

  export type GempoRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    highestPoint?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    correctAttempt?: FloatFieldUpdateOperationsInput | number
  }

  export type InnerLevelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type MatchMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    room?: ChampionshipMatchUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MatchMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchHistoryMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    room?: ChampionshipHistoryUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MatchHistoryMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchHistoryMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubLevelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
  }

  export type TestParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type UserLoginUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZoneUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
  }

  export type ZoneUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
  }

  export type ZoneUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inGameId?: StringFieldUpdateOperationsInput | string
    posttest?: IntFieldUpdateOperationsInput | number
    posttestTryCount?: IntFieldUpdateOperationsInput | number
    pretest?: IntFieldUpdateOperationsInput | number
    pretestTryCount?: IntFieldUpdateOperationsInput | number
  }

  export type AdminAuthorityCreateManyAdminInput = {
    id?: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type AdminLogCreateManyAdminInput = {
    id?: string
    ipAddress?: string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: string | null
    operation?: string | null
    createdAt?: Date | string
  }

  export type AdminOperationHistoryCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateManyOpAdminInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    operation?: $Enums.Operation
  }

  export type AdminTransactionCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
    processedById?: string | null
  }

  export type AdminTransactionCreateManyProcessedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    zones?: AdminTransactionCreatezonesInput | string[]
    adminId: string
    amount: number
    archived?: boolean
    description?: string | null
    name: string
    subscriptionTime: number
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    transactionRef?: string | null
    status?: $Enums.Transaction
    processedAt?: Date | string | null
  }

  export type BannerCreateManyAdminInput = {
    id?: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    lastBroadcastedAt?: Date | string | null
    thumbnailId: string
  }

  export type RedeemCodeCreateManyAdminInput = {
    id?: string
    transactionId: string
    code?: string
    expiredAt?: Date | string | null
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    suspend?: boolean
  }

  export type TestCreateManyAdminInput = {
    id?: string
    name?: string
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    category: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAuthorityUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    old?: NullableJsonNullValueInput | InputJsonValue
    new?: NullableJsonNullValueInput | InputJsonValue
    table?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOperationHistoryUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    opAdmin?: AdminUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUpdateWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    admin?: AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminTransactionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: AdminUpdateOneWithoutTransactionProcessedNestedInput
    redeemCode?: RedeemCodeUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    redeemCode?: RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminTransactionUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutTransactionsNestedInput
    redeemCode?: RedeemCodeUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    adminId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemCode?: RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    adminId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    archived?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    provincies?: ProvinceUpdateManyWithoutBannersNestedInput
    cities?: CityUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
    provincies?: ProvinceUncheckedUpdateManyWithoutBannersNestedInput
    cities?: CityUncheckedUpdateManyWithoutBannersNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutBannersNestedInput
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    lastBroadcastedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnailId?: StringFieldUpdateOperationsInput | string
  }

  export type RedeemCodeUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    redeemers?: CodeRedeemerUpdateManyWithoutCodeNestedInput
    transaction?: AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    redeemers?: CodeRedeemerUncheckedUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TestUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TestParticipantUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TestParticipantUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    banners?: BannerUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    banners?: BannerUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdistrictUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    banners?: BannerUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    banners?: BannerUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutSchoolNestedInput
    city?: CityUpdateOneWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneWithoutSchoolsNestedInput
    subdistrict?: SubdistrictUpdateOneWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    level?: EnumEducationLevelFieldUpdateOperationsInput | $Enums.EducationLevel
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    subdistrictId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerVisitorCreateManyBannerInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type ProvinceUpdateWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateManyWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateManyWithoutCityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    subdistricts?: SubdistrictUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateManyWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdistrictUpdateWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSubdistrictsNestedInput
    city?: CityUpdateOneRequiredWithoutSubdistrictsNestedInput
    schools?: SchoolUpdateManyWithoutSubdistrictNestedInput
    users?: UserUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutSubdistrictNestedInput
    users?: UserUncheckedUpdateManyWithoutSubdistrictNestedInput
    admins?: AdminUncheckedUpdateManyWithoutSubdistrictNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSubdistrictsNestedInput
  }

  export type SubdistrictUncheckedUpdateManyWithoutBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerVisitorUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBannerVisitorNestedInput
  }

  export type BannerVisitorUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type TestParticipantCreateManyTestInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type TestParticipantUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantRecordCreateManyParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type CodeRedeemerCreateManyCodeInput = {
    id?: string
    banned?: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedeemerUpdateWithoutCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRedeemedCodesNestedInput
  }

  export type CodeRedeemerUncheckedUpdateWithoutCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedeemerUncheckedUpdateManyWithoutCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMemberCreateManyRoomInput = {
    id?: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    answerPoint?: number
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchMemberUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMatchMembersNestedInput
  }

  export type MatchMemberUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchMemberUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    answerPoint?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchHistoryMemberCreateManyRoomInput = {
    id?: string
    userId: string
    slot?: number
    status?: $Enums.MatchStatus
    point?: number
    bonusPoint?: number
    teamType?: $Enums.TeamType
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MatchHistoryMemberUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutHistoryMatchMembersNestedInput
  }

  export type MatchHistoryMemberUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchHistoryMemberUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    slot?: IntFieldUpdateOperationsInput | number
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    teamType?: EnumTeamTypeFieldUpdateOperationsInput | $Enums.TeamType
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}