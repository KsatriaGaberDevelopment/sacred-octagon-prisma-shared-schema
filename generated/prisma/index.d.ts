
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Province
 * 
 */
export type Province = $Result.DefaultSelection<Prisma.$ProvincePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model SubLevel
 * 
 */
export type SubLevel = $Result.DefaultSelection<Prisma.$SubLevelPayload>
/**
 * Model InnerLevel
 * 
 */
export type InnerLevel = $Result.DefaultSelection<Prisma.$InnerLevelPayload>
/**
 * Model Gempo
 * 
 */
export type Gempo = $Result.DefaultSelection<Prisma.$GempoPayload>
/**
 * Model Championship
 * 
 */
export type Championship = $Result.DefaultSelection<Prisma.$ChampionshipPayload>
/**
 * Model GempoRecord
 * 
 */
export type GempoRecord = $Result.DefaultSelection<Prisma.$GempoRecordPayload>
/**
 * Model ChampionshipRecord
 * 
 */
export type ChampionshipRecord = $Result.DefaultSelection<Prisma.$ChampionshipRecordPayload>
/**
 * Model UserLogin
 * 
 */
export type UserLogin = $Result.DefaultSelection<Prisma.$UserLoginPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminOperationHistory
 * 
 */
export type AdminOperationHistory = $Result.DefaultSelection<Prisma.$AdminOperationHistoryPayload>
/**
 * Model AdminAuthority
 * 
 */
export type AdminAuthority = $Result.DefaultSelection<Prisma.$AdminAuthorityPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model BannerLocation
 * 
 */
export type BannerLocation = $Result.DefaultSelection<Prisma.$BannerLocationPayload>
/**
 * Model BannerVisitor
 * 
 */
export type BannerVisitor = $Result.DefaultSelection<Prisma.$BannerVisitorPayload>
/**
 * Model Test
 * 
 */
export type Test = $Result.DefaultSelection<Prisma.$TestPayload>
/**
 * Model TestParticipant
 * 
 */
export type TestParticipant = $Result.DefaultSelection<Prisma.$TestParticipantPayload>
/**
 * Model TestParticipantRecord
 * 
 */
export type TestParticipantRecord = $Result.DefaultSelection<Prisma.$TestParticipantRecordPayload>
/**
 * Model Background
 * 
 */
export type Background = $Result.DefaultSelection<Prisma.$BackgroundPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model AdminTransaction
 * 
 */
export type AdminTransaction = $Result.DefaultSelection<Prisma.$AdminTransactionPayload>
/**
 * Model RedeemCode
 * 
 */
export type RedeemCode = $Result.DefaultSelection<Prisma.$RedeemCodePayload>
/**
 * Model CodeRedemeer
 * 
 */
export type CodeRedemeer = $Result.DefaultSelection<Prisma.$CodeRedemeerPayload>
/**
 * Model MultiplayerRoom
 * 
 */
export type MultiplayerRoom = $Result.DefaultSelection<Prisma.$MultiplayerRoomPayload>
/**
 * Model MultiPlayerMember
 * 
 */
export type MultiPlayerMember = $Result.DefaultSelection<Prisma.$MultiPlayerMemberPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  Developer: 'Developer',
  SuperAdmin: 'SuperAdmin',
  Admin: 'Admin',
  SchoolAdmin: 'SchoolAdmin',
  Teacher: 'Teacher',
  User: 'User'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AccountType: {
  LMS: 'LMS',
  Self: 'Self'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const VoucherType: {
  Discount: 'Discount',
  FixedPrice: 'FixedPrice'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const QuestionType: {
  Addition: 'Addition',
  Multiplication: 'Multiplication',
  Subtraction: 'Subtraction',
  Division: 'Division',
  Bakalkubagi: 'Bakalkubagi'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const TestType: {
  PreTest: 'PreTest',
  PostTest: 'PostTest',
  FirstPreTest: 'FirstPreTest',
  Contest: 'Contest'
};

export type TestType = (typeof TestType)[keyof typeof TestType]


export const Operation: {
  None: 'None',
  Create: 'Create',
  Update: 'Update',
  Delete: 'Delete'
};

export type Operation = (typeof Operation)[keyof typeof Operation]


export const Transaction: {
  Pending: 'Pending',
  Cancelled: 'Cancelled',
  Settlement: 'Settlement'
};

export type Transaction = (typeof Transaction)[keyof typeof Transaction]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type TestType = $Enums.TestType

export const TestType: typeof $Enums.TestType

export type Operation = $Enums.Operation

export const Operation: typeof $Enums.Operation

export type Transaction = $Enums.Transaction

export const Transaction: typeof $Enums.Transaction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Provinces
 * const provinces = await prisma.province.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Provinces
   * const provinces = await prisma.province.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.province`: Exposes CRUD operations for the **Province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.ProvinceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subLevel`: Exposes CRUD operations for the **SubLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubLevels
    * const subLevels = await prisma.subLevel.findMany()
    * ```
    */
  get subLevel(): Prisma.SubLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.innerLevel`: Exposes CRUD operations for the **InnerLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InnerLevels
    * const innerLevels = await prisma.innerLevel.findMany()
    * ```
    */
  get innerLevel(): Prisma.InnerLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gempo`: Exposes CRUD operations for the **Gempo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gempos
    * const gempos = await prisma.gempo.findMany()
    * ```
    */
  get gempo(): Prisma.GempoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championship`: Exposes CRUD operations for the **Championship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Championships
    * const championships = await prisma.championship.findMany()
    * ```
    */
  get championship(): Prisma.ChampionshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gempoRecord`: Exposes CRUD operations for the **GempoRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GempoRecords
    * const gempoRecords = await prisma.gempoRecord.findMany()
    * ```
    */
  get gempoRecord(): Prisma.GempoRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.championshipRecord`: Exposes CRUD operations for the **ChampionshipRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChampionshipRecords
    * const championshipRecords = await prisma.championshipRecord.findMany()
    * ```
    */
  get championshipRecord(): Prisma.ChampionshipRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLogin`: Exposes CRUD operations for the **UserLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLogins
    * const userLogins = await prisma.userLogin.findMany()
    * ```
    */
  get userLogin(): Prisma.UserLoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminOperationHistory`: Exposes CRUD operations for the **AdminOperationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminOperationHistories
    * const adminOperationHistories = await prisma.adminOperationHistory.findMany()
    * ```
    */
  get adminOperationHistory(): Prisma.AdminOperationHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuthority`: Exposes CRUD operations for the **AdminAuthority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuthorities
    * const adminAuthorities = await prisma.adminAuthority.findMany()
    * ```
    */
  get adminAuthority(): Prisma.AdminAuthorityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerLocation`: Exposes CRUD operations for the **BannerLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerLocations
    * const bannerLocations = await prisma.bannerLocation.findMany()
    * ```
    */
  get bannerLocation(): Prisma.BannerLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerVisitor`: Exposes CRUD operations for the **BannerVisitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerVisitors
    * const bannerVisitors = await prisma.bannerVisitor.findMany()
    * ```
    */
  get bannerVisitor(): Prisma.BannerVisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParticipant`: Exposes CRUD operations for the **TestParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParticipants
    * const testParticipants = await prisma.testParticipant.findMany()
    * ```
    */
  get testParticipant(): Prisma.TestParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParticipantRecord`: Exposes CRUD operations for the **TestParticipantRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParticipantRecords
    * const testParticipantRecords = await prisma.testParticipantRecord.findMany()
    * ```
    */
  get testParticipantRecord(): Prisma.TestParticipantRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.background`: Exposes CRUD operations for the **Background** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backgrounds
    * const backgrounds = await prisma.background.findMany()
    * ```
    */
  get background(): Prisma.BackgroundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminTransaction`: Exposes CRUD operations for the **AdminTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminTransactions
    * const adminTransactions = await prisma.adminTransaction.findMany()
    * ```
    */
  get adminTransaction(): Prisma.AdminTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemCode`: Exposes CRUD operations for the **RedeemCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedeemCodes
    * const redeemCodes = await prisma.redeemCode.findMany()
    * ```
    */
  get redeemCode(): Prisma.RedeemCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.codeRedemeer`: Exposes CRUD operations for the **CodeRedemeer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeRedemeers
    * const codeRedemeers = await prisma.codeRedemeer.findMany()
    * ```
    */
  get codeRedemeer(): Prisma.CodeRedemeerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multiplayerRoom`: Exposes CRUD operations for the **MultiplayerRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiplayerRooms
    * const multiplayerRooms = await prisma.multiplayerRoom.findMany()
    * ```
    */
  get multiplayerRoom(): Prisma.MultiplayerRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multiPlayerMember`: Exposes CRUD operations for the **MultiPlayerMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiPlayerMembers
    * const multiPlayerMembers = await prisma.multiPlayerMember.findMany()
    * ```
    */
  get multiPlayerMember(): Prisma.MultiPlayerMemberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Province: 'Province',
    City: 'City',
    School: 'School',
    User: 'User',
    Zone: 'Zone',
    Level: 'Level',
    SubLevel: 'SubLevel',
    InnerLevel: 'InnerLevel',
    Gempo: 'Gempo',
    Championship: 'Championship',
    GempoRecord: 'GempoRecord',
    ChampionshipRecord: 'ChampionshipRecord',
    UserLogin: 'UserLogin',
    Admin: 'Admin',
    AdminOperationHistory: 'AdminOperationHistory',
    AdminAuthority: 'AdminAuthority',
    Banner: 'Banner',
    BannerLocation: 'BannerLocation',
    BannerVisitor: 'BannerVisitor',
    Test: 'Test',
    TestParticipant: 'TestParticipant',
    TestParticipantRecord: 'TestParticipantRecord',
    Background: 'Background',
    Setting: 'Setting',
    AdminTransaction: 'AdminTransaction',
    RedeemCode: 'RedeemCode',
    CodeRedemeer: 'CodeRedemeer',
    MultiplayerRoom: 'MultiplayerRoom',
    MultiPlayerMember: 'MultiPlayerMember'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "province" | "city" | "school" | "user" | "zone" | "level" | "subLevel" | "innerLevel" | "gempo" | "championship" | "gempoRecord" | "championshipRecord" | "userLogin" | "admin" | "adminOperationHistory" | "adminAuthority" | "banner" | "bannerLocation" | "bannerVisitor" | "test" | "testParticipant" | "testParticipantRecord" | "background" | "setting" | "adminTransaction" | "redeemCode" | "codeRedemeer" | "multiplayerRoom" | "multiPlayerMember"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Province: {
        payload: Prisma.$ProvincePayload<ExtArgs>
        fields: Prisma.ProvinceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findFirst: {
            args: Prisma.ProvinceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          findMany: {
            args: Prisma.ProvinceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          create: {
            args: Prisma.ProvinceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          createMany: {
            args: Prisma.ProvinceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvinceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          delete: {
            args: Prisma.ProvinceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          update: {
            args: Prisma.ProvinceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          deleteMany: {
            args: Prisma.ProvinceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvinceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>[]
          }
          upsert: {
            args: Prisma.ProvinceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvincePayload>
          }
          aggregate: {
            args: Prisma.ProvinceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvince>
          }
          groupBy: {
            args: Prisma.ProvinceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinceCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinceCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      SubLevel: {
        payload: Prisma.$SubLevelPayload<ExtArgs>
        fields: Prisma.SubLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          findFirst: {
            args: Prisma.SubLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          findMany: {
            args: Prisma.SubLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          create: {
            args: Prisma.SubLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          createMany: {
            args: Prisma.SubLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          delete: {
            args: Prisma.SubLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          update: {
            args: Prisma.SubLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          deleteMany: {
            args: Prisma.SubLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>[]
          }
          upsert: {
            args: Prisma.SubLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubLevelPayload>
          }
          aggregate: {
            args: Prisma.SubLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubLevel>
          }
          groupBy: {
            args: Prisma.SubLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubLevelCountArgs<ExtArgs>
            result: $Utils.Optional<SubLevelCountAggregateOutputType> | number
          }
        }
      }
      InnerLevel: {
        payload: Prisma.$InnerLevelPayload<ExtArgs>
        fields: Prisma.InnerLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InnerLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InnerLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          findFirst: {
            args: Prisma.InnerLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InnerLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          findMany: {
            args: Prisma.InnerLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          create: {
            args: Prisma.InnerLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          createMany: {
            args: Prisma.InnerLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InnerLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          delete: {
            args: Prisma.InnerLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          update: {
            args: Prisma.InnerLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          deleteMany: {
            args: Prisma.InnerLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InnerLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InnerLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>[]
          }
          upsert: {
            args: Prisma.InnerLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InnerLevelPayload>
          }
          aggregate: {
            args: Prisma.InnerLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInnerLevel>
          }
          groupBy: {
            args: Prisma.InnerLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<InnerLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.InnerLevelCountArgs<ExtArgs>
            result: $Utils.Optional<InnerLevelCountAggregateOutputType> | number
          }
        }
      }
      Gempo: {
        payload: Prisma.$GempoPayload<ExtArgs>
        fields: Prisma.GempoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GempoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GempoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          findFirst: {
            args: Prisma.GempoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GempoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          findMany: {
            args: Prisma.GempoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          create: {
            args: Prisma.GempoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          createMany: {
            args: Prisma.GempoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GempoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          delete: {
            args: Prisma.GempoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          update: {
            args: Prisma.GempoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          deleteMany: {
            args: Prisma.GempoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GempoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GempoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>[]
          }
          upsert: {
            args: Prisma.GempoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoPayload>
          }
          aggregate: {
            args: Prisma.GempoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGempo>
          }
          groupBy: {
            args: Prisma.GempoGroupByArgs<ExtArgs>
            result: $Utils.Optional<GempoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GempoCountArgs<ExtArgs>
            result: $Utils.Optional<GempoCountAggregateOutputType> | number
          }
        }
      }
      Championship: {
        payload: Prisma.$ChampionshipPayload<ExtArgs>
        fields: Prisma.ChampionshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          findMany: {
            args: Prisma.ChampionshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          create: {
            args: Prisma.ChampionshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          createMany: {
            args: Prisma.ChampionshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          update: {
            args: Prisma.ChampionshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionship>
          }
          groupBy: {
            args: Prisma.ChampionshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipCountAggregateOutputType> | number
          }
        }
      }
      GempoRecord: {
        payload: Prisma.$GempoRecordPayload<ExtArgs>
        fields: Prisma.GempoRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GempoRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GempoRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          findFirst: {
            args: Prisma.GempoRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GempoRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          findMany: {
            args: Prisma.GempoRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          create: {
            args: Prisma.GempoRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          createMany: {
            args: Prisma.GempoRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GempoRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          delete: {
            args: Prisma.GempoRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          update: {
            args: Prisma.GempoRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          deleteMany: {
            args: Prisma.GempoRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GempoRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GempoRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>[]
          }
          upsert: {
            args: Prisma.GempoRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GempoRecordPayload>
          }
          aggregate: {
            args: Prisma.GempoRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGempoRecord>
          }
          groupBy: {
            args: Prisma.GempoRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<GempoRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.GempoRecordCountArgs<ExtArgs>
            result: $Utils.Optional<GempoRecordCountAggregateOutputType> | number
          }
        }
      }
      ChampionshipRecord: {
        payload: Prisma.$ChampionshipRecordPayload<ExtArgs>
        fields: Prisma.ChampionshipRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChampionshipRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          findFirst: {
            args: Prisma.ChampionshipRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChampionshipRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          findMany: {
            args: Prisma.ChampionshipRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          create: {
            args: Prisma.ChampionshipRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          createMany: {
            args: Prisma.ChampionshipRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChampionshipRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          delete: {
            args: Prisma.ChampionshipRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          update: {
            args: Prisma.ChampionshipRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          deleteMany: {
            args: Prisma.ChampionshipRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChampionshipRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>[]
          }
          upsert: {
            args: Prisma.ChampionshipRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChampionshipRecordPayload>
          }
          aggregate: {
            args: Prisma.ChampionshipRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChampionshipRecord>
          }
          groupBy: {
            args: Prisma.ChampionshipRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChampionshipRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ChampionshipRecordCountAggregateOutputType> | number
          }
        }
      }
      UserLogin: {
        payload: Prisma.$UserLoginPayload<ExtArgs>
        fields: Prisma.UserLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          findFirst: {
            args: Prisma.UserLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          findMany: {
            args: Prisma.UserLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          create: {
            args: Prisma.UserLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          createMany: {
            args: Prisma.UserLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLoginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          delete: {
            args: Prisma.UserLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          update: {
            args: Prisma.UserLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          deleteMany: {
            args: Prisma.UserLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLoginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>[]
          }
          upsert: {
            args: Prisma.UserLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLoginPayload>
          }
          aggregate: {
            args: Prisma.UserLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLogin>
          }
          groupBy: {
            args: Prisma.UserLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLoginCountArgs<ExtArgs>
            result: $Utils.Optional<UserLoginCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminOperationHistory: {
        payload: Prisma.$AdminOperationHistoryPayload<ExtArgs>
        fields: Prisma.AdminOperationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminOperationHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          findFirst: {
            args: Prisma.AdminOperationHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          findMany: {
            args: Prisma.AdminOperationHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          create: {
            args: Prisma.AdminOperationHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          createMany: {
            args: Prisma.AdminOperationHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          delete: {
            args: Prisma.AdminOperationHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          update: {
            args: Prisma.AdminOperationHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AdminOperationHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminOperationHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>[]
          }
          upsert: {
            args: Prisma.AdminOperationHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminOperationHistoryPayload>
          }
          aggregate: {
            args: Prisma.AdminOperationHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminOperationHistory>
          }
          groupBy: {
            args: Prisma.AdminOperationHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminOperationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminOperationHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AdminOperationHistoryCountAggregateOutputType> | number
          }
        }
      }
      AdminAuthority: {
        payload: Prisma.$AdminAuthorityPayload<ExtArgs>
        fields: Prisma.AdminAuthorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuthorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuthorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          findFirst: {
            args: Prisma.AdminAuthorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuthorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          findMany: {
            args: Prisma.AdminAuthorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          create: {
            args: Prisma.AdminAuthorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          createMany: {
            args: Prisma.AdminAuthorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuthorityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          delete: {
            args: Prisma.AdminAuthorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          update: {
            args: Prisma.AdminAuthorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuthorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuthorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuthorityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuthorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuthorityPayload>
          }
          aggregate: {
            args: Prisma.AdminAuthorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuthority>
          }
          groupBy: {
            args: Prisma.AdminAuthorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuthorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuthorityCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuthorityCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      BannerLocation: {
        payload: Prisma.$BannerLocationPayload<ExtArgs>
        fields: Prisma.BannerLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          findFirst: {
            args: Prisma.BannerLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          findMany: {
            args: Prisma.BannerLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>[]
          }
          create: {
            args: Prisma.BannerLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          createMany: {
            args: Prisma.BannerLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>[]
          }
          delete: {
            args: Prisma.BannerLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          update: {
            args: Prisma.BannerLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          deleteMany: {
            args: Prisma.BannerLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>[]
          }
          upsert: {
            args: Prisma.BannerLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerLocationPayload>
          }
          aggregate: {
            args: Prisma.BannerLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerLocation>
          }
          groupBy: {
            args: Prisma.BannerLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerLocationCountArgs<ExtArgs>
            result: $Utils.Optional<BannerLocationCountAggregateOutputType> | number
          }
        }
      }
      BannerVisitor: {
        payload: Prisma.$BannerVisitorPayload<ExtArgs>
        fields: Prisma.BannerVisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerVisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerVisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          findFirst: {
            args: Prisma.BannerVisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerVisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          findMany: {
            args: Prisma.BannerVisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          create: {
            args: Prisma.BannerVisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          createMany: {
            args: Prisma.BannerVisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerVisitorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          delete: {
            args: Prisma.BannerVisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          update: {
            args: Prisma.BannerVisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          deleteMany: {
            args: Prisma.BannerVisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerVisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerVisitorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>[]
          }
          upsert: {
            args: Prisma.BannerVisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerVisitorPayload>
          }
          aggregate: {
            args: Prisma.BannerVisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerVisitor>
          }
          groupBy: {
            args: Prisma.BannerVisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerVisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerVisitorCountArgs<ExtArgs>
            result: $Utils.Optional<BannerVisitorCountAggregateOutputType> | number
          }
        }
      }
      Test: {
        payload: Prisma.$TestPayload<ExtArgs>
        fields: Prisma.TestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findFirst: {
            args: Prisma.TestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          findMany: {
            args: Prisma.TestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          create: {
            args: Prisma.TestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          createMany: {
            args: Prisma.TestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          delete: {
            args: Prisma.TestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          update: {
            args: Prisma.TestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          deleteMany: {
            args: Prisma.TestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>[]
          }
          upsert: {
            args: Prisma.TestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.TestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      TestParticipant: {
        payload: Prisma.$TestParticipantPayload<ExtArgs>
        fields: Prisma.TestParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          findFirst: {
            args: Prisma.TestParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          findMany: {
            args: Prisma.TestParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          create: {
            args: Prisma.TestParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          createMany: {
            args: Prisma.TestParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          delete: {
            args: Prisma.TestParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          update: {
            args: Prisma.TestParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          deleteMany: {
            args: Prisma.TestParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>[]
          }
          upsert: {
            args: Prisma.TestParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantPayload>
          }
          aggregate: {
            args: Prisma.TestParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParticipant>
          }
          groupBy: {
            args: Prisma.TestParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantCountAggregateOutputType> | number
          }
        }
      }
      TestParticipantRecord: {
        payload: Prisma.$TestParticipantRecordPayload<ExtArgs>
        fields: Prisma.TestParticipantRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParticipantRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          findFirst: {
            args: Prisma.TestParticipantRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParticipantRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          findMany: {
            args: Prisma.TestParticipantRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          create: {
            args: Prisma.TestParticipantRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          createMany: {
            args: Prisma.TestParticipantRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParticipantRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          delete: {
            args: Prisma.TestParticipantRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          update: {
            args: Prisma.TestParticipantRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          deleteMany: {
            args: Prisma.TestParticipantRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParticipantRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>[]
          }
          upsert: {
            args: Prisma.TestParticipantRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParticipantRecordPayload>
          }
          aggregate: {
            args: Prisma.TestParticipantRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParticipantRecord>
          }
          groupBy: {
            args: Prisma.TestParticipantRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParticipantRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TestParticipantRecordCountAggregateOutputType> | number
          }
        }
      }
      Background: {
        payload: Prisma.$BackgroundPayload<ExtArgs>
        fields: Prisma.BackgroundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackgroundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackgroundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findFirst: {
            args: Prisma.BackgroundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackgroundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          findMany: {
            args: Prisma.BackgroundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          create: {
            args: Prisma.BackgroundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          createMany: {
            args: Prisma.BackgroundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackgroundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          delete: {
            args: Prisma.BackgroundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          update: {
            args: Prisma.BackgroundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          deleteMany: {
            args: Prisma.BackgroundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackgroundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BackgroundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>[]
          }
          upsert: {
            args: Prisma.BackgroundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackgroundPayload>
          }
          aggregate: {
            args: Prisma.BackgroundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackground>
          }
          groupBy: {
            args: Prisma.BackgroundGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackgroundGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackgroundCountArgs<ExtArgs>
            result: $Utils.Optional<BackgroundCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      AdminTransaction: {
        payload: Prisma.$AdminTransactionPayload<ExtArgs>
        fields: Prisma.AdminTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          findFirst: {
            args: Prisma.AdminTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          findMany: {
            args: Prisma.AdminTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          create: {
            args: Prisma.AdminTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          createMany: {
            args: Prisma.AdminTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          delete: {
            args: Prisma.AdminTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          update: {
            args: Prisma.AdminTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          deleteMany: {
            args: Prisma.AdminTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>[]
          }
          upsert: {
            args: Prisma.AdminTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminTransactionPayload>
          }
          aggregate: {
            args: Prisma.AdminTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminTransaction>
          }
          groupBy: {
            args: Prisma.AdminTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminTransactionCountAggregateOutputType> | number
          }
        }
      }
      RedeemCode: {
        payload: Prisma.$RedeemCodePayload<ExtArgs>
        fields: Prisma.RedeemCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedeemCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedeemCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          findFirst: {
            args: Prisma.RedeemCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedeemCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          findMany: {
            args: Prisma.RedeemCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          create: {
            args: Prisma.RedeemCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          createMany: {
            args: Prisma.RedeemCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedeemCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          delete: {
            args: Prisma.RedeemCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          update: {
            args: Prisma.RedeemCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          deleteMany: {
            args: Prisma.RedeemCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedeemCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RedeemCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>[]
          }
          upsert: {
            args: Prisma.RedeemCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedeemCodePayload>
          }
          aggregate: {
            args: Prisma.RedeemCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemCode>
          }
          groupBy: {
            args: Prisma.RedeemCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedeemCodeCountArgs<ExtArgs>
            result: $Utils.Optional<RedeemCodeCountAggregateOutputType> | number
          }
        }
      }
      CodeRedemeer: {
        payload: Prisma.$CodeRedemeerPayload<ExtArgs>
        fields: Prisma.CodeRedemeerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodeRedemeerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodeRedemeerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>
          }
          findFirst: {
            args: Prisma.CodeRedemeerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodeRedemeerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>
          }
          findMany: {
            args: Prisma.CodeRedemeerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>[]
          }
          create: {
            args: Prisma.CodeRedemeerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>
          }
          createMany: {
            args: Prisma.CodeRedemeerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CodeRedemeerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>[]
          }
          delete: {
            args: Prisma.CodeRedemeerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>
          }
          update: {
            args: Prisma.CodeRedemeerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>
          }
          deleteMany: {
            args: Prisma.CodeRedemeerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodeRedemeerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CodeRedemeerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>[]
          }
          upsert: {
            args: Prisma.CodeRedemeerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeRedemeerPayload>
          }
          aggregate: {
            args: Prisma.CodeRedemeerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodeRedemeer>
          }
          groupBy: {
            args: Prisma.CodeRedemeerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodeRedemeerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodeRedemeerCountArgs<ExtArgs>
            result: $Utils.Optional<CodeRedemeerCountAggregateOutputType> | number
          }
        }
      }
      MultiplayerRoom: {
        payload: Prisma.$MultiplayerRoomPayload<ExtArgs>
        fields: Prisma.MultiplayerRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiplayerRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiplayerRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          findFirst: {
            args: Prisma.MultiplayerRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiplayerRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          findMany: {
            args: Prisma.MultiplayerRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>[]
          }
          create: {
            args: Prisma.MultiplayerRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          createMany: {
            args: Prisma.MultiplayerRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultiplayerRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>[]
          }
          delete: {
            args: Prisma.MultiplayerRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          update: {
            args: Prisma.MultiplayerRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          deleteMany: {
            args: Prisma.MultiplayerRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultiplayerRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultiplayerRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>[]
          }
          upsert: {
            args: Prisma.MultiplayerRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiplayerRoomPayload>
          }
          aggregate: {
            args: Prisma.MultiplayerRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultiplayerRoom>
          }
          groupBy: {
            args: Prisma.MultiplayerRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultiplayerRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiplayerRoomCountArgs<ExtArgs>
            result: $Utils.Optional<MultiplayerRoomCountAggregateOutputType> | number
          }
        }
      }
      MultiPlayerMember: {
        payload: Prisma.$MultiPlayerMemberPayload<ExtArgs>
        fields: Prisma.MultiPlayerMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiPlayerMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiPlayerMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          findFirst: {
            args: Prisma.MultiPlayerMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiPlayerMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          findMany: {
            args: Prisma.MultiPlayerMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>[]
          }
          create: {
            args: Prisma.MultiPlayerMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          createMany: {
            args: Prisma.MultiPlayerMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultiPlayerMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>[]
          }
          delete: {
            args: Prisma.MultiPlayerMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          update: {
            args: Prisma.MultiPlayerMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          deleteMany: {
            args: Prisma.MultiPlayerMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultiPlayerMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultiPlayerMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>[]
          }
          upsert: {
            args: Prisma.MultiPlayerMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiPlayerMemberPayload>
          }
          aggregate: {
            args: Prisma.MultiPlayerMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultiPlayerMember>
          }
          groupBy: {
            args: Prisma.MultiPlayerMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultiPlayerMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiPlayerMemberCountArgs<ExtArgs>
            result: $Utils.Optional<MultiPlayerMemberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    province?: ProvinceOmit
    city?: CityOmit
    school?: SchoolOmit
    user?: UserOmit
    zone?: ZoneOmit
    level?: LevelOmit
    subLevel?: SubLevelOmit
    innerLevel?: InnerLevelOmit
    gempo?: GempoOmit
    championship?: ChampionshipOmit
    gempoRecord?: GempoRecordOmit
    championshipRecord?: ChampionshipRecordOmit
    userLogin?: UserLoginOmit
    admin?: AdminOmit
    adminOperationHistory?: AdminOperationHistoryOmit
    adminAuthority?: AdminAuthorityOmit
    banner?: BannerOmit
    bannerLocation?: BannerLocationOmit
    bannerVisitor?: BannerVisitorOmit
    test?: TestOmit
    testParticipant?: TestParticipantOmit
    testParticipantRecord?: TestParticipantRecordOmit
    background?: BackgroundOmit
    setting?: SettingOmit
    adminTransaction?: AdminTransactionOmit
    redeemCode?: RedeemCodeOmit
    codeRedemeer?: CodeRedemeerOmit
    multiplayerRoom?: MultiplayerRoomOmit
    multiPlayerMember?: MultiPlayerMemberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProvinceCountOutputType
   */

  export type ProvinceCountOutputType = {
    cities: number
    schools: number
    users: number
    adminAuthority: number
    bannerLocation: number
    admin: number
  }

  export type ProvinceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | ProvinceCountOutputTypeCountCitiesArgs
    schools?: boolean | ProvinceCountOutputTypeCountSchoolsArgs
    users?: boolean | ProvinceCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | ProvinceCountOutputTypeCountAdminAuthorityArgs
    bannerLocation?: boolean | ProvinceCountOutputTypeCountBannerLocationArgs
    admin?: boolean | ProvinceCountOutputTypeCountAdminArgs
  }

  // Custom InputTypes
  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinceCountOutputType
     */
    select?: ProvinceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountBannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
  }

  /**
   * ProvinceCountOutputType without action
   */
  export type ProvinceCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    schools: number
    users: number
    adminAuthority: number
    bannerLocation: number
    admin: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | CityCountOutputTypeCountSchoolsArgs
    users?: boolean | CityCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | CityCountOutputTypeCountAdminAuthorityArgs
    bannerLocation?: boolean | CityCountOutputTypeCountBannerLocationArgs
    admin?: boolean | CityCountOutputTypeCountAdminArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountBannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    users: number
    adminAuthority: number
    admin: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SchoolCountOutputTypeCountUsersArgs
    adminAuthority?: boolean | SchoolCountOutputTypeCountAdminAuthorityArgs
    admin?: boolean | SchoolCountOutputTypeCountAdminArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    zones: number
    userLogin: number
    bannerVisitor: number
    testParticipant: number
    multiPlayerMember: number
    subLevels: number
    innerLevels: number
    levels: number
    gempos: number
    championships: number
    gempoRecords: number
    championshipRecords: number
    redemeedCodes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | UserCountOutputTypeCountZonesArgs
    userLogin?: boolean | UserCountOutputTypeCountUserLoginArgs
    bannerVisitor?: boolean | UserCountOutputTypeCountBannerVisitorArgs
    testParticipant?: boolean | UserCountOutputTypeCountTestParticipantArgs
    multiPlayerMember?: boolean | UserCountOutputTypeCountMultiPlayerMemberArgs
    subLevels?: boolean | UserCountOutputTypeCountSubLevelsArgs
    innerLevels?: boolean | UserCountOutputTypeCountInnerLevelsArgs
    levels?: boolean | UserCountOutputTypeCountLevelsArgs
    gempos?: boolean | UserCountOutputTypeCountGemposArgs
    championships?: boolean | UserCountOutputTypeCountChampionshipsArgs
    gempoRecords?: boolean | UserCountOutputTypeCountGempoRecordsArgs
    championshipRecords?: boolean | UserCountOutputTypeCountChampionshipRecordsArgs
    redemeedCodes?: boolean | UserCountOutputTypeCountRedemeedCodesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBannerVisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMultiPlayerMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiPlayerMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubLevelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInnerLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InnerLevelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGemposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChampionshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGempoRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChampionshipRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRedemeedCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeRedemeerWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    authority: number
    operationHistories: number
    operations: number
    banner: number
    transactions: number
    transactionProcessed: number
    redeemCodes: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authority?: boolean | AdminCountOutputTypeCountAuthorityArgs
    operationHistories?: boolean | AdminCountOutputTypeCountOperationHistoriesArgs
    operations?: boolean | AdminCountOutputTypeCountOperationsArgs
    banner?: boolean | AdminCountOutputTypeCountBannerArgs
    transactions?: boolean | AdminCountOutputTypeCountTransactionsArgs
    transactionProcessed?: boolean | AdminCountOutputTypeCountTransactionProcessedArgs
    redeemCodes?: boolean | AdminCountOutputTypeCountRedeemCodesArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOperationHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountTransactionProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountRedeemCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeWhereInput
  }


  /**
   * Count Type AdminAuthorityCountOutputType
   */

  export type AdminAuthorityCountOutputType = {
    cities: number
    schools: number
  }

  export type AdminAuthorityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | AdminAuthorityCountOutputTypeCountCitiesArgs
    schools?: boolean | AdminAuthorityCountOutputTypeCountSchoolsArgs
  }

  // Custom InputTypes
  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthorityCountOutputType
     */
    select?: AdminAuthorityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }

  /**
   * AdminAuthorityCountOutputType without action
   */
  export type AdminAuthorityCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }


  /**
   * Count Type BannerCountOutputType
   */

  export type BannerCountOutputType = {
    visitors: number
    bannerLocation: number
  }

  export type BannerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | BannerCountOutputTypeCountVisitorsArgs
    bannerLocation?: boolean | BannerCountOutputTypeCountBannerLocationArgs
  }

  // Custom InputTypes
  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerCountOutputType
     */
    select?: BannerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountVisitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountBannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
  }


  /**
   * Count Type BannerLocationCountOutputType
   */

  export type BannerLocationCountOutputType = {
    cities: number
  }

  export type BannerLocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | BannerLocationCountOutputTypeCountCitiesArgs
  }

  // Custom InputTypes
  /**
   * BannerLocationCountOutputType without action
   */
  export type BannerLocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocationCountOutputType
     */
    select?: BannerLocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BannerLocationCountOutputType without action
   */
  export type BannerLocationCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
  }


  /**
   * Count Type TestCountOutputType
   */

  export type TestCountOutputType = {
    participants: number
  }

  export type TestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | TestCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCountOutputType
     */
    select?: TestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
  }


  /**
   * Count Type TestParticipantCountOutputType
   */

  export type TestParticipantCountOutputType = {
    records: number
  }

  export type TestParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | TestParticipantCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * TestParticipantCountOutputType without action
   */
  export type TestParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantCountOutputType
     */
    select?: TestParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestParticipantCountOutputType without action
   */
  export type TestParticipantCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
  }


  /**
   * Count Type RedeemCodeCountOutputType
   */

  export type RedeemCodeCountOutputType = {
    redemeers: number
  }

  export type RedeemCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemeers?: boolean | RedeemCodeCountOutputTypeCountRedemeersArgs
  }

  // Custom InputTypes
  /**
   * RedeemCodeCountOutputType without action
   */
  export type RedeemCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCodeCountOutputType
     */
    select?: RedeemCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RedeemCodeCountOutputType without action
   */
  export type RedeemCodeCountOutputTypeCountRedemeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeRedemeerWhereInput
  }


  /**
   * Count Type MultiplayerRoomCountOutputType
   */

  export type MultiplayerRoomCountOutputType = {
    members: number
  }

  export type MultiplayerRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MultiplayerRoomCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * MultiplayerRoomCountOutputType without action
   */
  export type MultiplayerRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoomCountOutputType
     */
    select?: MultiplayerRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultiplayerRoomCountOutputType without action
   */
  export type MultiplayerRoomCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiPlayerMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Province
   */

  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type ProvinceSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type ProvinceMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvinceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvinceCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProvinceAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type ProvinceSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type ProvinceMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvinceMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvinceCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProvinceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Province to aggregate.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }




  export type ProvinceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinceWhereInput
    orderBy?: ProvinceOrderByWithAggregationInput | ProvinceOrderByWithAggregationInput[]
    by: ProvinceScalarFieldEnum[] | ProvinceScalarFieldEnum
    having?: ProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _avg?: ProvinceAvgAggregateInputType
    _sum?: ProvinceSumAggregateInputType
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }

  export type ProvinceGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt: Date
    updatedAt: Date
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends ProvinceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      >
    >


  export type ProvinceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cities?: boolean | Province$citiesArgs<ExtArgs>
    schools?: boolean | Province$schoolsArgs<ExtArgs>
    users?: boolean | Province$usersArgs<ExtArgs>
    adminAuthority?: boolean | Province$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | Province$bannerLocationArgs<ExtArgs>
    admin?: boolean | Province$adminArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["province"]>

  export type ProvinceSelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProvinceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "createdAt" | "updatedAt", ExtArgs["result"]["province"]>
  export type ProvinceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | Province$citiesArgs<ExtArgs>
    schools?: boolean | Province$schoolsArgs<ExtArgs>
    users?: boolean | Province$usersArgs<ExtArgs>
    adminAuthority?: boolean | Province$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | Province$bannerLocationArgs<ExtArgs>
    admin?: boolean | Province$adminArgs<ExtArgs>
    _count?: boolean | ProvinceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvinceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProvinceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProvincePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Province"
    objects: {
      cities: Prisma.$CityPayload<ExtArgs>[]
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      bannerLocation: Prisma.$BannerLocationPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["province"]>
    composites: {}
  }

  type ProvinceGetPayload<S extends boolean | null | undefined | ProvinceDefaultArgs> = $Result.GetResult<Prisma.$ProvincePayload, S>

  type ProvinceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvinceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvinceCountAggregateInputType | true
    }

  export interface ProvinceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Province'], meta: { name: 'Province' } }
    /**
     * Find zero or one Province that matches the filter.
     * @param {ProvinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvinceFindUniqueArgs>(args: SelectSubset<T, ProvinceFindUniqueArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Province that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvinceFindUniqueOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvinceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvinceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvinceFindFirstArgs>(args?: SelectSubset<T, ProvinceFindFirstArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Province that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstOrThrowArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvinceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvinceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinceWithIdOnly = await prisma.province.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProvinceFindManyArgs>(args?: SelectSubset<T, ProvinceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Province.
     * @param {ProvinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
     */
    create<T extends ProvinceCreateArgs>(args: SelectSubset<T, ProvinceCreateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provinces.
     * @param {ProvinceCreateManyArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvinceCreateManyArgs>(args?: SelectSubset<T, ProvinceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provinces and returns the data saved in the database.
     * @param {ProvinceCreateManyAndReturnArgs} args - Arguments to create many Provinces.
     * @example
     * // Create many Provinces
     * const province = await prisma.province.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvinceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvinceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Province.
     * @param {ProvinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
     */
    delete<T extends ProvinceDeleteArgs>(args: SelectSubset<T, ProvinceDeleteArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Province.
     * @param {ProvinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvinceUpdateArgs>(args: SelectSubset<T, ProvinceUpdateArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provinces.
     * @param {ProvinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvinceDeleteManyArgs>(args?: SelectSubset<T, ProvinceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvinceUpdateManyArgs>(args: SelectSubset<T, ProvinceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces and returns the data updated in the database.
     * @param {ProvinceUpdateManyAndReturnArgs} args - Arguments to update many Provinces.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provinces and only return the `id`
     * const provinceWithIdOnly = await prisma.province.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvinceUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvinceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Province.
     * @param {ProvinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
     */
    upsert<T extends ProvinceUpsertArgs>(args: SelectSubset<T, ProvinceUpsertArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends ProvinceCountArgs>(
      args?: Subset<T, ProvinceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): Prisma.PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinceGroupByArgs['orderBy'] }
        : { orderBy?: ProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Province model
   */
  readonly fields: ProvinceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends Province$citiesArgs<ExtArgs> = {}>(args?: Subset<T, Province$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends Province$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Province$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Province$usersArgs<ExtArgs> = {}>(args?: Subset<T, Province$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends Province$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, Province$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bannerLocation<T extends Province$bannerLocationArgs<ExtArgs> = {}>(args?: Subset<T, Province$bannerLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends Province$adminArgs<ExtArgs> = {}>(args?: Subset<T, Province$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Province model
   */
  interface ProvinceFieldRefs {
    readonly id: FieldRef<"Province", 'String'>
    readonly name: FieldRef<"Province", 'String'>
    readonly longitude: FieldRef<"Province", 'Float'>
    readonly latitude: FieldRef<"Province", 'Float'>
    readonly geoId: FieldRef<"Province", 'String'>
    readonly createdAt: FieldRef<"Province", 'DateTime'>
    readonly updatedAt: FieldRef<"Province", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Province findUnique
   */
  export type ProvinceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findUniqueOrThrow
   */
  export type ProvinceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province findFirst
   */
  export type ProvinceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findFirstOrThrow
   */
  export type ProvinceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Province to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     */
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province findMany
   */
  export type ProvinceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter, which Provinces to fetch.
     */
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     */
    orderBy?: ProvinceOrderByWithRelationInput | ProvinceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinces.
     */
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     */
    skip?: number
    distinct?: ProvinceScalarFieldEnum | ProvinceScalarFieldEnum[]
  }

  /**
   * Province create
   */
  export type ProvinceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to create a Province.
     */
    data: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
  }

  /**
   * Province createMany
   */
  export type ProvinceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province createManyAndReturn
   */
  export type ProvinceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to create many Provinces.
     */
    data: ProvinceCreateManyInput | ProvinceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Province update
   */
  export type ProvinceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The data needed to update a Province.
     */
    data: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
    /**
     * Choose, which Province to update.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province updateMany
   */
  export type ProvinceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province updateManyAndReturn
   */
  export type ProvinceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * The data used to update Provinces.
     */
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    /**
     * Filter which Provinces to update
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to update.
     */
    limit?: number
  }

  /**
   * Province upsert
   */
  export type ProvinceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * The filter to search for the Province to update in case it exists.
     */
    where: ProvinceWhereUniqueInput
    /**
     * In case the Province found by the `where` argument doesn't exist, create a new Province with this data.
     */
    create: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
    /**
     * In case the Province was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
  }

  /**
   * Province delete
   */
  export type ProvinceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    /**
     * Filter which Province to delete.
     */
    where: ProvinceWhereUniqueInput
  }

  /**
   * Province deleteMany
   */
  export type ProvinceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provinces to delete
     */
    where?: ProvinceWhereInput
    /**
     * Limit how many Provinces to delete.
     */
    limit?: number
  }

  /**
   * Province.cities
   */
  export type Province$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * Province.schools
   */
  export type Province$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * Province.users
   */
  export type Province$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Province.adminAuthority
   */
  export type Province$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Province.bannerLocation
   */
  export type Province$bannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    cursor?: BannerLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * Province.admin
   */
  export type Province$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Province without action
   */
  export type ProvinceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type CitySumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    geoId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    longitude: number
    latitude: number
    geoId: number
    provinceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type CitySumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    longitude?: true
    latitude?: true
    geoId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    schools?: boolean | City$schoolsArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    adminAuthority?: boolean | City$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | City$bannerLocationArgs<ExtArgs>
    admin?: boolean | City$adminArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    geoId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "longitude" | "latitude" | "geoId" | "provinceId" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    schools?: boolean | City$schoolsArgs<ExtArgs>
    users?: boolean | City$usersArgs<ExtArgs>
    adminAuthority?: boolean | City$adminAuthorityArgs<ExtArgs>
    bannerLocation?: boolean | City$bannerLocationArgs<ExtArgs>
    admin?: boolean | City$adminArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      province: Prisma.$ProvincePayload<ExtArgs>
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      bannerLocation: Prisma.$BannerLocationPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      longitude: number
      latitude: number
      geoId: string
      provinceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schools<T extends City$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, City$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends City$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, City$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bannerLocation<T extends City$bannerLocationArgs<ExtArgs> = {}>(args?: Subset<T, City$bannerLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends City$adminArgs<ExtArgs> = {}>(args?: Subset<T, City$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly longitude: FieldRef<"City", 'Float'>
    readonly latitude: FieldRef<"City", 'Float'>
    readonly geoId: FieldRef<"City", 'String'>
    readonly provinceId: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.schools
   */
  export type City$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * City.adminAuthority
   */
  export type City$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * City.bannerLocation
   */
  export type City$bannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    cursor?: BannerLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * City.admin
   */
  export type City$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SchoolSumAggregateOutputType = {
    longitude: number | null
    latitude: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    identity: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    cityId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    identity: string | null
    name: string | null
    longitude: number | null
    latitude: number | null
    cityId: string | null
    provinceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    identity: number
    name: number
    longitude: number
    latitude: number
    cityId: number
    provinceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SchoolSumAggregateInputType = {
    longitude?: true
    latitude?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    identity?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    identity?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    identity?: true
    name?: true
    longitude?: true
    latitude?: true
    cityId?: true
    provinceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    adminAuthority?: boolean | School$adminAuthorityArgs<ExtArgs>
    admin?: boolean | School$adminArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    identity?: boolean
    name?: boolean
    longitude?: boolean
    latitude?: boolean
    cityId?: boolean
    provinceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identity" | "name" | "longitude" | "latitude" | "cityId" | "provinceId" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    users?: boolean | School$usersArgs<ExtArgs>
    adminAuthority?: boolean | School$adminAuthorityArgs<ExtArgs>
    admin?: boolean | School$adminArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      adminAuthority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identity: string
      name: string
      longitude: number
      latitude: number
      cityId: string
      provinceId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends School$usersArgs<ExtArgs> = {}>(args?: Subset<T, School$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminAuthority<T extends School$adminAuthorityArgs<ExtArgs> = {}>(args?: Subset<T, School$adminAuthorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends School$adminArgs<ExtArgs> = {}>(args?: Subset<T, School$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly identity: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly longitude: FieldRef<"School", 'Float'>
    readonly latitude: FieldRef<"School", 'Float'>
    readonly cityId: FieldRef<"School", 'String'>
    readonly provinceId: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.users
   */
  export type School$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * School.adminAuthority
   */
  export type School$adminAuthorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * School.admin
   */
  export type School$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    grade: number | null
    playTime: number | null
    inventory: number | null
  }

  export type UserSumAggregateOutputType = {
    grade: number | null
    playTime: number | null
    inventory: number[]
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    role: $Enums.Role | null
    suspend: boolean | null
    accountType: $Enums.AccountType | null
    firstTest: boolean | null
    fullname: string | null
    birthDate: Date | null
    grade: number | null
    lastGradeUpdateAt: Date | null
    schoolIdentity: string | null
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number | null
    characterUsed: string | null
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    lastIdZoneUnlocked: string | null
    lastIdZonePosition: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    role: $Enums.Role | null
    suspend: boolean | null
    accountType: $Enums.AccountType | null
    firstTest: boolean | null
    fullname: string | null
    birthDate: Date | null
    grade: number | null
    lastGradeUpdateAt: Date | null
    schoolIdentity: string | null
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number | null
    characterUsed: string | null
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    lastIdZoneUnlocked: string | null
    lastIdZonePosition: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    authId: number
    email: number
    role: number
    suspend: number
    accountType: number
    firstTest: number
    fullname: number
    birthDate: number
    grade: number
    lastGradeUpdateAt: number
    schoolIdentity: number
    loginAt: number
    logoutAt: number
    playTime: number
    characterUsed: number
    inventory: number
    schoolId: number
    cityId: number
    provinceId: number
    adminId: number
    createdAt: number
    updatedAt: number
    username: number
    lastIdZoneUnlocked: number
    lastIdZonePosition: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    grade?: true
    playTime?: true
    inventory?: true
  }

  export type UserSumAggregateInputType = {
    grade?: true
    playTime?: true
    inventory?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    role?: true
    suspend?: true
    accountType?: true
    firstTest?: true
    fullname?: true
    birthDate?: true
    grade?: true
    lastGradeUpdateAt?: true
    schoolIdentity?: true
    loginAt?: true
    logoutAt?: true
    playTime?: true
    characterUsed?: true
    inventory?: true
    schoolId?: true
    cityId?: true
    provinceId?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    lastIdZoneUnlocked?: true
    lastIdZonePosition?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    authId: string
    email: string
    role: $Enums.Role
    suspend: boolean
    accountType: $Enums.AccountType
    firstTest: boolean
    fullname: string
    birthDate: Date | null
    grade: number
    lastGradeUpdateAt: Date | null
    schoolIdentity: string
    loginAt: Date | null
    logoutAt: Date | null
    playTime: number
    characterUsed: string
    inventory: number[]
    schoolId: string | null
    cityId: string | null
    provinceId: string | null
    adminId: string | null
    createdAt: Date
    updatedAt: Date
    username: string
    lastIdZoneUnlocked: string
    lastIdZonePosition: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    zones?: boolean | User$zonesArgs<ExtArgs>
    userLogin?: boolean | User$userLoginArgs<ExtArgs>
    bannerVisitor?: boolean | User$bannerVisitorArgs<ExtArgs>
    testParticipant?: boolean | User$testParticipantArgs<ExtArgs>
    multiPlayerMember?: boolean | User$multiPlayerMemberArgs<ExtArgs>
    subLevels?: boolean | User$subLevelsArgs<ExtArgs>
    innerLevels?: boolean | User$innerLevelsArgs<ExtArgs>
    levels?: boolean | User$levelsArgs<ExtArgs>
    gempos?: boolean | User$gemposArgs<ExtArgs>
    championships?: boolean | User$championshipsArgs<ExtArgs>
    gempoRecords?: boolean | User$gempoRecordsArgs<ExtArgs>
    championshipRecords?: boolean | User$championshipRecordsArgs<ExtArgs>
    redemeedCodes?: boolean | User$redemeedCodesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    authId?: boolean
    email?: boolean
    role?: boolean
    suspend?: boolean
    accountType?: boolean
    firstTest?: boolean
    fullname?: boolean
    birthDate?: boolean
    grade?: boolean
    lastGradeUpdateAt?: boolean
    schoolIdentity?: boolean
    loginAt?: boolean
    logoutAt?: boolean
    playTime?: boolean
    characterUsed?: boolean
    inventory?: boolean
    schoolId?: boolean
    cityId?: boolean
    provinceId?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    lastIdZoneUnlocked?: boolean
    lastIdZonePosition?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "email" | "role" | "suspend" | "accountType" | "firstTest" | "fullname" | "birthDate" | "grade" | "lastGradeUpdateAt" | "schoolIdentity" | "loginAt" | "logoutAt" | "playTime" | "characterUsed" | "inventory" | "schoolId" | "cityId" | "provinceId" | "adminId" | "createdAt" | "updatedAt" | "username" | "lastIdZoneUnlocked" | "lastIdZonePosition", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    zones?: boolean | User$zonesArgs<ExtArgs>
    userLogin?: boolean | User$userLoginArgs<ExtArgs>
    bannerVisitor?: boolean | User$bannerVisitorArgs<ExtArgs>
    testParticipant?: boolean | User$testParticipantArgs<ExtArgs>
    multiPlayerMember?: boolean | User$multiPlayerMemberArgs<ExtArgs>
    subLevels?: boolean | User$subLevelsArgs<ExtArgs>
    innerLevels?: boolean | User$innerLevelsArgs<ExtArgs>
    levels?: boolean | User$levelsArgs<ExtArgs>
    gempos?: boolean | User$gemposArgs<ExtArgs>
    championships?: boolean | User$championshipsArgs<ExtArgs>
    gempoRecords?: boolean | User$gempoRecordsArgs<ExtArgs>
    championshipRecords?: boolean | User$championshipRecordsArgs<ExtArgs>
    redemeedCodes?: boolean | User$redemeedCodesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | User$cityArgs<ExtArgs>
    province?: boolean | User$provinceArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      city: Prisma.$CityPayload<ExtArgs> | null
      province: Prisma.$ProvincePayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      zones: Prisma.$ZonePayload<ExtArgs>[]
      userLogin: Prisma.$UserLoginPayload<ExtArgs>[]
      bannerVisitor: Prisma.$BannerVisitorPayload<ExtArgs>[]
      testParticipant: Prisma.$TestParticipantPayload<ExtArgs>[]
      multiPlayerMember: Prisma.$MultiPlayerMemberPayload<ExtArgs>[]
      subLevels: Prisma.$SubLevelPayload<ExtArgs>[]
      innerLevels: Prisma.$InnerLevelPayload<ExtArgs>[]
      levels: Prisma.$LevelPayload<ExtArgs>[]
      gempos: Prisma.$GempoPayload<ExtArgs>[]
      championships: Prisma.$ChampionshipPayload<ExtArgs>[]
      gempoRecords: Prisma.$GempoRecordPayload<ExtArgs>[]
      championshipRecords: Prisma.$ChampionshipRecordPayload<ExtArgs>[]
      redemeedCodes: Prisma.$CodeRedemeerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      email: string
      role: $Enums.Role
      suspend: boolean
      accountType: $Enums.AccountType
      firstTest: boolean
      fullname: string
      birthDate: Date | null
      grade: number
      lastGradeUpdateAt: Date | null
      schoolIdentity: string
      loginAt: Date | null
      logoutAt: Date | null
      playTime: number
      characterUsed: string
      inventory: number[]
      schoolId: string | null
      cityId: string | null
      provinceId: string | null
      adminId: string | null
      createdAt: Date
      updatedAt: Date
      username: string
      lastIdZoneUnlocked: string
      lastIdZonePosition: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends User$cityArgs<ExtArgs> = {}>(args?: Subset<T, User$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    province<T extends User$provinceArgs<ExtArgs> = {}>(args?: Subset<T, User$provinceArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    zones<T extends User$zonesArgs<ExtArgs> = {}>(args?: Subset<T, User$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLogin<T extends User$userLoginArgs<ExtArgs> = {}>(args?: Subset<T, User$userLoginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bannerVisitor<T extends User$bannerVisitorArgs<ExtArgs> = {}>(args?: Subset<T, User$bannerVisitorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testParticipant<T extends User$testParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$testParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    multiPlayerMember<T extends User$multiPlayerMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$multiPlayerMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subLevels<T extends User$subLevelsArgs<ExtArgs> = {}>(args?: Subset<T, User$subLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    innerLevels<T extends User$innerLevelsArgs<ExtArgs> = {}>(args?: Subset<T, User$innerLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    levels<T extends User$levelsArgs<ExtArgs> = {}>(args?: Subset<T, User$levelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gempos<T extends User$gemposArgs<ExtArgs> = {}>(args?: Subset<T, User$gemposArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    championships<T extends User$championshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$championshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gempoRecords<T extends User$gempoRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$gempoRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    championshipRecords<T extends User$championshipRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$championshipRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redemeedCodes<T extends User$redemeedCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$redemeedCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly authId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly suspend: FieldRef<"User", 'Boolean'>
    readonly accountType: FieldRef<"User", 'AccountType'>
    readonly firstTest: FieldRef<"User", 'Boolean'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly grade: FieldRef<"User", 'Int'>
    readonly lastGradeUpdateAt: FieldRef<"User", 'DateTime'>
    readonly schoolIdentity: FieldRef<"User", 'String'>
    readonly loginAt: FieldRef<"User", 'DateTime'>
    readonly logoutAt: FieldRef<"User", 'DateTime'>
    readonly playTime: FieldRef<"User", 'Int'>
    readonly characterUsed: FieldRef<"User", 'String'>
    readonly inventory: FieldRef<"User", 'Int[]'>
    readonly schoolId: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly provinceId: FieldRef<"User", 'String'>
    readonly adminId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly lastIdZoneUnlocked: FieldRef<"User", 'String'>
    readonly lastIdZonePosition: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.city
   */
  export type User$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * User.province
   */
  export type User$provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.zones
   */
  export type User$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * User.userLogin
   */
  export type User$userLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    where?: UserLoginWhereInput
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    cursor?: UserLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * User.bannerVisitor
   */
  export type User$bannerVisitorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    cursor?: BannerVisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * User.testParticipant
   */
  export type User$testParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    cursor?: TestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * User.multiPlayerMember
   */
  export type User$multiPlayerMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    where?: MultiPlayerMemberWhereInput
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    cursor?: MultiPlayerMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * User.subLevels
   */
  export type User$subLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    where?: SubLevelWhereInput
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    cursor?: SubLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * User.innerLevels
   */
  export type User$innerLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    where?: InnerLevelWhereInput
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    cursor?: InnerLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * User.levels
   */
  export type User$levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    cursor?: LevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * User.gempos
   */
  export type User$gemposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    where?: GempoWhereInput
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    cursor?: GempoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * User.championships
   */
  export type User$championshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    where?: ChampionshipWhereInput
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    cursor?: ChampionshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * User.gempoRecords
   */
  export type User$gempoRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    where?: GempoRecordWhereInput
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    cursor?: GempoRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * User.championshipRecords
   */
  export type User$championshipRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    where?: ChampionshipRecordWhereInput
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    cursor?: ChampionshipRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * User.redemeedCodes
   */
  export type User$redemeedCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    where?: CodeRedemeerWhereInput
    orderBy?: CodeRedemeerOrderByWithRelationInput | CodeRedemeerOrderByWithRelationInput[]
    cursor?: CodeRedemeerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeRedemeerScalarFieldEnum | CodeRedemeerScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    inGameId: string | null
    userId: string | null
    isComplete: boolean | null
    completedAt: Date | null
    lastLevelId: string | null
    lastSubLevelId: string | null
    lastInnerLevelId: string | null
    lastLevelUnlock: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    inGameId: string | null
    userId: string | null
    isComplete: boolean | null
    completedAt: Date | null
    lastLevelId: string | null
    lastSubLevelId: string | null
    lastInnerLevelId: string | null
    lastLevelUnlock: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    inGameId: number
    userId: number
    isComplete: number
    completedAt: number
    lastLevelId: number
    lastSubLevelId: number
    lastInnerLevelId: number
    lastLevelUnlock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    id?: true
    inGameId?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    inGameId?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    inGameId?: true
    userId?: true
    isComplete?: true
    completedAt?: true
    lastLevelId?: true
    lastSubLevelId?: true
    lastInnerLevelId?: true
    lastLevelUnlock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    inGameId: string
    userId: string
    isComplete: boolean
    completedAt: Date | null
    lastLevelId: string
    lastSubLevelId: string
    lastInnerLevelId: string
    lastLevelUnlock: string
    createdAt: Date
    updatedAt: Date
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    inGameId?: boolean
    userId?: boolean
    isComplete?: boolean
    completedAt?: boolean
    lastLevelId?: boolean
    lastSubLevelId?: boolean
    lastInnerLevelId?: boolean
    lastLevelUnlock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inGameId" | "userId" | "isComplete" | "completedAt" | "lastLevelId" | "lastSubLevelId" | "lastInnerLevelId" | "lastLevelUnlock" | "createdAt" | "updatedAt", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inGameId: string
      userId: string
      isComplete: boolean
      completedAt: Date | null
      lastLevelId: string
      lastSubLevelId: string
      lastInnerLevelId: string
      lastLevelUnlock: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly inGameId: FieldRef<"Zone", 'String'>
    readonly userId: FieldRef<"Zone", 'String'>
    readonly isComplete: FieldRef<"Zone", 'Boolean'>
    readonly completedAt: FieldRef<"Zone", 'DateTime'>
    readonly lastLevelId: FieldRef<"Zone", 'String'>
    readonly lastSubLevelId: FieldRef<"Zone", 'String'>
    readonly lastInnerLevelId: FieldRef<"Zone", 'String'>
    readonly lastLevelUnlock: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    inGameId: number
    zoneInGameId: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type LevelMinAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    inGameId: string
    zoneInGameId: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: LevelCountAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectScalar = {
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inGameId" | "zoneInGameId" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inGameId: string
      zoneInGameId: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {LevelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LevelUpdateManyAndReturnArgs>(args: SelectSubset<T, LevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly inGameId: FieldRef<"Level", 'String'>
    readonly zoneInGameId: FieldRef<"Level", 'String'>
    readonly isUnlock: FieldRef<"Level", 'Boolean'>
    readonly unlockedAt: FieldRef<"Level", 'DateTime'>
    readonly isComplete: FieldRef<"Level", 'Boolean'>
    readonly completedAt: FieldRef<"Level", 'DateTime'>
    readonly createdAt: FieldRef<"Level", 'DateTime'>
    readonly updatedAt: FieldRef<"Level", 'DateTime'>
    readonly userId: FieldRef<"Level", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level updateManyAndReturn
   */
  export type LevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model SubLevel
   */

  export type AggregateSubLevel = {
    _count: SubLevelCountAggregateOutputType | null
    _min: SubLevelMinAggregateOutputType | null
    _max: SubLevelMaxAggregateOutputType | null
  }

  export type SubLevelMinAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    levelInGameId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type SubLevelMaxAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    levelInGameId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type SubLevelCountAggregateOutputType = {
    id: number
    inGameId: number
    zoneInGameId: number
    levelInGameId: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type SubLevelMinAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    levelInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type SubLevelMaxAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    levelInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type SubLevelCountAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    levelInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type SubLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubLevel to aggregate.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubLevels
    **/
    _count?: true | SubLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubLevelMaxAggregateInputType
  }

  export type GetSubLevelAggregateType<T extends SubLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateSubLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubLevel[P]>
      : GetScalarType<T[P], AggregateSubLevel[P]>
  }




  export type SubLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubLevelWhereInput
    orderBy?: SubLevelOrderByWithAggregationInput | SubLevelOrderByWithAggregationInput[]
    by: SubLevelScalarFieldEnum[] | SubLevelScalarFieldEnum
    having?: SubLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubLevelCountAggregateInputType | true
    _min?: SubLevelMinAggregateInputType
    _max?: SubLevelMaxAggregateInputType
  }

  export type SubLevelGroupByOutputType = {
    id: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: SubLevelCountAggregateOutputType | null
    _min: SubLevelMinAggregateOutputType | null
    _max: SubLevelMaxAggregateOutputType | null
  }

  type GetSubLevelGroupByPayload<T extends SubLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubLevelGroupByOutputType[P]>
            : GetScalarType<T[P], SubLevelGroupByOutputType[P]>
        }
      >
    >


  export type SubLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subLevel"]>

  export type SubLevelSelectScalar = {
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type SubLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inGameId" | "zoneInGameId" | "levelInGameId" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["subLevel"]>
  export type SubLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubLevel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inGameId: string
      zoneInGameId: string
      levelInGameId: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["subLevel"]>
    composites: {}
  }

  type SubLevelGetPayload<S extends boolean | null | undefined | SubLevelDefaultArgs> = $Result.GetResult<Prisma.$SubLevelPayload, S>

  type SubLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubLevelCountAggregateInputType | true
    }

  export interface SubLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubLevel'], meta: { name: 'SubLevel' } }
    /**
     * Find zero or one SubLevel that matches the filter.
     * @param {SubLevelFindUniqueArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubLevelFindUniqueArgs>(args: SelectSubset<T, SubLevelFindUniqueArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubLevelFindUniqueOrThrowArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, SubLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindFirstArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubLevelFindFirstArgs>(args?: SelectSubset<T, SubLevelFindFirstArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindFirstOrThrowArgs} args - Arguments to find a SubLevel
     * @example
     * // Get one SubLevel
     * const subLevel = await prisma.subLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, SubLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubLevels
     * const subLevels = await prisma.subLevel.findMany()
     * 
     * // Get first 10 SubLevels
     * const subLevels = await prisma.subLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubLevelFindManyArgs>(args?: SelectSubset<T, SubLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubLevel.
     * @param {SubLevelCreateArgs} args - Arguments to create a SubLevel.
     * @example
     * // Create one SubLevel
     * const SubLevel = await prisma.subLevel.create({
     *   data: {
     *     // ... data to create a SubLevel
     *   }
     * })
     * 
     */
    create<T extends SubLevelCreateArgs>(args: SelectSubset<T, SubLevelCreateArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubLevels.
     * @param {SubLevelCreateManyArgs} args - Arguments to create many SubLevels.
     * @example
     * // Create many SubLevels
     * const subLevel = await prisma.subLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubLevelCreateManyArgs>(args?: SelectSubset<T, SubLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubLevels and returns the data saved in the database.
     * @param {SubLevelCreateManyAndReturnArgs} args - Arguments to create many SubLevels.
     * @example
     * // Create many SubLevels
     * const subLevel = await prisma.subLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubLevels and only return the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, SubLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubLevel.
     * @param {SubLevelDeleteArgs} args - Arguments to delete one SubLevel.
     * @example
     * // Delete one SubLevel
     * const SubLevel = await prisma.subLevel.delete({
     *   where: {
     *     // ... filter to delete one SubLevel
     *   }
     * })
     * 
     */
    delete<T extends SubLevelDeleteArgs>(args: SelectSubset<T, SubLevelDeleteArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubLevel.
     * @param {SubLevelUpdateArgs} args - Arguments to update one SubLevel.
     * @example
     * // Update one SubLevel
     * const subLevel = await prisma.subLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubLevelUpdateArgs>(args: SelectSubset<T, SubLevelUpdateArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubLevels.
     * @param {SubLevelDeleteManyArgs} args - Arguments to filter SubLevels to delete.
     * @example
     * // Delete a few SubLevels
     * const { count } = await prisma.subLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubLevelDeleteManyArgs>(args?: SelectSubset<T, SubLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubLevels
     * const subLevel = await prisma.subLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubLevelUpdateManyArgs>(args: SelectSubset<T, SubLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubLevels and returns the data updated in the database.
     * @param {SubLevelUpdateManyAndReturnArgs} args - Arguments to update many SubLevels.
     * @example
     * // Update many SubLevels
     * const subLevel = await prisma.subLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubLevels and only return the `id`
     * const subLevelWithIdOnly = await prisma.subLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, SubLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubLevel.
     * @param {SubLevelUpsertArgs} args - Arguments to update or create a SubLevel.
     * @example
     * // Update or create a SubLevel
     * const subLevel = await prisma.subLevel.upsert({
     *   create: {
     *     // ... data to create a SubLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubLevel we want to update
     *   }
     * })
     */
    upsert<T extends SubLevelUpsertArgs>(args: SelectSubset<T, SubLevelUpsertArgs<ExtArgs>>): Prisma__SubLevelClient<$Result.GetResult<Prisma.$SubLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelCountArgs} args - Arguments to filter SubLevels to count.
     * @example
     * // Count the number of SubLevels
     * const count = await prisma.subLevel.count({
     *   where: {
     *     // ... the filter for the SubLevels we want to count
     *   }
     * })
    **/
    count<T extends SubLevelCountArgs>(
      args?: Subset<T, SubLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubLevelAggregateArgs>(args: Subset<T, SubLevelAggregateArgs>): Prisma.PrismaPromise<GetSubLevelAggregateType<T>>

    /**
     * Group by SubLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubLevelGroupByArgs['orderBy'] }
        : { orderBy?: SubLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubLevel model
   */
  readonly fields: SubLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubLevel model
   */
  interface SubLevelFieldRefs {
    readonly id: FieldRef<"SubLevel", 'String'>
    readonly inGameId: FieldRef<"SubLevel", 'String'>
    readonly zoneInGameId: FieldRef<"SubLevel", 'String'>
    readonly levelInGameId: FieldRef<"SubLevel", 'String'>
    readonly isUnlock: FieldRef<"SubLevel", 'Boolean'>
    readonly unlockedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly isComplete: FieldRef<"SubLevel", 'Boolean'>
    readonly completedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly createdAt: FieldRef<"SubLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"SubLevel", 'DateTime'>
    readonly userId: FieldRef<"SubLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubLevel findUnique
   */
  export type SubLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel findUniqueOrThrow
   */
  export type SubLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel findFirst
   */
  export type SubLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubLevels.
     */
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel findFirstOrThrow
   */
  export type SubLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevel to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubLevels.
     */
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel findMany
   */
  export type SubLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter, which SubLevels to fetch.
     */
    where?: SubLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubLevels to fetch.
     */
    orderBy?: SubLevelOrderByWithRelationInput | SubLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubLevels.
     */
    cursor?: SubLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubLevels.
     */
    skip?: number
    distinct?: SubLevelScalarFieldEnum | SubLevelScalarFieldEnum[]
  }

  /**
   * SubLevel create
   */
  export type SubLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a SubLevel.
     */
    data: XOR<SubLevelCreateInput, SubLevelUncheckedCreateInput>
  }

  /**
   * SubLevel createMany
   */
  export type SubLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubLevels.
     */
    data: SubLevelCreateManyInput | SubLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubLevel createManyAndReturn
   */
  export type SubLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * The data used to create many SubLevels.
     */
    data: SubLevelCreateManyInput | SubLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubLevel update
   */
  export type SubLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a SubLevel.
     */
    data: XOR<SubLevelUpdateInput, SubLevelUncheckedUpdateInput>
    /**
     * Choose, which SubLevel to update.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel updateMany
   */
  export type SubLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubLevels.
     */
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyInput>
    /**
     * Filter which SubLevels to update
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to update.
     */
    limit?: number
  }

  /**
   * SubLevel updateManyAndReturn
   */
  export type SubLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * The data used to update SubLevels.
     */
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyInput>
    /**
     * Filter which SubLevels to update
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubLevel upsert
   */
  export type SubLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the SubLevel to update in case it exists.
     */
    where: SubLevelWhereUniqueInput
    /**
     * In case the SubLevel found by the `where` argument doesn't exist, create a new SubLevel with this data.
     */
    create: XOR<SubLevelCreateInput, SubLevelUncheckedCreateInput>
    /**
     * In case the SubLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubLevelUpdateInput, SubLevelUncheckedUpdateInput>
  }

  /**
   * SubLevel delete
   */
  export type SubLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
    /**
     * Filter which SubLevel to delete.
     */
    where: SubLevelWhereUniqueInput
  }

  /**
   * SubLevel deleteMany
   */
  export type SubLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubLevels to delete
     */
    where?: SubLevelWhereInput
    /**
     * Limit how many SubLevels to delete.
     */
    limit?: number
  }

  /**
   * SubLevel without action
   */
  export type SubLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubLevel
     */
    select?: SubLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubLevel
     */
    omit?: SubLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubLevelInclude<ExtArgs> | null
  }


  /**
   * Model InnerLevel
   */

  export type AggregateInnerLevel = {
    _count: InnerLevelCountAggregateOutputType | null
    _avg: InnerLevelAvgAggregateOutputType | null
    _sum: InnerLevelSumAggregateOutputType | null
    _min: InnerLevelMinAggregateOutputType | null
    _max: InnerLevelMaxAggregateOutputType | null
  }

  export type InnerLevelAvgAggregateOutputType = {
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
  }

  export type InnerLevelSumAggregateOutputType = {
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
  }

  export type InnerLevelMinAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    levelInGameId: string | null
    subLevelInGameId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type InnerLevelMaxAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    levelInGameId: string | null
    subLevelInGameId: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    isComplete: boolean | null
    completedAt: Date | null
    correctAttempt: number | null
    playTime: number | null
    point: number | null
    played: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type InnerLevelCountAggregateOutputType = {
    id: number
    inGameId: number
    zoneInGameId: number
    levelInGameId: number
    subLevelInGameId: number
    isUnlock: number
    unlockedAt: number
    isComplete: number
    completedAt: number
    correctAttempt: number
    playTime: number
    point: number
    played: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type InnerLevelAvgAggregateInputType = {
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
  }

  export type InnerLevelSumAggregateInputType = {
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
  }

  export type InnerLevelMinAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    levelInGameId?: true
    subLevelInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type InnerLevelMaxAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    levelInGameId?: true
    subLevelInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type InnerLevelCountAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    levelInGameId?: true
    subLevelInGameId?: true
    isUnlock?: true
    unlockedAt?: true
    isComplete?: true
    completedAt?: true
    correctAttempt?: true
    playTime?: true
    point?: true
    played?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type InnerLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnerLevel to aggregate.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InnerLevels
    **/
    _count?: true | InnerLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InnerLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InnerLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InnerLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InnerLevelMaxAggregateInputType
  }

  export type GetInnerLevelAggregateType<T extends InnerLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateInnerLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInnerLevel[P]>
      : GetScalarType<T[P], AggregateInnerLevel[P]>
  }




  export type InnerLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InnerLevelWhereInput
    orderBy?: InnerLevelOrderByWithAggregationInput | InnerLevelOrderByWithAggregationInput[]
    by: InnerLevelScalarFieldEnum[] | InnerLevelScalarFieldEnum
    having?: InnerLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InnerLevelCountAggregateInputType | true
    _avg?: InnerLevelAvgAggregateInputType
    _sum?: InnerLevelSumAggregateInputType
    _min?: InnerLevelMinAggregateInputType
    _max?: InnerLevelMaxAggregateInputType
  }

  export type InnerLevelGroupByOutputType = {
    id: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock: boolean
    unlockedAt: Date | null
    isComplete: boolean
    completedAt: Date | null
    correctAttempt: number
    playTime: number
    point: number
    played: number
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: InnerLevelCountAggregateOutputType | null
    _avg: InnerLevelAvgAggregateOutputType | null
    _sum: InnerLevelSumAggregateOutputType | null
    _min: InnerLevelMinAggregateOutputType | null
    _max: InnerLevelMaxAggregateOutputType | null
  }

  type GetInnerLevelGroupByPayload<T extends InnerLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InnerLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InnerLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InnerLevelGroupByOutputType[P]>
            : GetScalarType<T[P], InnerLevelGroupByOutputType[P]>
        }
      >
    >


  export type InnerLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["innerLevel"]>

  export type InnerLevelSelectScalar = {
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    levelInGameId?: boolean
    subLevelInGameId?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    isComplete?: boolean
    completedAt?: boolean
    correctAttempt?: boolean
    playTime?: boolean
    point?: boolean
    played?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type InnerLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inGameId" | "zoneInGameId" | "levelInGameId" | "subLevelInGameId" | "isUnlock" | "unlockedAt" | "isComplete" | "completedAt" | "correctAttempt" | "playTime" | "point" | "played" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["innerLevel"]>
  export type InnerLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InnerLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InnerLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InnerLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InnerLevel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inGameId: string
      zoneInGameId: string
      levelInGameId: string
      subLevelInGameId: string
      isUnlock: boolean
      unlockedAt: Date | null
      isComplete: boolean
      completedAt: Date | null
      correctAttempt: number
      playTime: number
      point: number
      played: number
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["innerLevel"]>
    composites: {}
  }

  type InnerLevelGetPayload<S extends boolean | null | undefined | InnerLevelDefaultArgs> = $Result.GetResult<Prisma.$InnerLevelPayload, S>

  type InnerLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InnerLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InnerLevelCountAggregateInputType | true
    }

  export interface InnerLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InnerLevel'], meta: { name: 'InnerLevel' } }
    /**
     * Find zero or one InnerLevel that matches the filter.
     * @param {InnerLevelFindUniqueArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InnerLevelFindUniqueArgs>(args: SelectSubset<T, InnerLevelFindUniqueArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InnerLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InnerLevelFindUniqueOrThrowArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InnerLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, InnerLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InnerLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindFirstArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InnerLevelFindFirstArgs>(args?: SelectSubset<T, InnerLevelFindFirstArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InnerLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindFirstOrThrowArgs} args - Arguments to find a InnerLevel
     * @example
     * // Get one InnerLevel
     * const innerLevel = await prisma.innerLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InnerLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, InnerLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InnerLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InnerLevels
     * const innerLevels = await prisma.innerLevel.findMany()
     * 
     * // Get first 10 InnerLevels
     * const innerLevels = await prisma.innerLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InnerLevelFindManyArgs>(args?: SelectSubset<T, InnerLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InnerLevel.
     * @param {InnerLevelCreateArgs} args - Arguments to create a InnerLevel.
     * @example
     * // Create one InnerLevel
     * const InnerLevel = await prisma.innerLevel.create({
     *   data: {
     *     // ... data to create a InnerLevel
     *   }
     * })
     * 
     */
    create<T extends InnerLevelCreateArgs>(args: SelectSubset<T, InnerLevelCreateArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InnerLevels.
     * @param {InnerLevelCreateManyArgs} args - Arguments to create many InnerLevels.
     * @example
     * // Create many InnerLevels
     * const innerLevel = await prisma.innerLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InnerLevelCreateManyArgs>(args?: SelectSubset<T, InnerLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InnerLevels and returns the data saved in the database.
     * @param {InnerLevelCreateManyAndReturnArgs} args - Arguments to create many InnerLevels.
     * @example
     * // Create many InnerLevels
     * const innerLevel = await prisma.innerLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InnerLevels and only return the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InnerLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, InnerLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InnerLevel.
     * @param {InnerLevelDeleteArgs} args - Arguments to delete one InnerLevel.
     * @example
     * // Delete one InnerLevel
     * const InnerLevel = await prisma.innerLevel.delete({
     *   where: {
     *     // ... filter to delete one InnerLevel
     *   }
     * })
     * 
     */
    delete<T extends InnerLevelDeleteArgs>(args: SelectSubset<T, InnerLevelDeleteArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InnerLevel.
     * @param {InnerLevelUpdateArgs} args - Arguments to update one InnerLevel.
     * @example
     * // Update one InnerLevel
     * const innerLevel = await prisma.innerLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InnerLevelUpdateArgs>(args: SelectSubset<T, InnerLevelUpdateArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InnerLevels.
     * @param {InnerLevelDeleteManyArgs} args - Arguments to filter InnerLevels to delete.
     * @example
     * // Delete a few InnerLevels
     * const { count } = await prisma.innerLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InnerLevelDeleteManyArgs>(args?: SelectSubset<T, InnerLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnerLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InnerLevels
     * const innerLevel = await prisma.innerLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InnerLevelUpdateManyArgs>(args: SelectSubset<T, InnerLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnerLevels and returns the data updated in the database.
     * @param {InnerLevelUpdateManyAndReturnArgs} args - Arguments to update many InnerLevels.
     * @example
     * // Update many InnerLevels
     * const innerLevel = await prisma.innerLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InnerLevels and only return the `id`
     * const innerLevelWithIdOnly = await prisma.innerLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InnerLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, InnerLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InnerLevel.
     * @param {InnerLevelUpsertArgs} args - Arguments to update or create a InnerLevel.
     * @example
     * // Update or create a InnerLevel
     * const innerLevel = await prisma.innerLevel.upsert({
     *   create: {
     *     // ... data to create a InnerLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InnerLevel we want to update
     *   }
     * })
     */
    upsert<T extends InnerLevelUpsertArgs>(args: SelectSubset<T, InnerLevelUpsertArgs<ExtArgs>>): Prisma__InnerLevelClient<$Result.GetResult<Prisma.$InnerLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InnerLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelCountArgs} args - Arguments to filter InnerLevels to count.
     * @example
     * // Count the number of InnerLevels
     * const count = await prisma.innerLevel.count({
     *   where: {
     *     // ... the filter for the InnerLevels we want to count
     *   }
     * })
    **/
    count<T extends InnerLevelCountArgs>(
      args?: Subset<T, InnerLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InnerLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InnerLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InnerLevelAggregateArgs>(args: Subset<T, InnerLevelAggregateArgs>): Prisma.PrismaPromise<GetInnerLevelAggregateType<T>>

    /**
     * Group by InnerLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnerLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InnerLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InnerLevelGroupByArgs['orderBy'] }
        : { orderBy?: InnerLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InnerLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInnerLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InnerLevel model
   */
  readonly fields: InnerLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InnerLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InnerLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InnerLevel model
   */
  interface InnerLevelFieldRefs {
    readonly id: FieldRef<"InnerLevel", 'String'>
    readonly inGameId: FieldRef<"InnerLevel", 'String'>
    readonly zoneInGameId: FieldRef<"InnerLevel", 'String'>
    readonly levelInGameId: FieldRef<"InnerLevel", 'String'>
    readonly subLevelInGameId: FieldRef<"InnerLevel", 'String'>
    readonly isUnlock: FieldRef<"InnerLevel", 'Boolean'>
    readonly unlockedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly isComplete: FieldRef<"InnerLevel", 'Boolean'>
    readonly completedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly correctAttempt: FieldRef<"InnerLevel", 'Float'>
    readonly playTime: FieldRef<"InnerLevel", 'Int'>
    readonly point: FieldRef<"InnerLevel", 'Int'>
    readonly played: FieldRef<"InnerLevel", 'Int'>
    readonly createdAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"InnerLevel", 'DateTime'>
    readonly userId: FieldRef<"InnerLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InnerLevel findUnique
   */
  export type InnerLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel findUniqueOrThrow
   */
  export type InnerLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel findFirst
   */
  export type InnerLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnerLevels.
     */
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel findFirstOrThrow
   */
  export type InnerLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevel to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnerLevels.
     */
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel findMany
   */
  export type InnerLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter, which InnerLevels to fetch.
     */
    where?: InnerLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnerLevels to fetch.
     */
    orderBy?: InnerLevelOrderByWithRelationInput | InnerLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InnerLevels.
     */
    cursor?: InnerLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnerLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnerLevels.
     */
    skip?: number
    distinct?: InnerLevelScalarFieldEnum | InnerLevelScalarFieldEnum[]
  }

  /**
   * InnerLevel create
   */
  export type InnerLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a InnerLevel.
     */
    data: XOR<InnerLevelCreateInput, InnerLevelUncheckedCreateInput>
  }

  /**
   * InnerLevel createMany
   */
  export type InnerLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InnerLevels.
     */
    data: InnerLevelCreateManyInput | InnerLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InnerLevel createManyAndReturn
   */
  export type InnerLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * The data used to create many InnerLevels.
     */
    data: InnerLevelCreateManyInput | InnerLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InnerLevel update
   */
  export type InnerLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a InnerLevel.
     */
    data: XOR<InnerLevelUpdateInput, InnerLevelUncheckedUpdateInput>
    /**
     * Choose, which InnerLevel to update.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel updateMany
   */
  export type InnerLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InnerLevels.
     */
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyInput>
    /**
     * Filter which InnerLevels to update
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to update.
     */
    limit?: number
  }

  /**
   * InnerLevel updateManyAndReturn
   */
  export type InnerLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * The data used to update InnerLevels.
     */
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyInput>
    /**
     * Filter which InnerLevels to update
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InnerLevel upsert
   */
  export type InnerLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the InnerLevel to update in case it exists.
     */
    where: InnerLevelWhereUniqueInput
    /**
     * In case the InnerLevel found by the `where` argument doesn't exist, create a new InnerLevel with this data.
     */
    create: XOR<InnerLevelCreateInput, InnerLevelUncheckedCreateInput>
    /**
     * In case the InnerLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InnerLevelUpdateInput, InnerLevelUncheckedUpdateInput>
  }

  /**
   * InnerLevel delete
   */
  export type InnerLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
    /**
     * Filter which InnerLevel to delete.
     */
    where: InnerLevelWhereUniqueInput
  }

  /**
   * InnerLevel deleteMany
   */
  export type InnerLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnerLevels to delete
     */
    where?: InnerLevelWhereInput
    /**
     * Limit how many InnerLevels to delete.
     */
    limit?: number
  }

  /**
   * InnerLevel without action
   */
  export type InnerLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnerLevel
     */
    select?: InnerLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InnerLevel
     */
    omit?: InnerLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InnerLevelInclude<ExtArgs> | null
  }


  /**
   * Model Gempo
   */

  export type AggregateGempo = {
    _count: GempoCountAggregateOutputType | null
    _min: GempoMinAggregateOutputType | null
    _max: GempoMaxAggregateOutputType | null
  }

  export type GempoMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    inGameId: string | null
    zoneInGameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type GempoMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    inGameId: string | null
    zoneInGameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type GempoCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    inGameId: number
    zoneInGameId: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type GempoMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    inGameId?: true
    zoneInGameId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type GempoMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    inGameId?: true
    zoneInGameId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type GempoCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    inGameId?: true
    zoneInGameId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type GempoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gempo to aggregate.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gempos
    **/
    _count?: true | GempoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GempoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GempoMaxAggregateInputType
  }

  export type GetGempoAggregateType<T extends GempoAggregateArgs> = {
        [P in keyof T & keyof AggregateGempo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGempo[P]>
      : GetScalarType<T[P], AggregateGempo[P]>
  }




  export type GempoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoWhereInput
    orderBy?: GempoOrderByWithAggregationInput | GempoOrderByWithAggregationInput[]
    by: GempoScalarFieldEnum[] | GempoScalarFieldEnum
    having?: GempoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GempoCountAggregateInputType | true
    _min?: GempoMinAggregateInputType
    _max?: GempoMaxAggregateInputType
  }

  export type GempoGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    inGameId: string
    zoneInGameId: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: GempoCountAggregateOutputType | null
    _min: GempoMinAggregateOutputType | null
    _max: GempoMaxAggregateOutputType | null
  }

  type GetGempoGroupByPayload<T extends GempoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GempoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GempoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GempoGroupByOutputType[P]>
            : GetScalarType<T[P], GempoGroupByOutputType[P]>
        }
      >
    >


  export type GempoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempo"]>

  export type GempoSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type GempoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "inGameId" | "zoneInGameId" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["gempo"]>
  export type GempoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GempoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gempo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      inGameId: string
      zoneInGameId: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["gempo"]>
    composites: {}
  }

  type GempoGetPayload<S extends boolean | null | undefined | GempoDefaultArgs> = $Result.GetResult<Prisma.$GempoPayload, S>

  type GempoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GempoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GempoCountAggregateInputType | true
    }

  export interface GempoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gempo'], meta: { name: 'Gempo' } }
    /**
     * Find zero or one Gempo that matches the filter.
     * @param {GempoFindUniqueArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GempoFindUniqueArgs>(args: SelectSubset<T, GempoFindUniqueArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gempo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GempoFindUniqueOrThrowArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GempoFindUniqueOrThrowArgs>(args: SelectSubset<T, GempoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gempo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindFirstArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GempoFindFirstArgs>(args?: SelectSubset<T, GempoFindFirstArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gempo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindFirstOrThrowArgs} args - Arguments to find a Gempo
     * @example
     * // Get one Gempo
     * const gempo = await prisma.gempo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GempoFindFirstOrThrowArgs>(args?: SelectSubset<T, GempoFindFirstOrThrowArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gempos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gempos
     * const gempos = await prisma.gempo.findMany()
     * 
     * // Get first 10 Gempos
     * const gempos = await prisma.gempo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gempoWithIdOnly = await prisma.gempo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GempoFindManyArgs>(args?: SelectSubset<T, GempoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gempo.
     * @param {GempoCreateArgs} args - Arguments to create a Gempo.
     * @example
     * // Create one Gempo
     * const Gempo = await prisma.gempo.create({
     *   data: {
     *     // ... data to create a Gempo
     *   }
     * })
     * 
     */
    create<T extends GempoCreateArgs>(args: SelectSubset<T, GempoCreateArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gempos.
     * @param {GempoCreateManyArgs} args - Arguments to create many Gempos.
     * @example
     * // Create many Gempos
     * const gempo = await prisma.gempo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GempoCreateManyArgs>(args?: SelectSubset<T, GempoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gempos and returns the data saved in the database.
     * @param {GempoCreateManyAndReturnArgs} args - Arguments to create many Gempos.
     * @example
     * // Create many Gempos
     * const gempo = await prisma.gempo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gempos and only return the `id`
     * const gempoWithIdOnly = await prisma.gempo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GempoCreateManyAndReturnArgs>(args?: SelectSubset<T, GempoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gempo.
     * @param {GempoDeleteArgs} args - Arguments to delete one Gempo.
     * @example
     * // Delete one Gempo
     * const Gempo = await prisma.gempo.delete({
     *   where: {
     *     // ... filter to delete one Gempo
     *   }
     * })
     * 
     */
    delete<T extends GempoDeleteArgs>(args: SelectSubset<T, GempoDeleteArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gempo.
     * @param {GempoUpdateArgs} args - Arguments to update one Gempo.
     * @example
     * // Update one Gempo
     * const gempo = await prisma.gempo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GempoUpdateArgs>(args: SelectSubset<T, GempoUpdateArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gempos.
     * @param {GempoDeleteManyArgs} args - Arguments to filter Gempos to delete.
     * @example
     * // Delete a few Gempos
     * const { count } = await prisma.gempo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GempoDeleteManyArgs>(args?: SelectSubset<T, GempoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gempos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gempos
     * const gempo = await prisma.gempo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GempoUpdateManyArgs>(args: SelectSubset<T, GempoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gempos and returns the data updated in the database.
     * @param {GempoUpdateManyAndReturnArgs} args - Arguments to update many Gempos.
     * @example
     * // Update many Gempos
     * const gempo = await prisma.gempo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gempos and only return the `id`
     * const gempoWithIdOnly = await prisma.gempo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GempoUpdateManyAndReturnArgs>(args: SelectSubset<T, GempoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gempo.
     * @param {GempoUpsertArgs} args - Arguments to update or create a Gempo.
     * @example
     * // Update or create a Gempo
     * const gempo = await prisma.gempo.upsert({
     *   create: {
     *     // ... data to create a Gempo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gempo we want to update
     *   }
     * })
     */
    upsert<T extends GempoUpsertArgs>(args: SelectSubset<T, GempoUpsertArgs<ExtArgs>>): Prisma__GempoClient<$Result.GetResult<Prisma.$GempoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gempos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoCountArgs} args - Arguments to filter Gempos to count.
     * @example
     * // Count the number of Gempos
     * const count = await prisma.gempo.count({
     *   where: {
     *     // ... the filter for the Gempos we want to count
     *   }
     * })
    **/
    count<T extends GempoCountArgs>(
      args?: Subset<T, GempoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GempoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gempo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GempoAggregateArgs>(args: Subset<T, GempoAggregateArgs>): Prisma.PrismaPromise<GetGempoAggregateType<T>>

    /**
     * Group by Gempo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GempoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GempoGroupByArgs['orderBy'] }
        : { orderBy?: GempoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GempoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGempoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gempo model
   */
  readonly fields: GempoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gempo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GempoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gempo model
   */
  interface GempoFieldRefs {
    readonly id: FieldRef<"Gempo", 'String'>
    readonly isUnlock: FieldRef<"Gempo", 'Boolean'>
    readonly unlockedAt: FieldRef<"Gempo", 'DateTime'>
    readonly inGameId: FieldRef<"Gempo", 'String'>
    readonly zoneInGameId: FieldRef<"Gempo", 'String'>
    readonly createdAt: FieldRef<"Gempo", 'DateTime'>
    readonly updatedAt: FieldRef<"Gempo", 'DateTime'>
    readonly userId: FieldRef<"Gempo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Gempo findUnique
   */
  export type GempoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo findUniqueOrThrow
   */
  export type GempoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo findFirst
   */
  export type GempoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gempos.
     */
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo findFirstOrThrow
   */
  export type GempoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempo to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gempos.
     */
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo findMany
   */
  export type GempoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter, which Gempos to fetch.
     */
    where?: GempoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gempos to fetch.
     */
    orderBy?: GempoOrderByWithRelationInput | GempoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gempos.
     */
    cursor?: GempoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gempos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gempos.
     */
    skip?: number
    distinct?: GempoScalarFieldEnum | GempoScalarFieldEnum[]
  }

  /**
   * Gempo create
   */
  export type GempoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The data needed to create a Gempo.
     */
    data: XOR<GempoCreateInput, GempoUncheckedCreateInput>
  }

  /**
   * Gempo createMany
   */
  export type GempoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gempos.
     */
    data: GempoCreateManyInput | GempoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gempo createManyAndReturn
   */
  export type GempoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * The data used to create many Gempos.
     */
    data: GempoCreateManyInput | GempoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gempo update
   */
  export type GempoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The data needed to update a Gempo.
     */
    data: XOR<GempoUpdateInput, GempoUncheckedUpdateInput>
    /**
     * Choose, which Gempo to update.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo updateMany
   */
  export type GempoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gempos.
     */
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyInput>
    /**
     * Filter which Gempos to update
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to update.
     */
    limit?: number
  }

  /**
   * Gempo updateManyAndReturn
   */
  export type GempoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * The data used to update Gempos.
     */
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyInput>
    /**
     * Filter which Gempos to update
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gempo upsert
   */
  export type GempoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * The filter to search for the Gempo to update in case it exists.
     */
    where: GempoWhereUniqueInput
    /**
     * In case the Gempo found by the `where` argument doesn't exist, create a new Gempo with this data.
     */
    create: XOR<GempoCreateInput, GempoUncheckedCreateInput>
    /**
     * In case the Gempo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GempoUpdateInput, GempoUncheckedUpdateInput>
  }

  /**
   * Gempo delete
   */
  export type GempoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
    /**
     * Filter which Gempo to delete.
     */
    where: GempoWhereUniqueInput
  }

  /**
   * Gempo deleteMany
   */
  export type GempoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gempos to delete
     */
    where?: GempoWhereInput
    /**
     * Limit how many Gempos to delete.
     */
    limit?: number
  }

  /**
   * Gempo without action
   */
  export type GempoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gempo
     */
    select?: GempoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gempo
     */
    omit?: GempoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoInclude<ExtArgs> | null
  }


  /**
   * Model Championship
   */

  export type AggregateChampionship = {
    _count: ChampionshipCountAggregateOutputType | null
    _min: ChampionshipMinAggregateOutputType | null
    _max: ChampionshipMaxAggregateOutputType | null
  }

  export type ChampionshipMinAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    inGameId: string | null
    zoneInGameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ChampionshipMaxAggregateOutputType = {
    id: string | null
    isUnlock: boolean | null
    unlockedAt: Date | null
    inGameId: string | null
    zoneInGameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ChampionshipCountAggregateOutputType = {
    id: number
    isUnlock: number
    unlockedAt: number
    inGameId: number
    zoneInGameId: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ChampionshipMinAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    inGameId?: true
    zoneInGameId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ChampionshipMaxAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    inGameId?: true
    zoneInGameId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ChampionshipCountAggregateInputType = {
    id?: true
    isUnlock?: true
    unlockedAt?: true
    inGameId?: true
    zoneInGameId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ChampionshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Championship to aggregate.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Championships
    **/
    _count?: true | ChampionshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipMaxAggregateInputType
  }

  export type GetChampionshipAggregateType<T extends ChampionshipAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionship[P]>
      : GetScalarType<T[P], AggregateChampionship[P]>
  }




  export type ChampionshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipWhereInput
    orderBy?: ChampionshipOrderByWithAggregationInput | ChampionshipOrderByWithAggregationInput[]
    by: ChampionshipScalarFieldEnum[] | ChampionshipScalarFieldEnum
    having?: ChampionshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipCountAggregateInputType | true
    _min?: ChampionshipMinAggregateInputType
    _max?: ChampionshipMaxAggregateInputType
  }

  export type ChampionshipGroupByOutputType = {
    id: string
    isUnlock: boolean
    unlockedAt: Date | null
    inGameId: string
    zoneInGameId: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: ChampionshipCountAggregateOutputType | null
    _min: ChampionshipMinAggregateOutputType | null
    _max: ChampionshipMaxAggregateOutputType | null
  }

  type GetChampionshipGroupByPayload<T extends ChampionshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championship"]>

  export type ChampionshipSelectScalar = {
    id?: boolean
    isUnlock?: boolean
    unlockedAt?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ChampionshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUnlock" | "unlockedAt" | "inGameId" | "zoneInGameId" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["championship"]>
  export type ChampionshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChampionshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Championship"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUnlock: boolean
      unlockedAt: Date | null
      inGameId: string
      zoneInGameId: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["championship"]>
    composites: {}
  }

  type ChampionshipGetPayload<S extends boolean | null | undefined | ChampionshipDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipPayload, S>

  type ChampionshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipCountAggregateInputType | true
    }

  export interface ChampionshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Championship'], meta: { name: 'Championship' } }
    /**
     * Find zero or one Championship that matches the filter.
     * @param {ChampionshipFindUniqueArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipFindUniqueArgs>(args: SelectSubset<T, ChampionshipFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Championship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipFindUniqueOrThrowArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Championship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindFirstArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipFindFirstArgs>(args?: SelectSubset<T, ChampionshipFindFirstArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Championship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindFirstOrThrowArgs} args - Arguments to find a Championship
     * @example
     * // Get one Championship
     * const championship = await prisma.championship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Championships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Championships
     * const championships = await prisma.championship.findMany()
     * 
     * // Get first 10 Championships
     * const championships = await prisma.championship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipWithIdOnly = await prisma.championship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipFindManyArgs>(args?: SelectSubset<T, ChampionshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Championship.
     * @param {ChampionshipCreateArgs} args - Arguments to create a Championship.
     * @example
     * // Create one Championship
     * const Championship = await prisma.championship.create({
     *   data: {
     *     // ... data to create a Championship
     *   }
     * })
     * 
     */
    create<T extends ChampionshipCreateArgs>(args: SelectSubset<T, ChampionshipCreateArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Championships.
     * @param {ChampionshipCreateManyArgs} args - Arguments to create many Championships.
     * @example
     * // Create many Championships
     * const championship = await prisma.championship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipCreateManyArgs>(args?: SelectSubset<T, ChampionshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Championships and returns the data saved in the database.
     * @param {ChampionshipCreateManyAndReturnArgs} args - Arguments to create many Championships.
     * @example
     * // Create many Championships
     * const championship = await prisma.championship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Championships and only return the `id`
     * const championshipWithIdOnly = await prisma.championship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Championship.
     * @param {ChampionshipDeleteArgs} args - Arguments to delete one Championship.
     * @example
     * // Delete one Championship
     * const Championship = await prisma.championship.delete({
     *   where: {
     *     // ... filter to delete one Championship
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipDeleteArgs>(args: SelectSubset<T, ChampionshipDeleteArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Championship.
     * @param {ChampionshipUpdateArgs} args - Arguments to update one Championship.
     * @example
     * // Update one Championship
     * const championship = await prisma.championship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipUpdateArgs>(args: SelectSubset<T, ChampionshipUpdateArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Championships.
     * @param {ChampionshipDeleteManyArgs} args - Arguments to filter Championships to delete.
     * @example
     * // Delete a few Championships
     * const { count } = await prisma.championship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipDeleteManyArgs>(args?: SelectSubset<T, ChampionshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Championships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Championships
     * const championship = await prisma.championship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipUpdateManyArgs>(args: SelectSubset<T, ChampionshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Championships and returns the data updated in the database.
     * @param {ChampionshipUpdateManyAndReturnArgs} args - Arguments to update many Championships.
     * @example
     * // Update many Championships
     * const championship = await prisma.championship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Championships and only return the `id`
     * const championshipWithIdOnly = await prisma.championship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Championship.
     * @param {ChampionshipUpsertArgs} args - Arguments to update or create a Championship.
     * @example
     * // Update or create a Championship
     * const championship = await prisma.championship.upsert({
     *   create: {
     *     // ... data to create a Championship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Championship we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipUpsertArgs>(args: SelectSubset<T, ChampionshipUpsertArgs<ExtArgs>>): Prisma__ChampionshipClient<$Result.GetResult<Prisma.$ChampionshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Championships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipCountArgs} args - Arguments to filter Championships to count.
     * @example
     * // Count the number of Championships
     * const count = await prisma.championship.count({
     *   where: {
     *     // ... the filter for the Championships we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipCountArgs>(
      args?: Subset<T, ChampionshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Championship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipAggregateArgs>(args: Subset<T, ChampionshipAggregateArgs>): Prisma.PrismaPromise<GetChampionshipAggregateType<T>>

    /**
     * Group by Championship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Championship model
   */
  readonly fields: ChampionshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Championship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Championship model
   */
  interface ChampionshipFieldRefs {
    readonly id: FieldRef<"Championship", 'String'>
    readonly isUnlock: FieldRef<"Championship", 'Boolean'>
    readonly unlockedAt: FieldRef<"Championship", 'DateTime'>
    readonly inGameId: FieldRef<"Championship", 'String'>
    readonly zoneInGameId: FieldRef<"Championship", 'String'>
    readonly createdAt: FieldRef<"Championship", 'DateTime'>
    readonly updatedAt: FieldRef<"Championship", 'DateTime'>
    readonly userId: FieldRef<"Championship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Championship findUnique
   */
  export type ChampionshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship findUniqueOrThrow
   */
  export type ChampionshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship findFirst
   */
  export type ChampionshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Championships.
     */
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship findFirstOrThrow
   */
  export type ChampionshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championship to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Championships.
     */
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship findMany
   */
  export type ChampionshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter, which Championships to fetch.
     */
    where?: ChampionshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Championships to fetch.
     */
    orderBy?: ChampionshipOrderByWithRelationInput | ChampionshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Championships.
     */
    cursor?: ChampionshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Championships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Championships.
     */
    skip?: number
    distinct?: ChampionshipScalarFieldEnum | ChampionshipScalarFieldEnum[]
  }

  /**
   * Championship create
   */
  export type ChampionshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Championship.
     */
    data: XOR<ChampionshipCreateInput, ChampionshipUncheckedCreateInput>
  }

  /**
   * Championship createMany
   */
  export type ChampionshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Championships.
     */
    data: ChampionshipCreateManyInput | ChampionshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Championship createManyAndReturn
   */
  export type ChampionshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * The data used to create many Championships.
     */
    data: ChampionshipCreateManyInput | ChampionshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Championship update
   */
  export type ChampionshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Championship.
     */
    data: XOR<ChampionshipUpdateInput, ChampionshipUncheckedUpdateInput>
    /**
     * Choose, which Championship to update.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship updateMany
   */
  export type ChampionshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Championships.
     */
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyInput>
    /**
     * Filter which Championships to update
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to update.
     */
    limit?: number
  }

  /**
   * Championship updateManyAndReturn
   */
  export type ChampionshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * The data used to update Championships.
     */
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyInput>
    /**
     * Filter which Championships to update
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Championship upsert
   */
  export type ChampionshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Championship to update in case it exists.
     */
    where: ChampionshipWhereUniqueInput
    /**
     * In case the Championship found by the `where` argument doesn't exist, create a new Championship with this data.
     */
    create: XOR<ChampionshipCreateInput, ChampionshipUncheckedCreateInput>
    /**
     * In case the Championship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipUpdateInput, ChampionshipUncheckedUpdateInput>
  }

  /**
   * Championship delete
   */
  export type ChampionshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
    /**
     * Filter which Championship to delete.
     */
    where: ChampionshipWhereUniqueInput
  }

  /**
   * Championship deleteMany
   */
  export type ChampionshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Championships to delete
     */
    where?: ChampionshipWhereInput
    /**
     * Limit how many Championships to delete.
     */
    limit?: number
  }

  /**
   * Championship without action
   */
  export type ChampionshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Championship
     */
    select?: ChampionshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Championship
     */
    omit?: ChampionshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipInclude<ExtArgs> | null
  }


  /**
   * Model GempoRecord
   */

  export type AggregateGempoRecord = {
    _count: GempoRecordCountAggregateOutputType | null
    _avg: GempoRecordAvgAggregateOutputType | null
    _sum: GempoRecordSumAggregateOutputType | null
    _min: GempoRecordMinAggregateOutputType | null
    _max: GempoRecordMaxAggregateOutputType | null
  }

  export type GempoRecordAvgAggregateOutputType = {
    played: number | null
    point: number | null
  }

  export type GempoRecordSumAggregateOutputType = {
    played: number | null
    point: number | null
  }

  export type GempoRecordMinAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    gempoInGameId: string | null
    played: number | null
    point: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type GempoRecordMaxAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    gempoInGameId: string | null
    played: number | null
    point: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type GempoRecordCountAggregateOutputType = {
    id: number
    inGameId: number
    zoneInGameId: number
    gempoInGameId: number
    played: number
    point: number
    lastPlayedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type GempoRecordAvgAggregateInputType = {
    played?: true
    point?: true
  }

  export type GempoRecordSumAggregateInputType = {
    played?: true
    point?: true
  }

  export type GempoRecordMinAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    gempoInGameId?: true
    played?: true
    point?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type GempoRecordMaxAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    gempoInGameId?: true
    played?: true
    point?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type GempoRecordCountAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    gempoInGameId?: true
    played?: true
    point?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type GempoRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GempoRecord to aggregate.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GempoRecords
    **/
    _count?: true | GempoRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GempoRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GempoRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GempoRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GempoRecordMaxAggregateInputType
  }

  export type GetGempoRecordAggregateType<T extends GempoRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateGempoRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGempoRecord[P]>
      : GetScalarType<T[P], AggregateGempoRecord[P]>
  }




  export type GempoRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GempoRecordWhereInput
    orderBy?: GempoRecordOrderByWithAggregationInput | GempoRecordOrderByWithAggregationInput[]
    by: GempoRecordScalarFieldEnum[] | GempoRecordScalarFieldEnum
    having?: GempoRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GempoRecordCountAggregateInputType | true
    _avg?: GempoRecordAvgAggregateInputType
    _sum?: GempoRecordSumAggregateInputType
    _min?: GempoRecordMinAggregateInputType
    _max?: GempoRecordMaxAggregateInputType
  }

  export type GempoRecordGroupByOutputType = {
    id: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played: number
    point: number
    lastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: GempoRecordCountAggregateOutputType | null
    _avg: GempoRecordAvgAggregateOutputType | null
    _sum: GempoRecordSumAggregateOutputType | null
    _min: GempoRecordMinAggregateOutputType | null
    _max: GempoRecordMaxAggregateOutputType | null
  }

  type GetGempoRecordGroupByPayload<T extends GempoRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GempoRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GempoRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GempoRecordGroupByOutputType[P]>
            : GetScalarType<T[P], GempoRecordGroupByOutputType[P]>
        }
      >
    >


  export type GempoRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    gempoInGameId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    gempoInGameId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    gempoInGameId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gempoRecord"]>

  export type GempoRecordSelectScalar = {
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    gempoInGameId?: boolean
    played?: boolean
    point?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type GempoRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inGameId" | "zoneInGameId" | "gempoInGameId" | "played" | "point" | "lastPlayedAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["gempoRecord"]>
  export type GempoRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GempoRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GempoRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GempoRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inGameId: string
      zoneInGameId: string
      gempoInGameId: string
      played: number
      point: number
      lastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["gempoRecord"]>
    composites: {}
  }

  type GempoRecordGetPayload<S extends boolean | null | undefined | GempoRecordDefaultArgs> = $Result.GetResult<Prisma.$GempoRecordPayload, S>

  type GempoRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GempoRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GempoRecordCountAggregateInputType | true
    }

  export interface GempoRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GempoRecord'], meta: { name: 'GempoRecord' } }
    /**
     * Find zero or one GempoRecord that matches the filter.
     * @param {GempoRecordFindUniqueArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GempoRecordFindUniqueArgs>(args: SelectSubset<T, GempoRecordFindUniqueArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GempoRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GempoRecordFindUniqueOrThrowArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GempoRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, GempoRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GempoRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindFirstArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GempoRecordFindFirstArgs>(args?: SelectSubset<T, GempoRecordFindFirstArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GempoRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindFirstOrThrowArgs} args - Arguments to find a GempoRecord
     * @example
     * // Get one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GempoRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, GempoRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GempoRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GempoRecords
     * const gempoRecords = await prisma.gempoRecord.findMany()
     * 
     * // Get first 10 GempoRecords
     * const gempoRecords = await prisma.gempoRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GempoRecordFindManyArgs>(args?: SelectSubset<T, GempoRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GempoRecord.
     * @param {GempoRecordCreateArgs} args - Arguments to create a GempoRecord.
     * @example
     * // Create one GempoRecord
     * const GempoRecord = await prisma.gempoRecord.create({
     *   data: {
     *     // ... data to create a GempoRecord
     *   }
     * })
     * 
     */
    create<T extends GempoRecordCreateArgs>(args: SelectSubset<T, GempoRecordCreateArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GempoRecords.
     * @param {GempoRecordCreateManyArgs} args - Arguments to create many GempoRecords.
     * @example
     * // Create many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GempoRecordCreateManyArgs>(args?: SelectSubset<T, GempoRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GempoRecords and returns the data saved in the database.
     * @param {GempoRecordCreateManyAndReturnArgs} args - Arguments to create many GempoRecords.
     * @example
     * // Create many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GempoRecords and only return the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GempoRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, GempoRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GempoRecord.
     * @param {GempoRecordDeleteArgs} args - Arguments to delete one GempoRecord.
     * @example
     * // Delete one GempoRecord
     * const GempoRecord = await prisma.gempoRecord.delete({
     *   where: {
     *     // ... filter to delete one GempoRecord
     *   }
     * })
     * 
     */
    delete<T extends GempoRecordDeleteArgs>(args: SelectSubset<T, GempoRecordDeleteArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GempoRecord.
     * @param {GempoRecordUpdateArgs} args - Arguments to update one GempoRecord.
     * @example
     * // Update one GempoRecord
     * const gempoRecord = await prisma.gempoRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GempoRecordUpdateArgs>(args: SelectSubset<T, GempoRecordUpdateArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GempoRecords.
     * @param {GempoRecordDeleteManyArgs} args - Arguments to filter GempoRecords to delete.
     * @example
     * // Delete a few GempoRecords
     * const { count } = await prisma.gempoRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GempoRecordDeleteManyArgs>(args?: SelectSubset<T, GempoRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GempoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GempoRecordUpdateManyArgs>(args: SelectSubset<T, GempoRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GempoRecords and returns the data updated in the database.
     * @param {GempoRecordUpdateManyAndReturnArgs} args - Arguments to update many GempoRecords.
     * @example
     * // Update many GempoRecords
     * const gempoRecord = await prisma.gempoRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GempoRecords and only return the `id`
     * const gempoRecordWithIdOnly = await prisma.gempoRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GempoRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, GempoRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GempoRecord.
     * @param {GempoRecordUpsertArgs} args - Arguments to update or create a GempoRecord.
     * @example
     * // Update or create a GempoRecord
     * const gempoRecord = await prisma.gempoRecord.upsert({
     *   create: {
     *     // ... data to create a GempoRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GempoRecord we want to update
     *   }
     * })
     */
    upsert<T extends GempoRecordUpsertArgs>(args: SelectSubset<T, GempoRecordUpsertArgs<ExtArgs>>): Prisma__GempoRecordClient<$Result.GetResult<Prisma.$GempoRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GempoRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordCountArgs} args - Arguments to filter GempoRecords to count.
     * @example
     * // Count the number of GempoRecords
     * const count = await prisma.gempoRecord.count({
     *   where: {
     *     // ... the filter for the GempoRecords we want to count
     *   }
     * })
    **/
    count<T extends GempoRecordCountArgs>(
      args?: Subset<T, GempoRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GempoRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GempoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GempoRecordAggregateArgs>(args: Subset<T, GempoRecordAggregateArgs>): Prisma.PrismaPromise<GetGempoRecordAggregateType<T>>

    /**
     * Group by GempoRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GempoRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GempoRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GempoRecordGroupByArgs['orderBy'] }
        : { orderBy?: GempoRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GempoRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGempoRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GempoRecord model
   */
  readonly fields: GempoRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GempoRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GempoRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GempoRecord model
   */
  interface GempoRecordFieldRefs {
    readonly id: FieldRef<"GempoRecord", 'String'>
    readonly inGameId: FieldRef<"GempoRecord", 'String'>
    readonly zoneInGameId: FieldRef<"GempoRecord", 'String'>
    readonly gempoInGameId: FieldRef<"GempoRecord", 'String'>
    readonly played: FieldRef<"GempoRecord", 'Int'>
    readonly point: FieldRef<"GempoRecord", 'Int'>
    readonly lastPlayedAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly createdAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"GempoRecord", 'DateTime'>
    readonly userId: FieldRef<"GempoRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GempoRecord findUnique
   */
  export type GempoRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord findUniqueOrThrow
   */
  export type GempoRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord findFirst
   */
  export type GempoRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GempoRecords.
     */
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord findFirstOrThrow
   */
  export type GempoRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecord to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GempoRecords.
     */
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord findMany
   */
  export type GempoRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter, which GempoRecords to fetch.
     */
    where?: GempoRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GempoRecords to fetch.
     */
    orderBy?: GempoRecordOrderByWithRelationInput | GempoRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GempoRecords.
     */
    cursor?: GempoRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GempoRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GempoRecords.
     */
    skip?: number
    distinct?: GempoRecordScalarFieldEnum | GempoRecordScalarFieldEnum[]
  }

  /**
   * GempoRecord create
   */
  export type GempoRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a GempoRecord.
     */
    data: XOR<GempoRecordCreateInput, GempoRecordUncheckedCreateInput>
  }

  /**
   * GempoRecord createMany
   */
  export type GempoRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GempoRecords.
     */
    data: GempoRecordCreateManyInput | GempoRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GempoRecord createManyAndReturn
   */
  export type GempoRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * The data used to create many GempoRecords.
     */
    data: GempoRecordCreateManyInput | GempoRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GempoRecord update
   */
  export type GempoRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a GempoRecord.
     */
    data: XOR<GempoRecordUpdateInput, GempoRecordUncheckedUpdateInput>
    /**
     * Choose, which GempoRecord to update.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord updateMany
   */
  export type GempoRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GempoRecords.
     */
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyInput>
    /**
     * Filter which GempoRecords to update
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to update.
     */
    limit?: number
  }

  /**
   * GempoRecord updateManyAndReturn
   */
  export type GempoRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * The data used to update GempoRecords.
     */
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyInput>
    /**
     * Filter which GempoRecords to update
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GempoRecord upsert
   */
  export type GempoRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the GempoRecord to update in case it exists.
     */
    where: GempoRecordWhereUniqueInput
    /**
     * In case the GempoRecord found by the `where` argument doesn't exist, create a new GempoRecord with this data.
     */
    create: XOR<GempoRecordCreateInput, GempoRecordUncheckedCreateInput>
    /**
     * In case the GempoRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GempoRecordUpdateInput, GempoRecordUncheckedUpdateInput>
  }

  /**
   * GempoRecord delete
   */
  export type GempoRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
    /**
     * Filter which GempoRecord to delete.
     */
    where: GempoRecordWhereUniqueInput
  }

  /**
   * GempoRecord deleteMany
   */
  export type GempoRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GempoRecords to delete
     */
    where?: GempoRecordWhereInput
    /**
     * Limit how many GempoRecords to delete.
     */
    limit?: number
  }

  /**
   * GempoRecord without action
   */
  export type GempoRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GempoRecord
     */
    select?: GempoRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GempoRecord
     */
    omit?: GempoRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GempoRecordInclude<ExtArgs> | null
  }


  /**
   * Model ChampionshipRecord
   */

  export type AggregateChampionshipRecord = {
    _count: ChampionshipRecordCountAggregateOutputType | null
    _avg: ChampionshipRecordAvgAggregateOutputType | null
    _sum: ChampionshipRecordSumAggregateOutputType | null
    _min: ChampionshipRecordMinAggregateOutputType | null
    _max: ChampionshipRecordMaxAggregateOutputType | null
  }

  export type ChampionshipRecordAvgAggregateOutputType = {
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
  }

  export type ChampionshipRecordSumAggregateOutputType = {
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
  }

  export type ChampionshipRecordMinAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    championshipInGameId: string | null
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    teamLastPlayedAt: Date | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
    soloLastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ChampionshipRecordMaxAggregateOutputType = {
    id: string | null
    inGameId: string | null
    zoneInGameId: string | null
    championshipInGameId: string | null
    teamWin: number | null
    teamLose: number | null
    teamPlayed: number | null
    teamPoint: number | null
    teamLastPlayedAt: Date | null
    soloWin: number | null
    soloLose: number | null
    soloPlayed: number | null
    soloPoint: number | null
    soloLastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ChampionshipRecordCountAggregateOutputType = {
    id: number
    inGameId: number
    zoneInGameId: number
    championshipInGameId: number
    teamWin: number
    teamLose: number
    teamPlayed: number
    teamPoint: number
    teamLastPlayedAt: number
    soloWin: number
    soloLose: number
    soloPlayed: number
    soloPoint: number
    soloLastPlayedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ChampionshipRecordAvgAggregateInputType = {
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
  }

  export type ChampionshipRecordSumAggregateInputType = {
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
  }

  export type ChampionshipRecordMinAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    championshipInGameId?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ChampionshipRecordMaxAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    championshipInGameId?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ChampionshipRecordCountAggregateInputType = {
    id?: true
    inGameId?: true
    zoneInGameId?: true
    championshipInGameId?: true
    teamWin?: true
    teamLose?: true
    teamPlayed?: true
    teamPoint?: true
    teamLastPlayedAt?: true
    soloWin?: true
    soloLose?: true
    soloPlayed?: true
    soloPoint?: true
    soloLastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ChampionshipRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipRecord to aggregate.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChampionshipRecords
    **/
    _count?: true | ChampionshipRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChampionshipRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChampionshipRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChampionshipRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChampionshipRecordMaxAggregateInputType
  }

  export type GetChampionshipRecordAggregateType<T extends ChampionshipRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateChampionshipRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChampionshipRecord[P]>
      : GetScalarType<T[P], AggregateChampionshipRecord[P]>
  }




  export type ChampionshipRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChampionshipRecordWhereInput
    orderBy?: ChampionshipRecordOrderByWithAggregationInput | ChampionshipRecordOrderByWithAggregationInput[]
    by: ChampionshipRecordScalarFieldEnum[] | ChampionshipRecordScalarFieldEnum
    having?: ChampionshipRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChampionshipRecordCountAggregateInputType | true
    _avg?: ChampionshipRecordAvgAggregateInputType
    _sum?: ChampionshipRecordSumAggregateInputType
    _min?: ChampionshipRecordMinAggregateInputType
    _max?: ChampionshipRecordMaxAggregateInputType
  }

  export type ChampionshipRecordGroupByOutputType = {
    id: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin: number
    teamLose: number
    teamPlayed: number
    teamPoint: number
    teamLastPlayedAt: Date | null
    soloWin: number
    soloLose: number
    soloPlayed: number
    soloPoint: number
    soloLastPlayedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: ChampionshipRecordCountAggregateOutputType | null
    _avg: ChampionshipRecordAvgAggregateOutputType | null
    _sum: ChampionshipRecordSumAggregateOutputType | null
    _min: ChampionshipRecordMinAggregateOutputType | null
    _max: ChampionshipRecordMaxAggregateOutputType | null
  }

  type GetChampionshipRecordGroupByPayload<T extends ChampionshipRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChampionshipRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChampionshipRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChampionshipRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ChampionshipRecordGroupByOutputType[P]>
        }
      >
    >


  export type ChampionshipRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    championshipInGameId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    championshipInGameId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    championshipInGameId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["championshipRecord"]>

  export type ChampionshipRecordSelectScalar = {
    id?: boolean
    inGameId?: boolean
    zoneInGameId?: boolean
    championshipInGameId?: boolean
    teamWin?: boolean
    teamLose?: boolean
    teamPlayed?: boolean
    teamPoint?: boolean
    teamLastPlayedAt?: boolean
    soloWin?: boolean
    soloLose?: boolean
    soloPlayed?: boolean
    soloPoint?: boolean
    soloLastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ChampionshipRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inGameId" | "zoneInGameId" | "championshipInGameId" | "teamWin" | "teamLose" | "teamPlayed" | "teamPoint" | "teamLastPlayedAt" | "soloWin" | "soloLose" | "soloPlayed" | "soloPoint" | "soloLastPlayedAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["championshipRecord"]>
  export type ChampionshipRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChampionshipRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChampionshipRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChampionshipRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inGameId: string
      zoneInGameId: string
      championshipInGameId: string
      teamWin: number
      teamLose: number
      teamPlayed: number
      teamPoint: number
      teamLastPlayedAt: Date | null
      soloWin: number
      soloLose: number
      soloPlayed: number
      soloPoint: number
      soloLastPlayedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["championshipRecord"]>
    composites: {}
  }

  type ChampionshipRecordGetPayload<S extends boolean | null | undefined | ChampionshipRecordDefaultArgs> = $Result.GetResult<Prisma.$ChampionshipRecordPayload, S>

  type ChampionshipRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChampionshipRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChampionshipRecordCountAggregateInputType | true
    }

  export interface ChampionshipRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChampionshipRecord'], meta: { name: 'ChampionshipRecord' } }
    /**
     * Find zero or one ChampionshipRecord that matches the filter.
     * @param {ChampionshipRecordFindUniqueArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChampionshipRecordFindUniqueArgs>(args: SelectSubset<T, ChampionshipRecordFindUniqueArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChampionshipRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChampionshipRecordFindUniqueOrThrowArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChampionshipRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindFirstArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChampionshipRecordFindFirstArgs>(args?: SelectSubset<T, ChampionshipRecordFindFirstArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChampionshipRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindFirstOrThrowArgs} args - Arguments to find a ChampionshipRecord
     * @example
     * // Get one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChampionshipRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ChampionshipRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChampionshipRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChampionshipRecords
     * const championshipRecords = await prisma.championshipRecord.findMany()
     * 
     * // Get first 10 ChampionshipRecords
     * const championshipRecords = await prisma.championshipRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChampionshipRecordFindManyArgs>(args?: SelectSubset<T, ChampionshipRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChampionshipRecord.
     * @param {ChampionshipRecordCreateArgs} args - Arguments to create a ChampionshipRecord.
     * @example
     * // Create one ChampionshipRecord
     * const ChampionshipRecord = await prisma.championshipRecord.create({
     *   data: {
     *     // ... data to create a ChampionshipRecord
     *   }
     * })
     * 
     */
    create<T extends ChampionshipRecordCreateArgs>(args: SelectSubset<T, ChampionshipRecordCreateArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChampionshipRecords.
     * @param {ChampionshipRecordCreateManyArgs} args - Arguments to create many ChampionshipRecords.
     * @example
     * // Create many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChampionshipRecordCreateManyArgs>(args?: SelectSubset<T, ChampionshipRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChampionshipRecords and returns the data saved in the database.
     * @param {ChampionshipRecordCreateManyAndReturnArgs} args - Arguments to create many ChampionshipRecords.
     * @example
     * // Create many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChampionshipRecords and only return the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChampionshipRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ChampionshipRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChampionshipRecord.
     * @param {ChampionshipRecordDeleteArgs} args - Arguments to delete one ChampionshipRecord.
     * @example
     * // Delete one ChampionshipRecord
     * const ChampionshipRecord = await prisma.championshipRecord.delete({
     *   where: {
     *     // ... filter to delete one ChampionshipRecord
     *   }
     * })
     * 
     */
    delete<T extends ChampionshipRecordDeleteArgs>(args: SelectSubset<T, ChampionshipRecordDeleteArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChampionshipRecord.
     * @param {ChampionshipRecordUpdateArgs} args - Arguments to update one ChampionshipRecord.
     * @example
     * // Update one ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChampionshipRecordUpdateArgs>(args: SelectSubset<T, ChampionshipRecordUpdateArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChampionshipRecords.
     * @param {ChampionshipRecordDeleteManyArgs} args - Arguments to filter ChampionshipRecords to delete.
     * @example
     * // Delete a few ChampionshipRecords
     * const { count } = await prisma.championshipRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChampionshipRecordDeleteManyArgs>(args?: SelectSubset<T, ChampionshipRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChampionshipRecordUpdateManyArgs>(args: SelectSubset<T, ChampionshipRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChampionshipRecords and returns the data updated in the database.
     * @param {ChampionshipRecordUpdateManyAndReturnArgs} args - Arguments to update many ChampionshipRecords.
     * @example
     * // Update many ChampionshipRecords
     * const championshipRecord = await prisma.championshipRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChampionshipRecords and only return the `id`
     * const championshipRecordWithIdOnly = await prisma.championshipRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChampionshipRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChampionshipRecord.
     * @param {ChampionshipRecordUpsertArgs} args - Arguments to update or create a ChampionshipRecord.
     * @example
     * // Update or create a ChampionshipRecord
     * const championshipRecord = await prisma.championshipRecord.upsert({
     *   create: {
     *     // ... data to create a ChampionshipRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChampionshipRecord we want to update
     *   }
     * })
     */
    upsert<T extends ChampionshipRecordUpsertArgs>(args: SelectSubset<T, ChampionshipRecordUpsertArgs<ExtArgs>>): Prisma__ChampionshipRecordClient<$Result.GetResult<Prisma.$ChampionshipRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChampionshipRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordCountArgs} args - Arguments to filter ChampionshipRecords to count.
     * @example
     * // Count the number of ChampionshipRecords
     * const count = await prisma.championshipRecord.count({
     *   where: {
     *     // ... the filter for the ChampionshipRecords we want to count
     *   }
     * })
    **/
    count<T extends ChampionshipRecordCountArgs>(
      args?: Subset<T, ChampionshipRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChampionshipRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChampionshipRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChampionshipRecordAggregateArgs>(args: Subset<T, ChampionshipRecordAggregateArgs>): Prisma.PrismaPromise<GetChampionshipRecordAggregateType<T>>

    /**
     * Group by ChampionshipRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChampionshipRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChampionshipRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChampionshipRecordGroupByArgs['orderBy'] }
        : { orderBy?: ChampionshipRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChampionshipRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChampionshipRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChampionshipRecord model
   */
  readonly fields: ChampionshipRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChampionshipRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChampionshipRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChampionshipRecord model
   */
  interface ChampionshipRecordFieldRefs {
    readonly id: FieldRef<"ChampionshipRecord", 'String'>
    readonly inGameId: FieldRef<"ChampionshipRecord", 'String'>
    readonly zoneInGameId: FieldRef<"ChampionshipRecord", 'String'>
    readonly championshipInGameId: FieldRef<"ChampionshipRecord", 'String'>
    readonly teamWin: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamLose: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamPlayed: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamPoint: FieldRef<"ChampionshipRecord", 'Int'>
    readonly teamLastPlayedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly soloWin: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloLose: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloPlayed: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloPoint: FieldRef<"ChampionshipRecord", 'Int'>
    readonly soloLastPlayedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"ChampionshipRecord", 'DateTime'>
    readonly userId: FieldRef<"ChampionshipRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChampionshipRecord findUnique
   */
  export type ChampionshipRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord findUniqueOrThrow
   */
  export type ChampionshipRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord findFirst
   */
  export type ChampionshipRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipRecords.
     */
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord findFirstOrThrow
   */
  export type ChampionshipRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecord to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChampionshipRecords.
     */
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord findMany
   */
  export type ChampionshipRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter, which ChampionshipRecords to fetch.
     */
    where?: ChampionshipRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChampionshipRecords to fetch.
     */
    orderBy?: ChampionshipRecordOrderByWithRelationInput | ChampionshipRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChampionshipRecords.
     */
    cursor?: ChampionshipRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChampionshipRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChampionshipRecords.
     */
    skip?: number
    distinct?: ChampionshipRecordScalarFieldEnum | ChampionshipRecordScalarFieldEnum[]
  }

  /**
   * ChampionshipRecord create
   */
  export type ChampionshipRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ChampionshipRecord.
     */
    data: XOR<ChampionshipRecordCreateInput, ChampionshipRecordUncheckedCreateInput>
  }

  /**
   * ChampionshipRecord createMany
   */
  export type ChampionshipRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChampionshipRecords.
     */
    data: ChampionshipRecordCreateManyInput | ChampionshipRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChampionshipRecord createManyAndReturn
   */
  export type ChampionshipRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ChampionshipRecords.
     */
    data: ChampionshipRecordCreateManyInput | ChampionshipRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChampionshipRecord update
   */
  export type ChampionshipRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ChampionshipRecord.
     */
    data: XOR<ChampionshipRecordUpdateInput, ChampionshipRecordUncheckedUpdateInput>
    /**
     * Choose, which ChampionshipRecord to update.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord updateMany
   */
  export type ChampionshipRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChampionshipRecords.
     */
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipRecords to update
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to update.
     */
    limit?: number
  }

  /**
   * ChampionshipRecord updateManyAndReturn
   */
  export type ChampionshipRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * The data used to update ChampionshipRecords.
     */
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyInput>
    /**
     * Filter which ChampionshipRecords to update
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChampionshipRecord upsert
   */
  export type ChampionshipRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ChampionshipRecord to update in case it exists.
     */
    where: ChampionshipRecordWhereUniqueInput
    /**
     * In case the ChampionshipRecord found by the `where` argument doesn't exist, create a new ChampionshipRecord with this data.
     */
    create: XOR<ChampionshipRecordCreateInput, ChampionshipRecordUncheckedCreateInput>
    /**
     * In case the ChampionshipRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChampionshipRecordUpdateInput, ChampionshipRecordUncheckedUpdateInput>
  }

  /**
   * ChampionshipRecord delete
   */
  export type ChampionshipRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
    /**
     * Filter which ChampionshipRecord to delete.
     */
    where: ChampionshipRecordWhereUniqueInput
  }

  /**
   * ChampionshipRecord deleteMany
   */
  export type ChampionshipRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChampionshipRecords to delete
     */
    where?: ChampionshipRecordWhereInput
    /**
     * Limit how many ChampionshipRecords to delete.
     */
    limit?: number
  }

  /**
   * ChampionshipRecord without action
   */
  export type ChampionshipRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChampionshipRecord
     */
    select?: ChampionshipRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChampionshipRecord
     */
    omit?: ChampionshipRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChampionshipRecordInclude<ExtArgs> | null
  }


  /**
   * Model UserLogin
   */

  export type AggregateUserLogin = {
    _count: UserLoginCountAggregateOutputType | null
    _min: UserLoginMinAggregateOutputType | null
    _max: UserLoginMaxAggregateOutputType | null
  }

  export type UserLoginMinAggregateOutputType = {
    id: string | null
    userId: string | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type UserLoginMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    loginDate: Date | null
    logoutDate: Date | null
  }

  export type UserLoginCountAggregateOutputType = {
    id: number
    userId: number
    loginDate: number
    logoutDate: number
    _all: number
  }


  export type UserLoginMinAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
  }

  export type UserLoginMaxAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
  }

  export type UserLoginCountAggregateInputType = {
    id?: true
    userId?: true
    loginDate?: true
    logoutDate?: true
    _all?: true
  }

  export type UserLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogin to aggregate.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLogins
    **/
    _count?: true | UserLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLoginMaxAggregateInputType
  }

  export type GetUserLoginAggregateType<T extends UserLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLogin[P]>
      : GetScalarType<T[P], AggregateUserLogin[P]>
  }




  export type UserLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLoginWhereInput
    orderBy?: UserLoginOrderByWithAggregationInput | UserLoginOrderByWithAggregationInput[]
    by: UserLoginScalarFieldEnum[] | UserLoginScalarFieldEnum
    having?: UserLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLoginCountAggregateInputType | true
    _min?: UserLoginMinAggregateInputType
    _max?: UserLoginMaxAggregateInputType
  }

  export type UserLoginGroupByOutputType = {
    id: string
    userId: string
    loginDate: Date
    logoutDate: Date | null
    _count: UserLoginCountAggregateOutputType | null
    _min: UserLoginMinAggregateOutputType | null
    _max: UserLoginMaxAggregateOutputType | null
  }

  type GetUserLoginGroupByPayload<T extends UserLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLoginGroupByOutputType[P]>
            : GetScalarType<T[P], UserLoginGroupByOutputType[P]>
        }
      >
    >


  export type UserLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLogin"]>

  export type UserLoginSelectScalar = {
    id?: boolean
    userId?: boolean
    loginDate?: boolean
    logoutDate?: boolean
  }

  export type UserLoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "loginDate" | "logoutDate", ExtArgs["result"]["userLogin"]>
  export type UserLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserLoginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLogin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      loginDate: Date
      logoutDate: Date | null
    }, ExtArgs["result"]["userLogin"]>
    composites: {}
  }

  type UserLoginGetPayload<S extends boolean | null | undefined | UserLoginDefaultArgs> = $Result.GetResult<Prisma.$UserLoginPayload, S>

  type UserLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLoginCountAggregateInputType | true
    }

  export interface UserLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLogin'], meta: { name: 'UserLogin' } }
    /**
     * Find zero or one UserLogin that matches the filter.
     * @param {UserLoginFindUniqueArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLoginFindUniqueArgs>(args: SelectSubset<T, UserLoginFindUniqueArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLogin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLoginFindUniqueOrThrowArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindFirstArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLoginFindFirstArgs>(args?: SelectSubset<T, UserLoginFindFirstArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindFirstOrThrowArgs} args - Arguments to find a UserLogin
     * @example
     * // Get one UserLogin
     * const userLogin = await prisma.userLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLogins
     * const userLogins = await prisma.userLogin.findMany()
     * 
     * // Get first 10 UserLogins
     * const userLogins = await prisma.userLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLoginFindManyArgs>(args?: SelectSubset<T, UserLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLogin.
     * @param {UserLoginCreateArgs} args - Arguments to create a UserLogin.
     * @example
     * // Create one UserLogin
     * const UserLogin = await prisma.userLogin.create({
     *   data: {
     *     // ... data to create a UserLogin
     *   }
     * })
     * 
     */
    create<T extends UserLoginCreateArgs>(args: SelectSubset<T, UserLoginCreateArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLogins.
     * @param {UserLoginCreateManyArgs} args - Arguments to create many UserLogins.
     * @example
     * // Create many UserLogins
     * const userLogin = await prisma.userLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLoginCreateManyArgs>(args?: SelectSubset<T, UserLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLogins and returns the data saved in the database.
     * @param {UserLoginCreateManyAndReturnArgs} args - Arguments to create many UserLogins.
     * @example
     * // Create many UserLogins
     * const userLogin = await prisma.userLogin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLogins and only return the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLoginCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLoginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLogin.
     * @param {UserLoginDeleteArgs} args - Arguments to delete one UserLogin.
     * @example
     * // Delete one UserLogin
     * const UserLogin = await prisma.userLogin.delete({
     *   where: {
     *     // ... filter to delete one UserLogin
     *   }
     * })
     * 
     */
    delete<T extends UserLoginDeleteArgs>(args: SelectSubset<T, UserLoginDeleteArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLogin.
     * @param {UserLoginUpdateArgs} args - Arguments to update one UserLogin.
     * @example
     * // Update one UserLogin
     * const userLogin = await prisma.userLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLoginUpdateArgs>(args: SelectSubset<T, UserLoginUpdateArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLogins.
     * @param {UserLoginDeleteManyArgs} args - Arguments to filter UserLogins to delete.
     * @example
     * // Delete a few UserLogins
     * const { count } = await prisma.userLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLoginDeleteManyArgs>(args?: SelectSubset<T, UserLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLogins
     * const userLogin = await prisma.userLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLoginUpdateManyArgs>(args: SelectSubset<T, UserLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLogins and returns the data updated in the database.
     * @param {UserLoginUpdateManyAndReturnArgs} args - Arguments to update many UserLogins.
     * @example
     * // Update many UserLogins
     * const userLogin = await prisma.userLogin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLogins and only return the `id`
     * const userLoginWithIdOnly = await prisma.userLogin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLoginUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLoginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLogin.
     * @param {UserLoginUpsertArgs} args - Arguments to update or create a UserLogin.
     * @example
     * // Update or create a UserLogin
     * const userLogin = await prisma.userLogin.upsert({
     *   create: {
     *     // ... data to create a UserLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLogin we want to update
     *   }
     * })
     */
    upsert<T extends UserLoginUpsertArgs>(args: SelectSubset<T, UserLoginUpsertArgs<ExtArgs>>): Prisma__UserLoginClient<$Result.GetResult<Prisma.$UserLoginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginCountArgs} args - Arguments to filter UserLogins to count.
     * @example
     * // Count the number of UserLogins
     * const count = await prisma.userLogin.count({
     *   where: {
     *     // ... the filter for the UserLogins we want to count
     *   }
     * })
    **/
    count<T extends UserLoginCountArgs>(
      args?: Subset<T, UserLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLoginAggregateArgs>(args: Subset<T, UserLoginAggregateArgs>): Prisma.PrismaPromise<GetUserLoginAggregateType<T>>

    /**
     * Group by UserLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLoginGroupByArgs['orderBy'] }
        : { orderBy?: UserLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLogin model
   */
  readonly fields: UserLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLogin model
   */
  interface UserLoginFieldRefs {
    readonly id: FieldRef<"UserLogin", 'String'>
    readonly userId: FieldRef<"UserLogin", 'String'>
    readonly loginDate: FieldRef<"UserLogin", 'DateTime'>
    readonly logoutDate: FieldRef<"UserLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLogin findUnique
   */
  export type UserLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin findUniqueOrThrow
   */
  export type UserLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin findFirst
   */
  export type UserLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogins.
     */
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin findFirstOrThrow
   */
  export type UserLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogin to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLogins.
     */
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin findMany
   */
  export type UserLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter, which UserLogins to fetch.
     */
    where?: UserLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLogins to fetch.
     */
    orderBy?: UserLoginOrderByWithRelationInput | UserLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLogins.
     */
    cursor?: UserLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLogins.
     */
    skip?: number
    distinct?: UserLoginScalarFieldEnum | UserLoginScalarFieldEnum[]
  }

  /**
   * UserLogin create
   */
  export type UserLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLogin.
     */
    data: XOR<UserLoginCreateInput, UserLoginUncheckedCreateInput>
  }

  /**
   * UserLogin createMany
   */
  export type UserLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLogins.
     */
    data: UserLoginCreateManyInput | UserLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLogin createManyAndReturn
   */
  export type UserLoginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * The data used to create many UserLogins.
     */
    data: UserLoginCreateManyInput | UserLoginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLogin update
   */
  export type UserLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLogin.
     */
    data: XOR<UserLoginUpdateInput, UserLoginUncheckedUpdateInput>
    /**
     * Choose, which UserLogin to update.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin updateMany
   */
  export type UserLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLogins.
     */
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyInput>
    /**
     * Filter which UserLogins to update
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to update.
     */
    limit?: number
  }

  /**
   * UserLogin updateManyAndReturn
   */
  export type UserLoginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * The data used to update UserLogins.
     */
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyInput>
    /**
     * Filter which UserLogins to update
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLogin upsert
   */
  export type UserLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLogin to update in case it exists.
     */
    where: UserLoginWhereUniqueInput
    /**
     * In case the UserLogin found by the `where` argument doesn't exist, create a new UserLogin with this data.
     */
    create: XOR<UserLoginCreateInput, UserLoginUncheckedCreateInput>
    /**
     * In case the UserLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLoginUpdateInput, UserLoginUncheckedUpdateInput>
  }

  /**
   * UserLogin delete
   */
  export type UserLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
    /**
     * Filter which UserLogin to delete.
     */
    where: UserLoginWhereUniqueInput
  }

  /**
   * UserLogin deleteMany
   */
  export type UserLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLogins to delete
     */
    where?: UserLoginWhereInput
    /**
     * Limit how many UserLogins to delete.
     */
    limit?: number
  }

  /**
   * UserLogin without action
   */
  export type UserLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLogin
     */
    select?: UserLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLogin
     */
    omit?: UserLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLoginInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    name: string | null
    suspend: boolean | null
    role: $Enums.Role | null
    provinceId: string | null
    cityId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    email: string | null
    name: string | null
    suspend: boolean | null
    role: $Enums.Role | null
    provinceId: string | null
    cityId: string | null
    schoolId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    authId: number
    email: number
    name: number
    suspend: number
    role: number
    provinceId: number
    cityId: number
    schoolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    suspend?: true
    role?: true
    provinceId?: true
    cityId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    suspend?: true
    role?: true
    provinceId?: true
    cityId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    authId?: true
    email?: true
    name?: true
    suspend?: true
    role?: true
    provinceId?: true
    cityId?: true
    schoolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    authId: string
    email: string
    name: string
    suspend: boolean
    role: $Enums.Role | null
    provinceId: string | null
    cityId: string | null
    schoolId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Admin$userArgs<ExtArgs>
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
    authority?: boolean | Admin$authorityArgs<ExtArgs>
    operationHistories?: boolean | Admin$operationHistoriesArgs<ExtArgs>
    operations?: boolean | Admin$operationsArgs<ExtArgs>
    banner?: boolean | Admin$bannerArgs<ExtArgs>
    transactions?: boolean | Admin$transactionsArgs<ExtArgs>
    transactionProcessed?: boolean | Admin$transactionProcessedArgs<ExtArgs>
    redeemCodes?: boolean | Admin$redeemCodesArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    authId?: boolean
    email?: boolean
    name?: boolean
    suspend?: boolean
    role?: boolean
    provinceId?: boolean
    cityId?: boolean
    schoolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "email" | "name" | "suspend" | "role" | "provinceId" | "cityId" | "schoolId" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Admin$userArgs<ExtArgs>
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
    authority?: boolean | Admin$authorityArgs<ExtArgs>
    operationHistories?: boolean | Admin$operationHistoriesArgs<ExtArgs>
    operations?: boolean | Admin$operationsArgs<ExtArgs>
    banner?: boolean | Admin$bannerArgs<ExtArgs>
    transactions?: boolean | Admin$transactionsArgs<ExtArgs>
    transactionProcessed?: boolean | Admin$transactionProcessedArgs<ExtArgs>
    redeemCodes?: boolean | Admin$redeemCodesArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    province?: boolean | Admin$provinceArgs<ExtArgs>
    city?: boolean | Admin$cityArgs<ExtArgs>
    school?: boolean | Admin$schoolArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      province: Prisma.$ProvincePayload<ExtArgs> | null
      city: Prisma.$CityPayload<ExtArgs> | null
      school: Prisma.$SchoolPayload<ExtArgs> | null
      authority: Prisma.$AdminAuthorityPayload<ExtArgs>[]
      operationHistories: Prisma.$AdminOperationHistoryPayload<ExtArgs>[]
      operations: Prisma.$AdminOperationHistoryPayload<ExtArgs>[]
      banner: Prisma.$BannerPayload<ExtArgs>[]
      transactions: Prisma.$AdminTransactionPayload<ExtArgs>[]
      transactionProcessed: Prisma.$AdminTransactionPayload<ExtArgs>[]
      redeemCodes: Prisma.$RedeemCodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      email: string
      name: string
      suspend: boolean
      role: $Enums.Role | null
      provinceId: string | null
      cityId: string | null
      schoolId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Admin$userArgs<ExtArgs> = {}>(args?: Subset<T, Admin$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    province<T extends Admin$provinceArgs<ExtArgs> = {}>(args?: Subset<T, Admin$provinceArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    city<T extends Admin$cityArgs<ExtArgs> = {}>(args?: Subset<T, Admin$cityArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    school<T extends Admin$schoolArgs<ExtArgs> = {}>(args?: Subset<T, Admin$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    authority<T extends Admin$authorityArgs<ExtArgs> = {}>(args?: Subset<T, Admin$authorityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operationHistories<T extends Admin$operationHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$operationHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operations<T extends Admin$operationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$operationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banner<T extends Admin$bannerArgs<ExtArgs> = {}>(args?: Subset<T, Admin$bannerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Admin$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionProcessed<T extends Admin$transactionProcessedArgs<ExtArgs> = {}>(args?: Subset<T, Admin$transactionProcessedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redeemCodes<T extends Admin$redeemCodesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$redeemCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly authId: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly suspend: FieldRef<"Admin", 'Boolean'>
    readonly role: FieldRef<"Admin", 'Role'>
    readonly provinceId: FieldRef<"Admin", 'String'>
    readonly cityId: FieldRef<"Admin", 'String'>
    readonly schoolId: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.user
   */
  export type Admin$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Admin.province
   */
  export type Admin$provinceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Province
     */
    select?: ProvinceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Province
     */
    omit?: ProvinceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinceInclude<ExtArgs> | null
    where?: ProvinceWhereInput
  }

  /**
   * Admin.city
   */
  export type Admin$cityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
  }

  /**
   * Admin.school
   */
  export type Admin$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * Admin.authority
   */
  export type Admin$authorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    cursor?: AdminAuthorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * Admin.operationHistories
   */
  export type Admin$operationHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    cursor?: AdminOperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * Admin.operations
   */
  export type Admin$operationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    cursor?: AdminOperationHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * Admin.banner
   */
  export type Admin$bannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    cursor?: BannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Admin.transactions
   */
  export type Admin$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    cursor?: AdminTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * Admin.transactionProcessed
   */
  export type Admin$transactionProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    cursor?: AdminTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * Admin.redeemCodes
   */
  export type Admin$redeemCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    where?: RedeemCodeWhereInput
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    cursor?: RedeemCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model AdminOperationHistory
   */

  export type AggregateAdminOperationHistory = {
    _count: AdminOperationHistoryCountAggregateOutputType | null
    _min: AdminOperationHistoryMinAggregateOutputType | null
    _max: AdminOperationHistoryMaxAggregateOutputType | null
  }

  export type AdminOperationHistoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    adminId: string | null
    opAdminId: string | null
    operation: $Enums.Operation | null
  }

  export type AdminOperationHistoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    adminId: string | null
    opAdminId: string | null
    operation: $Enums.Operation | null
  }

  export type AdminOperationHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    adminId: number
    opAdminId: number
    operation: number
    _all: number
  }


  export type AdminOperationHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
  }

  export type AdminOperationHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
  }

  export type AdminOperationHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    adminId?: true
    opAdminId?: true
    operation?: true
    _all?: true
  }

  export type AdminOperationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminOperationHistory to aggregate.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminOperationHistories
    **/
    _count?: true | AdminOperationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminOperationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminOperationHistoryMaxAggregateInputType
  }

  export type GetAdminOperationHistoryAggregateType<T extends AdminOperationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminOperationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminOperationHistory[P]>
      : GetScalarType<T[P], AggregateAdminOperationHistory[P]>
  }




  export type AdminOperationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminOperationHistoryWhereInput
    orderBy?: AdminOperationHistoryOrderByWithAggregationInput | AdminOperationHistoryOrderByWithAggregationInput[]
    by: AdminOperationHistoryScalarFieldEnum[] | AdminOperationHistoryScalarFieldEnum
    having?: AdminOperationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminOperationHistoryCountAggregateInputType | true
    _min?: AdminOperationHistoryMinAggregateInputType
    _max?: AdminOperationHistoryMaxAggregateInputType
  }

  export type AdminOperationHistoryGroupByOutputType = {
    id: string
    createdAt: Date
    adminId: string
    opAdminId: string
    operation: $Enums.Operation
    _count: AdminOperationHistoryCountAggregateOutputType | null
    _min: AdminOperationHistoryMinAggregateOutputType | null
    _max: AdminOperationHistoryMaxAggregateOutputType | null
  }

  type GetAdminOperationHistoryGroupByPayload<T extends AdminOperationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminOperationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminOperationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminOperationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AdminOperationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AdminOperationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminOperationHistory"]>

  export type AdminOperationHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    adminId?: boolean
    opAdminId?: boolean
    operation?: boolean
  }

  export type AdminOperationHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "adminId" | "opAdminId" | "operation", ExtArgs["result"]["adminOperationHistory"]>
  export type AdminOperationHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminOperationHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminOperationHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    opAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminOperationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminOperationHistory"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      opAdmin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      adminId: string
      opAdminId: string
      operation: $Enums.Operation
    }, ExtArgs["result"]["adminOperationHistory"]>
    composites: {}
  }

  type AdminOperationHistoryGetPayload<S extends boolean | null | undefined | AdminOperationHistoryDefaultArgs> = $Result.GetResult<Prisma.$AdminOperationHistoryPayload, S>

  type AdminOperationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminOperationHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminOperationHistoryCountAggregateInputType | true
    }

  export interface AdminOperationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminOperationHistory'], meta: { name: 'AdminOperationHistory' } }
    /**
     * Find zero or one AdminOperationHistory that matches the filter.
     * @param {AdminOperationHistoryFindUniqueArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminOperationHistoryFindUniqueArgs>(args: SelectSubset<T, AdminOperationHistoryFindUniqueArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminOperationHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminOperationHistoryFindUniqueOrThrowArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminOperationHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminOperationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindFirstArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminOperationHistoryFindFirstArgs>(args?: SelectSubset<T, AdminOperationHistoryFindFirstArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminOperationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindFirstOrThrowArgs} args - Arguments to find a AdminOperationHistory
     * @example
     * // Get one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminOperationHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminOperationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminOperationHistories
     * const adminOperationHistories = await prisma.adminOperationHistory.findMany()
     * 
     * // Get first 10 AdminOperationHistories
     * const adminOperationHistories = await prisma.adminOperationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminOperationHistoryFindManyArgs>(args?: SelectSubset<T, AdminOperationHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminOperationHistory.
     * @param {AdminOperationHistoryCreateArgs} args - Arguments to create a AdminOperationHistory.
     * @example
     * // Create one AdminOperationHistory
     * const AdminOperationHistory = await prisma.adminOperationHistory.create({
     *   data: {
     *     // ... data to create a AdminOperationHistory
     *   }
     * })
     * 
     */
    create<T extends AdminOperationHistoryCreateArgs>(args: SelectSubset<T, AdminOperationHistoryCreateArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminOperationHistories.
     * @param {AdminOperationHistoryCreateManyArgs} args - Arguments to create many AdminOperationHistories.
     * @example
     * // Create many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminOperationHistoryCreateManyArgs>(args?: SelectSubset<T, AdminOperationHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminOperationHistories and returns the data saved in the database.
     * @param {AdminOperationHistoryCreateManyAndReturnArgs} args - Arguments to create many AdminOperationHistories.
     * @example
     * // Create many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminOperationHistories and only return the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminOperationHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminOperationHistory.
     * @param {AdminOperationHistoryDeleteArgs} args - Arguments to delete one AdminOperationHistory.
     * @example
     * // Delete one AdminOperationHistory
     * const AdminOperationHistory = await prisma.adminOperationHistory.delete({
     *   where: {
     *     // ... filter to delete one AdminOperationHistory
     *   }
     * })
     * 
     */
    delete<T extends AdminOperationHistoryDeleteArgs>(args: SelectSubset<T, AdminOperationHistoryDeleteArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminOperationHistory.
     * @param {AdminOperationHistoryUpdateArgs} args - Arguments to update one AdminOperationHistory.
     * @example
     * // Update one AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminOperationHistoryUpdateArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminOperationHistories.
     * @param {AdminOperationHistoryDeleteManyArgs} args - Arguments to filter AdminOperationHistories to delete.
     * @example
     * // Delete a few AdminOperationHistories
     * const { count } = await prisma.adminOperationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminOperationHistoryDeleteManyArgs>(args?: SelectSubset<T, AdminOperationHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminOperationHistoryUpdateManyArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminOperationHistories and returns the data updated in the database.
     * @param {AdminOperationHistoryUpdateManyAndReturnArgs} args - Arguments to update many AdminOperationHistories.
     * @example
     * // Update many AdminOperationHistories
     * const adminOperationHistory = await prisma.adminOperationHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminOperationHistories and only return the `id`
     * const adminOperationHistoryWithIdOnly = await prisma.adminOperationHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminOperationHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminOperationHistory.
     * @param {AdminOperationHistoryUpsertArgs} args - Arguments to update or create a AdminOperationHistory.
     * @example
     * // Update or create a AdminOperationHistory
     * const adminOperationHistory = await prisma.adminOperationHistory.upsert({
     *   create: {
     *     // ... data to create a AdminOperationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminOperationHistory we want to update
     *   }
     * })
     */
    upsert<T extends AdminOperationHistoryUpsertArgs>(args: SelectSubset<T, AdminOperationHistoryUpsertArgs<ExtArgs>>): Prisma__AdminOperationHistoryClient<$Result.GetResult<Prisma.$AdminOperationHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminOperationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryCountArgs} args - Arguments to filter AdminOperationHistories to count.
     * @example
     * // Count the number of AdminOperationHistories
     * const count = await prisma.adminOperationHistory.count({
     *   where: {
     *     // ... the filter for the AdminOperationHistories we want to count
     *   }
     * })
    **/
    count<T extends AdminOperationHistoryCountArgs>(
      args?: Subset<T, AdminOperationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminOperationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminOperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminOperationHistoryAggregateArgs>(args: Subset<T, AdminOperationHistoryAggregateArgs>): Prisma.PrismaPromise<GetAdminOperationHistoryAggregateType<T>>

    /**
     * Group by AdminOperationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminOperationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminOperationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminOperationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AdminOperationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminOperationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminOperationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminOperationHistory model
   */
  readonly fields: AdminOperationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminOperationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminOperationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminOperationHistory model
   */
  interface AdminOperationHistoryFieldRefs {
    readonly id: FieldRef<"AdminOperationHistory", 'String'>
    readonly createdAt: FieldRef<"AdminOperationHistory", 'DateTime'>
    readonly adminId: FieldRef<"AdminOperationHistory", 'String'>
    readonly opAdminId: FieldRef<"AdminOperationHistory", 'String'>
    readonly operation: FieldRef<"AdminOperationHistory", 'Operation'>
  }
    

  // Custom InputTypes
  /**
   * AdminOperationHistory findUnique
   */
  export type AdminOperationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory findUniqueOrThrow
   */
  export type AdminOperationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory findFirst
   */
  export type AdminOperationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOperationHistories.
     */
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory findFirstOrThrow
   */
  export type AdminOperationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistory to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminOperationHistories.
     */
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory findMany
   */
  export type AdminOperationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AdminOperationHistories to fetch.
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminOperationHistories to fetch.
     */
    orderBy?: AdminOperationHistoryOrderByWithRelationInput | AdminOperationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminOperationHistories.
     */
    cursor?: AdminOperationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminOperationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminOperationHistories.
     */
    skip?: number
    distinct?: AdminOperationHistoryScalarFieldEnum | AdminOperationHistoryScalarFieldEnum[]
  }

  /**
   * AdminOperationHistory create
   */
  export type AdminOperationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminOperationHistory.
     */
    data: XOR<AdminOperationHistoryCreateInput, AdminOperationHistoryUncheckedCreateInput>
  }

  /**
   * AdminOperationHistory createMany
   */
  export type AdminOperationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminOperationHistories.
     */
    data: AdminOperationHistoryCreateManyInput | AdminOperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminOperationHistory createManyAndReturn
   */
  export type AdminOperationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many AdminOperationHistories.
     */
    data: AdminOperationHistoryCreateManyInput | AdminOperationHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminOperationHistory update
   */
  export type AdminOperationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminOperationHistory.
     */
    data: XOR<AdminOperationHistoryUpdateInput, AdminOperationHistoryUncheckedUpdateInput>
    /**
     * Choose, which AdminOperationHistory to update.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory updateMany
   */
  export type AdminOperationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminOperationHistories.
     */
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AdminOperationHistories to update
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to update.
     */
    limit?: number
  }

  /**
   * AdminOperationHistory updateManyAndReturn
   */
  export type AdminOperationHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * The data used to update AdminOperationHistories.
     */
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AdminOperationHistories to update
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminOperationHistory upsert
   */
  export type AdminOperationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminOperationHistory to update in case it exists.
     */
    where: AdminOperationHistoryWhereUniqueInput
    /**
     * In case the AdminOperationHistory found by the `where` argument doesn't exist, create a new AdminOperationHistory with this data.
     */
    create: XOR<AdminOperationHistoryCreateInput, AdminOperationHistoryUncheckedCreateInput>
    /**
     * In case the AdminOperationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminOperationHistoryUpdateInput, AdminOperationHistoryUncheckedUpdateInput>
  }

  /**
   * AdminOperationHistory delete
   */
  export type AdminOperationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
    /**
     * Filter which AdminOperationHistory to delete.
     */
    where: AdminOperationHistoryWhereUniqueInput
  }

  /**
   * AdminOperationHistory deleteMany
   */
  export type AdminOperationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminOperationHistories to delete
     */
    where?: AdminOperationHistoryWhereInput
    /**
     * Limit how many AdminOperationHistories to delete.
     */
    limit?: number
  }

  /**
   * AdminOperationHistory without action
   */
  export type AdminOperationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminOperationHistory
     */
    select?: AdminOperationHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminOperationHistory
     */
    omit?: AdminOperationHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminOperationHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuthority
   */

  export type AggregateAdminAuthority = {
    _count: AdminAuthorityCountAggregateOutputType | null
    _avg: AdminAuthorityAvgAggregateOutputType | null
    _sum: AdminAuthoritySumAggregateOutputType | null
    _min: AdminAuthorityMinAggregateOutputType | null
    _max: AdminAuthorityMaxAggregateOutputType | null
  }

  export type AdminAuthorityAvgAggregateOutputType = {
    grades: number | null
  }

  export type AdminAuthoritySumAggregateOutputType = {
    grades: number[]
  }

  export type AdminAuthorityMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    provinceId: string | null
  }

  export type AdminAuthorityMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    provinceId: string | null
  }

  export type AdminAuthorityCountAggregateOutputType = {
    id: number
    adminId: number
    provinceId: number
    grades: number
    _all: number
  }


  export type AdminAuthorityAvgAggregateInputType = {
    grades?: true
  }

  export type AdminAuthoritySumAggregateInputType = {
    grades?: true
  }

  export type AdminAuthorityMinAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
  }

  export type AdminAuthorityMaxAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
  }

  export type AdminAuthorityCountAggregateInputType = {
    id?: true
    adminId?: true
    provinceId?: true
    grades?: true
    _all?: true
  }

  export type AdminAuthorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuthority to aggregate.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuthorities
    **/
    _count?: true | AdminAuthorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAuthorityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminAuthoritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuthorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuthorityMaxAggregateInputType
  }

  export type GetAdminAuthorityAggregateType<T extends AdminAuthorityAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuthority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuthority[P]>
      : GetScalarType<T[P], AggregateAdminAuthority[P]>
  }




  export type AdminAuthorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuthorityWhereInput
    orderBy?: AdminAuthorityOrderByWithAggregationInput | AdminAuthorityOrderByWithAggregationInput[]
    by: AdminAuthorityScalarFieldEnum[] | AdminAuthorityScalarFieldEnum
    having?: AdminAuthorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuthorityCountAggregateInputType | true
    _avg?: AdminAuthorityAvgAggregateInputType
    _sum?: AdminAuthoritySumAggregateInputType
    _min?: AdminAuthorityMinAggregateInputType
    _max?: AdminAuthorityMaxAggregateInputType
  }

  export type AdminAuthorityGroupByOutputType = {
    id: string
    adminId: string
    provinceId: string
    grades: number[]
    _count: AdminAuthorityCountAggregateOutputType | null
    _avg: AdminAuthorityAvgAggregateOutputType | null
    _sum: AdminAuthoritySumAggregateOutputType | null
    _min: AdminAuthorityMinAggregateOutputType | null
    _max: AdminAuthorityMaxAggregateOutputType | null
  }

  type GetAdminAuthorityGroupByPayload<T extends AdminAuthorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuthorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuthorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuthorityGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuthorityGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuthoritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | AdminAuthority$citiesArgs<ExtArgs>
    schools?: boolean | AdminAuthority$schoolsArgs<ExtArgs>
    _count?: boolean | AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuthority"]>

  export type AdminAuthoritySelectScalar = {
    id?: boolean
    adminId?: boolean
    provinceId?: boolean
    grades?: boolean
  }

  export type AdminAuthorityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "provinceId" | "grades", ExtArgs["result"]["adminAuthority"]>
  export type AdminAuthorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | AdminAuthority$citiesArgs<ExtArgs>
    schools?: boolean | AdminAuthority$schoolsArgs<ExtArgs>
    _count?: boolean | AdminAuthorityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminAuthorityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type AdminAuthorityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $AdminAuthorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuthority"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
      schools: Prisma.$SchoolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      provinceId: string
      grades: number[]
    }, ExtArgs["result"]["adminAuthority"]>
    composites: {}
  }

  type AdminAuthorityGetPayload<S extends boolean | null | undefined | AdminAuthorityDefaultArgs> = $Result.GetResult<Prisma.$AdminAuthorityPayload, S>

  type AdminAuthorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuthorityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuthorityCountAggregateInputType | true
    }

  export interface AdminAuthorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuthority'], meta: { name: 'AdminAuthority' } }
    /**
     * Find zero or one AdminAuthority that matches the filter.
     * @param {AdminAuthorityFindUniqueArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuthorityFindUniqueArgs>(args: SelectSubset<T, AdminAuthorityFindUniqueArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuthority that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuthorityFindUniqueOrThrowArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuthorityFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuthorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuthority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindFirstArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuthorityFindFirstArgs>(args?: SelectSubset<T, AdminAuthorityFindFirstArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuthority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindFirstOrThrowArgs} args - Arguments to find a AdminAuthority
     * @example
     * // Get one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuthorityFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuthorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuthorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuthorities
     * const adminAuthorities = await prisma.adminAuthority.findMany()
     * 
     * // Get first 10 AdminAuthorities
     * const adminAuthorities = await prisma.adminAuthority.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuthorityFindManyArgs>(args?: SelectSubset<T, AdminAuthorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuthority.
     * @param {AdminAuthorityCreateArgs} args - Arguments to create a AdminAuthority.
     * @example
     * // Create one AdminAuthority
     * const AdminAuthority = await prisma.adminAuthority.create({
     *   data: {
     *     // ... data to create a AdminAuthority
     *   }
     * })
     * 
     */
    create<T extends AdminAuthorityCreateArgs>(args: SelectSubset<T, AdminAuthorityCreateArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuthorities.
     * @param {AdminAuthorityCreateManyArgs} args - Arguments to create many AdminAuthorities.
     * @example
     * // Create many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuthorityCreateManyArgs>(args?: SelectSubset<T, AdminAuthorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuthorities and returns the data saved in the database.
     * @param {AdminAuthorityCreateManyAndReturnArgs} args - Arguments to create many AdminAuthorities.
     * @example
     * // Create many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuthorities and only return the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuthorityCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuthorityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuthority.
     * @param {AdminAuthorityDeleteArgs} args - Arguments to delete one AdminAuthority.
     * @example
     * // Delete one AdminAuthority
     * const AdminAuthority = await prisma.adminAuthority.delete({
     *   where: {
     *     // ... filter to delete one AdminAuthority
     *   }
     * })
     * 
     */
    delete<T extends AdminAuthorityDeleteArgs>(args: SelectSubset<T, AdminAuthorityDeleteArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuthority.
     * @param {AdminAuthorityUpdateArgs} args - Arguments to update one AdminAuthority.
     * @example
     * // Update one AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuthorityUpdateArgs>(args: SelectSubset<T, AdminAuthorityUpdateArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuthorities.
     * @param {AdminAuthorityDeleteManyArgs} args - Arguments to filter AdminAuthorities to delete.
     * @example
     * // Delete a few AdminAuthorities
     * const { count } = await prisma.adminAuthority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuthorityDeleteManyArgs>(args?: SelectSubset<T, AdminAuthorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuthorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuthorityUpdateManyArgs>(args: SelectSubset<T, AdminAuthorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuthorities and returns the data updated in the database.
     * @param {AdminAuthorityUpdateManyAndReturnArgs} args - Arguments to update many AdminAuthorities.
     * @example
     * // Update many AdminAuthorities
     * const adminAuthority = await prisma.adminAuthority.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuthorities and only return the `id`
     * const adminAuthorityWithIdOnly = await prisma.adminAuthority.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuthorityUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuthorityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuthority.
     * @param {AdminAuthorityUpsertArgs} args - Arguments to update or create a AdminAuthority.
     * @example
     * // Update or create a AdminAuthority
     * const adminAuthority = await prisma.adminAuthority.upsert({
     *   create: {
     *     // ... data to create a AdminAuthority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuthority we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuthorityUpsertArgs>(args: SelectSubset<T, AdminAuthorityUpsertArgs<ExtArgs>>): Prisma__AdminAuthorityClient<$Result.GetResult<Prisma.$AdminAuthorityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuthorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityCountArgs} args - Arguments to filter AdminAuthorities to count.
     * @example
     * // Count the number of AdminAuthorities
     * const count = await prisma.adminAuthority.count({
     *   where: {
     *     // ... the filter for the AdminAuthorities we want to count
     *   }
     * })
    **/
    count<T extends AdminAuthorityCountArgs>(
      args?: Subset<T, AdminAuthorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuthorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuthority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuthorityAggregateArgs>(args: Subset<T, AdminAuthorityAggregateArgs>): Prisma.PrismaPromise<GetAdminAuthorityAggregateType<T>>

    /**
     * Group by AdminAuthority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuthorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuthorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuthorityGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuthorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuthorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuthorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuthority model
   */
  readonly fields: AdminAuthorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuthority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuthorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cities<T extends AdminAuthority$citiesArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schools<T extends AdminAuthority$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, AdminAuthority$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuthority model
   */
  interface AdminAuthorityFieldRefs {
    readonly id: FieldRef<"AdminAuthority", 'String'>
    readonly adminId: FieldRef<"AdminAuthority", 'String'>
    readonly provinceId: FieldRef<"AdminAuthority", 'String'>
    readonly grades: FieldRef<"AdminAuthority", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuthority findUnique
   */
  export type AdminAuthorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority findUniqueOrThrow
   */
  export type AdminAuthorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority findFirst
   */
  export type AdminAuthorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuthorities.
     */
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority findFirstOrThrow
   */
  export type AdminAuthorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthority to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuthorities.
     */
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority findMany
   */
  export type AdminAuthorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuthorities to fetch.
     */
    where?: AdminAuthorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuthorities to fetch.
     */
    orderBy?: AdminAuthorityOrderByWithRelationInput | AdminAuthorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuthorities.
     */
    cursor?: AdminAuthorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuthorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuthorities.
     */
    skip?: number
    distinct?: AdminAuthorityScalarFieldEnum | AdminAuthorityScalarFieldEnum[]
  }

  /**
   * AdminAuthority create
   */
  export type AdminAuthorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuthority.
     */
    data: XOR<AdminAuthorityCreateInput, AdminAuthorityUncheckedCreateInput>
  }

  /**
   * AdminAuthority createMany
   */
  export type AdminAuthorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuthorities.
     */
    data: AdminAuthorityCreateManyInput | AdminAuthorityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuthority createManyAndReturn
   */
  export type AdminAuthorityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuthorities.
     */
    data: AdminAuthorityCreateManyInput | AdminAuthorityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuthority update
   */
  export type AdminAuthorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuthority.
     */
    data: XOR<AdminAuthorityUpdateInput, AdminAuthorityUncheckedUpdateInput>
    /**
     * Choose, which AdminAuthority to update.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority updateMany
   */
  export type AdminAuthorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuthorities.
     */
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuthorities to update
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to update.
     */
    limit?: number
  }

  /**
   * AdminAuthority updateManyAndReturn
   */
  export type AdminAuthorityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuthorities.
     */
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuthorities to update
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuthority upsert
   */
  export type AdminAuthorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuthority to update in case it exists.
     */
    where: AdminAuthorityWhereUniqueInput
    /**
     * In case the AdminAuthority found by the `where` argument doesn't exist, create a new AdminAuthority with this data.
     */
    create: XOR<AdminAuthorityCreateInput, AdminAuthorityUncheckedCreateInput>
    /**
     * In case the AdminAuthority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuthorityUpdateInput, AdminAuthorityUncheckedUpdateInput>
  }

  /**
   * AdminAuthority delete
   */
  export type AdminAuthorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
    /**
     * Filter which AdminAuthority to delete.
     */
    where: AdminAuthorityWhereUniqueInput
  }

  /**
   * AdminAuthority deleteMany
   */
  export type AdminAuthorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuthorities to delete
     */
    where?: AdminAuthorityWhereInput
    /**
     * Limit how many AdminAuthorities to delete.
     */
    limit?: number
  }

  /**
   * AdminAuthority.cities
   */
  export type AdminAuthority$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * AdminAuthority.schools
   */
  export type AdminAuthority$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * AdminAuthority without action
   */
  export type AdminAuthorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuthority
     */
    select?: AdminAuthoritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuthority
     */
    omit?: AdminAuthorityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuthorityInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    thumbnailId: string | null
    thumbnail: string | null
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean | null
    adminId: string | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    thumbnailId: string | null
    thumbnail: string | null
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean | null
    adminId: string | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    thumbnailId: number
    thumbnail: number
    link: number
    startedAt: number
    endedAt: number
    isHide: number
    adminId: number
    _all: number
  }


  export type BannerMinAggregateInputType = {
    id?: true
    thumbnailId?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    adminId?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    thumbnailId?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    adminId?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    thumbnailId?: true
    thumbnail?: true
    link?: true
    startedAt?: true
    endedAt?: true
    isHide?: true
    adminId?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    thumbnailId: string
    thumbnail: string
    link: string | null
    startedAt: Date | null
    endedAt: Date | null
    isHide: boolean
    adminId: string
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
    visitors?: boolean | Banner$visitorsArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    bannerLocation?: boolean | Banner$bannerLocationArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    link?: boolean
    startedAt?: boolean
    endedAt?: boolean
    isHide?: boolean
    adminId?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "thumbnailId" | "thumbnail" | "link" | "startedAt" | "endedAt" | "isHide" | "adminId", ExtArgs["result"]["banner"]>
  export type BannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    visitors?: boolean | Banner$visitorsArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    bannerLocation?: boolean | Banner$bannerLocationArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type BannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {
      visitors: Prisma.$BannerVisitorPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>
      bannerLocation: Prisma.$BannerLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      thumbnailId: string
      thumbnail: string
      link: string | null
      startedAt: Date | null
      endedAt: Date | null
      isHide: boolean
      adminId: string
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {BannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners and returns the data updated in the database.
     * @param {BannerUpdateManyAndReturnArgs} args - Arguments to update many Banners.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    visitors<T extends Banner$visitorsArgs<ExtArgs> = {}>(args?: Subset<T, Banner$visitorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bannerLocation<T extends Banner$bannerLocationArgs<ExtArgs> = {}>(args?: Subset<T, Banner$bannerLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly thumbnailId: FieldRef<"Banner", 'String'>
    readonly thumbnail: FieldRef<"Banner", 'String'>
    readonly link: FieldRef<"Banner", 'String'>
    readonly startedAt: FieldRef<"Banner", 'DateTime'>
    readonly endedAt: FieldRef<"Banner", 'DateTime'>
    readonly isHide: FieldRef<"Banner", 'Boolean'>
    readonly adminId: FieldRef<"Banner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner createManyAndReturn
   */
  export type BannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner updateManyAndReturn
   */
  export type BannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner.visitors
   */
  export type Banner$visitorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    cursor?: BannerVisitorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * Banner.bannerLocation
   */
  export type Banner$bannerLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    cursor?: BannerLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
  }


  /**
   * Model BannerLocation
   */

  export type AggregateBannerLocation = {
    _count: BannerLocationCountAggregateOutputType | null
    _min: BannerLocationMinAggregateOutputType | null
    _max: BannerLocationMaxAggregateOutputType | null
  }

  export type BannerLocationMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    provinceId: string | null
  }

  export type BannerLocationMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    provinceId: string | null
  }

  export type BannerLocationCountAggregateOutputType = {
    id: number
    bannerId: number
    provinceId: number
    _all: number
  }


  export type BannerLocationMinAggregateInputType = {
    id?: true
    bannerId?: true
    provinceId?: true
  }

  export type BannerLocationMaxAggregateInputType = {
    id?: true
    bannerId?: true
    provinceId?: true
  }

  export type BannerLocationCountAggregateInputType = {
    id?: true
    bannerId?: true
    provinceId?: true
    _all?: true
  }

  export type BannerLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerLocation to aggregate.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerLocations
    **/
    _count?: true | BannerLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerLocationMaxAggregateInputType
  }

  export type GetBannerLocationAggregateType<T extends BannerLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerLocation[P]>
      : GetScalarType<T[P], AggregateBannerLocation[P]>
  }




  export type BannerLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerLocationWhereInput
    orderBy?: BannerLocationOrderByWithAggregationInput | BannerLocationOrderByWithAggregationInput[]
    by: BannerLocationScalarFieldEnum[] | BannerLocationScalarFieldEnum
    having?: BannerLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerLocationCountAggregateInputType | true
    _min?: BannerLocationMinAggregateInputType
    _max?: BannerLocationMaxAggregateInputType
  }

  export type BannerLocationGroupByOutputType = {
    id: string
    bannerId: string
    provinceId: string
    _count: BannerLocationCountAggregateOutputType | null
    _min: BannerLocationMinAggregateOutputType | null
    _max: BannerLocationMaxAggregateOutputType | null
  }

  type GetBannerLocationGroupByPayload<T extends BannerLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerLocationGroupByOutputType[P]>
            : GetScalarType<T[P], BannerLocationGroupByOutputType[P]>
        }
      >
    >


  export type BannerLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | BannerLocation$citiesArgs<ExtArgs>
    _count?: boolean | BannerLocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerLocation"]>

  export type BannerLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerLocation"]>

  export type BannerLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerLocation"]>

  export type BannerLocationSelectScalar = {
    id?: boolean
    bannerId?: boolean
    provinceId?: boolean
  }

  export type BannerLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "provinceId", ExtArgs["result"]["bannerLocation"]>
  export type BannerLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
    cities?: boolean | BannerLocation$citiesArgs<ExtArgs>
    _count?: boolean | BannerLocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BannerLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }
  export type BannerLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    province?: boolean | ProvinceDefaultArgs<ExtArgs>
  }

  export type $BannerLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerLocation"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
      province: Prisma.$ProvincePayload<ExtArgs>
      cities: Prisma.$CityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      provinceId: string
    }, ExtArgs["result"]["bannerLocation"]>
    composites: {}
  }

  type BannerLocationGetPayload<S extends boolean | null | undefined | BannerLocationDefaultArgs> = $Result.GetResult<Prisma.$BannerLocationPayload, S>

  type BannerLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerLocationCountAggregateInputType | true
    }

  export interface BannerLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerLocation'], meta: { name: 'BannerLocation' } }
    /**
     * Find zero or one BannerLocation that matches the filter.
     * @param {BannerLocationFindUniqueArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerLocationFindUniqueArgs>(args: SelectSubset<T, BannerLocationFindUniqueArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerLocationFindUniqueOrThrowArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationFindFirstArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerLocationFindFirstArgs>(args?: SelectSubset<T, BannerLocationFindFirstArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationFindFirstOrThrowArgs} args - Arguments to find a BannerLocation
     * @example
     * // Get one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerLocations
     * const bannerLocations = await prisma.bannerLocation.findMany()
     * 
     * // Get first 10 BannerLocations
     * const bannerLocations = await prisma.bannerLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerLocationWithIdOnly = await prisma.bannerLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerLocationFindManyArgs>(args?: SelectSubset<T, BannerLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerLocation.
     * @param {BannerLocationCreateArgs} args - Arguments to create a BannerLocation.
     * @example
     * // Create one BannerLocation
     * const BannerLocation = await prisma.bannerLocation.create({
     *   data: {
     *     // ... data to create a BannerLocation
     *   }
     * })
     * 
     */
    create<T extends BannerLocationCreateArgs>(args: SelectSubset<T, BannerLocationCreateArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerLocations.
     * @param {BannerLocationCreateManyArgs} args - Arguments to create many BannerLocations.
     * @example
     * // Create many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerLocationCreateManyArgs>(args?: SelectSubset<T, BannerLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BannerLocations and returns the data saved in the database.
     * @param {BannerLocationCreateManyAndReturnArgs} args - Arguments to create many BannerLocations.
     * @example
     * // Create many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BannerLocations and only return the `id`
     * const bannerLocationWithIdOnly = await prisma.bannerLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BannerLocation.
     * @param {BannerLocationDeleteArgs} args - Arguments to delete one BannerLocation.
     * @example
     * // Delete one BannerLocation
     * const BannerLocation = await prisma.bannerLocation.delete({
     *   where: {
     *     // ... filter to delete one BannerLocation
     *   }
     * })
     * 
     */
    delete<T extends BannerLocationDeleteArgs>(args: SelectSubset<T, BannerLocationDeleteArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerLocation.
     * @param {BannerLocationUpdateArgs} args - Arguments to update one BannerLocation.
     * @example
     * // Update one BannerLocation
     * const bannerLocation = await prisma.bannerLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerLocationUpdateArgs>(args: SelectSubset<T, BannerLocationUpdateArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerLocations.
     * @param {BannerLocationDeleteManyArgs} args - Arguments to filter BannerLocations to delete.
     * @example
     * // Delete a few BannerLocations
     * const { count } = await prisma.bannerLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerLocationDeleteManyArgs>(args?: SelectSubset<T, BannerLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerLocationUpdateManyArgs>(args: SelectSubset<T, BannerLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerLocations and returns the data updated in the database.
     * @param {BannerLocationUpdateManyAndReturnArgs} args - Arguments to update many BannerLocations.
     * @example
     * // Update many BannerLocations
     * const bannerLocation = await prisma.bannerLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BannerLocations and only return the `id`
     * const bannerLocationWithIdOnly = await prisma.bannerLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BannerLocation.
     * @param {BannerLocationUpsertArgs} args - Arguments to update or create a BannerLocation.
     * @example
     * // Update or create a BannerLocation
     * const bannerLocation = await prisma.bannerLocation.upsert({
     *   create: {
     *     // ... data to create a BannerLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerLocation we want to update
     *   }
     * })
     */
    upsert<T extends BannerLocationUpsertArgs>(args: SelectSubset<T, BannerLocationUpsertArgs<ExtArgs>>): Prisma__BannerLocationClient<$Result.GetResult<Prisma.$BannerLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationCountArgs} args - Arguments to filter BannerLocations to count.
     * @example
     * // Count the number of BannerLocations
     * const count = await prisma.bannerLocation.count({
     *   where: {
     *     // ... the filter for the BannerLocations we want to count
     *   }
     * })
    **/
    count<T extends BannerLocationCountArgs>(
      args?: Subset<T, BannerLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerLocationAggregateArgs>(args: Subset<T, BannerLocationAggregateArgs>): Prisma.PrismaPromise<GetBannerLocationAggregateType<T>>

    /**
     * Group by BannerLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerLocationGroupByArgs['orderBy'] }
        : { orderBy?: BannerLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerLocation model
   */
  readonly fields: BannerLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    province<T extends ProvinceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinceDefaultArgs<ExtArgs>>): Prisma__ProvinceClient<$Result.GetResult<Prisma.$ProvincePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cities<T extends BannerLocation$citiesArgs<ExtArgs> = {}>(args?: Subset<T, BannerLocation$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerLocation model
   */
  interface BannerLocationFieldRefs {
    readonly id: FieldRef<"BannerLocation", 'String'>
    readonly bannerId: FieldRef<"BannerLocation", 'String'>
    readonly provinceId: FieldRef<"BannerLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BannerLocation findUnique
   */
  export type BannerLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation findUniqueOrThrow
   */
  export type BannerLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation findFirst
   */
  export type BannerLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerLocations.
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerLocations.
     */
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * BannerLocation findFirstOrThrow
   */
  export type BannerLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocation to fetch.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerLocations.
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerLocations.
     */
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * BannerLocation findMany
   */
  export type BannerLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter, which BannerLocations to fetch.
     */
    where?: BannerLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerLocations to fetch.
     */
    orderBy?: BannerLocationOrderByWithRelationInput | BannerLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerLocations.
     */
    cursor?: BannerLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerLocations.
     */
    skip?: number
    distinct?: BannerLocationScalarFieldEnum | BannerLocationScalarFieldEnum[]
  }

  /**
   * BannerLocation create
   */
  export type BannerLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerLocation.
     */
    data: XOR<BannerLocationCreateInput, BannerLocationUncheckedCreateInput>
  }

  /**
   * BannerLocation createMany
   */
  export type BannerLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerLocations.
     */
    data: BannerLocationCreateManyInput | BannerLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerLocation createManyAndReturn
   */
  export type BannerLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * The data used to create many BannerLocations.
     */
    data: BannerLocationCreateManyInput | BannerLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerLocation update
   */
  export type BannerLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerLocation.
     */
    data: XOR<BannerLocationUpdateInput, BannerLocationUncheckedUpdateInput>
    /**
     * Choose, which BannerLocation to update.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation updateMany
   */
  export type BannerLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerLocations.
     */
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyInput>
    /**
     * Filter which BannerLocations to update
     */
    where?: BannerLocationWhereInput
    /**
     * Limit how many BannerLocations to update.
     */
    limit?: number
  }

  /**
   * BannerLocation updateManyAndReturn
   */
  export type BannerLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * The data used to update BannerLocations.
     */
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyInput>
    /**
     * Filter which BannerLocations to update
     */
    where?: BannerLocationWhereInput
    /**
     * Limit how many BannerLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerLocation upsert
   */
  export type BannerLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerLocation to update in case it exists.
     */
    where: BannerLocationWhereUniqueInput
    /**
     * In case the BannerLocation found by the `where` argument doesn't exist, create a new BannerLocation with this data.
     */
    create: XOR<BannerLocationCreateInput, BannerLocationUncheckedCreateInput>
    /**
     * In case the BannerLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerLocationUpdateInput, BannerLocationUncheckedUpdateInput>
  }

  /**
   * BannerLocation delete
   */
  export type BannerLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
    /**
     * Filter which BannerLocation to delete.
     */
    where: BannerLocationWhereUniqueInput
  }

  /**
   * BannerLocation deleteMany
   */
  export type BannerLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerLocations to delete
     */
    where?: BannerLocationWhereInput
    /**
     * Limit how many BannerLocations to delete.
     */
    limit?: number
  }

  /**
   * BannerLocation.cities
   */
  export type BannerLocation$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    where?: CityWhereInput
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    cursor?: CityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * BannerLocation without action
   */
  export type BannerLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerLocation
     */
    select?: BannerLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerLocation
     */
    omit?: BannerLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerLocationInclude<ExtArgs> | null
  }


  /**
   * Model BannerVisitor
   */

  export type AggregateBannerVisitor = {
    _count: BannerVisitorCountAggregateOutputType | null
    _avg: BannerVisitorAvgAggregateOutputType | null
    _sum: BannerVisitorSumAggregateOutputType | null
    _min: BannerVisitorMinAggregateOutputType | null
    _max: BannerVisitorMaxAggregateOutputType | null
  }

  export type BannerVisitorAvgAggregateOutputType = {
    traffic: number | null
  }

  export type BannerVisitorSumAggregateOutputType = {
    traffic: number | null
  }

  export type BannerVisitorMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    traffic: number | null
  }

  export type BannerVisitorMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    traffic: number | null
  }

  export type BannerVisitorCountAggregateOutputType = {
    id: number
    bannerId: number
    userId: number
    createdAt: number
    updatedAt: number
    traffic: number
    _all: number
  }


  export type BannerVisitorAvgAggregateInputType = {
    traffic?: true
  }

  export type BannerVisitorSumAggregateInputType = {
    traffic?: true
  }

  export type BannerVisitorMinAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
  }

  export type BannerVisitorMaxAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
  }

  export type BannerVisitorCountAggregateInputType = {
    id?: true
    bannerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    traffic?: true
    _all?: true
  }

  export type BannerVisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerVisitor to aggregate.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerVisitors
    **/
    _count?: true | BannerVisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerVisitorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerVisitorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerVisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerVisitorMaxAggregateInputType
  }

  export type GetBannerVisitorAggregateType<T extends BannerVisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerVisitor[P]>
      : GetScalarType<T[P], AggregateBannerVisitor[P]>
  }




  export type BannerVisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerVisitorWhereInput
    orderBy?: BannerVisitorOrderByWithAggregationInput | BannerVisitorOrderByWithAggregationInput[]
    by: BannerVisitorScalarFieldEnum[] | BannerVisitorScalarFieldEnum
    having?: BannerVisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerVisitorCountAggregateInputType | true
    _avg?: BannerVisitorAvgAggregateInputType
    _sum?: BannerVisitorSumAggregateInputType
    _min?: BannerVisitorMinAggregateInputType
    _max?: BannerVisitorMaxAggregateInputType
  }

  export type BannerVisitorGroupByOutputType = {
    id: string
    bannerId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    traffic: number
    _count: BannerVisitorCountAggregateOutputType | null
    _avg: BannerVisitorAvgAggregateOutputType | null
    _sum: BannerVisitorSumAggregateOutputType | null
    _min: BannerVisitorMinAggregateOutputType | null
    _max: BannerVisitorMaxAggregateOutputType | null
  }

  type GetBannerVisitorGroupByPayload<T extends BannerVisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerVisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerVisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerVisitorGroupByOutputType[P]>
            : GetScalarType<T[P], BannerVisitorGroupByOutputType[P]>
        }
      >
    >


  export type BannerVisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerVisitor"]>

  export type BannerVisitorSelectScalar = {
    id?: boolean
    bannerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    traffic?: boolean
  }

  export type BannerVisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "userId" | "createdAt" | "updatedAt" | "traffic", ExtArgs["result"]["bannerVisitor"]>
  export type BannerVisitorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BannerVisitorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BannerVisitorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BannerVisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerVisitor"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      userId: string
      createdAt: Date
      updatedAt: Date
      traffic: number
    }, ExtArgs["result"]["bannerVisitor"]>
    composites: {}
  }

  type BannerVisitorGetPayload<S extends boolean | null | undefined | BannerVisitorDefaultArgs> = $Result.GetResult<Prisma.$BannerVisitorPayload, S>

  type BannerVisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerVisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerVisitorCountAggregateInputType | true
    }

  export interface BannerVisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerVisitor'], meta: { name: 'BannerVisitor' } }
    /**
     * Find zero or one BannerVisitor that matches the filter.
     * @param {BannerVisitorFindUniqueArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerVisitorFindUniqueArgs>(args: SelectSubset<T, BannerVisitorFindUniqueArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerVisitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerVisitorFindUniqueOrThrowArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerVisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerVisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerVisitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindFirstArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerVisitorFindFirstArgs>(args?: SelectSubset<T, BannerVisitorFindFirstArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerVisitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindFirstOrThrowArgs} args - Arguments to find a BannerVisitor
     * @example
     * // Get one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerVisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerVisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerVisitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerVisitors
     * const bannerVisitors = await prisma.bannerVisitor.findMany()
     * 
     * // Get first 10 BannerVisitors
     * const bannerVisitors = await prisma.bannerVisitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerVisitorFindManyArgs>(args?: SelectSubset<T, BannerVisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerVisitor.
     * @param {BannerVisitorCreateArgs} args - Arguments to create a BannerVisitor.
     * @example
     * // Create one BannerVisitor
     * const BannerVisitor = await prisma.bannerVisitor.create({
     *   data: {
     *     // ... data to create a BannerVisitor
     *   }
     * })
     * 
     */
    create<T extends BannerVisitorCreateArgs>(args: SelectSubset<T, BannerVisitorCreateArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerVisitors.
     * @param {BannerVisitorCreateManyArgs} args - Arguments to create many BannerVisitors.
     * @example
     * // Create many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerVisitorCreateManyArgs>(args?: SelectSubset<T, BannerVisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BannerVisitors and returns the data saved in the database.
     * @param {BannerVisitorCreateManyAndReturnArgs} args - Arguments to create many BannerVisitors.
     * @example
     * // Create many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BannerVisitors and only return the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerVisitorCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerVisitorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BannerVisitor.
     * @param {BannerVisitorDeleteArgs} args - Arguments to delete one BannerVisitor.
     * @example
     * // Delete one BannerVisitor
     * const BannerVisitor = await prisma.bannerVisitor.delete({
     *   where: {
     *     // ... filter to delete one BannerVisitor
     *   }
     * })
     * 
     */
    delete<T extends BannerVisitorDeleteArgs>(args: SelectSubset<T, BannerVisitorDeleteArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerVisitor.
     * @param {BannerVisitorUpdateArgs} args - Arguments to update one BannerVisitor.
     * @example
     * // Update one BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerVisitorUpdateArgs>(args: SelectSubset<T, BannerVisitorUpdateArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerVisitors.
     * @param {BannerVisitorDeleteManyArgs} args - Arguments to filter BannerVisitors to delete.
     * @example
     * // Delete a few BannerVisitors
     * const { count } = await prisma.bannerVisitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerVisitorDeleteManyArgs>(args?: SelectSubset<T, BannerVisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerVisitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerVisitorUpdateManyArgs>(args: SelectSubset<T, BannerVisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerVisitors and returns the data updated in the database.
     * @param {BannerVisitorUpdateManyAndReturnArgs} args - Arguments to update many BannerVisitors.
     * @example
     * // Update many BannerVisitors
     * const bannerVisitor = await prisma.bannerVisitor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BannerVisitors and only return the `id`
     * const bannerVisitorWithIdOnly = await prisma.bannerVisitor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerVisitorUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerVisitorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BannerVisitor.
     * @param {BannerVisitorUpsertArgs} args - Arguments to update or create a BannerVisitor.
     * @example
     * // Update or create a BannerVisitor
     * const bannerVisitor = await prisma.bannerVisitor.upsert({
     *   create: {
     *     // ... data to create a BannerVisitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerVisitor we want to update
     *   }
     * })
     */
    upsert<T extends BannerVisitorUpsertArgs>(args: SelectSubset<T, BannerVisitorUpsertArgs<ExtArgs>>): Prisma__BannerVisitorClient<$Result.GetResult<Prisma.$BannerVisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerVisitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorCountArgs} args - Arguments to filter BannerVisitors to count.
     * @example
     * // Count the number of BannerVisitors
     * const count = await prisma.bannerVisitor.count({
     *   where: {
     *     // ... the filter for the BannerVisitors we want to count
     *   }
     * })
    **/
    count<T extends BannerVisitorCountArgs>(
      args?: Subset<T, BannerVisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerVisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerVisitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerVisitorAggregateArgs>(args: Subset<T, BannerVisitorAggregateArgs>): Prisma.PrismaPromise<GetBannerVisitorAggregateType<T>>

    /**
     * Group by BannerVisitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerVisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerVisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerVisitorGroupByArgs['orderBy'] }
        : { orderBy?: BannerVisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerVisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerVisitor model
   */
  readonly fields: BannerVisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerVisitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerVisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerVisitor model
   */
  interface BannerVisitorFieldRefs {
    readonly id: FieldRef<"BannerVisitor", 'String'>
    readonly bannerId: FieldRef<"BannerVisitor", 'String'>
    readonly userId: FieldRef<"BannerVisitor", 'String'>
    readonly createdAt: FieldRef<"BannerVisitor", 'DateTime'>
    readonly updatedAt: FieldRef<"BannerVisitor", 'DateTime'>
    readonly traffic: FieldRef<"BannerVisitor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BannerVisitor findUnique
   */
  export type BannerVisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor findUniqueOrThrow
   */
  export type BannerVisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor findFirst
   */
  export type BannerVisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerVisitors.
     */
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor findFirstOrThrow
   */
  export type BannerVisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitor to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerVisitors.
     */
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor findMany
   */
  export type BannerVisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter, which BannerVisitors to fetch.
     */
    where?: BannerVisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerVisitors to fetch.
     */
    orderBy?: BannerVisitorOrderByWithRelationInput | BannerVisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerVisitors.
     */
    cursor?: BannerVisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerVisitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerVisitors.
     */
    skip?: number
    distinct?: BannerVisitorScalarFieldEnum | BannerVisitorScalarFieldEnum[]
  }

  /**
   * BannerVisitor create
   */
  export type BannerVisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerVisitor.
     */
    data: XOR<BannerVisitorCreateInput, BannerVisitorUncheckedCreateInput>
  }

  /**
   * BannerVisitor createMany
   */
  export type BannerVisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerVisitors.
     */
    data: BannerVisitorCreateManyInput | BannerVisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerVisitor createManyAndReturn
   */
  export type BannerVisitorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * The data used to create many BannerVisitors.
     */
    data: BannerVisitorCreateManyInput | BannerVisitorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerVisitor update
   */
  export type BannerVisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerVisitor.
     */
    data: XOR<BannerVisitorUpdateInput, BannerVisitorUncheckedUpdateInput>
    /**
     * Choose, which BannerVisitor to update.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor updateMany
   */
  export type BannerVisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerVisitors.
     */
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyInput>
    /**
     * Filter which BannerVisitors to update
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to update.
     */
    limit?: number
  }

  /**
   * BannerVisitor updateManyAndReturn
   */
  export type BannerVisitorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * The data used to update BannerVisitors.
     */
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyInput>
    /**
     * Filter which BannerVisitors to update
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BannerVisitor upsert
   */
  export type BannerVisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerVisitor to update in case it exists.
     */
    where: BannerVisitorWhereUniqueInput
    /**
     * In case the BannerVisitor found by the `where` argument doesn't exist, create a new BannerVisitor with this data.
     */
    create: XOR<BannerVisitorCreateInput, BannerVisitorUncheckedCreateInput>
    /**
     * In case the BannerVisitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerVisitorUpdateInput, BannerVisitorUncheckedUpdateInput>
  }

  /**
   * BannerVisitor delete
   */
  export type BannerVisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
    /**
     * Filter which BannerVisitor to delete.
     */
    where: BannerVisitorWhereUniqueInput
  }

  /**
   * BannerVisitor deleteMany
   */
  export type BannerVisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerVisitors to delete
     */
    where?: BannerVisitorWhereInput
    /**
     * Limit how many BannerVisitors to delete.
     */
    limit?: number
  }

  /**
   * BannerVisitor without action
   */
  export type BannerVisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerVisitor
     */
    select?: BannerVisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerVisitor
     */
    omit?: BannerVisitorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerVisitorInclude<ExtArgs> | null
  }


  /**
   * Model Test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type TestSumAggregateOutputType = {
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    quota: number | null
    currentQuota: number | null
  }

  export type TestMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.Role | null
    question: $Enums.QuestionType | null
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    type: $Enums.TestType | null
    quota: number | null
    currentQuota: number | null
    code: string | null
    zoneId: string | null
    startedAt: Date | null
    endedAt: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.Role | null
    question: $Enums.QuestionType | null
    duration: number | null
    passedPoint: number | null
    remidialCount: number | null
    type: $Enums.TestType | null
    quota: number | null
    currentQuota: number | null
    code: string | null
    zoneId: string | null
    startedAt: Date | null
    endedAt: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestCountAggregateOutputType = {
    id: number
    name: number
    category: number
    question: number
    duration: number
    passedPoint: number
    remidialCount: number
    type: number
    quota: number
    currentQuota: number
    code: number
    zoneId: number
    startedAt: number
    endedAt: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    duration?: true
    passedPoint?: true
    remidialCount?: true
    quota?: true
    currentQuota?: true
  }

  export type TestSumAggregateInputType = {
    duration?: true
    passedPoint?: true
    remidialCount?: true
    quota?: true
    currentQuota?: true
  }

  export type TestMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    question?: true
    duration?: true
    passedPoint?: true
    remidialCount?: true
    type?: true
    quota?: true
    currentQuota?: true
    code?: true
    zoneId?: true
    startedAt?: true
    endedAt?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Test to aggregate.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestWhereInput
    orderBy?: TestOrderByWithAggregationInput | TestOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    id: string
    name: string
    category: $Enums.Role
    question: $Enums.QuestionType
    duration: number
    passedPoint: number
    remidialCount: number
    type: $Enums.TestType
    quota: number
    currentQuota: number
    code: string | null
    zoneId: string | null
    startedAt: Date
    endedAt: Date | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | Test$participantsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>

  export type TestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["test"]>

  export type TestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["test"]>

  export type TestSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    question?: boolean
    duration?: boolean
    passedPoint?: boolean
    remidialCount?: boolean
    type?: boolean
    quota?: boolean
    currentQuota?: boolean
    code?: boolean
    zoneId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "question" | "duration" | "passedPoint" | "remidialCount" | "type" | "quota" | "currentQuota" | "code" | "zoneId" | "startedAt" | "endedAt" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["test"]>
  export type TestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Test$participantsArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Test"
    objects: {
      participants: Prisma.$TestParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.Role
      question: $Enums.QuestionType
      duration: number
      passedPoint: number
      remidialCount: number
      type: $Enums.TestType
      quota: number
      currentQuota: number
      code: string | null
      zoneId: string | null
      startedAt: Date
      endedAt: Date | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type TestGetPayload<S extends boolean | null | undefined | TestDefaultArgs> = $Result.GetResult<Prisma.$TestPayload, S>

  type TestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface TestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Test'], meta: { name: 'Test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestFindUniqueArgs>(args: SelectSubset<T, TestFindUniqueArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestFindUniqueOrThrowArgs>(args: SelectSubset<T, TestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestFindFirstArgs>(args?: SelectSubset<T, TestFindFirstArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestFindFirstOrThrowArgs>(args?: SelectSubset<T, TestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testWithIdOnly = await prisma.test.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestFindManyArgs>(args?: SelectSubset<T, TestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends TestCreateArgs>(args: SelectSubset<T, TestCreateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tests.
     * @param {TestCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestCreateManyArgs>(args?: SelectSubset<T, TestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tests and returns the data saved in the database.
     * @param {TestCreateManyAndReturnArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tests and only return the `id`
     * const testWithIdOnly = await prisma.test.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestCreateManyAndReturnArgs>(args?: SelectSubset<T, TestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends TestDeleteArgs>(args: SelectSubset<T, TestDeleteArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestUpdateArgs>(args: SelectSubset<T, TestUpdateArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestDeleteManyArgs>(args?: SelectSubset<T, TestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestUpdateManyArgs>(args: SelectSubset<T, TestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests and returns the data updated in the database.
     * @param {TestUpdateManyAndReturnArgs} args - Arguments to update many Tests.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tests and only return the `id`
     * const testWithIdOnly = await prisma.test.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestUpdateManyAndReturnArgs>(args: SelectSubset<T, TestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends TestUpsertArgs>(args: SelectSubset<T, TestUpsertArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Test model
   */
  readonly fields: TestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Test$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Test$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Test model
   */
  interface TestFieldRefs {
    readonly id: FieldRef<"Test", 'String'>
    readonly name: FieldRef<"Test", 'String'>
    readonly category: FieldRef<"Test", 'Role'>
    readonly question: FieldRef<"Test", 'QuestionType'>
    readonly duration: FieldRef<"Test", 'Int'>
    readonly passedPoint: FieldRef<"Test", 'Int'>
    readonly remidialCount: FieldRef<"Test", 'Int'>
    readonly type: FieldRef<"Test", 'TestType'>
    readonly quota: FieldRef<"Test", 'Int'>
    readonly currentQuota: FieldRef<"Test", 'Int'>
    readonly code: FieldRef<"Test", 'String'>
    readonly zoneId: FieldRef<"Test", 'String'>
    readonly startedAt: FieldRef<"Test", 'DateTime'>
    readonly endedAt: FieldRef<"Test", 'DateTime'>
    readonly description: FieldRef<"Test", 'String'>
    readonly createdAt: FieldRef<"Test", 'DateTime'>
    readonly updatedAt: FieldRef<"Test", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findUniqueOrThrow
   */
  export type TestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test findFirst
   */
  export type TestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findFirstOrThrow
   */
  export type TestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Test to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test findMany
   */
  export type TestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestOrderByWithRelationInput | TestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * Test create
   */
  export type TestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to create a Test.
     */
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }

  /**
   * Test createMany
   */
  export type TestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Test createManyAndReturn
   */
  export type TestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data used to create many Tests.
     */
    data: TestCreateManyInput | TestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Test update
   */
  export type TestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The data needed to update a Test.
     */
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test updateManyAndReturn
   */
  export type TestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * The data used to update Tests.
     */
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to update.
     */
    limit?: number
  }

  /**
   * Test upsert
   */
  export type TestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * The filter to search for the Test to update in case it exists.
     */
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     */
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }

  /**
   * Test delete
   */
  export type TestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
    /**
     * Filter which Test to delete.
     */
    where: TestWhereUniqueInput
  }

  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestWhereInput
    /**
     * Limit how many Tests to delete.
     */
    limit?: number
  }

  /**
   * Test.participants
   */
  export type Test$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    cursor?: TestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * Test without action
   */
  export type TestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Test
     */
    select?: TestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Test
     */
    omit?: TestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestInclude<ExtArgs> | null
  }


  /**
   * Model TestParticipant
   */

  export type AggregateTestParticipant = {
    _count: TestParticipantCountAggregateOutputType | null
    _avg: TestParticipantAvgAggregateOutputType | null
    _sum: TestParticipantSumAggregateOutputType | null
    _min: TestParticipantMinAggregateOutputType | null
    _max: TestParticipantMaxAggregateOutputType | null
  }

  export type TestParticipantAvgAggregateOutputType = {
    highscore: number | null
  }

  export type TestParticipantSumAggregateOutputType = {
    highscore: number | null
  }

  export type TestParticipantMinAggregateOutputType = {
    id: string | null
    testId: string | null
    userId: string | null
    firstTimeAt: Date | null
    lastTestAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    highscore: number | null
  }

  export type TestParticipantMaxAggregateOutputType = {
    id: string | null
    testId: string | null
    userId: string | null
    firstTimeAt: Date | null
    lastTestAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    highscore: number | null
  }

  export type TestParticipantCountAggregateOutputType = {
    id: number
    testId: number
    userId: number
    firstTimeAt: number
    lastTestAt: number
    createdAt: number
    updatedAt: number
    highscore: number
    _all: number
  }


  export type TestParticipantAvgAggregateInputType = {
    highscore?: true
  }

  export type TestParticipantSumAggregateInputType = {
    highscore?: true
  }

  export type TestParticipantMinAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    firstTimeAt?: true
    lastTestAt?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
  }

  export type TestParticipantMaxAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    firstTimeAt?: true
    lastTestAt?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
  }

  export type TestParticipantCountAggregateInputType = {
    id?: true
    testId?: true
    userId?: true
    firstTimeAt?: true
    lastTestAt?: true
    createdAt?: true
    updatedAt?: true
    highscore?: true
    _all?: true
  }

  export type TestParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipant to aggregate.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParticipants
    **/
    _count?: true | TestParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParticipantMaxAggregateInputType
  }

  export type GetTestParticipantAggregateType<T extends TestParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParticipant[P]>
      : GetScalarType<T[P], AggregateTestParticipant[P]>
  }




  export type TestParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantWhereInput
    orderBy?: TestParticipantOrderByWithAggregationInput | TestParticipantOrderByWithAggregationInput[]
    by: TestParticipantScalarFieldEnum[] | TestParticipantScalarFieldEnum
    having?: TestParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParticipantCountAggregateInputType | true
    _avg?: TestParticipantAvgAggregateInputType
    _sum?: TestParticipantSumAggregateInputType
    _min?: TestParticipantMinAggregateInputType
    _max?: TestParticipantMaxAggregateInputType
  }

  export type TestParticipantGroupByOutputType = {
    id: string
    testId: string
    userId: string
    firstTimeAt: Date | null
    lastTestAt: Date | null
    createdAt: Date
    updatedAt: Date
    highscore: number
    _count: TestParticipantCountAggregateOutputType | null
    _avg: TestParticipantAvgAggregateOutputType | null
    _sum: TestParticipantSumAggregateOutputType | null
    _min: TestParticipantMinAggregateOutputType | null
    _max: TestParticipantMaxAggregateOutputType | null
  }

  type GetTestParticipantGroupByPayload<T extends TestParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], TestParticipantGroupByOutputType[P]>
        }
      >
    >


  export type TestParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    records?: boolean | TestParticipant$recordsArgs<ExtArgs>
    _count?: boolean | TestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipant"]>

  export type TestParticipantSelectScalar = {
    id?: boolean
    testId?: boolean
    userId?: boolean
    firstTimeAt?: boolean
    lastTestAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highscore?: boolean
  }

  export type TestParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testId" | "userId" | "firstTimeAt" | "lastTestAt" | "createdAt" | "updatedAt" | "highscore", ExtArgs["result"]["testParticipant"]>
  export type TestParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    records?: boolean | TestParticipant$recordsArgs<ExtArgs>
    _count?: boolean | TestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | TestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParticipant"
    objects: {
      test: Prisma.$TestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      records: Prisma.$TestParticipantRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testId: string
      userId: string
      firstTimeAt: Date | null
      lastTestAt: Date | null
      createdAt: Date
      updatedAt: Date
      highscore: number
    }, ExtArgs["result"]["testParticipant"]>
    composites: {}
  }

  type TestParticipantGetPayload<S extends boolean | null | undefined | TestParticipantDefaultArgs> = $Result.GetResult<Prisma.$TestParticipantPayload, S>

  type TestParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParticipantCountAggregateInputType | true
    }

  export interface TestParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParticipant'], meta: { name: 'TestParticipant' } }
    /**
     * Find zero or one TestParticipant that matches the filter.
     * @param {TestParticipantFindUniqueArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParticipantFindUniqueArgs>(args: SelectSubset<T, TestParticipantFindUniqueArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParticipantFindUniqueOrThrowArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindFirstArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParticipantFindFirstArgs>(args?: SelectSubset<T, TestParticipantFindFirstArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindFirstOrThrowArgs} args - Arguments to find a TestParticipant
     * @example
     * // Get one TestParticipant
     * const testParticipant = await prisma.testParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParticipants
     * const testParticipants = await prisma.testParticipant.findMany()
     * 
     * // Get first 10 TestParticipants
     * const testParticipants = await prisma.testParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParticipantFindManyArgs>(args?: SelectSubset<T, TestParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParticipant.
     * @param {TestParticipantCreateArgs} args - Arguments to create a TestParticipant.
     * @example
     * // Create one TestParticipant
     * const TestParticipant = await prisma.testParticipant.create({
     *   data: {
     *     // ... data to create a TestParticipant
     *   }
     * })
     * 
     */
    create<T extends TestParticipantCreateArgs>(args: SelectSubset<T, TestParticipantCreateArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParticipants.
     * @param {TestParticipantCreateManyArgs} args - Arguments to create many TestParticipants.
     * @example
     * // Create many TestParticipants
     * const testParticipant = await prisma.testParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParticipantCreateManyArgs>(args?: SelectSubset<T, TestParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParticipants and returns the data saved in the database.
     * @param {TestParticipantCreateManyAndReturnArgs} args - Arguments to create many TestParticipants.
     * @example
     * // Create many TestParticipants
     * const testParticipant = await prisma.testParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParticipants and only return the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParticipant.
     * @param {TestParticipantDeleteArgs} args - Arguments to delete one TestParticipant.
     * @example
     * // Delete one TestParticipant
     * const TestParticipant = await prisma.testParticipant.delete({
     *   where: {
     *     // ... filter to delete one TestParticipant
     *   }
     * })
     * 
     */
    delete<T extends TestParticipantDeleteArgs>(args: SelectSubset<T, TestParticipantDeleteArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParticipant.
     * @param {TestParticipantUpdateArgs} args - Arguments to update one TestParticipant.
     * @example
     * // Update one TestParticipant
     * const testParticipant = await prisma.testParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParticipantUpdateArgs>(args: SelectSubset<T, TestParticipantUpdateArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParticipants.
     * @param {TestParticipantDeleteManyArgs} args - Arguments to filter TestParticipants to delete.
     * @example
     * // Delete a few TestParticipants
     * const { count } = await prisma.testParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParticipantDeleteManyArgs>(args?: SelectSubset<T, TestParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParticipants
     * const testParticipant = await prisma.testParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParticipantUpdateManyArgs>(args: SelectSubset<T, TestParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipants and returns the data updated in the database.
     * @param {TestParticipantUpdateManyAndReturnArgs} args - Arguments to update many TestParticipants.
     * @example
     * // Update many TestParticipants
     * const testParticipant = await prisma.testParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParticipants and only return the `id`
     * const testParticipantWithIdOnly = await prisma.testParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParticipant.
     * @param {TestParticipantUpsertArgs} args - Arguments to update or create a TestParticipant.
     * @example
     * // Update or create a TestParticipant
     * const testParticipant = await prisma.testParticipant.upsert({
     *   create: {
     *     // ... data to create a TestParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParticipant we want to update
     *   }
     * })
     */
    upsert<T extends TestParticipantUpsertArgs>(args: SelectSubset<T, TestParticipantUpsertArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantCountArgs} args - Arguments to filter TestParticipants to count.
     * @example
     * // Count the number of TestParticipants
     * const count = await prisma.testParticipant.count({
     *   where: {
     *     // ... the filter for the TestParticipants we want to count
     *   }
     * })
    **/
    count<T extends TestParticipantCountArgs>(
      args?: Subset<T, TestParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParticipantAggregateArgs>(args: Subset<T, TestParticipantAggregateArgs>): Prisma.PrismaPromise<GetTestParticipantAggregateType<T>>

    /**
     * Group by TestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParticipantGroupByArgs['orderBy'] }
        : { orderBy?: TestParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParticipant model
   */
  readonly fields: TestParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends TestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestDefaultArgs<ExtArgs>>): Prisma__TestClient<$Result.GetResult<Prisma.$TestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    records<T extends TestParticipant$recordsArgs<ExtArgs> = {}>(args?: Subset<T, TestParticipant$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParticipant model
   */
  interface TestParticipantFieldRefs {
    readonly id: FieldRef<"TestParticipant", 'String'>
    readonly testId: FieldRef<"TestParticipant", 'String'>
    readonly userId: FieldRef<"TestParticipant", 'String'>
    readonly firstTimeAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly lastTestAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly createdAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParticipant", 'DateTime'>
    readonly highscore: FieldRef<"TestParticipant", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TestParticipant findUnique
   */
  export type TestParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant findUniqueOrThrow
   */
  export type TestParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant findFirst
   */
  export type TestParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipants.
     */
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant findFirstOrThrow
   */
  export type TestParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipant to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipants.
     */
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant findMany
   */
  export type TestParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipants to fetch.
     */
    where?: TestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipants to fetch.
     */
    orderBy?: TestParticipantOrderByWithRelationInput | TestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParticipants.
     */
    cursor?: TestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipants.
     */
    skip?: number
    distinct?: TestParticipantScalarFieldEnum | TestParticipantScalarFieldEnum[]
  }

  /**
   * TestParticipant create
   */
  export type TestParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParticipant.
     */
    data: XOR<TestParticipantCreateInput, TestParticipantUncheckedCreateInput>
  }

  /**
   * TestParticipant createMany
   */
  export type TestParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParticipants.
     */
    data: TestParticipantCreateManyInput | TestParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParticipant createManyAndReturn
   */
  export type TestParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many TestParticipants.
     */
    data: TestParticipantCreateManyInput | TestParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipant update
   */
  export type TestParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParticipant.
     */
    data: XOR<TestParticipantUpdateInput, TestParticipantUncheckedUpdateInput>
    /**
     * Choose, which TestParticipant to update.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant updateMany
   */
  export type TestParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParticipants.
     */
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipants to update
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to update.
     */
    limit?: number
  }

  /**
   * TestParticipant updateManyAndReturn
   */
  export type TestParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * The data used to update TestParticipants.
     */
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipants to update
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipant upsert
   */
  export type TestParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParticipant to update in case it exists.
     */
    where: TestParticipantWhereUniqueInput
    /**
     * In case the TestParticipant found by the `where` argument doesn't exist, create a new TestParticipant with this data.
     */
    create: XOR<TestParticipantCreateInput, TestParticipantUncheckedCreateInput>
    /**
     * In case the TestParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParticipantUpdateInput, TestParticipantUncheckedUpdateInput>
  }

  /**
   * TestParticipant delete
   */
  export type TestParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
    /**
     * Filter which TestParticipant to delete.
     */
    where: TestParticipantWhereUniqueInput
  }

  /**
   * TestParticipant deleteMany
   */
  export type TestParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipants to delete
     */
    where?: TestParticipantWhereInput
    /**
     * Limit how many TestParticipants to delete.
     */
    limit?: number
  }

  /**
   * TestParticipant.records
   */
  export type TestParticipant$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    cursor?: TestParticipantRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipant without action
   */
  export type TestParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipant
     */
    select?: TestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipant
     */
    omit?: TestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantInclude<ExtArgs> | null
  }


  /**
   * Model TestParticipantRecord
   */

  export type AggregateTestParticipantRecord = {
    _count: TestParticipantRecordCountAggregateOutputType | null
    _avg: TestParticipantRecordAvgAggregateOutputType | null
    _sum: TestParticipantRecordSumAggregateOutputType | null
    _min: TestParticipantRecordMinAggregateOutputType | null
    _max: TestParticipantRecordMaxAggregateOutputType | null
  }

  export type TestParticipantRecordAvgAggregateOutputType = {
    score: number | null
  }

  export type TestParticipantRecordSumAggregateOutputType = {
    score: number | null
  }

  export type TestParticipantRecordMinAggregateOutputType = {
    id: string | null
    participantId: string | null
    startedAt: Date | null
    endedAt: Date | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestParticipantRecordMaxAggregateOutputType = {
    id: string | null
    participantId: string | null
    startedAt: Date | null
    endedAt: Date | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestParticipantRecordCountAggregateOutputType = {
    id: number
    participantId: number
    startedAt: number
    endedAt: number
    score: number
    createdAt: number
    updatedAt: number
    answers: number
    _all: number
  }


  export type TestParticipantRecordAvgAggregateInputType = {
    score?: true
  }

  export type TestParticipantRecordSumAggregateInputType = {
    score?: true
  }

  export type TestParticipantRecordMinAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestParticipantRecordMaxAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestParticipantRecordCountAggregateInputType = {
    id?: true
    participantId?: true
    startedAt?: true
    endedAt?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    answers?: true
    _all?: true
  }

  export type TestParticipantRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipantRecord to aggregate.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParticipantRecords
    **/
    _count?: true | TestParticipantRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestParticipantRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestParticipantRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParticipantRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParticipantRecordMaxAggregateInputType
  }

  export type GetTestParticipantRecordAggregateType<T extends TestParticipantRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParticipantRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParticipantRecord[P]>
      : GetScalarType<T[P], AggregateTestParticipantRecord[P]>
  }




  export type TestParticipantRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParticipantRecordWhereInput
    orderBy?: TestParticipantRecordOrderByWithAggregationInput | TestParticipantRecordOrderByWithAggregationInput[]
    by: TestParticipantRecordScalarFieldEnum[] | TestParticipantRecordScalarFieldEnum
    having?: TestParticipantRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParticipantRecordCountAggregateInputType | true
    _avg?: TestParticipantRecordAvgAggregateInputType
    _sum?: TestParticipantRecordSumAggregateInputType
    _min?: TestParticipantRecordMinAggregateInputType
    _max?: TestParticipantRecordMaxAggregateInputType
  }

  export type TestParticipantRecordGroupByOutputType = {
    id: string
    participantId: string
    startedAt: Date | null
    endedAt: Date | null
    score: number
    createdAt: Date
    updatedAt: Date
    answers: JsonValue
    _count: TestParticipantRecordCountAggregateOutputType | null
    _avg: TestParticipantRecordAvgAggregateOutputType | null
    _sum: TestParticipantRecordSumAggregateOutputType | null
    _min: TestParticipantRecordMinAggregateOutputType | null
    _max: TestParticipantRecordMaxAggregateOutputType | null
  }

  type GetTestParticipantRecordGroupByPayload<T extends TestParticipantRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParticipantRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParticipantRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParticipantRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TestParticipantRecordGroupByOutputType[P]>
        }
      >
    >


  export type TestParticipantRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParticipantRecord"]>

  export type TestParticipantRecordSelectScalar = {
    id?: boolean
    participantId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answers?: boolean
  }

  export type TestParticipantRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participantId" | "startedAt" | "endedAt" | "score" | "createdAt" | "updatedAt" | "answers", ExtArgs["result"]["testParticipantRecord"]>
  export type TestParticipantRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }
  export type TestParticipantRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }
  export type TestParticipantRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | TestParticipantDefaultArgs<ExtArgs>
  }

  export type $TestParticipantRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParticipantRecord"
    objects: {
      participant: Prisma.$TestParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participantId: string
      startedAt: Date | null
      endedAt: Date | null
      score: number
      createdAt: Date
      updatedAt: Date
      answers: Prisma.JsonValue
    }, ExtArgs["result"]["testParticipantRecord"]>
    composites: {}
  }

  type TestParticipantRecordGetPayload<S extends boolean | null | undefined | TestParticipantRecordDefaultArgs> = $Result.GetResult<Prisma.$TestParticipantRecordPayload, S>

  type TestParticipantRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParticipantRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParticipantRecordCountAggregateInputType | true
    }

  export interface TestParticipantRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParticipantRecord'], meta: { name: 'TestParticipantRecord' } }
    /**
     * Find zero or one TestParticipantRecord that matches the filter.
     * @param {TestParticipantRecordFindUniqueArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParticipantRecordFindUniqueArgs>(args: SelectSubset<T, TestParticipantRecordFindUniqueArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParticipantRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParticipantRecordFindUniqueOrThrowArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParticipantRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipantRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindFirstArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParticipantRecordFindFirstArgs>(args?: SelectSubset<T, TestParticipantRecordFindFirstArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParticipantRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindFirstOrThrowArgs} args - Arguments to find a TestParticipantRecord
     * @example
     * // Get one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParticipantRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParticipantRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParticipantRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParticipantRecords
     * const testParticipantRecords = await prisma.testParticipantRecord.findMany()
     * 
     * // Get first 10 TestParticipantRecords
     * const testParticipantRecords = await prisma.testParticipantRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParticipantRecordFindManyArgs>(args?: SelectSubset<T, TestParticipantRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParticipantRecord.
     * @param {TestParticipantRecordCreateArgs} args - Arguments to create a TestParticipantRecord.
     * @example
     * // Create one TestParticipantRecord
     * const TestParticipantRecord = await prisma.testParticipantRecord.create({
     *   data: {
     *     // ... data to create a TestParticipantRecord
     *   }
     * })
     * 
     */
    create<T extends TestParticipantRecordCreateArgs>(args: SelectSubset<T, TestParticipantRecordCreateArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParticipantRecords.
     * @param {TestParticipantRecordCreateManyArgs} args - Arguments to create many TestParticipantRecords.
     * @example
     * // Create many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParticipantRecordCreateManyArgs>(args?: SelectSubset<T, TestParticipantRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParticipantRecords and returns the data saved in the database.
     * @param {TestParticipantRecordCreateManyAndReturnArgs} args - Arguments to create many TestParticipantRecords.
     * @example
     * // Create many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParticipantRecords and only return the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParticipantRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParticipantRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParticipantRecord.
     * @param {TestParticipantRecordDeleteArgs} args - Arguments to delete one TestParticipantRecord.
     * @example
     * // Delete one TestParticipantRecord
     * const TestParticipantRecord = await prisma.testParticipantRecord.delete({
     *   where: {
     *     // ... filter to delete one TestParticipantRecord
     *   }
     * })
     * 
     */
    delete<T extends TestParticipantRecordDeleteArgs>(args: SelectSubset<T, TestParticipantRecordDeleteArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParticipantRecord.
     * @param {TestParticipantRecordUpdateArgs} args - Arguments to update one TestParticipantRecord.
     * @example
     * // Update one TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParticipantRecordUpdateArgs>(args: SelectSubset<T, TestParticipantRecordUpdateArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParticipantRecords.
     * @param {TestParticipantRecordDeleteManyArgs} args - Arguments to filter TestParticipantRecords to delete.
     * @example
     * // Delete a few TestParticipantRecords
     * const { count } = await prisma.testParticipantRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParticipantRecordDeleteManyArgs>(args?: SelectSubset<T, TestParticipantRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipantRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParticipantRecordUpdateManyArgs>(args: SelectSubset<T, TestParticipantRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParticipantRecords and returns the data updated in the database.
     * @param {TestParticipantRecordUpdateManyAndReturnArgs} args - Arguments to update many TestParticipantRecords.
     * @example
     * // Update many TestParticipantRecords
     * const testParticipantRecord = await prisma.testParticipantRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParticipantRecords and only return the `id`
     * const testParticipantRecordWithIdOnly = await prisma.testParticipantRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParticipantRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParticipantRecord.
     * @param {TestParticipantRecordUpsertArgs} args - Arguments to update or create a TestParticipantRecord.
     * @example
     * // Update or create a TestParticipantRecord
     * const testParticipantRecord = await prisma.testParticipantRecord.upsert({
     *   create: {
     *     // ... data to create a TestParticipantRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParticipantRecord we want to update
     *   }
     * })
     */
    upsert<T extends TestParticipantRecordUpsertArgs>(args: SelectSubset<T, TestParticipantRecordUpsertArgs<ExtArgs>>): Prisma__TestParticipantRecordClient<$Result.GetResult<Prisma.$TestParticipantRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParticipantRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordCountArgs} args - Arguments to filter TestParticipantRecords to count.
     * @example
     * // Count the number of TestParticipantRecords
     * const count = await prisma.testParticipantRecord.count({
     *   where: {
     *     // ... the filter for the TestParticipantRecords we want to count
     *   }
     * })
    **/
    count<T extends TestParticipantRecordCountArgs>(
      args?: Subset<T, TestParticipantRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParticipantRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParticipantRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParticipantRecordAggregateArgs>(args: Subset<T, TestParticipantRecordAggregateArgs>): Prisma.PrismaPromise<GetTestParticipantRecordAggregateType<T>>

    /**
     * Group by TestParticipantRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParticipantRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParticipantRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParticipantRecordGroupByArgs['orderBy'] }
        : { orderBy?: TestParticipantRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParticipantRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParticipantRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParticipantRecord model
   */
  readonly fields: TestParticipantRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParticipantRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParticipantRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends TestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParticipantDefaultArgs<ExtArgs>>): Prisma__TestParticipantClient<$Result.GetResult<Prisma.$TestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParticipantRecord model
   */
  interface TestParticipantRecordFieldRefs {
    readonly id: FieldRef<"TestParticipantRecord", 'String'>
    readonly participantId: FieldRef<"TestParticipantRecord", 'String'>
    readonly startedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly endedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly score: FieldRef<"TestParticipantRecord", 'Float'>
    readonly createdAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParticipantRecord", 'DateTime'>
    readonly answers: FieldRef<"TestParticipantRecord", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * TestParticipantRecord findUnique
   */
  export type TestParticipantRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord findUniqueOrThrow
   */
  export type TestParticipantRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord findFirst
   */
  export type TestParticipantRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipantRecords.
     */
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord findFirstOrThrow
   */
  export type TestParticipantRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecord to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParticipantRecords.
     */
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord findMany
   */
  export type TestParticipantRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter, which TestParticipantRecords to fetch.
     */
    where?: TestParticipantRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParticipantRecords to fetch.
     */
    orderBy?: TestParticipantRecordOrderByWithRelationInput | TestParticipantRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParticipantRecords.
     */
    cursor?: TestParticipantRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParticipantRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParticipantRecords.
     */
    skip?: number
    distinct?: TestParticipantRecordScalarFieldEnum | TestParticipantRecordScalarFieldEnum[]
  }

  /**
   * TestParticipantRecord create
   */
  export type TestParticipantRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParticipantRecord.
     */
    data: XOR<TestParticipantRecordCreateInput, TestParticipantRecordUncheckedCreateInput>
  }

  /**
   * TestParticipantRecord createMany
   */
  export type TestParticipantRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParticipantRecords.
     */
    data: TestParticipantRecordCreateManyInput | TestParticipantRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParticipantRecord createManyAndReturn
   */
  export type TestParticipantRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TestParticipantRecords.
     */
    data: TestParticipantRecordCreateManyInput | TestParticipantRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipantRecord update
   */
  export type TestParticipantRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParticipantRecord.
     */
    data: XOR<TestParticipantRecordUpdateInput, TestParticipantRecordUncheckedUpdateInput>
    /**
     * Choose, which TestParticipantRecord to update.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord updateMany
   */
  export type TestParticipantRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParticipantRecords.
     */
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipantRecords to update
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to update.
     */
    limit?: number
  }

  /**
   * TestParticipantRecord updateManyAndReturn
   */
  export type TestParticipantRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * The data used to update TestParticipantRecords.
     */
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyInput>
    /**
     * Filter which TestParticipantRecords to update
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParticipantRecord upsert
   */
  export type TestParticipantRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParticipantRecord to update in case it exists.
     */
    where: TestParticipantRecordWhereUniqueInput
    /**
     * In case the TestParticipantRecord found by the `where` argument doesn't exist, create a new TestParticipantRecord with this data.
     */
    create: XOR<TestParticipantRecordCreateInput, TestParticipantRecordUncheckedCreateInput>
    /**
     * In case the TestParticipantRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParticipantRecordUpdateInput, TestParticipantRecordUncheckedUpdateInput>
  }

  /**
   * TestParticipantRecord delete
   */
  export type TestParticipantRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
    /**
     * Filter which TestParticipantRecord to delete.
     */
    where: TestParticipantRecordWhereUniqueInput
  }

  /**
   * TestParticipantRecord deleteMany
   */
  export type TestParticipantRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParticipantRecords to delete
     */
    where?: TestParticipantRecordWhereInput
    /**
     * Limit how many TestParticipantRecords to delete.
     */
    limit?: number
  }

  /**
   * TestParticipantRecord without action
   */
  export type TestParticipantRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParticipantRecord
     */
    select?: TestParticipantRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParticipantRecord
     */
    omit?: TestParticipantRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParticipantRecordInclude<ExtArgs> | null
  }


  /**
   * Model Background
   */

  export type AggregateBackground = {
    _count: BackgroundCountAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  export type BackgroundMinAggregateOutputType = {
    id: string | null
    name: string | null
    thumbnailId: string | null
    thumbnail: string | null
    isUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackgroundMaxAggregateOutputType = {
    id: string | null
    name: string | null
    thumbnailId: string | null
    thumbnail: string | null
    isUse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackgroundCountAggregateOutputType = {
    id: number
    name: number
    thumbnailId: number
    thumbnail: number
    isUse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BackgroundMinAggregateInputType = {
    id?: true
    name?: true
    thumbnailId?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackgroundMaxAggregateInputType = {
    id?: true
    name?: true
    thumbnailId?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackgroundCountAggregateInputType = {
    id?: true
    name?: true
    thumbnailId?: true
    thumbnail?: true
    isUse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BackgroundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Background to aggregate.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backgrounds
    **/
    _count?: true | BackgroundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackgroundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackgroundMaxAggregateInputType
  }

  export type GetBackgroundAggregateType<T extends BackgroundAggregateArgs> = {
        [P in keyof T & keyof AggregateBackground]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackground[P]>
      : GetScalarType<T[P], AggregateBackground[P]>
  }




  export type BackgroundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackgroundWhereInput
    orderBy?: BackgroundOrderByWithAggregationInput | BackgroundOrderByWithAggregationInput[]
    by: BackgroundScalarFieldEnum[] | BackgroundScalarFieldEnum
    having?: BackgroundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackgroundCountAggregateInputType | true
    _min?: BackgroundMinAggregateInputType
    _max?: BackgroundMaxAggregateInputType
  }

  export type BackgroundGroupByOutputType = {
    id: string
    name: string
    thumbnailId: string
    thumbnail: string
    isUse: boolean
    createdAt: Date
    updatedAt: Date
    _count: BackgroundCountAggregateOutputType | null
    _min: BackgroundMinAggregateOutputType | null
    _max: BackgroundMaxAggregateOutputType | null
  }

  type GetBackgroundGroupByPayload<T extends BackgroundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackgroundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackgroundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
            : GetScalarType<T[P], BackgroundGroupByOutputType[P]>
        }
      >
    >


  export type BackgroundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["background"]>

  export type BackgroundSelectScalar = {
    id?: boolean
    name?: boolean
    thumbnailId?: boolean
    thumbnail?: boolean
    isUse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BackgroundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "thumbnailId" | "thumbnail" | "isUse" | "createdAt" | "updatedAt", ExtArgs["result"]["background"]>

  export type $BackgroundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Background"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      thumbnailId: string
      thumbnail: string
      isUse: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["background"]>
    composites: {}
  }

  type BackgroundGetPayload<S extends boolean | null | undefined | BackgroundDefaultArgs> = $Result.GetResult<Prisma.$BackgroundPayload, S>

  type BackgroundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BackgroundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BackgroundCountAggregateInputType | true
    }

  export interface BackgroundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Background'], meta: { name: 'Background' } }
    /**
     * Find zero or one Background that matches the filter.
     * @param {BackgroundFindUniqueArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackgroundFindUniqueArgs>(args: SelectSubset<T, BackgroundFindUniqueArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Background that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BackgroundFindUniqueOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackgroundFindUniqueOrThrowArgs>(args: SelectSubset<T, BackgroundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackgroundFindFirstArgs>(args?: SelectSubset<T, BackgroundFindFirstArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Background that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindFirstOrThrowArgs} args - Arguments to find a Background
     * @example
     * // Get one Background
     * const background = await prisma.background.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackgroundFindFirstOrThrowArgs>(args?: SelectSubset<T, BackgroundFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Backgrounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backgrounds
     * const backgrounds = await prisma.background.findMany()
     * 
     * // Get first 10 Backgrounds
     * const backgrounds = await prisma.background.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backgroundWithIdOnly = await prisma.background.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackgroundFindManyArgs>(args?: SelectSubset<T, BackgroundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Background.
     * @param {BackgroundCreateArgs} args - Arguments to create a Background.
     * @example
     * // Create one Background
     * const Background = await prisma.background.create({
     *   data: {
     *     // ... data to create a Background
     *   }
     * })
     * 
     */
    create<T extends BackgroundCreateArgs>(args: SelectSubset<T, BackgroundCreateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Backgrounds.
     * @param {BackgroundCreateManyArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackgroundCreateManyArgs>(args?: SelectSubset<T, BackgroundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Backgrounds and returns the data saved in the database.
     * @param {BackgroundCreateManyAndReturnArgs} args - Arguments to create many Backgrounds.
     * @example
     * // Create many Backgrounds
     * const background = await prisma.background.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Backgrounds and only return the `id`
     * const backgroundWithIdOnly = await prisma.background.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackgroundCreateManyAndReturnArgs>(args?: SelectSubset<T, BackgroundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Background.
     * @param {BackgroundDeleteArgs} args - Arguments to delete one Background.
     * @example
     * // Delete one Background
     * const Background = await prisma.background.delete({
     *   where: {
     *     // ... filter to delete one Background
     *   }
     * })
     * 
     */
    delete<T extends BackgroundDeleteArgs>(args: SelectSubset<T, BackgroundDeleteArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Background.
     * @param {BackgroundUpdateArgs} args - Arguments to update one Background.
     * @example
     * // Update one Background
     * const background = await prisma.background.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackgroundUpdateArgs>(args: SelectSubset<T, BackgroundUpdateArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Backgrounds.
     * @param {BackgroundDeleteManyArgs} args - Arguments to filter Backgrounds to delete.
     * @example
     * // Delete a few Backgrounds
     * const { count } = await prisma.background.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackgroundDeleteManyArgs>(args?: SelectSubset<T, BackgroundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackgroundUpdateManyArgs>(args: SelectSubset<T, BackgroundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backgrounds and returns the data updated in the database.
     * @param {BackgroundUpdateManyAndReturnArgs} args - Arguments to update many Backgrounds.
     * @example
     * // Update many Backgrounds
     * const background = await prisma.background.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Backgrounds and only return the `id`
     * const backgroundWithIdOnly = await prisma.background.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BackgroundUpdateManyAndReturnArgs>(args: SelectSubset<T, BackgroundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Background.
     * @param {BackgroundUpsertArgs} args - Arguments to update or create a Background.
     * @example
     * // Update or create a Background
     * const background = await prisma.background.upsert({
     *   create: {
     *     // ... data to create a Background
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Background we want to update
     *   }
     * })
     */
    upsert<T extends BackgroundUpsertArgs>(args: SelectSubset<T, BackgroundUpsertArgs<ExtArgs>>): Prisma__BackgroundClient<$Result.GetResult<Prisma.$BackgroundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Backgrounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundCountArgs} args - Arguments to filter Backgrounds to count.
     * @example
     * // Count the number of Backgrounds
     * const count = await prisma.background.count({
     *   where: {
     *     // ... the filter for the Backgrounds we want to count
     *   }
     * })
    **/
    count<T extends BackgroundCountArgs>(
      args?: Subset<T, BackgroundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackgroundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackgroundAggregateArgs>(args: Subset<T, BackgroundAggregateArgs>): Prisma.PrismaPromise<GetBackgroundAggregateType<T>>

    /**
     * Group by Background.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackgroundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackgroundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackgroundGroupByArgs['orderBy'] }
        : { orderBy?: BackgroundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackgroundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackgroundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Background model
   */
  readonly fields: BackgroundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Background.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackgroundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Background model
   */
  interface BackgroundFieldRefs {
    readonly id: FieldRef<"Background", 'String'>
    readonly name: FieldRef<"Background", 'String'>
    readonly thumbnailId: FieldRef<"Background", 'String'>
    readonly thumbnail: FieldRef<"Background", 'String'>
    readonly isUse: FieldRef<"Background", 'Boolean'>
    readonly createdAt: FieldRef<"Background", 'DateTime'>
    readonly updatedAt: FieldRef<"Background", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Background findUnique
   */
  export type BackgroundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findUniqueOrThrow
   */
  export type BackgroundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background findFirst
   */
  export type BackgroundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findFirstOrThrow
   */
  export type BackgroundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Background to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backgrounds.
     */
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background findMany
   */
  export type BackgroundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter, which Backgrounds to fetch.
     */
    where?: BackgroundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backgrounds to fetch.
     */
    orderBy?: BackgroundOrderByWithRelationInput | BackgroundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backgrounds.
     */
    cursor?: BackgroundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backgrounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backgrounds.
     */
    skip?: number
    distinct?: BackgroundScalarFieldEnum | BackgroundScalarFieldEnum[]
  }

  /**
   * Background create
   */
  export type BackgroundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data needed to create a Background.
     */
    data: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
  }

  /**
   * Background createMany
   */
  export type BackgroundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background createManyAndReturn
   */
  export type BackgroundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to create many Backgrounds.
     */
    data: BackgroundCreateManyInput | BackgroundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Background update
   */
  export type BackgroundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data needed to update a Background.
     */
    data: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
    /**
     * Choose, which Background to update.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background updateMany
   */
  export type BackgroundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background updateManyAndReturn
   */
  export type BackgroundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The data used to update Backgrounds.
     */
    data: XOR<BackgroundUpdateManyMutationInput, BackgroundUncheckedUpdateManyInput>
    /**
     * Filter which Backgrounds to update
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to update.
     */
    limit?: number
  }

  /**
   * Background upsert
   */
  export type BackgroundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * The filter to search for the Background to update in case it exists.
     */
    where: BackgroundWhereUniqueInput
    /**
     * In case the Background found by the `where` argument doesn't exist, create a new Background with this data.
     */
    create: XOR<BackgroundCreateInput, BackgroundUncheckedCreateInput>
    /**
     * In case the Background was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackgroundUpdateInput, BackgroundUncheckedUpdateInput>
  }

  /**
   * Background delete
   */
  export type BackgroundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
    /**
     * Filter which Background to delete.
     */
    where: BackgroundWhereUniqueInput
  }

  /**
   * Background deleteMany
   */
  export type BackgroundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backgrounds to delete
     */
    where?: BackgroundWhereInput
    /**
     * Limit how many Backgrounds to delete.
     */
    limit?: number
  }

  /**
   * Background without action
   */
  export type BackgroundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Background
     */
    select?: BackgroundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Background
     */
    omit?: BackgroundOmit<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    name: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    name: string
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "title" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly name: FieldRef<"Setting", 'String'>
    readonly title: FieldRef<"Setting", 'String'>
    readonly content: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model AdminTransaction
   */

  export type AggregateAdminTransaction = {
    _count: AdminTransactionCountAggregateOutputType | null
    _avg: AdminTransactionAvgAggregateOutputType | null
    _sum: AdminTransactionSumAggregateOutputType | null
    _min: AdminTransactionMinAggregateOutputType | null
    _max: AdminTransactionMaxAggregateOutputType | null
  }

  export type AdminTransactionAvgAggregateOutputType = {
    quantity: number | null
    subscriptionTime: number | null
    amount: number | null
  }

  export type AdminTransactionSumAggregateOutputType = {
    quantity: number | null
    subscriptionTime: number | null
    amount: number | null
  }

  export type AdminTransactionMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.Transaction | null
    archived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    adminId: string | null
    quantity: number | null
    subscriptionTime: number | null
    transactionRef: string | null
    amount: number | null
    description: string | null
    transactionImageId: string | null
    transactionImageUrl: string | null
    processedById: string | null
    processedAt: Date | null
  }

  export type AdminTransactionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.Transaction | null
    archived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    adminId: string | null
    quantity: number | null
    subscriptionTime: number | null
    transactionRef: string | null
    amount: number | null
    description: string | null
    transactionImageId: string | null
    transactionImageUrl: string | null
    processedById: string | null
    processedAt: Date | null
  }

  export type AdminTransactionCountAggregateOutputType = {
    id: number
    name: number
    status: number
    archived: number
    createdAt: number
    updatedAt: number
    adminId: number
    quantity: number
    subscriptionTime: number
    zones: number
    transactionRef: number
    amount: number
    description: number
    transactionImageId: number
    transactionImageUrl: number
    processedById: number
    processedAt: number
    _all: number
  }


  export type AdminTransactionAvgAggregateInputType = {
    quantity?: true
    subscriptionTime?: true
    amount?: true
  }

  export type AdminTransactionSumAggregateInputType = {
    quantity?: true
    subscriptionTime?: true
    amount?: true
  }

  export type AdminTransactionMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    archived?: true
    createdAt?: true
    updatedAt?: true
    adminId?: true
    quantity?: true
    subscriptionTime?: true
    transactionRef?: true
    amount?: true
    description?: true
    transactionImageId?: true
    transactionImageUrl?: true
    processedById?: true
    processedAt?: true
  }

  export type AdminTransactionMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    archived?: true
    createdAt?: true
    updatedAt?: true
    adminId?: true
    quantity?: true
    subscriptionTime?: true
    transactionRef?: true
    amount?: true
    description?: true
    transactionImageId?: true
    transactionImageUrl?: true
    processedById?: true
    processedAt?: true
  }

  export type AdminTransactionCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    archived?: true
    createdAt?: true
    updatedAt?: true
    adminId?: true
    quantity?: true
    subscriptionTime?: true
    zones?: true
    transactionRef?: true
    amount?: true
    description?: true
    transactionImageId?: true
    transactionImageUrl?: true
    processedById?: true
    processedAt?: true
    _all?: true
  }

  export type AdminTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransaction to aggregate.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminTransactions
    **/
    _count?: true | AdminTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminTransactionMaxAggregateInputType
  }

  export type GetAdminTransactionAggregateType<T extends AdminTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminTransaction[P]>
      : GetScalarType<T[P], AggregateAdminTransaction[P]>
  }




  export type AdminTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminTransactionWhereInput
    orderBy?: AdminTransactionOrderByWithAggregationInput | AdminTransactionOrderByWithAggregationInput[]
    by: AdminTransactionScalarFieldEnum[] | AdminTransactionScalarFieldEnum
    having?: AdminTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminTransactionCountAggregateInputType | true
    _avg?: AdminTransactionAvgAggregateInputType
    _sum?: AdminTransactionSumAggregateInputType
    _min?: AdminTransactionMinAggregateInputType
    _max?: AdminTransactionMaxAggregateInputType
  }

  export type AdminTransactionGroupByOutputType = {
    id: string
    name: string
    status: $Enums.Transaction
    archived: boolean
    createdAt: Date
    updatedAt: Date
    adminId: string
    quantity: number
    subscriptionTime: number
    zones: string[]
    transactionRef: string | null
    amount: number
    description: string | null
    transactionImageId: string | null
    transactionImageUrl: string | null
    processedById: string | null
    processedAt: Date | null
    _count: AdminTransactionCountAggregateOutputType | null
    _avg: AdminTransactionAvgAggregateOutputType | null
    _sum: AdminTransactionSumAggregateOutputType | null
    _min: AdminTransactionMinAggregateOutputType | null
    _max: AdminTransactionMaxAggregateOutputType | null
  }

  type GetAdminTransactionGroupByPayload<T extends AdminTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminTransactionGroupByOutputType[P]>
        }
      >
    >


  export type AdminTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    quantity?: boolean
    subscriptionTime?: boolean
    zones?: boolean
    transactionRef?: boolean
    amount?: boolean
    description?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    processedById?: boolean
    processedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    redeemCode?: boolean | AdminTransaction$redeemCodeArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    quantity?: boolean
    subscriptionTime?: boolean
    zones?: boolean
    transactionRef?: boolean
    amount?: boolean
    description?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    processedById?: boolean
    processedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    quantity?: boolean
    subscriptionTime?: boolean
    zones?: boolean
    transactionRef?: boolean
    amount?: boolean
    description?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    processedById?: boolean
    processedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }, ExtArgs["result"]["adminTransaction"]>

  export type AdminTransactionSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminId?: boolean
    quantity?: boolean
    subscriptionTime?: boolean
    zones?: boolean
    transactionRef?: boolean
    amount?: boolean
    description?: boolean
    transactionImageId?: boolean
    transactionImageUrl?: boolean
    processedById?: boolean
    processedAt?: boolean
  }

  export type AdminTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "archived" | "createdAt" | "updatedAt" | "adminId" | "quantity" | "subscriptionTime" | "zones" | "transactionRef" | "amount" | "description" | "transactionImageId" | "transactionImageUrl" | "processedById" | "processedAt", ExtArgs["result"]["adminTransaction"]>
  export type AdminTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    redeemCode?: boolean | AdminTransaction$redeemCodeArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }
  export type AdminTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }
  export type AdminTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    processedBy?: boolean | AdminTransaction$processedByArgs<ExtArgs>
  }

  export type $AdminTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminTransaction"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      redeemCode: Prisma.$RedeemCodePayload<ExtArgs> | null
      processedBy: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.Transaction
      archived: boolean
      createdAt: Date
      updatedAt: Date
      adminId: string
      quantity: number
      subscriptionTime: number
      zones: string[]
      transactionRef: string | null
      amount: number
      description: string | null
      transactionImageId: string | null
      transactionImageUrl: string | null
      processedById: string | null
      processedAt: Date | null
    }, ExtArgs["result"]["adminTransaction"]>
    composites: {}
  }

  type AdminTransactionGetPayload<S extends boolean | null | undefined | AdminTransactionDefaultArgs> = $Result.GetResult<Prisma.$AdminTransactionPayload, S>

  type AdminTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminTransactionCountAggregateInputType | true
    }

  export interface AdminTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminTransaction'], meta: { name: 'AdminTransaction' } }
    /**
     * Find zero or one AdminTransaction that matches the filter.
     * @param {AdminTransactionFindUniqueArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminTransactionFindUniqueArgs>(args: SelectSubset<T, AdminTransactionFindUniqueArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminTransactionFindUniqueOrThrowArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindFirstArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminTransactionFindFirstArgs>(args?: SelectSubset<T, AdminTransactionFindFirstArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindFirstOrThrowArgs} args - Arguments to find a AdminTransaction
     * @example
     * // Get one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminTransactions
     * const adminTransactions = await prisma.adminTransaction.findMany()
     * 
     * // Get first 10 AdminTransactions
     * const adminTransactions = await prisma.adminTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminTransactionFindManyArgs>(args?: SelectSubset<T, AdminTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminTransaction.
     * @param {AdminTransactionCreateArgs} args - Arguments to create a AdminTransaction.
     * @example
     * // Create one AdminTransaction
     * const AdminTransaction = await prisma.adminTransaction.create({
     *   data: {
     *     // ... data to create a AdminTransaction
     *   }
     * })
     * 
     */
    create<T extends AdminTransactionCreateArgs>(args: SelectSubset<T, AdminTransactionCreateArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminTransactions.
     * @param {AdminTransactionCreateManyArgs} args - Arguments to create many AdminTransactions.
     * @example
     * // Create many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminTransactionCreateManyArgs>(args?: SelectSubset<T, AdminTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminTransactions and returns the data saved in the database.
     * @param {AdminTransactionCreateManyAndReturnArgs} args - Arguments to create many AdminTransactions.
     * @example
     * // Create many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminTransactions and only return the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminTransaction.
     * @param {AdminTransactionDeleteArgs} args - Arguments to delete one AdminTransaction.
     * @example
     * // Delete one AdminTransaction
     * const AdminTransaction = await prisma.adminTransaction.delete({
     *   where: {
     *     // ... filter to delete one AdminTransaction
     *   }
     * })
     * 
     */
    delete<T extends AdminTransactionDeleteArgs>(args: SelectSubset<T, AdminTransactionDeleteArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminTransaction.
     * @param {AdminTransactionUpdateArgs} args - Arguments to update one AdminTransaction.
     * @example
     * // Update one AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminTransactionUpdateArgs>(args: SelectSubset<T, AdminTransactionUpdateArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminTransactions.
     * @param {AdminTransactionDeleteManyArgs} args - Arguments to filter AdminTransactions to delete.
     * @example
     * // Delete a few AdminTransactions
     * const { count } = await prisma.adminTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminTransactionDeleteManyArgs>(args?: SelectSubset<T, AdminTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminTransactionUpdateManyArgs>(args: SelectSubset<T, AdminTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminTransactions and returns the data updated in the database.
     * @param {AdminTransactionUpdateManyAndReturnArgs} args - Arguments to update many AdminTransactions.
     * @example
     * // Update many AdminTransactions
     * const adminTransaction = await prisma.adminTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminTransactions and only return the `id`
     * const adminTransactionWithIdOnly = await prisma.adminTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminTransaction.
     * @param {AdminTransactionUpsertArgs} args - Arguments to update or create a AdminTransaction.
     * @example
     * // Update or create a AdminTransaction
     * const adminTransaction = await prisma.adminTransaction.upsert({
     *   create: {
     *     // ... data to create a AdminTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminTransaction we want to update
     *   }
     * })
     */
    upsert<T extends AdminTransactionUpsertArgs>(args: SelectSubset<T, AdminTransactionUpsertArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionCountArgs} args - Arguments to filter AdminTransactions to count.
     * @example
     * // Count the number of AdminTransactions
     * const count = await prisma.adminTransaction.count({
     *   where: {
     *     // ... the filter for the AdminTransactions we want to count
     *   }
     * })
    **/
    count<T extends AdminTransactionCountArgs>(
      args?: Subset<T, AdminTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminTransactionAggregateArgs>(args: Subset<T, AdminTransactionAggregateArgs>): Prisma.PrismaPromise<GetAdminTransactionAggregateType<T>>

    /**
     * Group by AdminTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminTransactionGroupByArgs['orderBy'] }
        : { orderBy?: AdminTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminTransaction model
   */
  readonly fields: AdminTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    redeemCode<T extends AdminTransaction$redeemCodeArgs<ExtArgs> = {}>(args?: Subset<T, AdminTransaction$redeemCodeArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends AdminTransaction$processedByArgs<ExtArgs> = {}>(args?: Subset<T, AdminTransaction$processedByArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminTransaction model
   */
  interface AdminTransactionFieldRefs {
    readonly id: FieldRef<"AdminTransaction", 'String'>
    readonly name: FieldRef<"AdminTransaction", 'String'>
    readonly status: FieldRef<"AdminTransaction", 'Transaction'>
    readonly archived: FieldRef<"AdminTransaction", 'Boolean'>
    readonly createdAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminTransaction", 'DateTime'>
    readonly adminId: FieldRef<"AdminTransaction", 'String'>
    readonly quantity: FieldRef<"AdminTransaction", 'Int'>
    readonly subscriptionTime: FieldRef<"AdminTransaction", 'Int'>
    readonly zones: FieldRef<"AdminTransaction", 'String[]'>
    readonly transactionRef: FieldRef<"AdminTransaction", 'String'>
    readonly amount: FieldRef<"AdminTransaction", 'Int'>
    readonly description: FieldRef<"AdminTransaction", 'String'>
    readonly transactionImageId: FieldRef<"AdminTransaction", 'String'>
    readonly transactionImageUrl: FieldRef<"AdminTransaction", 'String'>
    readonly processedById: FieldRef<"AdminTransaction", 'String'>
    readonly processedAt: FieldRef<"AdminTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminTransaction findUnique
   */
  export type AdminTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction findUniqueOrThrow
   */
  export type AdminTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction findFirst
   */
  export type AdminTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactions.
     */
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction findFirstOrThrow
   */
  export type AdminTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransaction to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminTransactions.
     */
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction findMany
   */
  export type AdminTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter, which AdminTransactions to fetch.
     */
    where?: AdminTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminTransactions to fetch.
     */
    orderBy?: AdminTransactionOrderByWithRelationInput | AdminTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminTransactions.
     */
    cursor?: AdminTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminTransactions.
     */
    skip?: number
    distinct?: AdminTransactionScalarFieldEnum | AdminTransactionScalarFieldEnum[]
  }

  /**
   * AdminTransaction create
   */
  export type AdminTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminTransaction.
     */
    data: XOR<AdminTransactionCreateInput, AdminTransactionUncheckedCreateInput>
  }

  /**
   * AdminTransaction createMany
   */
  export type AdminTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminTransactions.
     */
    data: AdminTransactionCreateManyInput | AdminTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminTransaction createManyAndReturn
   */
  export type AdminTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminTransactions.
     */
    data: AdminTransactionCreateManyInput | AdminTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransaction update
   */
  export type AdminTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminTransaction.
     */
    data: XOR<AdminTransactionUpdateInput, AdminTransactionUncheckedUpdateInput>
    /**
     * Choose, which AdminTransaction to update.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction updateMany
   */
  export type AdminTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminTransactions.
     */
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactions to update
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to update.
     */
    limit?: number
  }

  /**
   * AdminTransaction updateManyAndReturn
   */
  export type AdminTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * The data used to update AdminTransactions.
     */
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyInput>
    /**
     * Filter which AdminTransactions to update
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminTransaction upsert
   */
  export type AdminTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminTransaction to update in case it exists.
     */
    where: AdminTransactionWhereUniqueInput
    /**
     * In case the AdminTransaction found by the `where` argument doesn't exist, create a new AdminTransaction with this data.
     */
    create: XOR<AdminTransactionCreateInput, AdminTransactionUncheckedCreateInput>
    /**
     * In case the AdminTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminTransactionUpdateInput, AdminTransactionUncheckedUpdateInput>
  }

  /**
   * AdminTransaction delete
   */
  export type AdminTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
    /**
     * Filter which AdminTransaction to delete.
     */
    where: AdminTransactionWhereUniqueInput
  }

  /**
   * AdminTransaction deleteMany
   */
  export type AdminTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminTransactions to delete
     */
    where?: AdminTransactionWhereInput
    /**
     * Limit how many AdminTransactions to delete.
     */
    limit?: number
  }

  /**
   * AdminTransaction.redeemCode
   */
  export type AdminTransaction$redeemCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    where?: RedeemCodeWhereInput
  }

  /**
   * AdminTransaction.processedBy
   */
  export type AdminTransaction$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * AdminTransaction without action
   */
  export type AdminTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminTransaction
     */
    select?: AdminTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminTransaction
     */
    omit?: AdminTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminTransactionInclude<ExtArgs> | null
  }


  /**
   * Model RedeemCode
   */

  export type AggregateRedeemCode = {
    _count: RedeemCodeCountAggregateOutputType | null
    _avg: RedeemCodeAvgAggregateOutputType | null
    _sum: RedeemCodeSumAggregateOutputType | null
    _min: RedeemCodeMinAggregateOutputType | null
    _max: RedeemCodeMaxAggregateOutputType | null
  }

  export type RedeemCodeAvgAggregateOutputType = {
    currentAmount: number | null
    maxAmount: number | null
  }

  export type RedeemCodeSumAggregateOutputType = {
    currentAmount: number | null
    maxAmount: number | null
  }

  export type RedeemCodeMinAggregateOutputType = {
    id: string | null
    suspend: boolean | null
    transactionId: string | null
    adminId: string | null
    code: string | null
    expiredAt: Date | null
    currentAmount: number | null
    maxAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RedeemCodeMaxAggregateOutputType = {
    id: string | null
    suspend: boolean | null
    transactionId: string | null
    adminId: string | null
    code: string | null
    expiredAt: Date | null
    currentAmount: number | null
    maxAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RedeemCodeCountAggregateOutputType = {
    id: number
    suspend: number
    transactionId: number
    adminId: number
    code: number
    expiredAt: number
    currentAmount: number
    maxAmount: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RedeemCodeAvgAggregateInputType = {
    currentAmount?: true
    maxAmount?: true
  }

  export type RedeemCodeSumAggregateInputType = {
    currentAmount?: true
    maxAmount?: true
  }

  export type RedeemCodeMinAggregateInputType = {
    id?: true
    suspend?: true
    transactionId?: true
    adminId?: true
    code?: true
    expiredAt?: true
    currentAmount?: true
    maxAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RedeemCodeMaxAggregateInputType = {
    id?: true
    suspend?: true
    transactionId?: true
    adminId?: true
    code?: true
    expiredAt?: true
    currentAmount?: true
    maxAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RedeemCodeCountAggregateInputType = {
    id?: true
    suspend?: true
    transactionId?: true
    adminId?: true
    code?: true
    expiredAt?: true
    currentAmount?: true
    maxAmount?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RedeemCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCode to aggregate.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedeemCodes
    **/
    _count?: true | RedeemCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedeemCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedeemCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedeemCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedeemCodeMaxAggregateInputType
  }

  export type GetRedeemCodeAggregateType<T extends RedeemCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemCode[P]>
      : GetScalarType<T[P], AggregateRedeemCode[P]>
  }




  export type RedeemCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedeemCodeWhereInput
    orderBy?: RedeemCodeOrderByWithAggregationInput | RedeemCodeOrderByWithAggregationInput[]
    by: RedeemCodeScalarFieldEnum[] | RedeemCodeScalarFieldEnum
    having?: RedeemCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedeemCodeCountAggregateInputType | true
    _avg?: RedeemCodeAvgAggregateInputType
    _sum?: RedeemCodeSumAggregateInputType
    _min?: RedeemCodeMinAggregateInputType
    _max?: RedeemCodeMaxAggregateInputType
  }

  export type RedeemCodeGroupByOutputType = {
    id: string
    suspend: boolean
    transactionId: string
    adminId: string
    code: string
    expiredAt: Date
    currentAmount: number
    maxAmount: number
    data: string[]
    createdAt: Date
    updatedAt: Date
    _count: RedeemCodeCountAggregateOutputType | null
    _avg: RedeemCodeAvgAggregateOutputType | null
    _sum: RedeemCodeSumAggregateOutputType | null
    _min: RedeemCodeMinAggregateOutputType | null
    _max: RedeemCodeMaxAggregateOutputType | null
  }

  type GetRedeemCodeGroupByPayload<T extends RedeemCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedeemCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedeemCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedeemCodeGroupByOutputType[P]>
            : GetScalarType<T[P], RedeemCodeGroupByOutputType[P]>
        }
      >
    >


  export type RedeemCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suspend?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    redemeers?: boolean | RedeemCode$redemeersArgs<ExtArgs>
    _count?: boolean | RedeemCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suspend?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suspend?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redeemCode"]>

  export type RedeemCodeSelectScalar = {
    id?: boolean
    suspend?: boolean
    transactionId?: boolean
    adminId?: boolean
    code?: boolean
    expiredAt?: boolean
    currentAmount?: boolean
    maxAmount?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RedeemCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "suspend" | "transactionId" | "adminId" | "code" | "expiredAt" | "currentAmount" | "maxAmount" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["redeemCode"]>
  export type RedeemCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    redemeers?: boolean | RedeemCode$redemeersArgs<ExtArgs>
    _count?: boolean | RedeemCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RedeemCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type RedeemCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | AdminTransactionDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $RedeemCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedeemCode"
    objects: {
      transaction: Prisma.$AdminTransactionPayload<ExtArgs>
      admin: Prisma.$AdminPayload<ExtArgs>
      redemeers: Prisma.$CodeRedemeerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      suspend: boolean
      transactionId: string
      adminId: string
      code: string
      expiredAt: Date
      currentAmount: number
      maxAmount: number
      data: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["redeemCode"]>
    composites: {}
  }

  type RedeemCodeGetPayload<S extends boolean | null | undefined | RedeemCodeDefaultArgs> = $Result.GetResult<Prisma.$RedeemCodePayload, S>

  type RedeemCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedeemCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedeemCodeCountAggregateInputType | true
    }

  export interface RedeemCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedeemCode'], meta: { name: 'RedeemCode' } }
    /**
     * Find zero or one RedeemCode that matches the filter.
     * @param {RedeemCodeFindUniqueArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedeemCodeFindUniqueArgs>(args: SelectSubset<T, RedeemCodeFindUniqueArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RedeemCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedeemCodeFindUniqueOrThrowArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedeemCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, RedeemCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindFirstArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedeemCodeFindFirstArgs>(args?: SelectSubset<T, RedeemCodeFindFirstArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RedeemCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindFirstOrThrowArgs} args - Arguments to find a RedeemCode
     * @example
     * // Get one RedeemCode
     * const redeemCode = await prisma.redeemCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedeemCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, RedeemCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RedeemCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedeemCodes
     * const redeemCodes = await prisma.redeemCode.findMany()
     * 
     * // Get first 10 RedeemCodes
     * const redeemCodes = await prisma.redeemCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedeemCodeFindManyArgs>(args?: SelectSubset<T, RedeemCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RedeemCode.
     * @param {RedeemCodeCreateArgs} args - Arguments to create a RedeemCode.
     * @example
     * // Create one RedeemCode
     * const RedeemCode = await prisma.redeemCode.create({
     *   data: {
     *     // ... data to create a RedeemCode
     *   }
     * })
     * 
     */
    create<T extends RedeemCodeCreateArgs>(args: SelectSubset<T, RedeemCodeCreateArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RedeemCodes.
     * @param {RedeemCodeCreateManyArgs} args - Arguments to create many RedeemCodes.
     * @example
     * // Create many RedeemCodes
     * const redeemCode = await prisma.redeemCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedeemCodeCreateManyArgs>(args?: SelectSubset<T, RedeemCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RedeemCodes and returns the data saved in the database.
     * @param {RedeemCodeCreateManyAndReturnArgs} args - Arguments to create many RedeemCodes.
     * @example
     * // Create many RedeemCodes
     * const redeemCode = await prisma.redeemCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RedeemCodes and only return the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedeemCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, RedeemCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RedeemCode.
     * @param {RedeemCodeDeleteArgs} args - Arguments to delete one RedeemCode.
     * @example
     * // Delete one RedeemCode
     * const RedeemCode = await prisma.redeemCode.delete({
     *   where: {
     *     // ... filter to delete one RedeemCode
     *   }
     * })
     * 
     */
    delete<T extends RedeemCodeDeleteArgs>(args: SelectSubset<T, RedeemCodeDeleteArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RedeemCode.
     * @param {RedeemCodeUpdateArgs} args - Arguments to update one RedeemCode.
     * @example
     * // Update one RedeemCode
     * const redeemCode = await prisma.redeemCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedeemCodeUpdateArgs>(args: SelectSubset<T, RedeemCodeUpdateArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RedeemCodes.
     * @param {RedeemCodeDeleteManyArgs} args - Arguments to filter RedeemCodes to delete.
     * @example
     * // Delete a few RedeemCodes
     * const { count } = await prisma.redeemCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedeemCodeDeleteManyArgs>(args?: SelectSubset<T, RedeemCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedeemCodes
     * const redeemCode = await prisma.redeemCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedeemCodeUpdateManyArgs>(args: SelectSubset<T, RedeemCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedeemCodes and returns the data updated in the database.
     * @param {RedeemCodeUpdateManyAndReturnArgs} args - Arguments to update many RedeemCodes.
     * @example
     * // Update many RedeemCodes
     * const redeemCode = await prisma.redeemCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RedeemCodes and only return the `id`
     * const redeemCodeWithIdOnly = await prisma.redeemCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RedeemCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, RedeemCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RedeemCode.
     * @param {RedeemCodeUpsertArgs} args - Arguments to update or create a RedeemCode.
     * @example
     * // Update or create a RedeemCode
     * const redeemCode = await prisma.redeemCode.upsert({
     *   create: {
     *     // ... data to create a RedeemCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedeemCode we want to update
     *   }
     * })
     */
    upsert<T extends RedeemCodeUpsertArgs>(args: SelectSubset<T, RedeemCodeUpsertArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RedeemCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeCountArgs} args - Arguments to filter RedeemCodes to count.
     * @example
     * // Count the number of RedeemCodes
     * const count = await prisma.redeemCode.count({
     *   where: {
     *     // ... the filter for the RedeemCodes we want to count
     *   }
     * })
    **/
    count<T extends RedeemCodeCountArgs>(
      args?: Subset<T, RedeemCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedeemCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedeemCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedeemCodeAggregateArgs>(args: Subset<T, RedeemCodeAggregateArgs>): Prisma.PrismaPromise<GetRedeemCodeAggregateType<T>>

    /**
     * Group by RedeemCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedeemCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedeemCodeGroupByArgs['orderBy'] }
        : { orderBy?: RedeemCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedeemCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedeemCode model
   */
  readonly fields: RedeemCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedeemCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedeemCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends AdminTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminTransactionDefaultArgs<ExtArgs>>): Prisma__AdminTransactionClient<$Result.GetResult<Prisma.$AdminTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    redemeers<T extends RedeemCode$redemeersArgs<ExtArgs> = {}>(args?: Subset<T, RedeemCode$redemeersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedeemCode model
   */
  interface RedeemCodeFieldRefs {
    readonly id: FieldRef<"RedeemCode", 'String'>
    readonly suspend: FieldRef<"RedeemCode", 'Boolean'>
    readonly transactionId: FieldRef<"RedeemCode", 'String'>
    readonly adminId: FieldRef<"RedeemCode", 'String'>
    readonly code: FieldRef<"RedeemCode", 'String'>
    readonly expiredAt: FieldRef<"RedeemCode", 'DateTime'>
    readonly currentAmount: FieldRef<"RedeemCode", 'Int'>
    readonly maxAmount: FieldRef<"RedeemCode", 'Int'>
    readonly data: FieldRef<"RedeemCode", 'String[]'>
    readonly createdAt: FieldRef<"RedeemCode", 'DateTime'>
    readonly updatedAt: FieldRef<"RedeemCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RedeemCode findUnique
   */
  export type RedeemCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode findUniqueOrThrow
   */
  export type RedeemCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode findFirst
   */
  export type RedeemCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodes.
     */
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode findFirstOrThrow
   */
  export type RedeemCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCode to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedeemCodes.
     */
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode findMany
   */
  export type RedeemCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter, which RedeemCodes to fetch.
     */
    where?: RedeemCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedeemCodes to fetch.
     */
    orderBy?: RedeemCodeOrderByWithRelationInput | RedeemCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedeemCodes.
     */
    cursor?: RedeemCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedeemCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedeemCodes.
     */
    skip?: number
    distinct?: RedeemCodeScalarFieldEnum | RedeemCodeScalarFieldEnum[]
  }

  /**
   * RedeemCode create
   */
  export type RedeemCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a RedeemCode.
     */
    data: XOR<RedeemCodeCreateInput, RedeemCodeUncheckedCreateInput>
  }

  /**
   * RedeemCode createMany
   */
  export type RedeemCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedeemCodes.
     */
    data: RedeemCodeCreateManyInput | RedeemCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedeemCode createManyAndReturn
   */
  export type RedeemCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * The data used to create many RedeemCodes.
     */
    data: RedeemCodeCreateManyInput | RedeemCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemCode update
   */
  export type RedeemCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a RedeemCode.
     */
    data: XOR<RedeemCodeUpdateInput, RedeemCodeUncheckedUpdateInput>
    /**
     * Choose, which RedeemCode to update.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode updateMany
   */
  export type RedeemCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedeemCodes.
     */
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodes to update
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to update.
     */
    limit?: number
  }

  /**
   * RedeemCode updateManyAndReturn
   */
  export type RedeemCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * The data used to update RedeemCodes.
     */
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyInput>
    /**
     * Filter which RedeemCodes to update
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RedeemCode upsert
   */
  export type RedeemCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the RedeemCode to update in case it exists.
     */
    where: RedeemCodeWhereUniqueInput
    /**
     * In case the RedeemCode found by the `where` argument doesn't exist, create a new RedeemCode with this data.
     */
    create: XOR<RedeemCodeCreateInput, RedeemCodeUncheckedCreateInput>
    /**
     * In case the RedeemCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedeemCodeUpdateInput, RedeemCodeUncheckedUpdateInput>
  }

  /**
   * RedeemCode delete
   */
  export type RedeemCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
    /**
     * Filter which RedeemCode to delete.
     */
    where: RedeemCodeWhereUniqueInput
  }

  /**
   * RedeemCode deleteMany
   */
  export type RedeemCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedeemCodes to delete
     */
    where?: RedeemCodeWhereInput
    /**
     * Limit how many RedeemCodes to delete.
     */
    limit?: number
  }

  /**
   * RedeemCode.redemeers
   */
  export type RedeemCode$redemeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    where?: CodeRedemeerWhereInput
    orderBy?: CodeRedemeerOrderByWithRelationInput | CodeRedemeerOrderByWithRelationInput[]
    cursor?: CodeRedemeerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeRedemeerScalarFieldEnum | CodeRedemeerScalarFieldEnum[]
  }

  /**
   * RedeemCode without action
   */
  export type RedeemCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedeemCode
     */
    select?: RedeemCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RedeemCode
     */
    omit?: RedeemCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedeemCodeInclude<ExtArgs> | null
  }


  /**
   * Model CodeRedemeer
   */

  export type AggregateCodeRedemeer = {
    _count: CodeRedemeerCountAggregateOutputType | null
    _min: CodeRedemeerMinAggregateOutputType | null
    _max: CodeRedemeerMaxAggregateOutputType | null
  }

  export type CodeRedemeerMinAggregateOutputType = {
    id: string | null
    banned: boolean | null
    userId: string | null
    codeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeRedemeerMaxAggregateOutputType = {
    id: string | null
    banned: boolean | null
    userId: string | null
    codeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeRedemeerCountAggregateOutputType = {
    id: number
    banned: number
    userId: number
    codeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodeRedemeerMinAggregateInputType = {
    id?: true
    banned?: true
    userId?: true
    codeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeRedemeerMaxAggregateInputType = {
    id?: true
    banned?: true
    userId?: true
    codeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeRedemeerCountAggregateInputType = {
    id?: true
    banned?: true
    userId?: true
    codeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodeRedemeerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeRedemeer to aggregate.
     */
    where?: CodeRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedemeers to fetch.
     */
    orderBy?: CodeRedemeerOrderByWithRelationInput | CodeRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedemeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeRedemeers
    **/
    _count?: true | CodeRedemeerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeRedemeerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeRedemeerMaxAggregateInputType
  }

  export type GetCodeRedemeerAggregateType<T extends CodeRedemeerAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeRedemeer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeRedemeer[P]>
      : GetScalarType<T[P], AggregateCodeRedemeer[P]>
  }




  export type CodeRedemeerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeRedemeerWhereInput
    orderBy?: CodeRedemeerOrderByWithAggregationInput | CodeRedemeerOrderByWithAggregationInput[]
    by: CodeRedemeerScalarFieldEnum[] | CodeRedemeerScalarFieldEnum
    having?: CodeRedemeerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeRedemeerCountAggregateInputType | true
    _min?: CodeRedemeerMinAggregateInputType
    _max?: CodeRedemeerMaxAggregateInputType
  }

  export type CodeRedemeerGroupByOutputType = {
    id: string
    banned: boolean
    userId: string
    codeId: string
    createdAt: Date
    updatedAt: Date
    _count: CodeRedemeerCountAggregateOutputType | null
    _min: CodeRedemeerMinAggregateOutputType | null
    _max: CodeRedemeerMaxAggregateOutputType | null
  }

  type GetCodeRedemeerGroupByPayload<T extends CodeRedemeerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodeRedemeerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeRedemeerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeRedemeerGroupByOutputType[P]>
            : GetScalarType<T[P], CodeRedemeerGroupByOutputType[P]>
        }
      >
    >


  export type CodeRedemeerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeRedemeer"]>

  export type CodeRedemeerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeRedemeer"]>

  export type CodeRedemeerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeRedemeer"]>

  export type CodeRedemeerSelectScalar = {
    id?: boolean
    banned?: boolean
    userId?: boolean
    codeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CodeRedemeerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "banned" | "userId" | "codeId" | "createdAt" | "updatedAt", ExtArgs["result"]["codeRedemeer"]>
  export type CodeRedemeerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
  }
  export type CodeRedemeerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
  }
  export type CodeRedemeerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    code?: boolean | RedeemCodeDefaultArgs<ExtArgs>
  }

  export type $CodeRedemeerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodeRedemeer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      code: Prisma.$RedeemCodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      banned: boolean
      userId: string
      codeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["codeRedemeer"]>
    composites: {}
  }

  type CodeRedemeerGetPayload<S extends boolean | null | undefined | CodeRedemeerDefaultArgs> = $Result.GetResult<Prisma.$CodeRedemeerPayload, S>

  type CodeRedemeerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CodeRedemeerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CodeRedemeerCountAggregateInputType | true
    }

  export interface CodeRedemeerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodeRedemeer'], meta: { name: 'CodeRedemeer' } }
    /**
     * Find zero or one CodeRedemeer that matches the filter.
     * @param {CodeRedemeerFindUniqueArgs} args - Arguments to find a CodeRedemeer
     * @example
     * // Get one CodeRedemeer
     * const codeRedemeer = await prisma.codeRedemeer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodeRedemeerFindUniqueArgs>(args: SelectSubset<T, CodeRedemeerFindUniqueArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CodeRedemeer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CodeRedemeerFindUniqueOrThrowArgs} args - Arguments to find a CodeRedemeer
     * @example
     * // Get one CodeRedemeer
     * const codeRedemeer = await prisma.codeRedemeer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodeRedemeerFindUniqueOrThrowArgs>(args: SelectSubset<T, CodeRedemeerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeRedemeer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerFindFirstArgs} args - Arguments to find a CodeRedemeer
     * @example
     * // Get one CodeRedemeer
     * const codeRedemeer = await prisma.codeRedemeer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodeRedemeerFindFirstArgs>(args?: SelectSubset<T, CodeRedemeerFindFirstArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeRedemeer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerFindFirstOrThrowArgs} args - Arguments to find a CodeRedemeer
     * @example
     * // Get one CodeRedemeer
     * const codeRedemeer = await prisma.codeRedemeer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodeRedemeerFindFirstOrThrowArgs>(args?: SelectSubset<T, CodeRedemeerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CodeRedemeers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeRedemeers
     * const codeRedemeers = await prisma.codeRedemeer.findMany()
     * 
     * // Get first 10 CodeRedemeers
     * const codeRedemeers = await prisma.codeRedemeer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeRedemeerWithIdOnly = await prisma.codeRedemeer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CodeRedemeerFindManyArgs>(args?: SelectSubset<T, CodeRedemeerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CodeRedemeer.
     * @param {CodeRedemeerCreateArgs} args - Arguments to create a CodeRedemeer.
     * @example
     * // Create one CodeRedemeer
     * const CodeRedemeer = await prisma.codeRedemeer.create({
     *   data: {
     *     // ... data to create a CodeRedemeer
     *   }
     * })
     * 
     */
    create<T extends CodeRedemeerCreateArgs>(args: SelectSubset<T, CodeRedemeerCreateArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CodeRedemeers.
     * @param {CodeRedemeerCreateManyArgs} args - Arguments to create many CodeRedemeers.
     * @example
     * // Create many CodeRedemeers
     * const codeRedemeer = await prisma.codeRedemeer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodeRedemeerCreateManyArgs>(args?: SelectSubset<T, CodeRedemeerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CodeRedemeers and returns the data saved in the database.
     * @param {CodeRedemeerCreateManyAndReturnArgs} args - Arguments to create many CodeRedemeers.
     * @example
     * // Create many CodeRedemeers
     * const codeRedemeer = await prisma.codeRedemeer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CodeRedemeers and only return the `id`
     * const codeRedemeerWithIdOnly = await prisma.codeRedemeer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CodeRedemeerCreateManyAndReturnArgs>(args?: SelectSubset<T, CodeRedemeerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CodeRedemeer.
     * @param {CodeRedemeerDeleteArgs} args - Arguments to delete one CodeRedemeer.
     * @example
     * // Delete one CodeRedemeer
     * const CodeRedemeer = await prisma.codeRedemeer.delete({
     *   where: {
     *     // ... filter to delete one CodeRedemeer
     *   }
     * })
     * 
     */
    delete<T extends CodeRedemeerDeleteArgs>(args: SelectSubset<T, CodeRedemeerDeleteArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CodeRedemeer.
     * @param {CodeRedemeerUpdateArgs} args - Arguments to update one CodeRedemeer.
     * @example
     * // Update one CodeRedemeer
     * const codeRedemeer = await prisma.codeRedemeer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodeRedemeerUpdateArgs>(args: SelectSubset<T, CodeRedemeerUpdateArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CodeRedemeers.
     * @param {CodeRedemeerDeleteManyArgs} args - Arguments to filter CodeRedemeers to delete.
     * @example
     * // Delete a few CodeRedemeers
     * const { count } = await prisma.codeRedemeer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodeRedemeerDeleteManyArgs>(args?: SelectSubset<T, CodeRedemeerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeRedemeers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeRedemeers
     * const codeRedemeer = await prisma.codeRedemeer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodeRedemeerUpdateManyArgs>(args: SelectSubset<T, CodeRedemeerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeRedemeers and returns the data updated in the database.
     * @param {CodeRedemeerUpdateManyAndReturnArgs} args - Arguments to update many CodeRedemeers.
     * @example
     * // Update many CodeRedemeers
     * const codeRedemeer = await prisma.codeRedemeer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CodeRedemeers and only return the `id`
     * const codeRedemeerWithIdOnly = await prisma.codeRedemeer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CodeRedemeerUpdateManyAndReturnArgs>(args: SelectSubset<T, CodeRedemeerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CodeRedemeer.
     * @param {CodeRedemeerUpsertArgs} args - Arguments to update or create a CodeRedemeer.
     * @example
     * // Update or create a CodeRedemeer
     * const codeRedemeer = await prisma.codeRedemeer.upsert({
     *   create: {
     *     // ... data to create a CodeRedemeer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeRedemeer we want to update
     *   }
     * })
     */
    upsert<T extends CodeRedemeerUpsertArgs>(args: SelectSubset<T, CodeRedemeerUpsertArgs<ExtArgs>>): Prisma__CodeRedemeerClient<$Result.GetResult<Prisma.$CodeRedemeerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CodeRedemeers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerCountArgs} args - Arguments to filter CodeRedemeers to count.
     * @example
     * // Count the number of CodeRedemeers
     * const count = await prisma.codeRedemeer.count({
     *   where: {
     *     // ... the filter for the CodeRedemeers we want to count
     *   }
     * })
    **/
    count<T extends CodeRedemeerCountArgs>(
      args?: Subset<T, CodeRedemeerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeRedemeerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeRedemeer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeRedemeerAggregateArgs>(args: Subset<T, CodeRedemeerAggregateArgs>): Prisma.PrismaPromise<GetCodeRedemeerAggregateType<T>>

    /**
     * Group by CodeRedemeer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeRedemeerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeRedemeerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeRedemeerGroupByArgs['orderBy'] }
        : { orderBy?: CodeRedemeerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeRedemeerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeRedemeerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodeRedemeer model
   */
  readonly fields: CodeRedemeerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeRedemeer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodeRedemeerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    code<T extends RedeemCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RedeemCodeDefaultArgs<ExtArgs>>): Prisma__RedeemCodeClient<$Result.GetResult<Prisma.$RedeemCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodeRedemeer model
   */
  interface CodeRedemeerFieldRefs {
    readonly id: FieldRef<"CodeRedemeer", 'String'>
    readonly banned: FieldRef<"CodeRedemeer", 'Boolean'>
    readonly userId: FieldRef<"CodeRedemeer", 'String'>
    readonly codeId: FieldRef<"CodeRedemeer", 'String'>
    readonly createdAt: FieldRef<"CodeRedemeer", 'DateTime'>
    readonly updatedAt: FieldRef<"CodeRedemeer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CodeRedemeer findUnique
   */
  export type CodeRedemeerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedemeer to fetch.
     */
    where: CodeRedemeerWhereUniqueInput
  }

  /**
   * CodeRedemeer findUniqueOrThrow
   */
  export type CodeRedemeerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedemeer to fetch.
     */
    where: CodeRedemeerWhereUniqueInput
  }

  /**
   * CodeRedemeer findFirst
   */
  export type CodeRedemeerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedemeer to fetch.
     */
    where?: CodeRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedemeers to fetch.
     */
    orderBy?: CodeRedemeerOrderByWithRelationInput | CodeRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeRedemeers.
     */
    cursor?: CodeRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedemeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeRedemeers.
     */
    distinct?: CodeRedemeerScalarFieldEnum | CodeRedemeerScalarFieldEnum[]
  }

  /**
   * CodeRedemeer findFirstOrThrow
   */
  export type CodeRedemeerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedemeer to fetch.
     */
    where?: CodeRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedemeers to fetch.
     */
    orderBy?: CodeRedemeerOrderByWithRelationInput | CodeRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeRedemeers.
     */
    cursor?: CodeRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedemeers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeRedemeers.
     */
    distinct?: CodeRedemeerScalarFieldEnum | CodeRedemeerScalarFieldEnum[]
  }

  /**
   * CodeRedemeer findMany
   */
  export type CodeRedemeerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * Filter, which CodeRedemeers to fetch.
     */
    where?: CodeRedemeerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeRedemeers to fetch.
     */
    orderBy?: CodeRedemeerOrderByWithRelationInput | CodeRedemeerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeRedemeers.
     */
    cursor?: CodeRedemeerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeRedemeers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeRedemeers.
     */
    skip?: number
    distinct?: CodeRedemeerScalarFieldEnum | CodeRedemeerScalarFieldEnum[]
  }

  /**
   * CodeRedemeer create
   */
  export type CodeRedemeerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * The data needed to create a CodeRedemeer.
     */
    data: XOR<CodeRedemeerCreateInput, CodeRedemeerUncheckedCreateInput>
  }

  /**
   * CodeRedemeer createMany
   */
  export type CodeRedemeerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodeRedemeers.
     */
    data: CodeRedemeerCreateManyInput | CodeRedemeerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodeRedemeer createManyAndReturn
   */
  export type CodeRedemeerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * The data used to create many CodeRedemeers.
     */
    data: CodeRedemeerCreateManyInput | CodeRedemeerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeRedemeer update
   */
  export type CodeRedemeerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * The data needed to update a CodeRedemeer.
     */
    data: XOR<CodeRedemeerUpdateInput, CodeRedemeerUncheckedUpdateInput>
    /**
     * Choose, which CodeRedemeer to update.
     */
    where: CodeRedemeerWhereUniqueInput
  }

  /**
   * CodeRedemeer updateMany
   */
  export type CodeRedemeerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodeRedemeers.
     */
    data: XOR<CodeRedemeerUpdateManyMutationInput, CodeRedemeerUncheckedUpdateManyInput>
    /**
     * Filter which CodeRedemeers to update
     */
    where?: CodeRedemeerWhereInput
    /**
     * Limit how many CodeRedemeers to update.
     */
    limit?: number
  }

  /**
   * CodeRedemeer updateManyAndReturn
   */
  export type CodeRedemeerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * The data used to update CodeRedemeers.
     */
    data: XOR<CodeRedemeerUpdateManyMutationInput, CodeRedemeerUncheckedUpdateManyInput>
    /**
     * Filter which CodeRedemeers to update
     */
    where?: CodeRedemeerWhereInput
    /**
     * Limit how many CodeRedemeers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeRedemeer upsert
   */
  export type CodeRedemeerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * The filter to search for the CodeRedemeer to update in case it exists.
     */
    where: CodeRedemeerWhereUniqueInput
    /**
     * In case the CodeRedemeer found by the `where` argument doesn't exist, create a new CodeRedemeer with this data.
     */
    create: XOR<CodeRedemeerCreateInput, CodeRedemeerUncheckedCreateInput>
    /**
     * In case the CodeRedemeer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeRedemeerUpdateInput, CodeRedemeerUncheckedUpdateInput>
  }

  /**
   * CodeRedemeer delete
   */
  export type CodeRedemeerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
    /**
     * Filter which CodeRedemeer to delete.
     */
    where: CodeRedemeerWhereUniqueInput
  }

  /**
   * CodeRedemeer deleteMany
   */
  export type CodeRedemeerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeRedemeers to delete
     */
    where?: CodeRedemeerWhereInput
    /**
     * Limit how many CodeRedemeers to delete.
     */
    limit?: number
  }

  /**
   * CodeRedemeer without action
   */
  export type CodeRedemeerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeRedemeer
     */
    select?: CodeRedemeerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeRedemeer
     */
    omit?: CodeRedemeerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeRedemeerInclude<ExtArgs> | null
  }


  /**
   * Model MultiplayerRoom
   */

  export type AggregateMultiplayerRoom = {
    _count: MultiplayerRoomCountAggregateOutputType | null
    _avg: MultiplayerRoomAvgAggregateOutputType | null
    _sum: MultiplayerRoomSumAggregateOutputType | null
    _min: MultiplayerRoomMinAggregateOutputType | null
    _max: MultiplayerRoomMaxAggregateOutputType | null
  }

  export type MultiplayerRoomAvgAggregateOutputType = {
    max: number | null
    currentMember: number | null
  }

  export type MultiplayerRoomSumAggregateOutputType = {
    max: number | null
    currentMember: number | null
  }

  export type MultiplayerRoomMinAggregateOutputType = {
    id: string | null
    max: number | null
    gameplayId: string | null
    botOwner: string | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    currentMember: number | null
  }

  export type MultiplayerRoomMaxAggregateOutputType = {
    id: string | null
    max: number | null
    gameplayId: string | null
    botOwner: string | null
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean | null
    isEnded: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    currentMember: number | null
  }

  export type MultiplayerRoomCountAggregateOutputType = {
    id: number
    max: number
    gameplayId: number
    botOwner: number
    startedAt: number
    endedAt: number
    expiredAt: number
    isStarted: number
    isEnded: number
    createdAt: number
    updatedAt: number
    currentMember: number
    _all: number
  }


  export type MultiplayerRoomAvgAggregateInputType = {
    max?: true
    currentMember?: true
  }

  export type MultiplayerRoomSumAggregateInputType = {
    max?: true
    currentMember?: true
  }

  export type MultiplayerRoomMinAggregateInputType = {
    id?: true
    max?: true
    gameplayId?: true
    botOwner?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
  }

  export type MultiplayerRoomMaxAggregateInputType = {
    id?: true
    max?: true
    gameplayId?: true
    botOwner?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
  }

  export type MultiplayerRoomCountAggregateInputType = {
    id?: true
    max?: true
    gameplayId?: true
    botOwner?: true
    startedAt?: true
    endedAt?: true
    expiredAt?: true
    isStarted?: true
    isEnded?: true
    createdAt?: true
    updatedAt?: true
    currentMember?: true
    _all?: true
  }

  export type MultiplayerRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiplayerRoom to aggregate.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiplayerRooms
    **/
    _count?: true | MultiplayerRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultiplayerRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultiplayerRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiplayerRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiplayerRoomMaxAggregateInputType
  }

  export type GetMultiplayerRoomAggregateType<T extends MultiplayerRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiplayerRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiplayerRoom[P]>
      : GetScalarType<T[P], AggregateMultiplayerRoom[P]>
  }




  export type MultiplayerRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiplayerRoomWhereInput
    orderBy?: MultiplayerRoomOrderByWithAggregationInput | MultiplayerRoomOrderByWithAggregationInput[]
    by: MultiplayerRoomScalarFieldEnum[] | MultiplayerRoomScalarFieldEnum
    having?: MultiplayerRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiplayerRoomCountAggregateInputType | true
    _avg?: MultiplayerRoomAvgAggregateInputType
    _sum?: MultiplayerRoomSumAggregateInputType
    _min?: MultiplayerRoomMinAggregateInputType
    _max?: MultiplayerRoomMaxAggregateInputType
  }

  export type MultiplayerRoomGroupByOutputType = {
    id: string
    max: number
    gameplayId: string
    botOwner: string
    startedAt: Date | null
    endedAt: Date | null
    expiredAt: Date | null
    isStarted: boolean
    isEnded: boolean
    createdAt: Date
    updatedAt: Date
    currentMember: number
    _count: MultiplayerRoomCountAggregateOutputType | null
    _avg: MultiplayerRoomAvgAggregateOutputType | null
    _sum: MultiplayerRoomSumAggregateOutputType | null
    _min: MultiplayerRoomMinAggregateOutputType | null
    _max: MultiplayerRoomMaxAggregateOutputType | null
  }

  type GetMultiplayerRoomGroupByPayload<T extends MultiplayerRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiplayerRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiplayerRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiplayerRoomGroupByOutputType[P]>
            : GetScalarType<T[P], MultiplayerRoomGroupByOutputType[P]>
        }
      >
    >


  export type MultiplayerRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
    members?: boolean | MultiplayerRoom$membersArgs<ExtArgs>
    _count?: boolean | MultiplayerRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiplayerRoom"]>

  export type MultiplayerRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }, ExtArgs["result"]["multiplayerRoom"]>

  export type MultiplayerRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }, ExtArgs["result"]["multiplayerRoom"]>

  export type MultiplayerRoomSelectScalar = {
    id?: boolean
    max?: boolean
    gameplayId?: boolean
    botOwner?: boolean
    startedAt?: boolean
    endedAt?: boolean
    expiredAt?: boolean
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMember?: boolean
  }

  export type MultiplayerRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "max" | "gameplayId" | "botOwner" | "startedAt" | "endedAt" | "expiredAt" | "isStarted" | "isEnded" | "createdAt" | "updatedAt" | "currentMember", ExtArgs["result"]["multiplayerRoom"]>
  export type MultiplayerRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MultiplayerRoom$membersArgs<ExtArgs>
    _count?: boolean | MultiplayerRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MultiplayerRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MultiplayerRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MultiplayerRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiplayerRoom"
    objects: {
      members: Prisma.$MultiPlayerMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      max: number
      gameplayId: string
      botOwner: string
      startedAt: Date | null
      endedAt: Date | null
      expiredAt: Date | null
      isStarted: boolean
      isEnded: boolean
      createdAt: Date
      updatedAt: Date
      currentMember: number
    }, ExtArgs["result"]["multiplayerRoom"]>
    composites: {}
  }

  type MultiplayerRoomGetPayload<S extends boolean | null | undefined | MultiplayerRoomDefaultArgs> = $Result.GetResult<Prisma.$MultiplayerRoomPayload, S>

  type MultiplayerRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultiplayerRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultiplayerRoomCountAggregateInputType | true
    }

  export interface MultiplayerRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiplayerRoom'], meta: { name: 'MultiplayerRoom' } }
    /**
     * Find zero or one MultiplayerRoom that matches the filter.
     * @param {MultiplayerRoomFindUniqueArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultiplayerRoomFindUniqueArgs>(args: SelectSubset<T, MultiplayerRoomFindUniqueArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultiplayerRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultiplayerRoomFindUniqueOrThrowArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultiplayerRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, MultiplayerRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiplayerRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomFindFirstArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultiplayerRoomFindFirstArgs>(args?: SelectSubset<T, MultiplayerRoomFindFirstArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiplayerRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomFindFirstOrThrowArgs} args - Arguments to find a MultiplayerRoom
     * @example
     * // Get one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultiplayerRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, MultiplayerRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultiplayerRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiplayerRooms
     * const multiplayerRooms = await prisma.multiplayerRoom.findMany()
     * 
     * // Get first 10 MultiplayerRooms
     * const multiplayerRooms = await prisma.multiplayerRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiplayerRoomWithIdOnly = await prisma.multiplayerRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultiplayerRoomFindManyArgs>(args?: SelectSubset<T, MultiplayerRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultiplayerRoom.
     * @param {MultiplayerRoomCreateArgs} args - Arguments to create a MultiplayerRoom.
     * @example
     * // Create one MultiplayerRoom
     * const MultiplayerRoom = await prisma.multiplayerRoom.create({
     *   data: {
     *     // ... data to create a MultiplayerRoom
     *   }
     * })
     * 
     */
    create<T extends MultiplayerRoomCreateArgs>(args: SelectSubset<T, MultiplayerRoomCreateArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultiplayerRooms.
     * @param {MultiplayerRoomCreateManyArgs} args - Arguments to create many MultiplayerRooms.
     * @example
     * // Create many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultiplayerRoomCreateManyArgs>(args?: SelectSubset<T, MultiplayerRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultiplayerRooms and returns the data saved in the database.
     * @param {MultiplayerRoomCreateManyAndReturnArgs} args - Arguments to create many MultiplayerRooms.
     * @example
     * // Create many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultiplayerRooms and only return the `id`
     * const multiplayerRoomWithIdOnly = await prisma.multiplayerRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultiplayerRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, MultiplayerRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultiplayerRoom.
     * @param {MultiplayerRoomDeleteArgs} args - Arguments to delete one MultiplayerRoom.
     * @example
     * // Delete one MultiplayerRoom
     * const MultiplayerRoom = await prisma.multiplayerRoom.delete({
     *   where: {
     *     // ... filter to delete one MultiplayerRoom
     *   }
     * })
     * 
     */
    delete<T extends MultiplayerRoomDeleteArgs>(args: SelectSubset<T, MultiplayerRoomDeleteArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultiplayerRoom.
     * @param {MultiplayerRoomUpdateArgs} args - Arguments to update one MultiplayerRoom.
     * @example
     * // Update one MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultiplayerRoomUpdateArgs>(args: SelectSubset<T, MultiplayerRoomUpdateArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultiplayerRooms.
     * @param {MultiplayerRoomDeleteManyArgs} args - Arguments to filter MultiplayerRooms to delete.
     * @example
     * // Delete a few MultiplayerRooms
     * const { count } = await prisma.multiplayerRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultiplayerRoomDeleteManyArgs>(args?: SelectSubset<T, MultiplayerRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiplayerRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultiplayerRoomUpdateManyArgs>(args: SelectSubset<T, MultiplayerRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiplayerRooms and returns the data updated in the database.
     * @param {MultiplayerRoomUpdateManyAndReturnArgs} args - Arguments to update many MultiplayerRooms.
     * @example
     * // Update many MultiplayerRooms
     * const multiplayerRoom = await prisma.multiplayerRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultiplayerRooms and only return the `id`
     * const multiplayerRoomWithIdOnly = await prisma.multiplayerRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultiplayerRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, MultiplayerRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultiplayerRoom.
     * @param {MultiplayerRoomUpsertArgs} args - Arguments to update or create a MultiplayerRoom.
     * @example
     * // Update or create a MultiplayerRoom
     * const multiplayerRoom = await prisma.multiplayerRoom.upsert({
     *   create: {
     *     // ... data to create a MultiplayerRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiplayerRoom we want to update
     *   }
     * })
     */
    upsert<T extends MultiplayerRoomUpsertArgs>(args: SelectSubset<T, MultiplayerRoomUpsertArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultiplayerRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomCountArgs} args - Arguments to filter MultiplayerRooms to count.
     * @example
     * // Count the number of MultiplayerRooms
     * const count = await prisma.multiplayerRoom.count({
     *   where: {
     *     // ... the filter for the MultiplayerRooms we want to count
     *   }
     * })
    **/
    count<T extends MultiplayerRoomCountArgs>(
      args?: Subset<T, MultiplayerRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiplayerRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiplayerRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiplayerRoomAggregateArgs>(args: Subset<T, MultiplayerRoomAggregateArgs>): Prisma.PrismaPromise<GetMultiplayerRoomAggregateType<T>>

    /**
     * Group by MultiplayerRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiplayerRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiplayerRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiplayerRoomGroupByArgs['orderBy'] }
        : { orderBy?: MultiplayerRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiplayerRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiplayerRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiplayerRoom model
   */
  readonly fields: MultiplayerRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiplayerRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiplayerRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends MultiplayerRoom$membersArgs<ExtArgs> = {}>(args?: Subset<T, MultiplayerRoom$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultiplayerRoom model
   */
  interface MultiplayerRoomFieldRefs {
    readonly id: FieldRef<"MultiplayerRoom", 'String'>
    readonly max: FieldRef<"MultiplayerRoom", 'Int'>
    readonly gameplayId: FieldRef<"MultiplayerRoom", 'String'>
    readonly botOwner: FieldRef<"MultiplayerRoom", 'String'>
    readonly startedAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly endedAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly expiredAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly isStarted: FieldRef<"MultiplayerRoom", 'Boolean'>
    readonly isEnded: FieldRef<"MultiplayerRoom", 'Boolean'>
    readonly createdAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"MultiplayerRoom", 'DateTime'>
    readonly currentMember: FieldRef<"MultiplayerRoom", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MultiplayerRoom findUnique
   */
  export type MultiplayerRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom findUniqueOrThrow
   */
  export type MultiplayerRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom findFirst
   */
  export type MultiplayerRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiplayerRooms.
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiplayerRooms.
     */
    distinct?: MultiplayerRoomScalarFieldEnum | MultiplayerRoomScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom findFirstOrThrow
   */
  export type MultiplayerRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRoom to fetch.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiplayerRooms.
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiplayerRooms.
     */
    distinct?: MultiplayerRoomScalarFieldEnum | MultiplayerRoomScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom findMany
   */
  export type MultiplayerRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter, which MultiplayerRooms to fetch.
     */
    where?: MultiplayerRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiplayerRooms to fetch.
     */
    orderBy?: MultiplayerRoomOrderByWithRelationInput | MultiplayerRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiplayerRooms.
     */
    cursor?: MultiplayerRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiplayerRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiplayerRooms.
     */
    skip?: number
    distinct?: MultiplayerRoomScalarFieldEnum | MultiplayerRoomScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom create
   */
  export type MultiplayerRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiplayerRoom.
     */
    data: XOR<MultiplayerRoomCreateInput, MultiplayerRoomUncheckedCreateInput>
  }

  /**
   * MultiplayerRoom createMany
   */
  export type MultiplayerRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiplayerRooms.
     */
    data: MultiplayerRoomCreateManyInput | MultiplayerRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiplayerRoom createManyAndReturn
   */
  export type MultiplayerRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * The data used to create many MultiplayerRooms.
     */
    data: MultiplayerRoomCreateManyInput | MultiplayerRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiplayerRoom update
   */
  export type MultiplayerRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiplayerRoom.
     */
    data: XOR<MultiplayerRoomUpdateInput, MultiplayerRoomUncheckedUpdateInput>
    /**
     * Choose, which MultiplayerRoom to update.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom updateMany
   */
  export type MultiplayerRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiplayerRooms.
     */
    data: XOR<MultiplayerRoomUpdateManyMutationInput, MultiplayerRoomUncheckedUpdateManyInput>
    /**
     * Filter which MultiplayerRooms to update
     */
    where?: MultiplayerRoomWhereInput
    /**
     * Limit how many MultiplayerRooms to update.
     */
    limit?: number
  }

  /**
   * MultiplayerRoom updateManyAndReturn
   */
  export type MultiplayerRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * The data used to update MultiplayerRooms.
     */
    data: XOR<MultiplayerRoomUpdateManyMutationInput, MultiplayerRoomUncheckedUpdateManyInput>
    /**
     * Filter which MultiplayerRooms to update
     */
    where?: MultiplayerRoomWhereInput
    /**
     * Limit how many MultiplayerRooms to update.
     */
    limit?: number
  }

  /**
   * MultiplayerRoom upsert
   */
  export type MultiplayerRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiplayerRoom to update in case it exists.
     */
    where: MultiplayerRoomWhereUniqueInput
    /**
     * In case the MultiplayerRoom found by the `where` argument doesn't exist, create a new MultiplayerRoom with this data.
     */
    create: XOR<MultiplayerRoomCreateInput, MultiplayerRoomUncheckedCreateInput>
    /**
     * In case the MultiplayerRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiplayerRoomUpdateInput, MultiplayerRoomUncheckedUpdateInput>
  }

  /**
   * MultiplayerRoom delete
   */
  export type MultiplayerRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
    /**
     * Filter which MultiplayerRoom to delete.
     */
    where: MultiplayerRoomWhereUniqueInput
  }

  /**
   * MultiplayerRoom deleteMany
   */
  export type MultiplayerRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiplayerRooms to delete
     */
    where?: MultiplayerRoomWhereInput
    /**
     * Limit how many MultiplayerRooms to delete.
     */
    limit?: number
  }

  /**
   * MultiplayerRoom.members
   */
  export type MultiplayerRoom$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    where?: MultiPlayerMemberWhereInput
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    cursor?: MultiPlayerMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiplayerRoom without action
   */
  export type MultiplayerRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiplayerRoom
     */
    select?: MultiplayerRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiplayerRoom
     */
    omit?: MultiplayerRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiplayerRoomInclude<ExtArgs> | null
  }


  /**
   * Model MultiPlayerMember
   */

  export type AggregateMultiPlayerMember = {
    _count: MultiPlayerMemberCountAggregateOutputType | null
    _avg: MultiPlayerMemberAvgAggregateOutputType | null
    _sum: MultiPlayerMemberSumAggregateOutputType | null
    _min: MultiPlayerMemberMinAggregateOutputType | null
    _max: MultiPlayerMemberMaxAggregateOutputType | null
  }

  export type MultiPlayerMemberAvgAggregateOutputType = {
    point: number | null
    bonusPoint: number | null
  }

  export type MultiPlayerMemberSumAggregateOutputType = {
    point: number | null
    bonusPoint: number | null
  }

  export type MultiPlayerMemberMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    point: number | null
    bonusPoint: number | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MultiPlayerMemberMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    point: number | null
    bonusPoint: number | null
    isReady: boolean | null
    isComplete: boolean | null
    isBot: boolean | null
    joinedAt: Date | null
    finishedAt: Date | null
    isDisconnect: boolean | null
  }

  export type MultiPlayerMemberCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    point: number
    bonusPoint: number
    isReady: number
    isComplete: number
    isBot: number
    joinedAt: number
    finishedAt: number
    isDisconnect: number
    _all: number
  }


  export type MultiPlayerMemberAvgAggregateInputType = {
    point?: true
    bonusPoint?: true
  }

  export type MultiPlayerMemberSumAggregateInputType = {
    point?: true
    bonusPoint?: true
  }

  export type MultiPlayerMemberMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    point?: true
    bonusPoint?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MultiPlayerMemberMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    point?: true
    bonusPoint?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
  }

  export type MultiPlayerMemberCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    point?: true
    bonusPoint?: true
    isReady?: true
    isComplete?: true
    isBot?: true
    joinedAt?: true
    finishedAt?: true
    isDisconnect?: true
    _all?: true
  }

  export type MultiPlayerMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiPlayerMember to aggregate.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiPlayerMembers
    **/
    _count?: true | MultiPlayerMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultiPlayerMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultiPlayerMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiPlayerMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiPlayerMemberMaxAggregateInputType
  }

  export type GetMultiPlayerMemberAggregateType<T extends MultiPlayerMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiPlayerMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiPlayerMember[P]>
      : GetScalarType<T[P], AggregateMultiPlayerMember[P]>
  }




  export type MultiPlayerMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiPlayerMemberWhereInput
    orderBy?: MultiPlayerMemberOrderByWithAggregationInput | MultiPlayerMemberOrderByWithAggregationInput[]
    by: MultiPlayerMemberScalarFieldEnum[] | MultiPlayerMemberScalarFieldEnum
    having?: MultiPlayerMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiPlayerMemberCountAggregateInputType | true
    _avg?: MultiPlayerMemberAvgAggregateInputType
    _sum?: MultiPlayerMemberSumAggregateInputType
    _min?: MultiPlayerMemberMinAggregateInputType
    _max?: MultiPlayerMemberMaxAggregateInputType
  }

  export type MultiPlayerMemberGroupByOutputType = {
    id: string
    roomId: string
    userId: string
    point: number
    bonusPoint: number
    isReady: boolean
    isComplete: boolean
    isBot: boolean
    joinedAt: Date
    finishedAt: Date | null
    isDisconnect: boolean
    _count: MultiPlayerMemberCountAggregateOutputType | null
    _avg: MultiPlayerMemberAvgAggregateOutputType | null
    _sum: MultiPlayerMemberSumAggregateOutputType | null
    _min: MultiPlayerMemberMinAggregateOutputType | null
    _max: MultiPlayerMemberMaxAggregateOutputType | null
  }

  type GetMultiPlayerMemberGroupByPayload<T extends MultiPlayerMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiPlayerMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiPlayerMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiPlayerMemberGroupByOutputType[P]>
            : GetScalarType<T[P], MultiPlayerMemberGroupByOutputType[P]>
        }
      >
    >


  export type MultiPlayerMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiPlayerMember"]>

  export type MultiPlayerMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiPlayerMember"]>

  export type MultiPlayerMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiPlayerMember"]>

  export type MultiPlayerMemberSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    point?: boolean
    bonusPoint?: boolean
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: boolean
    finishedAt?: boolean
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "point" | "bonusPoint" | "isReady" | "isComplete" | "isBot" | "joinedAt" | "finishedAt" | "isDisconnect", ExtArgs["result"]["multiPlayerMember"]>
  export type MultiPlayerMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }
  export type MultiPlayerMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }
  export type MultiPlayerMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    room?: boolean | MultiplayerRoomDefaultArgs<ExtArgs>
  }

  export type $MultiPlayerMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiPlayerMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      room: Prisma.$MultiplayerRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string
      point: number
      bonusPoint: number
      isReady: boolean
      isComplete: boolean
      isBot: boolean
      joinedAt: Date
      finishedAt: Date | null
      isDisconnect: boolean
    }, ExtArgs["result"]["multiPlayerMember"]>
    composites: {}
  }

  type MultiPlayerMemberGetPayload<S extends boolean | null | undefined | MultiPlayerMemberDefaultArgs> = $Result.GetResult<Prisma.$MultiPlayerMemberPayload, S>

  type MultiPlayerMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultiPlayerMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultiPlayerMemberCountAggregateInputType | true
    }

  export interface MultiPlayerMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiPlayerMember'], meta: { name: 'MultiPlayerMember' } }
    /**
     * Find zero or one MultiPlayerMember that matches the filter.
     * @param {MultiPlayerMemberFindUniqueArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultiPlayerMemberFindUniqueArgs>(args: SelectSubset<T, MultiPlayerMemberFindUniqueArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultiPlayerMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultiPlayerMemberFindUniqueOrThrowArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultiPlayerMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MultiPlayerMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiPlayerMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberFindFirstArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultiPlayerMemberFindFirstArgs>(args?: SelectSubset<T, MultiPlayerMemberFindFirstArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiPlayerMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberFindFirstOrThrowArgs} args - Arguments to find a MultiPlayerMember
     * @example
     * // Get one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultiPlayerMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MultiPlayerMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultiPlayerMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiPlayerMembers
     * const multiPlayerMembers = await prisma.multiPlayerMember.findMany()
     * 
     * // Get first 10 MultiPlayerMembers
     * const multiPlayerMembers = await prisma.multiPlayerMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiPlayerMemberWithIdOnly = await prisma.multiPlayerMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultiPlayerMemberFindManyArgs>(args?: SelectSubset<T, MultiPlayerMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultiPlayerMember.
     * @param {MultiPlayerMemberCreateArgs} args - Arguments to create a MultiPlayerMember.
     * @example
     * // Create one MultiPlayerMember
     * const MultiPlayerMember = await prisma.multiPlayerMember.create({
     *   data: {
     *     // ... data to create a MultiPlayerMember
     *   }
     * })
     * 
     */
    create<T extends MultiPlayerMemberCreateArgs>(args: SelectSubset<T, MultiPlayerMemberCreateArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultiPlayerMembers.
     * @param {MultiPlayerMemberCreateManyArgs} args - Arguments to create many MultiPlayerMembers.
     * @example
     * // Create many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultiPlayerMemberCreateManyArgs>(args?: SelectSubset<T, MultiPlayerMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultiPlayerMembers and returns the data saved in the database.
     * @param {MultiPlayerMemberCreateManyAndReturnArgs} args - Arguments to create many MultiPlayerMembers.
     * @example
     * // Create many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultiPlayerMembers and only return the `id`
     * const multiPlayerMemberWithIdOnly = await prisma.multiPlayerMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultiPlayerMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MultiPlayerMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultiPlayerMember.
     * @param {MultiPlayerMemberDeleteArgs} args - Arguments to delete one MultiPlayerMember.
     * @example
     * // Delete one MultiPlayerMember
     * const MultiPlayerMember = await prisma.multiPlayerMember.delete({
     *   where: {
     *     // ... filter to delete one MultiPlayerMember
     *   }
     * })
     * 
     */
    delete<T extends MultiPlayerMemberDeleteArgs>(args: SelectSubset<T, MultiPlayerMemberDeleteArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultiPlayerMember.
     * @param {MultiPlayerMemberUpdateArgs} args - Arguments to update one MultiPlayerMember.
     * @example
     * // Update one MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultiPlayerMemberUpdateArgs>(args: SelectSubset<T, MultiPlayerMemberUpdateArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultiPlayerMembers.
     * @param {MultiPlayerMemberDeleteManyArgs} args - Arguments to filter MultiPlayerMembers to delete.
     * @example
     * // Delete a few MultiPlayerMembers
     * const { count } = await prisma.multiPlayerMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultiPlayerMemberDeleteManyArgs>(args?: SelectSubset<T, MultiPlayerMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiPlayerMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultiPlayerMemberUpdateManyArgs>(args: SelectSubset<T, MultiPlayerMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiPlayerMembers and returns the data updated in the database.
     * @param {MultiPlayerMemberUpdateManyAndReturnArgs} args - Arguments to update many MultiPlayerMembers.
     * @example
     * // Update many MultiPlayerMembers
     * const multiPlayerMember = await prisma.multiPlayerMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultiPlayerMembers and only return the `id`
     * const multiPlayerMemberWithIdOnly = await prisma.multiPlayerMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultiPlayerMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MultiPlayerMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultiPlayerMember.
     * @param {MultiPlayerMemberUpsertArgs} args - Arguments to update or create a MultiPlayerMember.
     * @example
     * // Update or create a MultiPlayerMember
     * const multiPlayerMember = await prisma.multiPlayerMember.upsert({
     *   create: {
     *     // ... data to create a MultiPlayerMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiPlayerMember we want to update
     *   }
     * })
     */
    upsert<T extends MultiPlayerMemberUpsertArgs>(args: SelectSubset<T, MultiPlayerMemberUpsertArgs<ExtArgs>>): Prisma__MultiPlayerMemberClient<$Result.GetResult<Prisma.$MultiPlayerMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultiPlayerMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberCountArgs} args - Arguments to filter MultiPlayerMembers to count.
     * @example
     * // Count the number of MultiPlayerMembers
     * const count = await prisma.multiPlayerMember.count({
     *   where: {
     *     // ... the filter for the MultiPlayerMembers we want to count
     *   }
     * })
    **/
    count<T extends MultiPlayerMemberCountArgs>(
      args?: Subset<T, MultiPlayerMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiPlayerMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiPlayerMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiPlayerMemberAggregateArgs>(args: Subset<T, MultiPlayerMemberAggregateArgs>): Prisma.PrismaPromise<GetMultiPlayerMemberAggregateType<T>>

    /**
     * Group by MultiPlayerMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiPlayerMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiPlayerMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiPlayerMemberGroupByArgs['orderBy'] }
        : { orderBy?: MultiPlayerMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiPlayerMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiPlayerMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiPlayerMember model
   */
  readonly fields: MultiPlayerMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiPlayerMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiPlayerMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends MultiplayerRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MultiplayerRoomDefaultArgs<ExtArgs>>): Prisma__MultiplayerRoomClient<$Result.GetResult<Prisma.$MultiplayerRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultiPlayerMember model
   */
  interface MultiPlayerMemberFieldRefs {
    readonly id: FieldRef<"MultiPlayerMember", 'String'>
    readonly roomId: FieldRef<"MultiPlayerMember", 'String'>
    readonly userId: FieldRef<"MultiPlayerMember", 'String'>
    readonly point: FieldRef<"MultiPlayerMember", 'Int'>
    readonly bonusPoint: FieldRef<"MultiPlayerMember", 'Int'>
    readonly isReady: FieldRef<"MultiPlayerMember", 'Boolean'>
    readonly isComplete: FieldRef<"MultiPlayerMember", 'Boolean'>
    readonly isBot: FieldRef<"MultiPlayerMember", 'Boolean'>
    readonly joinedAt: FieldRef<"MultiPlayerMember", 'DateTime'>
    readonly finishedAt: FieldRef<"MultiPlayerMember", 'DateTime'>
    readonly isDisconnect: FieldRef<"MultiPlayerMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MultiPlayerMember findUnique
   */
  export type MultiPlayerMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember findUniqueOrThrow
   */
  export type MultiPlayerMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember findFirst
   */
  export type MultiPlayerMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiPlayerMembers.
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiPlayerMembers.
     */
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiPlayerMember findFirstOrThrow
   */
  export type MultiPlayerMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMember to fetch.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiPlayerMembers.
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiPlayerMembers.
     */
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiPlayerMember findMany
   */
  export type MultiPlayerMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter, which MultiPlayerMembers to fetch.
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiPlayerMembers to fetch.
     */
    orderBy?: MultiPlayerMemberOrderByWithRelationInput | MultiPlayerMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiPlayerMembers.
     */
    cursor?: MultiPlayerMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiPlayerMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiPlayerMembers.
     */
    skip?: number
    distinct?: MultiPlayerMemberScalarFieldEnum | MultiPlayerMemberScalarFieldEnum[]
  }

  /**
   * MultiPlayerMember create
   */
  export type MultiPlayerMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiPlayerMember.
     */
    data: XOR<MultiPlayerMemberCreateInput, MultiPlayerMemberUncheckedCreateInput>
  }

  /**
   * MultiPlayerMember createMany
   */
  export type MultiPlayerMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiPlayerMembers.
     */
    data: MultiPlayerMemberCreateManyInput | MultiPlayerMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiPlayerMember createManyAndReturn
   */
  export type MultiPlayerMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * The data used to create many MultiPlayerMembers.
     */
    data: MultiPlayerMemberCreateManyInput | MultiPlayerMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultiPlayerMember update
   */
  export type MultiPlayerMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiPlayerMember.
     */
    data: XOR<MultiPlayerMemberUpdateInput, MultiPlayerMemberUncheckedUpdateInput>
    /**
     * Choose, which MultiPlayerMember to update.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember updateMany
   */
  export type MultiPlayerMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiPlayerMembers.
     */
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyInput>
    /**
     * Filter which MultiPlayerMembers to update
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * Limit how many MultiPlayerMembers to update.
     */
    limit?: number
  }

  /**
   * MultiPlayerMember updateManyAndReturn
   */
  export type MultiPlayerMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * The data used to update MultiPlayerMembers.
     */
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyInput>
    /**
     * Filter which MultiPlayerMembers to update
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * Limit how many MultiPlayerMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultiPlayerMember upsert
   */
  export type MultiPlayerMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiPlayerMember to update in case it exists.
     */
    where: MultiPlayerMemberWhereUniqueInput
    /**
     * In case the MultiPlayerMember found by the `where` argument doesn't exist, create a new MultiPlayerMember with this data.
     */
    create: XOR<MultiPlayerMemberCreateInput, MultiPlayerMemberUncheckedCreateInput>
    /**
     * In case the MultiPlayerMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiPlayerMemberUpdateInput, MultiPlayerMemberUncheckedUpdateInput>
  }

  /**
   * MultiPlayerMember delete
   */
  export type MultiPlayerMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
    /**
     * Filter which MultiPlayerMember to delete.
     */
    where: MultiPlayerMemberWhereUniqueInput
  }

  /**
   * MultiPlayerMember deleteMany
   */
  export type MultiPlayerMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiPlayerMembers to delete
     */
    where?: MultiPlayerMemberWhereInput
    /**
     * Limit how many MultiPlayerMembers to delete.
     */
    limit?: number
  }

  /**
   * MultiPlayerMember without action
   */
  export type MultiPlayerMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiPlayerMember
     */
    select?: MultiPlayerMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiPlayerMember
     */
    omit?: MultiPlayerMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiPlayerMemberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProvinceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    geoId: 'geoId',
    provinceId: 'provinceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    identity: 'identity',
    name: 'name',
    longitude: 'longitude',
    latitude: 'latitude',
    cityId: 'cityId',
    provinceId: 'provinceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    email: 'email',
    role: 'role',
    suspend: 'suspend',
    accountType: 'accountType',
    firstTest: 'firstTest',
    fullname: 'fullname',
    birthDate: 'birthDate',
    grade: 'grade',
    lastGradeUpdateAt: 'lastGradeUpdateAt',
    schoolIdentity: 'schoolIdentity',
    loginAt: 'loginAt',
    logoutAt: 'logoutAt',
    playTime: 'playTime',
    characterUsed: 'characterUsed',
    inventory: 'inventory',
    schoolId: 'schoolId',
    cityId: 'cityId',
    provinceId: 'provinceId',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    lastIdZoneUnlocked: 'lastIdZoneUnlocked',
    lastIdZonePosition: 'lastIdZonePosition'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    inGameId: 'inGameId',
    userId: 'userId',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    lastLevelId: 'lastLevelId',
    lastSubLevelId: 'lastSubLevelId',
    lastInnerLevelId: 'lastInnerLevelId',
    lastLevelUnlock: 'lastLevelUnlock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const SubLevelScalarFieldEnum: {
    id: 'id',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    levelInGameId: 'levelInGameId',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type SubLevelScalarFieldEnum = (typeof SubLevelScalarFieldEnum)[keyof typeof SubLevelScalarFieldEnum]


  export const InnerLevelScalarFieldEnum: {
    id: 'id',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    levelInGameId: 'levelInGameId',
    subLevelInGameId: 'subLevelInGameId',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    isComplete: 'isComplete',
    completedAt: 'completedAt',
    correctAttempt: 'correctAttempt',
    playTime: 'playTime',
    point: 'point',
    played: 'played',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type InnerLevelScalarFieldEnum = (typeof InnerLevelScalarFieldEnum)[keyof typeof InnerLevelScalarFieldEnum]


  export const GempoScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type GempoScalarFieldEnum = (typeof GempoScalarFieldEnum)[keyof typeof GempoScalarFieldEnum]


  export const ChampionshipScalarFieldEnum: {
    id: 'id',
    isUnlock: 'isUnlock',
    unlockedAt: 'unlockedAt',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ChampionshipScalarFieldEnum = (typeof ChampionshipScalarFieldEnum)[keyof typeof ChampionshipScalarFieldEnum]


  export const GempoRecordScalarFieldEnum: {
    id: 'id',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    gempoInGameId: 'gempoInGameId',
    played: 'played',
    point: 'point',
    lastPlayedAt: 'lastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type GempoRecordScalarFieldEnum = (typeof GempoRecordScalarFieldEnum)[keyof typeof GempoRecordScalarFieldEnum]


  export const ChampionshipRecordScalarFieldEnum: {
    id: 'id',
    inGameId: 'inGameId',
    zoneInGameId: 'zoneInGameId',
    championshipInGameId: 'championshipInGameId',
    teamWin: 'teamWin',
    teamLose: 'teamLose',
    teamPlayed: 'teamPlayed',
    teamPoint: 'teamPoint',
    teamLastPlayedAt: 'teamLastPlayedAt',
    soloWin: 'soloWin',
    soloLose: 'soloLose',
    soloPlayed: 'soloPlayed',
    soloPoint: 'soloPoint',
    soloLastPlayedAt: 'soloLastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ChampionshipRecordScalarFieldEnum = (typeof ChampionshipRecordScalarFieldEnum)[keyof typeof ChampionshipRecordScalarFieldEnum]


  export const UserLoginScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    loginDate: 'loginDate',
    logoutDate: 'logoutDate'
  };

  export type UserLoginScalarFieldEnum = (typeof UserLoginScalarFieldEnum)[keyof typeof UserLoginScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    email: 'email',
    name: 'name',
    suspend: 'suspend',
    role: 'role',
    provinceId: 'provinceId',
    cityId: 'cityId',
    schoolId: 'schoolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminOperationHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    adminId: 'adminId',
    opAdminId: 'opAdminId',
    operation: 'operation'
  };

  export type AdminOperationHistoryScalarFieldEnum = (typeof AdminOperationHistoryScalarFieldEnum)[keyof typeof AdminOperationHistoryScalarFieldEnum]


  export const AdminAuthorityScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    provinceId: 'provinceId',
    grades: 'grades'
  };

  export type AdminAuthorityScalarFieldEnum = (typeof AdminAuthorityScalarFieldEnum)[keyof typeof AdminAuthorityScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    thumbnailId: 'thumbnailId',
    thumbnail: 'thumbnail',
    link: 'link',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    isHide: 'isHide',
    adminId: 'adminId'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const BannerLocationScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    provinceId: 'provinceId'
  };

  export type BannerLocationScalarFieldEnum = (typeof BannerLocationScalarFieldEnum)[keyof typeof BannerLocationScalarFieldEnum]


  export const BannerVisitorScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    traffic: 'traffic'
  };

  export type BannerVisitorScalarFieldEnum = (typeof BannerVisitorScalarFieldEnum)[keyof typeof BannerVisitorScalarFieldEnum]


  export const TestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    question: 'question',
    duration: 'duration',
    passedPoint: 'passedPoint',
    remidialCount: 'remidialCount',
    type: 'type',
    quota: 'quota',
    currentQuota: 'currentQuota',
    code: 'code',
    zoneId: 'zoneId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const TestParticipantScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    userId: 'userId',
    firstTimeAt: 'firstTimeAt',
    lastTestAt: 'lastTestAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    highscore: 'highscore'
  };

  export type TestParticipantScalarFieldEnum = (typeof TestParticipantScalarFieldEnum)[keyof typeof TestParticipantScalarFieldEnum]


  export const TestParticipantRecordScalarFieldEnum: {
    id: 'id',
    participantId: 'participantId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    answers: 'answers'
  };

  export type TestParticipantRecordScalarFieldEnum = (typeof TestParticipantRecordScalarFieldEnum)[keyof typeof TestParticipantRecordScalarFieldEnum]


  export const BackgroundScalarFieldEnum: {
    id: 'id',
    name: 'name',
    thumbnailId: 'thumbnailId',
    thumbnail: 'thumbnail',
    isUse: 'isUse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BackgroundScalarFieldEnum = (typeof BackgroundScalarFieldEnum)[keyof typeof BackgroundScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const AdminTransactionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    archived: 'archived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    adminId: 'adminId',
    quantity: 'quantity',
    subscriptionTime: 'subscriptionTime',
    zones: 'zones',
    transactionRef: 'transactionRef',
    amount: 'amount',
    description: 'description',
    transactionImageId: 'transactionImageId',
    transactionImageUrl: 'transactionImageUrl',
    processedById: 'processedById',
    processedAt: 'processedAt'
  };

  export type AdminTransactionScalarFieldEnum = (typeof AdminTransactionScalarFieldEnum)[keyof typeof AdminTransactionScalarFieldEnum]


  export const RedeemCodeScalarFieldEnum: {
    id: 'id',
    suspend: 'suspend',
    transactionId: 'transactionId',
    adminId: 'adminId',
    code: 'code',
    expiredAt: 'expiredAt',
    currentAmount: 'currentAmount',
    maxAmount: 'maxAmount',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RedeemCodeScalarFieldEnum = (typeof RedeemCodeScalarFieldEnum)[keyof typeof RedeemCodeScalarFieldEnum]


  export const CodeRedemeerScalarFieldEnum: {
    id: 'id',
    banned: 'banned',
    userId: 'userId',
    codeId: 'codeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodeRedemeerScalarFieldEnum = (typeof CodeRedemeerScalarFieldEnum)[keyof typeof CodeRedemeerScalarFieldEnum]


  export const MultiplayerRoomScalarFieldEnum: {
    id: 'id',
    max: 'max',
    gameplayId: 'gameplayId',
    botOwner: 'botOwner',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    expiredAt: 'expiredAt',
    isStarted: 'isStarted',
    isEnded: 'isEnded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currentMember: 'currentMember'
  };

  export type MultiplayerRoomScalarFieldEnum = (typeof MultiplayerRoomScalarFieldEnum)[keyof typeof MultiplayerRoomScalarFieldEnum]


  export const MultiPlayerMemberScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    point: 'point',
    bonusPoint: 'bonusPoint',
    isReady: 'isReady',
    isComplete: 'isComplete',
    isBot: 'isBot',
    joinedAt: 'joinedAt',
    finishedAt: 'finishedAt',
    isDisconnect: 'isDisconnect'
  };

  export type MultiPlayerMemberScalarFieldEnum = (typeof MultiPlayerMemberScalarFieldEnum)[keyof typeof MultiPlayerMemberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Operation'
   */
  export type EnumOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Operation'>
    


  /**
   * Reference to a field of type 'Operation[]'
   */
  export type ListEnumOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Operation[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'TestType'
   */
  export type EnumTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestType'>
    


  /**
   * Reference to a field of type 'TestType[]'
   */
  export type ListEnumTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TestType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Transaction'
   */
  export type EnumTransactionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Transaction'>
    


  /**
   * Reference to a field of type 'Transaction[]'
   */
  export type ListEnumTransactionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Transaction[]'>
    
  /**
   * Deep Input Types
   */


  export type ProvinceWhereInput = {
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    id?: StringFilter<"Province"> | string
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
    admin?: AdminListRelationFilter
  }

  export type ProvinceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cities?: CityOrderByRelationAggregateInput
    schools?: SchoolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    bannerLocation?: BannerLocationOrderByRelationAggregateInput
    admin?: AdminOrderByRelationAggregateInput
  }

  export type ProvinceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProvinceWhereInput | ProvinceWhereInput[]
    OR?: ProvinceWhereInput[]
    NOT?: ProvinceWhereInput | ProvinceWhereInput[]
    name?: StringFilter<"Province"> | string
    longitude?: FloatFilter<"Province"> | number
    latitude?: FloatFilter<"Province"> | number
    geoId?: StringFilter<"Province"> | string
    createdAt?: DateTimeFilter<"Province"> | Date | string
    updatedAt?: DateTimeFilter<"Province"> | Date | string
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
    admin?: AdminListRelationFilter
  }, "id">

  export type ProvinceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProvinceCountOrderByAggregateInput
    _avg?: ProvinceAvgOrderByAggregateInput
    _max?: ProvinceMaxOrderByAggregateInput
    _min?: ProvinceMinOrderByAggregateInput
    _sum?: ProvinceSumOrderByAggregateInput
  }

  export type ProvinceScalarWhereWithAggregatesInput = {
    AND?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    OR?: ProvinceScalarWhereWithAggregatesInput[]
    NOT?: ProvinceScalarWhereWithAggregatesInput | ProvinceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Province"> | string
    name?: StringWithAggregatesFilter<"Province"> | string
    longitude?: FloatWithAggregatesFilter<"Province"> | number
    latitude?: FloatWithAggregatesFilter<"Province"> | number
    geoId?: StringWithAggregatesFilter<"Province"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Province"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Province"> | Date | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
    admin?: AdminListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    province?: ProvinceOrderByWithRelationInput
    schools?: SchoolOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    bannerLocation?: BannerLocationOrderByRelationAggregateInput
    admin?: AdminOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    schools?: SchoolListRelationFilter
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    bannerLocation?: BannerLocationListRelationFilter
    admin?: AdminListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    name?: StringWithAggregatesFilter<"City"> | string
    longitude?: FloatWithAggregatesFilter<"City"> | number
    latitude?: FloatWithAggregatesFilter<"City"> | number
    geoId?: StringWithAggregatesFilter<"City"> | string
    provinceId?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    identity?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringFilter<"School"> | string
    provinceId?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    admin?: AdminListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: CityOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    adminAuthority?: AdminAuthorityOrderByRelationAggregateInput
    admin?: AdminOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    identity?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringFilter<"School"> | string
    provinceId?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    users?: UserListRelationFilter
    adminAuthority?: AdminAuthorityListRelationFilter
    admin?: AdminListRelationFilter
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    identity?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    longitude?: FloatWithAggregatesFilter<"School"> | number
    latitude?: FloatWithAggregatesFilter<"School"> | number
    cityId?: StringWithAggregatesFilter<"School"> | string
    provinceId?: StringWithAggregatesFilter<"School"> | string
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    authId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: StringFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    zones?: ZoneListRelationFilter
    userLogin?: UserLoginListRelationFilter
    bannerVisitor?: BannerVisitorListRelationFilter
    testParticipant?: TestParticipantListRelationFilter
    multiPlayerMember?: MultiPlayerMemberListRelationFilter
    subLevels?: SubLevelListRelationFilter
    innerLevels?: InnerLevelListRelationFilter
    levels?: LevelListRelationFilter
    gempos?: GempoListRelationFilter
    championships?: ChampionshipListRelationFilter
    gempoRecords?: GempoRecordListRelationFilter
    championshipRecords?: ChampionshipRecordListRelationFilter
    redemeedCodes?: CodeRedemeerListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrderInput | SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrderInput | SortOrder
    logoutAt?: SortOrderInput | SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
    city?: CityOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    zones?: ZoneOrderByRelationAggregateInput
    userLogin?: UserLoginOrderByRelationAggregateInput
    bannerVisitor?: BannerVisitorOrderByRelationAggregateInput
    testParticipant?: TestParticipantOrderByRelationAggregateInput
    multiPlayerMember?: MultiPlayerMemberOrderByRelationAggregateInput
    subLevels?: SubLevelOrderByRelationAggregateInput
    innerLevels?: InnerLevelOrderByRelationAggregateInput
    levels?: LevelOrderByRelationAggregateInput
    gempos?: GempoOrderByRelationAggregateInput
    championships?: ChampionshipOrderByRelationAggregateInput
    gempoRecords?: GempoRecordOrderByRelationAggregateInput
    championshipRecords?: ChampionshipRecordOrderByRelationAggregateInput
    redemeedCodes?: CodeRedemeerOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    schoolIdentity?: string
    adminId?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: StringFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    zones?: ZoneListRelationFilter
    userLogin?: UserLoginListRelationFilter
    bannerVisitor?: BannerVisitorListRelationFilter
    testParticipant?: TestParticipantListRelationFilter
    multiPlayerMember?: MultiPlayerMemberListRelationFilter
    subLevels?: SubLevelListRelationFilter
    innerLevels?: InnerLevelListRelationFilter
    levels?: LevelListRelationFilter
    gempos?: GempoListRelationFilter
    championships?: ChampionshipListRelationFilter
    gempoRecords?: GempoRecordListRelationFilter
    championshipRecords?: ChampionshipRecordListRelationFilter
    redemeedCodes?: CodeRedemeerListRelationFilter
  }, "id" | "authId" | "email" | "schoolIdentity" | "adminId" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrderInput | SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrderInput | SortOrder
    logoutAt?: SortOrderInput | SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    authId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    suspend?: BoolWithAggregatesFilter<"User"> | boolean
    accountType?: EnumAccountTypeWithAggregatesFilter<"User"> | $Enums.AccountType
    firstTest?: BoolWithAggregatesFilter<"User"> | boolean
    fullname?: StringWithAggregatesFilter<"User"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    grade?: IntWithAggregatesFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    schoolIdentity?: StringWithAggregatesFilter<"User"> | string
    loginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    playTime?: IntWithAggregatesFilter<"User"> | number
    characterUsed?: StringWithAggregatesFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    provinceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    adminId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringWithAggregatesFilter<"User"> | string
    lastIdZoneUnlocked?: StringWithAggregatesFilter<"User"> | string
    lastIdZonePosition?: StringWithAggregatesFilter<"User"> | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    inGameId?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: ZoneUserIdInGameIdCompoundUniqueInput
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    inGameId?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    inGameId?: StringWithAggregatesFilter<"Zone"> | string
    userId?: StringWithAggregatesFilter<"Zone"> | string
    isComplete?: BoolWithAggregatesFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Zone"> | Date | string | null
    lastLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastSubLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastInnerLevelId?: StringWithAggregatesFilter<"Zone"> | string
    lastLevelUnlock?: StringWithAggregatesFilter<"Zone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    inGameId?: StringFilter<"Level"> | string
    zoneInGameId?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    userId?: StringFilter<"Level"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: LevelUserIdInGameIdCompoundUniqueInput
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    inGameId?: StringFilter<"Level"> | string
    zoneInGameId?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    userId?: StringFilter<"Level"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    inGameId?: StringWithAggregatesFilter<"Level"> | string
    zoneInGameId?: StringWithAggregatesFilter<"Level"> | string
    isUnlock?: BoolWithAggregatesFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"Level"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"Level"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    userId?: StringWithAggregatesFilter<"Level"> | string
  }

  export type SubLevelWhereInput = {
    AND?: SubLevelWhereInput | SubLevelWhereInput[]
    OR?: SubLevelWhereInput[]
    NOT?: SubLevelWhereInput | SubLevelWhereInput[]
    id?: StringFilter<"SubLevel"> | string
    inGameId?: StringFilter<"SubLevel"> | string
    zoneInGameId?: StringFilter<"SubLevel"> | string
    levelInGameId?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    userId?: StringFilter<"SubLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubLevelOrderByWithRelationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: SubLevelUserIdInGameIdCompoundUniqueInput
    AND?: SubLevelWhereInput | SubLevelWhereInput[]
    OR?: SubLevelWhereInput[]
    NOT?: SubLevelWhereInput | SubLevelWhereInput[]
    inGameId?: StringFilter<"SubLevel"> | string
    zoneInGameId?: StringFilter<"SubLevel"> | string
    levelInGameId?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    userId?: StringFilter<"SubLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type SubLevelOrderByWithAggregationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: SubLevelCountOrderByAggregateInput
    _max?: SubLevelMaxOrderByAggregateInput
    _min?: SubLevelMinOrderByAggregateInput
  }

  export type SubLevelScalarWhereWithAggregatesInput = {
    AND?: SubLevelScalarWhereWithAggregatesInput | SubLevelScalarWhereWithAggregatesInput[]
    OR?: SubLevelScalarWhereWithAggregatesInput[]
    NOT?: SubLevelScalarWhereWithAggregatesInput | SubLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubLevel"> | string
    inGameId?: StringWithAggregatesFilter<"SubLevel"> | string
    zoneInGameId?: StringWithAggregatesFilter<"SubLevel"> | string
    levelInGameId?: StringWithAggregatesFilter<"SubLevel"> | string
    isUnlock?: BoolWithAggregatesFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubLevel"> | Date | string
    userId?: StringWithAggregatesFilter<"SubLevel"> | string
  }

  export type InnerLevelWhereInput = {
    AND?: InnerLevelWhereInput | InnerLevelWhereInput[]
    OR?: InnerLevelWhereInput[]
    NOT?: InnerLevelWhereInput | InnerLevelWhereInput[]
    id?: StringFilter<"InnerLevel"> | string
    inGameId?: StringFilter<"InnerLevel"> | string
    zoneInGameId?: StringFilter<"InnerLevel"> | string
    levelInGameId?: StringFilter<"InnerLevel"> | string
    subLevelInGameId?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatFilter<"InnerLevel"> | number
    playTime?: IntFilter<"InnerLevel"> | number
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    userId?: StringFilter<"InnerLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InnerLevelOrderByWithRelationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InnerLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: InnerLevelUserIdInGameIdCompoundUniqueInput
    AND?: InnerLevelWhereInput | InnerLevelWhereInput[]
    OR?: InnerLevelWhereInput[]
    NOT?: InnerLevelWhereInput | InnerLevelWhereInput[]
    inGameId?: StringFilter<"InnerLevel"> | string
    zoneInGameId?: StringFilter<"InnerLevel"> | string
    levelInGameId?: StringFilter<"InnerLevel"> | string
    subLevelInGameId?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatFilter<"InnerLevel"> | number
    playTime?: IntFilter<"InnerLevel"> | number
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    userId?: StringFilter<"InnerLevel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type InnerLevelOrderByWithAggregationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: InnerLevelCountOrderByAggregateInput
    _avg?: InnerLevelAvgOrderByAggregateInput
    _max?: InnerLevelMaxOrderByAggregateInput
    _min?: InnerLevelMinOrderByAggregateInput
    _sum?: InnerLevelSumOrderByAggregateInput
  }

  export type InnerLevelScalarWhereWithAggregatesInput = {
    AND?: InnerLevelScalarWhereWithAggregatesInput | InnerLevelScalarWhereWithAggregatesInput[]
    OR?: InnerLevelScalarWhereWithAggregatesInput[]
    NOT?: InnerLevelScalarWhereWithAggregatesInput | InnerLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InnerLevel"> | string
    inGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    zoneInGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    levelInGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    subLevelInGameId?: StringWithAggregatesFilter<"InnerLevel"> | string
    isUnlock?: BoolWithAggregatesFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolWithAggregatesFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatWithAggregatesFilter<"InnerLevel"> | number
    playTime?: IntWithAggregatesFilter<"InnerLevel"> | number
    point?: IntWithAggregatesFilter<"InnerLevel"> | number
    played?: IntWithAggregatesFilter<"InnerLevel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InnerLevel"> | Date | string
    userId?: StringWithAggregatesFilter<"InnerLevel"> | string
  }

  export type GempoWhereInput = {
    AND?: GempoWhereInput | GempoWhereInput[]
    OR?: GempoWhereInput[]
    NOT?: GempoWhereInput | GempoWhereInput[]
    id?: StringFilter<"Gempo"> | string
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    inGameId?: StringFilter<"Gempo"> | string
    zoneInGameId?: StringFilter<"Gempo"> | string
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    userId?: StringFilter<"Gempo"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GempoOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GempoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: GempoUserIdInGameIdCompoundUniqueInput
    AND?: GempoWhereInput | GempoWhereInput[]
    OR?: GempoWhereInput[]
    NOT?: GempoWhereInput | GempoWhereInput[]
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    inGameId?: StringFilter<"Gempo"> | string
    zoneInGameId?: StringFilter<"Gempo"> | string
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    userId?: StringFilter<"Gempo"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type GempoOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: GempoCountOrderByAggregateInput
    _max?: GempoMaxOrderByAggregateInput
    _min?: GempoMinOrderByAggregateInput
  }

  export type GempoScalarWhereWithAggregatesInput = {
    AND?: GempoScalarWhereWithAggregatesInput | GempoScalarWhereWithAggregatesInput[]
    OR?: GempoScalarWhereWithAggregatesInput[]
    NOT?: GempoScalarWhereWithAggregatesInput | GempoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gempo"> | string
    isUnlock?: BoolWithAggregatesFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Gempo"> | Date | string | null
    inGameId?: StringWithAggregatesFilter<"Gempo"> | string
    zoneInGameId?: StringWithAggregatesFilter<"Gempo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gempo"> | Date | string
    userId?: StringWithAggregatesFilter<"Gempo"> | string
  }

  export type ChampionshipWhereInput = {
    AND?: ChampionshipWhereInput | ChampionshipWhereInput[]
    OR?: ChampionshipWhereInput[]
    NOT?: ChampionshipWhereInput | ChampionshipWhereInput[]
    id?: StringFilter<"Championship"> | string
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    inGameId?: StringFilter<"Championship"> | string
    zoneInGameId?: StringFilter<"Championship"> | string
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    userId?: StringFilter<"Championship"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChampionshipOrderByWithRelationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChampionshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: ChampionshipUserIdInGameIdCompoundUniqueInput
    AND?: ChampionshipWhereInput | ChampionshipWhereInput[]
    OR?: ChampionshipWhereInput[]
    NOT?: ChampionshipWhereInput | ChampionshipWhereInput[]
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    inGameId?: StringFilter<"Championship"> | string
    zoneInGameId?: StringFilter<"Championship"> | string
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    userId?: StringFilter<"Championship"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type ChampionshipOrderByWithAggregationInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ChampionshipCountOrderByAggregateInput
    _max?: ChampionshipMaxOrderByAggregateInput
    _min?: ChampionshipMinOrderByAggregateInput
  }

  export type ChampionshipScalarWhereWithAggregatesInput = {
    AND?: ChampionshipScalarWhereWithAggregatesInput | ChampionshipScalarWhereWithAggregatesInput[]
    OR?: ChampionshipScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipScalarWhereWithAggregatesInput | ChampionshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Championship"> | string
    isUnlock?: BoolWithAggregatesFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"Championship"> | Date | string | null
    inGameId?: StringWithAggregatesFilter<"Championship"> | string
    zoneInGameId?: StringWithAggregatesFilter<"Championship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Championship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Championship"> | Date | string
    userId?: StringWithAggregatesFilter<"Championship"> | string
  }

  export type GempoRecordWhereInput = {
    AND?: GempoRecordWhereInput | GempoRecordWhereInput[]
    OR?: GempoRecordWhereInput[]
    NOT?: GempoRecordWhereInput | GempoRecordWhereInput[]
    id?: StringFilter<"GempoRecord"> | string
    inGameId?: StringFilter<"GempoRecord"> | string
    zoneInGameId?: StringFilter<"GempoRecord"> | string
    gempoInGameId?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    userId?: StringFilter<"GempoRecord"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GempoRecordOrderByWithRelationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    gempoInGameId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GempoRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: GempoRecordUserIdInGameIdCompoundUniqueInput
    AND?: GempoRecordWhereInput | GempoRecordWhereInput[]
    OR?: GempoRecordWhereInput[]
    NOT?: GempoRecordWhereInput | GempoRecordWhereInput[]
    inGameId?: StringFilter<"GempoRecord"> | string
    zoneInGameId?: StringFilter<"GempoRecord"> | string
    gempoInGameId?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    userId?: StringFilter<"GempoRecord"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type GempoRecordOrderByWithAggregationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    gempoInGameId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: GempoRecordCountOrderByAggregateInput
    _avg?: GempoRecordAvgOrderByAggregateInput
    _max?: GempoRecordMaxOrderByAggregateInput
    _min?: GempoRecordMinOrderByAggregateInput
    _sum?: GempoRecordSumOrderByAggregateInput
  }

  export type GempoRecordScalarWhereWithAggregatesInput = {
    AND?: GempoRecordScalarWhereWithAggregatesInput | GempoRecordScalarWhereWithAggregatesInput[]
    OR?: GempoRecordScalarWhereWithAggregatesInput[]
    NOT?: GempoRecordScalarWhereWithAggregatesInput | GempoRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GempoRecord"> | string
    inGameId?: StringWithAggregatesFilter<"GempoRecord"> | string
    zoneInGameId?: StringWithAggregatesFilter<"GempoRecord"> | string
    gempoInGameId?: StringWithAggregatesFilter<"GempoRecord"> | string
    played?: IntWithAggregatesFilter<"GempoRecord"> | number
    point?: IntWithAggregatesFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GempoRecord"> | Date | string
    userId?: StringWithAggregatesFilter<"GempoRecord"> | string
  }

  export type ChampionshipRecordWhereInput = {
    AND?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    OR?: ChampionshipRecordWhereInput[]
    NOT?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    id?: StringFilter<"ChampionshipRecord"> | string
    inGameId?: StringFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringFilter<"ChampionshipRecord"> | string
    championshipInGameId?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    userId?: StringFilter<"ChampionshipRecord"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChampionshipRecordOrderByWithRelationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    championshipInGameId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrderInput | SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChampionshipRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_inGameId?: ChampionshipRecordUserIdInGameIdCompoundUniqueInput
    AND?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    OR?: ChampionshipRecordWhereInput[]
    NOT?: ChampionshipRecordWhereInput | ChampionshipRecordWhereInput[]
    inGameId?: StringFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringFilter<"ChampionshipRecord"> | string
    championshipInGameId?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    userId?: StringFilter<"ChampionshipRecord"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_inGameId">

  export type ChampionshipRecordOrderByWithAggregationInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    championshipInGameId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrderInput | SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ChampionshipRecordCountOrderByAggregateInput
    _avg?: ChampionshipRecordAvgOrderByAggregateInput
    _max?: ChampionshipRecordMaxOrderByAggregateInput
    _min?: ChampionshipRecordMinOrderByAggregateInput
    _sum?: ChampionshipRecordSumOrderByAggregateInput
  }

  export type ChampionshipRecordScalarWhereWithAggregatesInput = {
    AND?: ChampionshipRecordScalarWhereWithAggregatesInput | ChampionshipRecordScalarWhereWithAggregatesInput[]
    OR?: ChampionshipRecordScalarWhereWithAggregatesInput[]
    NOT?: ChampionshipRecordScalarWhereWithAggregatesInput | ChampionshipRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    inGameId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    championshipInGameId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
    teamWin?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamLose?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamPoint?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloLose?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloPoint?: IntWithAggregatesFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableWithAggregatesFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChampionshipRecord"> | Date | string
    userId?: StringWithAggregatesFilter<"ChampionshipRecord"> | string
  }

  export type UserLoginWhereInput = {
    AND?: UserLoginWhereInput | UserLoginWhereInput[]
    OR?: UserLoginWhereInput[]
    NOT?: UserLoginWhereInput | UserLoginWhereInput[]
    id?: StringFilter<"UserLogin"> | string
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserLoginOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLoginWhereInput | UserLoginWhereInput[]
    OR?: UserLoginWhereInput[]
    NOT?: UserLoginWhereInput | UserLoginWhereInput[]
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserLoginOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrderInput | SortOrder
    _count?: UserLoginCountOrderByAggregateInput
    _max?: UserLoginMaxOrderByAggregateInput
    _min?: UserLoginMinOrderByAggregateInput
  }

  export type UserLoginScalarWhereWithAggregatesInput = {
    AND?: UserLoginScalarWhereWithAggregatesInput | UserLoginScalarWhereWithAggregatesInput[]
    OR?: UserLoginScalarWhereWithAggregatesInput[]
    NOT?: UserLoginScalarWhereWithAggregatesInput | UserLoginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLogin"> | string
    userId?: StringWithAggregatesFilter<"UserLogin"> | string
    loginDate?: DateTimeWithAggregatesFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableWithAggregatesFilter<"UserLogin"> | Date | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    authId?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    suspend?: BoolFilter<"Admin"> | boolean
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableFilter<"Admin"> | string | null
    cityId?: StringNullableFilter<"Admin"> | string | null
    schoolId?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    authority?: AdminAuthorityListRelationFilter
    operationHistories?: AdminOperationHistoryListRelationFilter
    operations?: AdminOperationHistoryListRelationFilter
    banner?: BannerListRelationFilter
    transactions?: AdminTransactionListRelationFilter
    transactionProcessed?: AdminTransactionListRelationFilter
    redeemCodes?: RedeemCodeListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    authority?: AdminAuthorityOrderByRelationAggregateInput
    operationHistories?: AdminOperationHistoryOrderByRelationAggregateInput
    operations?: AdminOperationHistoryOrderByRelationAggregateInput
    banner?: BannerOrderByRelationAggregateInput
    transactions?: AdminTransactionOrderByRelationAggregateInput
    transactionProcessed?: AdminTransactionOrderByRelationAggregateInput
    redeemCodes?: RedeemCodeOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    authId?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    suspend?: BoolFilter<"Admin"> | boolean
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableFilter<"Admin"> | string | null
    cityId?: StringNullableFilter<"Admin"> | string | null
    schoolId?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    province?: XOR<ProvinceNullableScalarRelationFilter, ProvinceWhereInput> | null
    city?: XOR<CityNullableScalarRelationFilter, CityWhereInput> | null
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    authority?: AdminAuthorityListRelationFilter
    operationHistories?: AdminOperationHistoryListRelationFilter
    operations?: AdminOperationHistoryListRelationFilter
    banner?: BannerListRelationFilter
    transactions?: AdminTransactionListRelationFilter
    transactionProcessed?: AdminTransactionListRelationFilter
    redeemCodes?: RedeemCodeListRelationFilter
  }, "id" | "authId" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrderInput | SortOrder
    provinceId?: SortOrderInput | SortOrder
    cityId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    authId?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    suspend?: BoolWithAggregatesFilter<"Admin"> | boolean
    role?: EnumRoleNullableWithAggregatesFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    cityId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type AdminOperationHistoryWhereInput = {
    AND?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    OR?: AdminOperationHistoryWhereInput[]
    NOT?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    opAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminOperationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
    admin?: AdminOrderByWithRelationInput
    opAdmin?: AdminOrderByWithRelationInput
  }

  export type AdminOperationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    OR?: AdminOperationHistoryWhereInput[]
    NOT?: AdminOperationHistoryWhereInput | AdminOperationHistoryWhereInput[]
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    opAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminOperationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
    _count?: AdminOperationHistoryCountOrderByAggregateInput
    _max?: AdminOperationHistoryMaxOrderByAggregateInput
    _min?: AdminOperationHistoryMinOrderByAggregateInput
  }

  export type AdminOperationHistoryScalarWhereWithAggregatesInput = {
    AND?: AdminOperationHistoryScalarWhereWithAggregatesInput | AdminOperationHistoryScalarWhereWithAggregatesInput[]
    OR?: AdminOperationHistoryScalarWhereWithAggregatesInput[]
    NOT?: AdminOperationHistoryScalarWhereWithAggregatesInput | AdminOperationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    opAdminId?: StringWithAggregatesFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationWithAggregatesFilter<"AdminOperationHistory"> | $Enums.Operation
  }

  export type AdminAuthorityWhereInput = {
    AND?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    OR?: AdminAuthorityWhereInput[]
    NOT?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    id?: StringFilter<"AdminAuthority"> | string
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
  }

  export type AdminAuthorityOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
    admin?: AdminOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
    schools?: SchoolOrderByRelationAggregateInput
  }

  export type AdminAuthorityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    OR?: AdminAuthorityWhereInput[]
    NOT?: AdminAuthorityWhereInput | AdminAuthorityWhereInput[]
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
    schools?: SchoolListRelationFilter
  }, "id">

  export type AdminAuthorityOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
    _count?: AdminAuthorityCountOrderByAggregateInput
    _avg?: AdminAuthorityAvgOrderByAggregateInput
    _max?: AdminAuthorityMaxOrderByAggregateInput
    _min?: AdminAuthorityMinOrderByAggregateInput
    _sum?: AdminAuthoritySumOrderByAggregateInput
  }

  export type AdminAuthorityScalarWhereWithAggregatesInput = {
    AND?: AdminAuthorityScalarWhereWithAggregatesInput | AdminAuthorityScalarWhereWithAggregatesInput[]
    OR?: AdminAuthorityScalarWhereWithAggregatesInput[]
    NOT?: AdminAuthorityScalarWhereWithAggregatesInput | AdminAuthorityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuthority"> | string
    adminId?: StringWithAggregatesFilter<"AdminAuthority"> | string
    provinceId?: StringWithAggregatesFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    thumbnailId?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    adminId?: StringFilter<"Banner"> | string
    visitors?: BannerVisitorListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    bannerLocation?: BannerLocationListRelationFilter
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
    visitors?: BannerVisitorOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    bannerLocation?: BannerLocationOrderByRelationAggregateInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    thumbnailId?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    adminId?: StringFilter<"Banner"> | string
    visitors?: BannerVisitorListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    bannerLocation?: BannerLocationListRelationFilter
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    thumbnailId?: StringWithAggregatesFilter<"Banner"> | string
    thumbnail?: StringWithAggregatesFilter<"Banner"> | string
    link?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    isHide?: BoolWithAggregatesFilter<"Banner"> | boolean
    adminId?: StringWithAggregatesFilter<"Banner"> | string
  }

  export type BannerLocationWhereInput = {
    AND?: BannerLocationWhereInput | BannerLocationWhereInput[]
    OR?: BannerLocationWhereInput[]
    NOT?: BannerLocationWhereInput | BannerLocationWhereInput[]
    id?: StringFilter<"BannerLocation"> | string
    bannerId?: StringFilter<"BannerLocation"> | string
    provinceId?: StringFilter<"BannerLocation"> | string
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
  }

  export type BannerLocationOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
    banner?: BannerOrderByWithRelationInput
    province?: ProvinceOrderByWithRelationInput
    cities?: CityOrderByRelationAggregateInput
  }

  export type BannerLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerLocationWhereInput | BannerLocationWhereInput[]
    OR?: BannerLocationWhereInput[]
    NOT?: BannerLocationWhereInput | BannerLocationWhereInput[]
    bannerId?: StringFilter<"BannerLocation"> | string
    provinceId?: StringFilter<"BannerLocation"> | string
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    province?: XOR<ProvinceScalarRelationFilter, ProvinceWhereInput>
    cities?: CityListRelationFilter
  }, "id">

  export type BannerLocationOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
    _count?: BannerLocationCountOrderByAggregateInput
    _max?: BannerLocationMaxOrderByAggregateInput
    _min?: BannerLocationMinOrderByAggregateInput
  }

  export type BannerLocationScalarWhereWithAggregatesInput = {
    AND?: BannerLocationScalarWhereWithAggregatesInput | BannerLocationScalarWhereWithAggregatesInput[]
    OR?: BannerLocationScalarWhereWithAggregatesInput[]
    NOT?: BannerLocationScalarWhereWithAggregatesInput | BannerLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerLocation"> | string
    bannerId?: StringWithAggregatesFilter<"BannerLocation"> | string
    provinceId?: StringWithAggregatesFilter<"BannerLocation"> | string
  }

  export type BannerVisitorWhereInput = {
    AND?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    OR?: BannerVisitorWhereInput[]
    NOT?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    id?: StringFilter<"BannerVisitor"> | string
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BannerVisitorOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
    banner?: BannerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BannerVisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bannerId?: string
    userId?: string
    AND?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    OR?: BannerVisitorWhereInput[]
    NOT?: BannerVisitorWhereInput | BannerVisitorWhereInput[]
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bannerId" | "userId">

  export type BannerVisitorOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
    _count?: BannerVisitorCountOrderByAggregateInput
    _avg?: BannerVisitorAvgOrderByAggregateInput
    _max?: BannerVisitorMaxOrderByAggregateInput
    _min?: BannerVisitorMinOrderByAggregateInput
    _sum?: BannerVisitorSumOrderByAggregateInput
  }

  export type BannerVisitorScalarWhereWithAggregatesInput = {
    AND?: BannerVisitorScalarWhereWithAggregatesInput | BannerVisitorScalarWhereWithAggregatesInput[]
    OR?: BannerVisitorScalarWhereWithAggregatesInput[]
    NOT?: BannerVisitorScalarWhereWithAggregatesInput | BannerVisitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerVisitor"> | string
    bannerId?: StringWithAggregatesFilter<"BannerVisitor"> | string
    userId?: StringWithAggregatesFilter<"BannerVisitor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BannerVisitor"> | Date | string
    traffic?: IntWithAggregatesFilter<"BannerVisitor"> | number
  }

  export type TestWhereInput = {
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    id?: StringFilter<"Test"> | string
    name?: StringFilter<"Test"> | string
    category?: EnumRoleFilter<"Test"> | $Enums.Role
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    participants?: TestParticipantListRelationFilter
  }

  export type TestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: TestParticipantOrderByRelationAggregateInput
  }

  export type TestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestWhereInput | TestWhereInput[]
    OR?: TestWhereInput[]
    NOT?: TestWhereInput | TestWhereInput[]
    name?: StringFilter<"Test"> | string
    category?: EnumRoleFilter<"Test"> | $Enums.Role
    question?: EnumQuestionTypeFilter<"Test"> | $Enums.QuestionType
    duration?: IntFilter<"Test"> | number
    passedPoint?: IntFilter<"Test"> | number
    remidialCount?: IntFilter<"Test"> | number
    type?: EnumTestTypeFilter<"Test"> | $Enums.TestType
    quota?: IntFilter<"Test"> | number
    currentQuota?: IntFilter<"Test"> | number
    code?: StringNullableFilter<"Test"> | string | null
    zoneId?: StringNullableFilter<"Test"> | string | null
    startedAt?: DateTimeFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableFilter<"Test"> | Date | string | null
    description?: StringNullableFilter<"Test"> | string | null
    createdAt?: DateTimeFilter<"Test"> | Date | string
    updatedAt?: DateTimeFilter<"Test"> | Date | string
    participants?: TestParticipantListRelationFilter
  }, "id">

  export type TestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrderInput | SortOrder
    zoneId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    OR?: TestScalarWhereWithAggregatesInput[]
    NOT?: TestScalarWhereWithAggregatesInput | TestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Test"> | string
    name?: StringWithAggregatesFilter<"Test"> | string
    category?: EnumRoleWithAggregatesFilter<"Test"> | $Enums.Role
    question?: EnumQuestionTypeWithAggregatesFilter<"Test"> | $Enums.QuestionType
    duration?: IntWithAggregatesFilter<"Test"> | number
    passedPoint?: IntWithAggregatesFilter<"Test"> | number
    remidialCount?: IntWithAggregatesFilter<"Test"> | number
    type?: EnumTestTypeWithAggregatesFilter<"Test"> | $Enums.TestType
    quota?: IntWithAggregatesFilter<"Test"> | number
    currentQuota?: IntWithAggregatesFilter<"Test"> | number
    code?: StringNullableWithAggregatesFilter<"Test"> | string | null
    zoneId?: StringNullableWithAggregatesFilter<"Test"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Test"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Test"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Test"> | Date | string
  }

  export type TestParticipantWhereInput = {
    AND?: TestParticipantWhereInput | TestParticipantWhereInput[]
    OR?: TestParticipantWhereInput[]
    NOT?: TestParticipantWhereInput | TestParticipantWhereInput[]
    id?: StringFilter<"TestParticipant"> | string
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    records?: TestParticipantRecordListRelationFilter
  }

  export type TestParticipantOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrderInput | SortOrder
    lastTestAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    test?: TestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    records?: TestParticipantRecordOrderByRelationAggregateInput
  }

  export type TestParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    testId_userId?: TestParticipantTestIdUserIdCompoundUniqueInput
    AND?: TestParticipantWhereInput | TestParticipantWhereInput[]
    OR?: TestParticipantWhereInput[]
    NOT?: TestParticipantWhereInput | TestParticipantWhereInput[]
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
    test?: XOR<TestScalarRelationFilter, TestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    records?: TestParticipantRecordListRelationFilter
  }, "id" | "testId_userId">

  export type TestParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrderInput | SortOrder
    lastTestAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
    _count?: TestParticipantCountOrderByAggregateInput
    _avg?: TestParticipantAvgOrderByAggregateInput
    _max?: TestParticipantMaxOrderByAggregateInput
    _min?: TestParticipantMinOrderByAggregateInput
    _sum?: TestParticipantSumOrderByAggregateInput
  }

  export type TestParticipantScalarWhereWithAggregatesInput = {
    AND?: TestParticipantScalarWhereWithAggregatesInput | TestParticipantScalarWhereWithAggregatesInput[]
    OR?: TestParticipantScalarWhereWithAggregatesInput[]
    NOT?: TestParticipantScalarWhereWithAggregatesInput | TestParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParticipant"> | string
    testId?: StringWithAggregatesFilter<"TestParticipant"> | string
    userId?: StringWithAggregatesFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableWithAggregatesFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableWithAggregatesFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParticipant"> | Date | string
    highscore?: FloatWithAggregatesFilter<"TestParticipant"> | number
  }

  export type TestParticipantRecordWhereInput = {
    AND?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    OR?: TestParticipantRecordWhereInput[]
    NOT?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    id?: StringFilter<"TestParticipantRecord"> | string
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonFilter<"TestParticipantRecord">
    participant?: XOR<TestParticipantScalarRelationFilter, TestParticipantWhereInput>
  }

  export type TestParticipantRecordOrderByWithRelationInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answers?: SortOrder
    participant?: TestParticipantOrderByWithRelationInput
  }

  export type TestParticipantRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    OR?: TestParticipantRecordWhereInput[]
    NOT?: TestParticipantRecordWhereInput | TestParticipantRecordWhereInput[]
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonFilter<"TestParticipantRecord">
    participant?: XOR<TestParticipantScalarRelationFilter, TestParticipantWhereInput>
  }, "id">

  export type TestParticipantRecordOrderByWithAggregationInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answers?: SortOrder
    _count?: TestParticipantRecordCountOrderByAggregateInput
    _avg?: TestParticipantRecordAvgOrderByAggregateInput
    _max?: TestParticipantRecordMaxOrderByAggregateInput
    _min?: TestParticipantRecordMinOrderByAggregateInput
    _sum?: TestParticipantRecordSumOrderByAggregateInput
  }

  export type TestParticipantRecordScalarWhereWithAggregatesInput = {
    AND?: TestParticipantRecordScalarWhereWithAggregatesInput | TestParticipantRecordScalarWhereWithAggregatesInput[]
    OR?: TestParticipantRecordScalarWhereWithAggregatesInput[]
    NOT?: TestParticipantRecordScalarWhereWithAggregatesInput | TestParticipantRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    participantId?: StringWithAggregatesFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatWithAggregatesFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonWithAggregatesFilter<"TestParticipantRecord">
  }

  export type BackgroundWhereInput = {
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    id?: StringFilter<"Background"> | string
    name?: StringFilter<"Background"> | string
    thumbnailId?: StringFilter<"Background"> | string
    thumbnail?: StringFilter<"Background"> | string
    isUse?: BoolFilter<"Background"> | boolean
    createdAt?: DateTimeFilter<"Background"> | Date | string
    updatedAt?: DateTimeFilter<"Background"> | Date | string
  }

  export type BackgroundOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackgroundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackgroundWhereInput | BackgroundWhereInput[]
    OR?: BackgroundWhereInput[]
    NOT?: BackgroundWhereInput | BackgroundWhereInput[]
    name?: StringFilter<"Background"> | string
    thumbnailId?: StringFilter<"Background"> | string
    thumbnail?: StringFilter<"Background"> | string
    isUse?: BoolFilter<"Background"> | boolean
    createdAt?: DateTimeFilter<"Background"> | Date | string
    updatedAt?: DateTimeFilter<"Background"> | Date | string
  }, "id">

  export type BackgroundOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BackgroundCountOrderByAggregateInput
    _max?: BackgroundMaxOrderByAggregateInput
    _min?: BackgroundMinOrderByAggregateInput
  }

  export type BackgroundScalarWhereWithAggregatesInput = {
    AND?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    OR?: BackgroundScalarWhereWithAggregatesInput[]
    NOT?: BackgroundScalarWhereWithAggregatesInput | BackgroundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Background"> | string
    name?: StringWithAggregatesFilter<"Background"> | string
    thumbnailId?: StringWithAggregatesFilter<"Background"> | string
    thumbnail?: StringWithAggregatesFilter<"Background"> | string
    isUse?: BoolWithAggregatesFilter<"Background"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Background"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Background"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    name?: StringFilter<"Setting"> | string
    title?: StringFilter<"Setting"> | string
    content?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    name?: StringFilter<"Setting"> | string
    title?: StringFilter<"Setting"> | string
    content?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    name?: StringWithAggregatesFilter<"Setting"> | string
    title?: StringWithAggregatesFilter<"Setting"> | string
    content?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type AdminTransactionWhereInput = {
    AND?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    OR?: AdminTransactionWhereInput[]
    NOT?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    id?: StringFilter<"AdminTransaction"> | string
    name?: StringFilter<"AdminTransaction"> | string
    status?: EnumTransactionFilter<"AdminTransaction"> | $Enums.Transaction
    archived?: BoolFilter<"AdminTransaction"> | boolean
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    adminId?: StringFilter<"AdminTransaction"> | string
    quantity?: IntFilter<"AdminTransaction"> | number
    subscriptionTime?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    transactionRef?: StringNullableFilter<"AdminTransaction"> | string | null
    amount?: IntFilter<"AdminTransaction"> | number
    description?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageId?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableFilter<"AdminTransaction"> | string | null
    processedById?: StringNullableFilter<"AdminTransaction"> | string | null
    processedAt?: DateTimeNullableFilter<"AdminTransaction"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    redeemCode?: XOR<RedeemCodeNullableScalarRelationFilter, RedeemCodeWhereInput> | null
    processedBy?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }

  export type AdminTransactionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    zones?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    transactionImageId?: SortOrderInput | SortOrder
    transactionImageUrl?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    redeemCode?: RedeemCodeOrderByWithRelationInput
    processedBy?: AdminOrderByWithRelationInput
  }

  export type AdminTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    OR?: AdminTransactionWhereInput[]
    NOT?: AdminTransactionWhereInput | AdminTransactionWhereInput[]
    name?: StringFilter<"AdminTransaction"> | string
    status?: EnumTransactionFilter<"AdminTransaction"> | $Enums.Transaction
    archived?: BoolFilter<"AdminTransaction"> | boolean
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    adminId?: StringFilter<"AdminTransaction"> | string
    quantity?: IntFilter<"AdminTransaction"> | number
    subscriptionTime?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    transactionRef?: StringNullableFilter<"AdminTransaction"> | string | null
    amount?: IntFilter<"AdminTransaction"> | number
    description?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageId?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableFilter<"AdminTransaction"> | string | null
    processedById?: StringNullableFilter<"AdminTransaction"> | string | null
    processedAt?: DateTimeNullableFilter<"AdminTransaction"> | Date | string | null
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    redeemCode?: XOR<RedeemCodeNullableScalarRelationFilter, RedeemCodeWhereInput> | null
    processedBy?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
  }, "id">

  export type AdminTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    zones?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    transactionImageId?: SortOrderInput | SortOrder
    transactionImageUrl?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: AdminTransactionCountOrderByAggregateInput
    _avg?: AdminTransactionAvgOrderByAggregateInput
    _max?: AdminTransactionMaxOrderByAggregateInput
    _min?: AdminTransactionMinOrderByAggregateInput
    _sum?: AdminTransactionSumOrderByAggregateInput
  }

  export type AdminTransactionScalarWhereWithAggregatesInput = {
    AND?: AdminTransactionScalarWhereWithAggregatesInput | AdminTransactionScalarWhereWithAggregatesInput[]
    OR?: AdminTransactionScalarWhereWithAggregatesInput[]
    NOT?: AdminTransactionScalarWhereWithAggregatesInput | AdminTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminTransaction"> | string
    name?: StringWithAggregatesFilter<"AdminTransaction"> | string
    status?: EnumTransactionWithAggregatesFilter<"AdminTransaction"> | $Enums.Transaction
    archived?: BoolWithAggregatesFilter<"AdminTransaction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminTransaction"> | Date | string
    adminId?: StringWithAggregatesFilter<"AdminTransaction"> | string
    quantity?: IntWithAggregatesFilter<"AdminTransaction"> | number
    subscriptionTime?: IntWithAggregatesFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    transactionRef?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    amount?: IntWithAggregatesFilter<"AdminTransaction"> | number
    description?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    transactionImageId?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    processedById?: StringNullableWithAggregatesFilter<"AdminTransaction"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"AdminTransaction"> | Date | string | null
  }

  export type RedeemCodeWhereInput = {
    AND?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    OR?: RedeemCodeWhereInput[]
    NOT?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    id?: StringFilter<"RedeemCode"> | string
    suspend?: BoolFilter<"RedeemCode"> | boolean
    transactionId?: StringFilter<"RedeemCode"> | string
    adminId?: StringFilter<"RedeemCode"> | string
    code?: StringFilter<"RedeemCode"> | string
    expiredAt?: DateTimeFilter<"RedeemCode"> | Date | string
    currentAmount?: IntFilter<"RedeemCode"> | number
    maxAmount?: IntFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeFilter<"RedeemCode"> | Date | string
    transaction?: XOR<AdminTransactionScalarRelationFilter, AdminTransactionWhereInput>
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    redemeers?: CodeRedemeerListRelationFilter
  }

  export type RedeemCodeOrderByWithRelationInput = {
    id?: SortOrder
    suspend?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: AdminTransactionOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    redemeers?: CodeRedemeerOrderByRelationAggregateInput
  }

  export type RedeemCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    code?: string
    AND?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    OR?: RedeemCodeWhereInput[]
    NOT?: RedeemCodeWhereInput | RedeemCodeWhereInput[]
    suspend?: BoolFilter<"RedeemCode"> | boolean
    adminId?: StringFilter<"RedeemCode"> | string
    expiredAt?: DateTimeFilter<"RedeemCode"> | Date | string
    currentAmount?: IntFilter<"RedeemCode"> | number
    maxAmount?: IntFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeFilter<"RedeemCode"> | Date | string
    transaction?: XOR<AdminTransactionScalarRelationFilter, AdminTransactionWhereInput>
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    redemeers?: CodeRedemeerListRelationFilter
  }, "id" | "transactionId" | "code">

  export type RedeemCodeOrderByWithAggregationInput = {
    id?: SortOrder
    suspend?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RedeemCodeCountOrderByAggregateInput
    _avg?: RedeemCodeAvgOrderByAggregateInput
    _max?: RedeemCodeMaxOrderByAggregateInput
    _min?: RedeemCodeMinOrderByAggregateInput
    _sum?: RedeemCodeSumOrderByAggregateInput
  }

  export type RedeemCodeScalarWhereWithAggregatesInput = {
    AND?: RedeemCodeScalarWhereWithAggregatesInput | RedeemCodeScalarWhereWithAggregatesInput[]
    OR?: RedeemCodeScalarWhereWithAggregatesInput[]
    NOT?: RedeemCodeScalarWhereWithAggregatesInput | RedeemCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RedeemCode"> | string
    suspend?: BoolWithAggregatesFilter<"RedeemCode"> | boolean
    transactionId?: StringWithAggregatesFilter<"RedeemCode"> | string
    adminId?: StringWithAggregatesFilter<"RedeemCode"> | string
    code?: StringWithAggregatesFilter<"RedeemCode"> | string
    expiredAt?: DateTimeWithAggregatesFilter<"RedeemCode"> | Date | string
    currentAmount?: IntWithAggregatesFilter<"RedeemCode"> | number
    maxAmount?: IntWithAggregatesFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeWithAggregatesFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RedeemCode"> | Date | string
  }

  export type CodeRedemeerWhereInput = {
    AND?: CodeRedemeerWhereInput | CodeRedemeerWhereInput[]
    OR?: CodeRedemeerWhereInput[]
    NOT?: CodeRedemeerWhereInput | CodeRedemeerWhereInput[]
    id?: StringFilter<"CodeRedemeer"> | string
    banned?: BoolFilter<"CodeRedemeer"> | boolean
    userId?: StringFilter<"CodeRedemeer"> | string
    codeId?: StringFilter<"CodeRedemeer"> | string
    createdAt?: DateTimeFilter<"CodeRedemeer"> | Date | string
    updatedAt?: DateTimeFilter<"CodeRedemeer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    code?: XOR<RedeemCodeScalarRelationFilter, RedeemCodeWhereInput>
  }

  export type CodeRedemeerOrderByWithRelationInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    code?: RedeemCodeOrderByWithRelationInput
  }

  export type CodeRedemeerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_userId?: CodeRedemeerIdUserIdCompoundUniqueInput
    codeId_userId?: CodeRedemeerCodeIdUserIdCompoundUniqueInput
    AND?: CodeRedemeerWhereInput | CodeRedemeerWhereInput[]
    OR?: CodeRedemeerWhereInput[]
    NOT?: CodeRedemeerWhereInput | CodeRedemeerWhereInput[]
    banned?: BoolFilter<"CodeRedemeer"> | boolean
    userId?: StringFilter<"CodeRedemeer"> | string
    codeId?: StringFilter<"CodeRedemeer"> | string
    createdAt?: DateTimeFilter<"CodeRedemeer"> | Date | string
    updatedAt?: DateTimeFilter<"CodeRedemeer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    code?: XOR<RedeemCodeScalarRelationFilter, RedeemCodeWhereInput>
  }, "id" | "id_userId" | "codeId_userId">

  export type CodeRedemeerOrderByWithAggregationInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodeRedemeerCountOrderByAggregateInput
    _max?: CodeRedemeerMaxOrderByAggregateInput
    _min?: CodeRedemeerMinOrderByAggregateInput
  }

  export type CodeRedemeerScalarWhereWithAggregatesInput = {
    AND?: CodeRedemeerScalarWhereWithAggregatesInput | CodeRedemeerScalarWhereWithAggregatesInput[]
    OR?: CodeRedemeerScalarWhereWithAggregatesInput[]
    NOT?: CodeRedemeerScalarWhereWithAggregatesInput | CodeRedemeerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CodeRedemeer"> | string
    banned?: BoolWithAggregatesFilter<"CodeRedemeer"> | boolean
    userId?: StringWithAggregatesFilter<"CodeRedemeer"> | string
    codeId?: StringWithAggregatesFilter<"CodeRedemeer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CodeRedemeer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CodeRedemeer"> | Date | string
  }

  export type MultiplayerRoomWhereInput = {
    AND?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    OR?: MultiplayerRoomWhereInput[]
    NOT?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    id?: StringFilter<"MultiplayerRoom"> | string
    max?: IntFilter<"MultiplayerRoom"> | number
    gameplayId?: StringFilter<"MultiplayerRoom"> | string
    botOwner?: StringFilter<"MultiplayerRoom"> | string
    startedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    isStarted?: BoolFilter<"MultiplayerRoom"> | boolean
    isEnded?: BoolFilter<"MultiplayerRoom"> | boolean
    createdAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    updatedAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    currentMember?: IntFilter<"MultiplayerRoom"> | number
    members?: MultiPlayerMemberListRelationFilter
  }

  export type MultiplayerRoomOrderByWithRelationInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
    members?: MultiPlayerMemberOrderByRelationAggregateInput
  }

  export type MultiplayerRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    gameplayId?: string
    AND?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    OR?: MultiplayerRoomWhereInput[]
    NOT?: MultiplayerRoomWhereInput | MultiplayerRoomWhereInput[]
    max?: IntFilter<"MultiplayerRoom"> | number
    botOwner?: StringFilter<"MultiplayerRoom"> | string
    startedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"MultiplayerRoom"> | Date | string | null
    isStarted?: BoolFilter<"MultiplayerRoom"> | boolean
    isEnded?: BoolFilter<"MultiplayerRoom"> | boolean
    createdAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    updatedAt?: DateTimeFilter<"MultiplayerRoom"> | Date | string
    currentMember?: IntFilter<"MultiplayerRoom"> | number
    members?: MultiPlayerMemberListRelationFilter
  }, "id" | "gameplayId">

  export type MultiplayerRoomOrderByWithAggregationInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
    _count?: MultiplayerRoomCountOrderByAggregateInput
    _avg?: MultiplayerRoomAvgOrderByAggregateInput
    _max?: MultiplayerRoomMaxOrderByAggregateInput
    _min?: MultiplayerRoomMinOrderByAggregateInput
    _sum?: MultiplayerRoomSumOrderByAggregateInput
  }

  export type MultiplayerRoomScalarWhereWithAggregatesInput = {
    AND?: MultiplayerRoomScalarWhereWithAggregatesInput | MultiplayerRoomScalarWhereWithAggregatesInput[]
    OR?: MultiplayerRoomScalarWhereWithAggregatesInput[]
    NOT?: MultiplayerRoomScalarWhereWithAggregatesInput | MultiplayerRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultiplayerRoom"> | string
    max?: IntWithAggregatesFilter<"MultiplayerRoom"> | number
    gameplayId?: StringWithAggregatesFilter<"MultiplayerRoom"> | string
    botOwner?: StringWithAggregatesFilter<"MultiplayerRoom"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"MultiplayerRoom"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"MultiplayerRoom"> | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter<"MultiplayerRoom"> | Date | string | null
    isStarted?: BoolWithAggregatesFilter<"MultiplayerRoom"> | boolean
    isEnded?: BoolWithAggregatesFilter<"MultiplayerRoom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MultiplayerRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MultiplayerRoom"> | Date | string
    currentMember?: IntWithAggregatesFilter<"MultiplayerRoom"> | number
  }

  export type MultiPlayerMemberWhereInput = {
    AND?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    OR?: MultiPlayerMemberWhereInput[]
    NOT?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    id?: StringFilter<"MultiPlayerMember"> | string
    roomId?: StringFilter<"MultiPlayerMember"> | string
    userId?: StringFilter<"MultiPlayerMember"> | string
    point?: IntFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntFilter<"MultiPlayerMember"> | number
    isReady?: BoolFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MultiPlayerMember"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    room?: XOR<MultiplayerRoomScalarRelationFilter, MultiplayerRoomWhereInput>
  }

  export type MultiPlayerMemberOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    user?: UserOrderByWithRelationInput
    room?: MultiplayerRoomOrderByWithRelationInput
  }

  export type MultiPlayerMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    OR?: MultiPlayerMemberWhereInput[]
    NOT?: MultiPlayerMemberWhereInput | MultiPlayerMemberWhereInput[]
    roomId?: StringFilter<"MultiPlayerMember"> | string
    userId?: StringFilter<"MultiPlayerMember"> | string
    point?: IntFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntFilter<"MultiPlayerMember"> | number
    isReady?: BoolFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MultiPlayerMember"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    room?: XOR<MultiplayerRoomScalarRelationFilter, MultiplayerRoomWhereInput>
  }, "id">

  export type MultiPlayerMemberOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    isDisconnect?: SortOrder
    _count?: MultiPlayerMemberCountOrderByAggregateInput
    _avg?: MultiPlayerMemberAvgOrderByAggregateInput
    _max?: MultiPlayerMemberMaxOrderByAggregateInput
    _min?: MultiPlayerMemberMinOrderByAggregateInput
    _sum?: MultiPlayerMemberSumOrderByAggregateInput
  }

  export type MultiPlayerMemberScalarWhereWithAggregatesInput = {
    AND?: MultiPlayerMemberScalarWhereWithAggregatesInput | MultiPlayerMemberScalarWhereWithAggregatesInput[]
    OR?: MultiPlayerMemberScalarWhereWithAggregatesInput[]
    NOT?: MultiPlayerMemberScalarWhereWithAggregatesInput | MultiPlayerMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultiPlayerMember"> | string
    roomId?: StringWithAggregatesFilter<"MultiPlayerMember"> | string
    userId?: StringWithAggregatesFilter<"MultiPlayerMember"> | string
    point?: IntWithAggregatesFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntWithAggregatesFilter<"MultiPlayerMember"> | number
    isReady?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolWithAggregatesFilter<"MultiPlayerMember"> | boolean
  }

  export type ProvinceCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
    admin?: AdminCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
    admin?: AdminUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProvinceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProvinceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
    admin?: AdminCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
    admin?: AdminUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
    admin?: AdminCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type ZoneCreateInput = {
    id?: string
    inGameId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZonesInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    inGameId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZonesNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateManyInput = {
    id?: string
    inGameId: string
    userId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLevelsInput
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLevelsNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelCreateManyInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type LevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubLevelsInput
  }

  export type SubLevelUncheckedCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type SubLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubLevelsNestedInput
  }

  export type SubLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SubLevelCreateManyInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type SubLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInnerLevelsInput
  }

  export type InnerLevelUncheckedCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type InnerLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInnerLevelsNestedInput
  }

  export type InnerLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InnerLevelCreateManyInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type InnerLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGemposInput
  }

  export type GempoUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type GempoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGemposNestedInput
  }

  export type GempoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type GempoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChampionshipsInput
  }

  export type ChampionshipUncheckedCreateInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ChampionshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChampionshipsNestedInput
  }

  export type ChampionshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipCreateManyInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ChampionshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoRecordCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGempoRecordsInput
  }

  export type GempoRecordUncheckedCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type GempoRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGempoRecordsNestedInput
  }

  export type GempoRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GempoRecordCreateManyInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type GempoRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutChampionshipRecordsInput
  }

  export type ChampionshipRecordUncheckedCreateInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ChampionshipRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChampionshipRecordsNestedInput
  }

  export type ChampionshipRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChampionshipRecordCreateManyInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ChampionshipRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLoginCreateInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
    user: UserCreateNestedOneWithoutUserLoginInput
  }

  export type UserLoginUncheckedCreateInput = {
    id?: string
    userId: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserLoginNestedInput
  }

  export type UserLoginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginCreateManyInput = {
    id?: string
    userId: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminCreateInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminOperationHistoryCreateInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    admin: AdminCreateNestedOneWithoutOperationHistoriesInput
    opAdmin: AdminCreateNestedOneWithoutOperationsInput
  }

  export type AdminOperationHistoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    admin?: AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput
    opAdmin?: AdminUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminAuthorityCreateInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityCreateManyInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type AdminAuthorityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminAuthorityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerCreateInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
    admin: AdminCreateNestedOneWithoutBannerInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerCreateManyInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerLocationCreateInput = {
    id?: string
    banner: BannerCreateNestedOneWithoutBannerLocationInput
    province: ProvinceCreateNestedOneWithoutBannerLocationInput
    cities?: CityCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateInput = {
    id?: string
    bannerId: string
    provinceId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: BannerUpdateOneRequiredWithoutBannerLocationNestedInput
    province?: ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput
    cities?: CityUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationCreateManyInput = {
    id?: string
    bannerId: string
    provinceId: string
  }

  export type BannerLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BannerLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerVisitorCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    banner: BannerCreateNestedOneWithoutVisitorsInput
    user: UserCreateNestedOneWithoutBannerVisitorInput
  }

  export type BannerVisitorUncheckedCreateInput = {
    id?: string
    bannerId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    banner?: BannerUpdateOneRequiredWithoutVisitorsNestedInput
    user?: UserUpdateOneRequiredWithoutBannerVisitorNestedInput
  }

  export type BannerVisitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorCreateManyInput = {
    id?: string
    bannerId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateInput = {
    id?: string
    name?: string
    category: $Enums.Role
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TestParticipantCreateNestedManyWithoutTestInput
  }

  export type TestUncheckedCreateInput = {
    id?: string
    name?: string
    category: $Enums.Role
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: TestParticipantUncheckedCreateNestedManyWithoutTestInput
  }

  export type TestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TestParticipantUpdateManyWithoutTestNestedInput
  }

  export type TestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: TestParticipantUncheckedUpdateManyWithoutTestNestedInput
  }

  export type TestCreateManyInput = {
    id?: string
    name?: string
    category: $Enums.Role
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestParticipantCreateInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTestParticipantInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateInput = {
    id?: string
    testId: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantCreateManyInput = {
    id?: string
    testId: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type TestParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantRecordCreateInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
    participant: TestParticipantCreateNestedOneWithoutRecordsInput
  }

  export type TestParticipantRecordUncheckedCreateInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
    participant?: TestParticipantUpdateOneRequiredWithoutRecordsNestedInput
  }

  export type TestParticipantRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateManyInput = {
    id?: string
    participantId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type BackgroundCreateInput = {
    id?: string
    name: string
    thumbnailId: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackgroundUncheckedCreateInput = {
    id?: string
    name: string
    thumbnailId: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackgroundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackgroundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackgroundCreateManyInput = {
    id?: string
    name: string
    thumbnailId: string
    thumbnail: string
    isUse: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackgroundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackgroundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isUse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    name: string
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminTransactionCreateInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutTransactionsInput
    redeemCode?: RedeemCodeCreateNestedOneWithoutTransactionInput
    processedBy?: AdminCreateNestedOneWithoutTransactionProcessedInput
  }

  export type AdminTransactionUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    redeemCode?: RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutTransactionsNestedInput
    redeemCode?: RedeemCodeUpdateOneWithoutTransactionNestedInput
    processedBy?: AdminUpdateOneWithoutTransactionProcessedNestedInput
  }

  export type AdminTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemCode?: RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
  }

  export type AdminTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RedeemCodeCreateInput = {
    id?: string
    suspend?: boolean
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: AdminTransactionCreateNestedOneWithoutRedeemCodeInput
    admin: AdminCreateNestedOneWithoutRedeemCodesInput
    redemeers?: CodeRedemeerCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeUncheckedCreateInput = {
    id?: string
    suspend?: boolean
    transactionId: string
    adminId: string
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    redemeers?: CodeRedemeerUncheckedCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput
    admin?: AdminUpdateOneRequiredWithoutRedeemCodesNestedInput
    redemeers?: CodeRedemeerUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemeers?: CodeRedemeerUncheckedUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeCreateManyInput = {
    id?: string
    suspend?: boolean
    transactionId: string
    adminId: string
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedeemCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedeemCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedemeerCreateInput = {
    id?: string
    banned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRedemeedCodesInput
    code: RedeemCodeCreateNestedOneWithoutRedemeersInput
  }

  export type CodeRedemeerUncheckedCreateInput = {
    id?: string
    banned?: boolean
    userId: string
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedemeerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRedemeedCodesNestedInput
    code?: RedeemCodeUpdateOneRequiredWithoutRedemeersNestedInput
  }

  export type CodeRedemeerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedemeerCreateManyInput = {
    id?: string
    banned?: boolean
    userId: string
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedemeerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedemeerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiplayerRoomCreateInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
    members?: MultiPlayerMemberCreateNestedManyWithoutRoomInput
  }

  export type MultiplayerRoomUncheckedCreateInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
    members?: MultiPlayerMemberUncheckedCreateNestedManyWithoutRoomInput
  }

  export type MultiplayerRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
    members?: MultiPlayerMemberUpdateManyWithoutRoomNestedInput
  }

  export type MultiplayerRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
    members?: MultiPlayerMemberUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type MultiplayerRoomCreateManyInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type MultiplayerRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type MultiplayerRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type MultiPlayerMemberCreateInput = {
    id?: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    user: UserCreateNestedOneWithoutMultiPlayerMemberInput
    room: MultiplayerRoomCreateNestedOneWithoutMembersInput
  }

  export type MultiPlayerMemberUncheckedCreateInput = {
    id?: string
    roomId: string
    userId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMultiPlayerMemberNestedInput
    room?: MultiplayerRoomUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MultiPlayerMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberCreateManyInput = {
    id?: string
    roomId: string
    userId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AdminAuthorityListRelationFilter = {
    every?: AdminAuthorityWhereInput
    some?: AdminAuthorityWhereInput
    none?: AdminAuthorityWhereInput
  }

  export type BannerLocationListRelationFilter = {
    every?: BannerLocationWhereInput
    some?: BannerLocationWhereInput
    none?: BannerLocationWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type CityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuthorityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type ProvinceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProvinceSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProvinceScalarRelationFilter = {
    is?: ProvinceWhereInput
    isNot?: ProvinceWhereInput
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    geoId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    identity?: SortOrder
    name?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CityNullableScalarRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type ProvinceNullableScalarRelationFilter = {
    is?: ProvinceWhereInput | null
    isNot?: ProvinceWhereInput | null
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type UserLoginListRelationFilter = {
    every?: UserLoginWhereInput
    some?: UserLoginWhereInput
    none?: UserLoginWhereInput
  }

  export type BannerVisitorListRelationFilter = {
    every?: BannerVisitorWhereInput
    some?: BannerVisitorWhereInput
    none?: BannerVisitorWhereInput
  }

  export type TestParticipantListRelationFilter = {
    every?: TestParticipantWhereInput
    some?: TestParticipantWhereInput
    none?: TestParticipantWhereInput
  }

  export type MultiPlayerMemberListRelationFilter = {
    every?: MultiPlayerMemberWhereInput
    some?: MultiPlayerMemberWhereInput
    none?: MultiPlayerMemberWhereInput
  }

  export type SubLevelListRelationFilter = {
    every?: SubLevelWhereInput
    some?: SubLevelWhereInput
    none?: SubLevelWhereInput
  }

  export type InnerLevelListRelationFilter = {
    every?: InnerLevelWhereInput
    some?: InnerLevelWhereInput
    none?: InnerLevelWhereInput
  }

  export type LevelListRelationFilter = {
    every?: LevelWhereInput
    some?: LevelWhereInput
    none?: LevelWhereInput
  }

  export type GempoListRelationFilter = {
    every?: GempoWhereInput
    some?: GempoWhereInput
    none?: GempoWhereInput
  }

  export type ChampionshipListRelationFilter = {
    every?: ChampionshipWhereInput
    some?: ChampionshipWhereInput
    none?: ChampionshipWhereInput
  }

  export type GempoRecordListRelationFilter = {
    every?: GempoRecordWhereInput
    some?: GempoRecordWhereInput
    none?: GempoRecordWhereInput
  }

  export type ChampionshipRecordListRelationFilter = {
    every?: ChampionshipRecordWhereInput
    some?: ChampionshipRecordWhereInput
    none?: ChampionshipRecordWhereInput
  }

  export type CodeRedemeerListRelationFilter = {
    every?: CodeRedemeerWhereInput
    some?: CodeRedemeerWhereInput
    none?: CodeRedemeerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerVisitorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultiPlayerMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InnerLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GempoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChampionshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GempoRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChampionshipRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeRedemeerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    inventory?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    grade?: SortOrder
    playTime?: SortOrder
    inventory?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    suspend?: SortOrder
    accountType?: SortOrder
    firstTest?: SortOrder
    fullname?: SortOrder
    birthDate?: SortOrder
    grade?: SortOrder
    lastGradeUpdateAt?: SortOrder
    schoolIdentity?: SortOrder
    loginAt?: SortOrder
    logoutAt?: SortOrder
    playTime?: SortOrder
    characterUsed?: SortOrder
    schoolId?: SortOrder
    cityId?: SortOrder
    provinceId?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    lastIdZoneUnlocked?: SortOrder
    lastIdZonePosition?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    grade?: SortOrder
    playTime?: SortOrder
    inventory?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ZoneUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    userId?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    lastLevelId?: SortOrder
    lastSubLevelId?: SortOrder
    lastInnerLevelId?: SortOrder
    lastLevelUnlock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type SubLevelUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type SubLevelCountOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type SubLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type SubLevelMinOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type InnerLevelUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type InnerLevelCountOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type InnerLevelAvgOrderByAggregateInput = {
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
  }

  export type InnerLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type InnerLevelMinOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    levelInGameId?: SortOrder
    subLevelInGameId?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    isComplete?: SortOrder
    completedAt?: SortOrder
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type InnerLevelSumOrderByAggregateInput = {
    correctAttempt?: SortOrder
    playTime?: SortOrder
    point?: SortOrder
    played?: SortOrder
  }

  export type GempoUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type GempoCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GempoMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GempoMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ChampionshipUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type ChampionshipCountOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ChampionshipMaxOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ChampionshipMinOrderByAggregateInput = {
    id?: SortOrder
    isUnlock?: SortOrder
    unlockedAt?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GempoRecordUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type GempoRecordCountOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    gempoInGameId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GempoRecordAvgOrderByAggregateInput = {
    played?: SortOrder
    point?: SortOrder
  }

  export type GempoRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    gempoInGameId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GempoRecordMinOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    gempoInGameId?: SortOrder
    played?: SortOrder
    point?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type GempoRecordSumOrderByAggregateInput = {
    played?: SortOrder
    point?: SortOrder
  }

  export type ChampionshipRecordUserIdInGameIdCompoundUniqueInput = {
    userId: string
    inGameId: string
  }

  export type ChampionshipRecordCountOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    championshipInGameId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ChampionshipRecordAvgOrderByAggregateInput = {
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
  }

  export type ChampionshipRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    championshipInGameId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ChampionshipRecordMinOrderByAggregateInput = {
    id?: SortOrder
    inGameId?: SortOrder
    zoneInGameId?: SortOrder
    championshipInGameId?: SortOrder
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    teamLastPlayedAt?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
    soloLastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ChampionshipRecordSumOrderByAggregateInput = {
    teamWin?: SortOrder
    teamLose?: SortOrder
    teamPlayed?: SortOrder
    teamPoint?: SortOrder
    soloWin?: SortOrder
    soloLose?: SortOrder
    soloPlayed?: SortOrder
    soloPoint?: SortOrder
  }

  export type UserLoginCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type UserLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type UserLoginMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    loginDate?: SortOrder
    logoutDate?: SortOrder
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AdminOperationHistoryListRelationFilter = {
    every?: AdminOperationHistoryWhereInput
    some?: AdminOperationHistoryWhereInput
    none?: AdminOperationHistoryWhereInput
  }

  export type BannerListRelationFilter = {
    every?: BannerWhereInput
    some?: BannerWhereInput
    none?: BannerWhereInput
  }

  export type AdminTransactionListRelationFilter = {
    every?: AdminTransactionWhereInput
    some?: AdminTransactionWhereInput
    none?: AdminTransactionWhereInput
  }

  export type RedeemCodeListRelationFilter = {
    every?: RedeemCodeWhereInput
    some?: RedeemCodeWhereInput
    none?: RedeemCodeWhereInput
  }

  export type AdminOperationHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedeemCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    suspend?: SortOrder
    role?: SortOrder
    provinceId?: SortOrder
    cityId?: SortOrder
    schoolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type EnumOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationFilter<$PrismaModel> | $Enums.Operation
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type AdminOperationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type AdminOperationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type AdminOperationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    adminId?: SortOrder
    opAdminId?: SortOrder
    operation?: SortOrder
  }

  export type EnumOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationWithAggregatesFilter<$PrismaModel> | $Enums.Operation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationFilter<$PrismaModel>
    _max?: NestedEnumOperationFilter<$PrismaModel>
  }

  export type AdminAuthorityCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
    grades?: SortOrder
  }

  export type AdminAuthorityAvgOrderByAggregateInput = {
    grades?: SortOrder
  }

  export type AdminAuthorityMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
  }

  export type AdminAuthorityMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    provinceId?: SortOrder
  }

  export type AdminAuthoritySumOrderByAggregateInput = {
    grades?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    link?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    isHide?: SortOrder
    adminId?: SortOrder
  }

  export type BannerScalarRelationFilter = {
    is?: BannerWhereInput
    isNot?: BannerWhereInput
  }

  export type BannerLocationCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
  }

  export type BannerLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
  }

  export type BannerLocationMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    provinceId?: SortOrder
  }

  export type BannerVisitorCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorAvgOrderByAggregateInput = {
    traffic?: SortOrder
  }

  export type BannerVisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    traffic?: SortOrder
  }

  export type BannerVisitorSumOrderByAggregateInput = {
    traffic?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type EnumTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeFilter<$PrismaModel> | $Enums.TestType
  }

  export type TestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    question?: SortOrder
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    type?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    duration?: SortOrder
    passedPoint?: SortOrder
    remidialCount?: SortOrder
    quota?: SortOrder
    currentQuota?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type EnumTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.TestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestTypeFilter<$PrismaModel>
    _max?: NestedEnumTestTypeFilter<$PrismaModel>
  }

  export type TestScalarRelationFilter = {
    is?: TestWhereInput
    isNot?: TestWhereInput
  }

  export type TestParticipantRecordListRelationFilter = {
    every?: TestParticipantRecordWhereInput
    some?: TestParticipantRecordWhereInput
    none?: TestParticipantRecordWhereInput
  }

  export type TestParticipantRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParticipantTestIdUserIdCompoundUniqueInput = {
    testId: string
    userId: string
  }

  export type TestParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrder
    lastTestAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
  }

  export type TestParticipantAvgOrderByAggregateInput = {
    highscore?: SortOrder
  }

  export type TestParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrder
    lastTestAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
  }

  export type TestParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    userId?: SortOrder
    firstTimeAt?: SortOrder
    lastTestAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highscore?: SortOrder
  }

  export type TestParticipantSumOrderByAggregateInput = {
    highscore?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TestParticipantScalarRelationFilter = {
    is?: TestParticipantWhereInput
    isNot?: TestParticipantWhereInput
  }

  export type TestParticipantRecordCountOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answers?: SortOrder
  }

  export type TestParticipantRecordAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type TestParticipantRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestParticipantRecordMinOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestParticipantRecordSumOrderByAggregateInput = {
    score?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BackgroundCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackgroundMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackgroundMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    thumbnailId?: SortOrder
    thumbnail?: SortOrder
    isUse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransactionFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFilter<$PrismaModel> | $Enums.Transaction
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RedeemCodeNullableScalarRelationFilter = {
    is?: RedeemCodeWhereInput | null
    isNot?: RedeemCodeWhereInput | null
  }

  export type AdminTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    zones?: SortOrder
    transactionRef?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionImageId?: SortOrder
    transactionImageUrl?: SortOrder
    processedById?: SortOrder
    processedAt?: SortOrder
  }

  export type AdminTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    amount?: SortOrder
  }

  export type AdminTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    transactionRef?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionImageId?: SortOrder
    transactionImageUrl?: SortOrder
    processedById?: SortOrder
    processedAt?: SortOrder
  }

  export type AdminTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminId?: SortOrder
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    transactionRef?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionImageId?: SortOrder
    transactionImageUrl?: SortOrder
    processedById?: SortOrder
    processedAt?: SortOrder
  }

  export type AdminTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
    subscriptionTime?: SortOrder
    amount?: SortOrder
  }

  export type EnumTransactionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionWithAggregatesFilter<$PrismaModel> | $Enums.Transaction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionFilter<$PrismaModel>
    _max?: NestedEnumTransactionFilter<$PrismaModel>
  }

  export type AdminTransactionScalarRelationFilter = {
    is?: AdminTransactionWhereInput
    isNot?: AdminTransactionWhereInput
  }

  export type RedeemCodeCountOrderByAggregateInput = {
    id?: SortOrder
    suspend?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedeemCodeAvgOrderByAggregateInput = {
    currentAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type RedeemCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    suspend?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedeemCodeMinOrderByAggregateInput = {
    id?: SortOrder
    suspend?: SortOrder
    transactionId?: SortOrder
    adminId?: SortOrder
    code?: SortOrder
    expiredAt?: SortOrder
    currentAmount?: SortOrder
    maxAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RedeemCodeSumOrderByAggregateInput = {
    currentAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type RedeemCodeScalarRelationFilter = {
    is?: RedeemCodeWhereInput
    isNot?: RedeemCodeWhereInput
  }

  export type CodeRedemeerIdUserIdCompoundUniqueInput = {
    id: string
    userId: string
  }

  export type CodeRedemeerCodeIdUserIdCompoundUniqueInput = {
    codeId: string
    userId: string
  }

  export type CodeRedemeerCountOrderByAggregateInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeRedemeerMaxOrderByAggregateInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeRedemeerMinOrderByAggregateInput = {
    id?: SortOrder
    banned?: SortOrder
    userId?: SortOrder
    codeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultiplayerRoomCountOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type MultiplayerRoomAvgOrderByAggregateInput = {
    max?: SortOrder
    currentMember?: SortOrder
  }

  export type MultiplayerRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type MultiplayerRoomMinOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    gameplayId?: SortOrder
    botOwner?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    expiredAt?: SortOrder
    isStarted?: SortOrder
    isEnded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMember?: SortOrder
  }

  export type MultiplayerRoomSumOrderByAggregateInput = {
    max?: SortOrder
    currentMember?: SortOrder
  }

  export type MultiplayerRoomScalarRelationFilter = {
    is?: MultiplayerRoomWhereInput
    isNot?: MultiplayerRoomWhereInput
  }

  export type MultiPlayerMemberCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MultiPlayerMemberAvgOrderByAggregateInput = {
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type MultiPlayerMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MultiPlayerMemberMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    point?: SortOrder
    bonusPoint?: SortOrder
    isReady?: SortOrder
    isComplete?: SortOrder
    isBot?: SortOrder
    joinedAt?: SortOrder
    finishedAt?: SortOrder
    isDisconnect?: SortOrder
  }

  export type MultiPlayerMemberSumOrderByAggregateInput = {
    point?: SortOrder
    bonusPoint?: SortOrder
  }

  export type CityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationCreateNestedManyWithoutProvinceInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CityUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutProvinceInput | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutProvinceInput | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: CityUpdateManyWithWhereWithoutProvinceInput | CityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutProvinceInput | SchoolUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutProvinceInput | SchoolUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutProvinceInput | SchoolUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProvinceInput | UserUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProvinceInput | UserUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProvinceInput | UserUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutProvinceInput | AdminAuthorityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutProvinceInput | BannerLocationUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutProvinceInput | BannerLocationUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutProvinceInput | BannerLocationUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutProvinceInput | AdminUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutProvinceInput | AdminUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutProvinceInput | AdminUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput> | CityCreateWithoutProvinceInput[] | CityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: CityCreateOrConnectWithoutProvinceInput | CityCreateOrConnectWithoutProvinceInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutProvinceInput | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: CityCreateManyProvinceInputEnvelope
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutProvinceInput | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: CityUpdateManyWithWhereWithoutProvinceInput | CityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput> | SchoolCreateWithoutProvinceInput[] | SchoolUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutProvinceInput | SchoolCreateOrConnectWithoutProvinceInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutProvinceInput | SchoolUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: SchoolCreateManyProvinceInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutProvinceInput | SchoolUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutProvinceInput | SchoolUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput> | UserCreateWithoutProvinceInput[] | UserUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProvinceInput | UserCreateOrConnectWithoutProvinceInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProvinceInput | UserUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: UserCreateManyProvinceInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProvinceInput | UserUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProvinceInput | UserUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput> | AdminAuthorityCreateWithoutProvinceInput[] | AdminAuthorityUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutProvinceInput | AdminAuthorityCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminAuthorityCreateManyProvinceInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput | AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutProvinceInput | AdminAuthorityUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput> | BannerLocationCreateWithoutProvinceInput[] | BannerLocationUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutProvinceInput | BannerLocationCreateOrConnectWithoutProvinceInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutProvinceInput | BannerLocationUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: BannerLocationCreateManyProvinceInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutProvinceInput | BannerLocationUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutProvinceInput | BannerLocationUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutProvinceNestedInput = {
    create?: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput> | AdminCreateWithoutProvinceInput[] | AdminUncheckedCreateWithoutProvinceInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutProvinceInput | AdminCreateOrConnectWithoutProvinceInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutProvinceInput | AdminUpsertWithWhereUniqueWithoutProvinceInput[]
    createMany?: AdminCreateManyProvinceInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutProvinceInput | AdminUpdateWithWhereUniqueWithoutProvinceInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutProvinceInput | AdminUpdateManyWithWhereWithoutProvinceInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type ProvinceCreateNestedOneWithoutCitiesInput = {
    create?: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCitiesInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutCityInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutCitiesInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationCreateNestedManyWithoutCitiesInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutCityInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type BannerLocationUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type ProvinceUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCitiesInput
    upsert?: ProvinceUpsertWithoutCitiesInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutCitiesInput, ProvinceUpdateWithoutCitiesInput>, ProvinceUncheckedUpdateWithoutCitiesInput>
  }

  export type SchoolUpdateManyWithoutCityNestedInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCityInput | SchoolUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCityInput | SchoolUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCityInput | SchoolUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutCitiesInput | AdminAuthorityUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutCitiesInput | BannerLocationUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutCitiesInput | BannerLocationUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutCitiesInput | BannerLocationUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCityInput | AdminUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCityInput | AdminUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCityInput | AdminUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput> | SchoolCreateWithoutCityInput[] | SchoolUncheckedCreateWithoutCityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutCityInput | SchoolCreateOrConnectWithoutCityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutCityInput | SchoolUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: SchoolCreateManyCityInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutCityInput | SchoolUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutCityInput | SchoolUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput> | AdminAuthorityCreateWithoutCitiesInput[] | AdminAuthorityUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutCitiesInput | AdminAuthorityCreateOrConnectWithoutCitiesInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput | AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutCitiesInput | AdminAuthorityUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput> | BannerLocationCreateWithoutCitiesInput[] | BannerLocationUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutCitiesInput | BannerLocationCreateOrConnectWithoutCitiesInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutCitiesInput | BannerLocationUpsertWithWhereUniqueWithoutCitiesInput[]
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutCitiesInput | BannerLocationUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutCitiesInput | BannerLocationUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput> | AdminCreateWithoutCityInput[] | AdminUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCityInput | AdminCreateOrConnectWithoutCityInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCityInput | AdminUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdminCreateManyCityInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCityInput | AdminUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCityInput | AdminUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolsInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSchoolsInput
    connect?: ProvinceWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: CityCreateOrConnectWithoutSchoolsInput
    upsert?: CityUpsertWithoutSchoolsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutSchoolsInput, CityUpdateWithoutSchoolsInput>, CityUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProvinceUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutSchoolsInput
    upsert?: ProvinceUpsertWithoutSchoolsInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutSchoolsInput, ProvinceUpdateWithoutSchoolsInput>, ProvinceUncheckedUpdateWithoutSchoolsInput>
  }

  export type UserUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput | AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSchoolInput | AdminUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSchoolInput | AdminUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSchoolInput | AdminUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput> | UserCreateWithoutSchoolInput[] | UserUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput | UserCreateOrConnectWithoutSchoolInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSchoolInput | UserUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: UserCreateManySchoolInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSchoolInput | UserUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSchoolInput | UserUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput> | AdminAuthorityCreateWithoutSchoolsInput[] | AdminAuthorityUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutSchoolsInput | AdminAuthorityCreateOrConnectWithoutSchoolsInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput[]
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput | AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput | AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput> | AdminCreateWithoutSchoolInput[] | AdminUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutSchoolInput | AdminCreateOrConnectWithoutSchoolInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutSchoolInput | AdminUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AdminCreateManySchoolInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutSchoolInput | AdminUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutSchoolInput | AdminUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type UserCreateinventoryInput = {
    set: number[]
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUsersInput
    connect?: ProvinceWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutUsersInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    connect?: SchoolWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type ZoneCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type UserLoginCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
  }

  export type BannerVisitorCreateNestedManyWithoutUserInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type TestParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type MultiPlayerMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type SubLevelCreateNestedManyWithoutUserInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
  }

  export type InnerLevelCreateNestedManyWithoutUserInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
  }

  export type LevelCreateNestedManyWithoutUserInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type GempoCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
  }

  export type ChampionshipCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
  }

  export type GempoRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
  }

  export type ChampionshipRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
  }

  export type CodeRedemeerCreateNestedManyWithoutUserInput = {
    create?: XOR<CodeRedemeerCreateWithoutUserInput, CodeRedemeerUncheckedCreateWithoutUserInput> | CodeRedemeerCreateWithoutUserInput[] | CodeRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutUserInput | CodeRedemeerCreateOrConnectWithoutUserInput[]
    createMany?: CodeRedemeerCreateManyUserInputEnvelope
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type UserLoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
  }

  export type BannerVisitorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type TestParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type SubLevelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
  }

  export type InnerLevelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
  }

  export type LevelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
  }

  export type GempoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
  }

  export type ChampionshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
  }

  export type GempoRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
  }

  export type ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
  }

  export type CodeRedemeerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CodeRedemeerCreateWithoutUserInput, CodeRedemeerUncheckedCreateWithoutUserInput> | CodeRedemeerCreateWithoutUserInput[] | CodeRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutUserInput | CodeRedemeerCreateOrConnectWithoutUserInput[]
    createMany?: CodeRedemeerCreateManyUserInputEnvelope
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateinventoryInput = {
    set?: number[]
    push?: number | number[]
  }

  export type CityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutUsersInput, CityUpdateWithoutUsersInput>, CityUncheckedUpdateWithoutUsersInput>
  }

  export type ProvinceUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUsersInput
    upsert?: ProvinceUpsertWithoutUsersInput
    disconnect?: ProvinceWhereInput | boolean
    delete?: ProvinceWhereInput | boolean
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutUsersInput, ProvinceUpdateWithoutUsersInput>, ProvinceUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUsersInput
    upsert?: SchoolUpsertWithoutUsersInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutUsersInput, SchoolUpdateWithoutUsersInput>, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type ZoneUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUserInput | ZoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUserInput | ZoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUserInput | ZoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type UserLoginUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginUpsertWithWhereUniqueWithoutUserInput | UserLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    set?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    disconnect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    delete?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    update?: UserLoginUpdateWithWhereUniqueWithoutUserInput | UserLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginUpdateManyWithWhereWithoutUserInput | UserLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
  }

  export type BannerVisitorUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutUserInput | BannerVisitorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutUserInput | BannerVisitorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutUserInput | BannerVisitorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type TestParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutUserInput | TestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutUserInput | TestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutUserInput | TestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type MultiPlayerMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutUserInput | MultiPlayerMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type SubLevelUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    upsert?: SubLevelUpsertWithWhereUniqueWithoutUserInput | SubLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    set?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    disconnect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    delete?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    update?: SubLevelUpdateWithWhereUniqueWithoutUserInput | SubLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubLevelUpdateManyWithWhereWithoutUserInput | SubLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
  }

  export type InnerLevelUpdateManyWithoutUserNestedInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    upsert?: InnerLevelUpsertWithWhereUniqueWithoutUserInput | InnerLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    set?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    disconnect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    delete?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    update?: InnerLevelUpdateWithWhereUniqueWithoutUserInput | InnerLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InnerLevelUpdateManyWithWhereWithoutUserInput | InnerLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
  }

  export type LevelUpdateManyWithoutUserNestedInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutUserInput | LevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutUserInput | LevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutUserInput | LevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type GempoUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    upsert?: GempoUpsertWithWhereUniqueWithoutUserInput | GempoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    set?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    disconnect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    delete?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    update?: GempoUpdateWithWhereUniqueWithoutUserInput | GempoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoUpdateManyWithWhereWithoutUserInput | GempoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoScalarWhereInput | GempoScalarWhereInput[]
  }

  export type ChampionshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipUpsertWithWhereUniqueWithoutUserInput | ChampionshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    set?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    disconnect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    delete?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    update?: ChampionshipUpdateWithWhereUniqueWithoutUserInput | ChampionshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipUpdateManyWithWhereWithoutUserInput | ChampionshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
  }

  export type GempoRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    upsert?: GempoRecordUpsertWithWhereUniqueWithoutUserInput | GempoRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    set?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    disconnect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    delete?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    update?: GempoRecordUpdateWithWhereUniqueWithoutUserInput | GempoRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoRecordUpdateManyWithWhereWithoutUserInput | GempoRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
  }

  export type ChampionshipRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput | ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    set?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    disconnect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    delete?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    update?: ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput | ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipRecordUpdateManyWithWhereWithoutUserInput | ChampionshipRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
  }

  export type CodeRedemeerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CodeRedemeerCreateWithoutUserInput, CodeRedemeerUncheckedCreateWithoutUserInput> | CodeRedemeerCreateWithoutUserInput[] | CodeRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutUserInput | CodeRedemeerCreateOrConnectWithoutUserInput[]
    upsert?: CodeRedemeerUpsertWithWhereUniqueWithoutUserInput | CodeRedemeerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CodeRedemeerCreateManyUserInputEnvelope
    set?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    disconnect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    delete?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    update?: CodeRedemeerUpdateWithWhereUniqueWithoutUserInput | CodeRedemeerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CodeRedemeerUpdateManyWithWhereWithoutUserInput | CodeRedemeerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CodeRedemeerScalarWhereInput | CodeRedemeerScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ZoneUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput> | ZoneCreateWithoutUserInput[] | ZoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutUserInput | ZoneCreateOrConnectWithoutUserInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutUserInput | ZoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoneCreateManyUserInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutUserInput | ZoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutUserInput | ZoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type UserLoginUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput> | UserLoginCreateWithoutUserInput[] | UserLoginUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLoginCreateOrConnectWithoutUserInput | UserLoginCreateOrConnectWithoutUserInput[]
    upsert?: UserLoginUpsertWithWhereUniqueWithoutUserInput | UserLoginUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLoginCreateManyUserInputEnvelope
    set?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    disconnect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    delete?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    connect?: UserLoginWhereUniqueInput | UserLoginWhereUniqueInput[]
    update?: UserLoginUpdateWithWhereUniqueWithoutUserInput | UserLoginUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLoginUpdateManyWithWhereWithoutUserInput | UserLoginUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
  }

  export type BannerVisitorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput> | BannerVisitorCreateWithoutUserInput[] | BannerVisitorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutUserInput | BannerVisitorCreateOrConnectWithoutUserInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutUserInput | BannerVisitorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BannerVisitorCreateManyUserInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutUserInput | BannerVisitorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutUserInput | BannerVisitorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type TestParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput> | TestParticipantCreateWithoutUserInput[] | TestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutUserInput | TestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutUserInput | TestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestParticipantCreateManyUserInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutUserInput | TestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutUserInput | TestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput> | MultiPlayerMemberCreateWithoutUserInput[] | MultiPlayerMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutUserInput | MultiPlayerMemberCreateOrConnectWithoutUserInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MultiPlayerMemberCreateManyUserInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutUserInput | MultiPlayerMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type SubLevelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput> | SubLevelCreateWithoutUserInput[] | SubLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubLevelCreateOrConnectWithoutUserInput | SubLevelCreateOrConnectWithoutUserInput[]
    upsert?: SubLevelUpsertWithWhereUniqueWithoutUserInput | SubLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubLevelCreateManyUserInputEnvelope
    set?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    disconnect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    delete?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    connect?: SubLevelWhereUniqueInput | SubLevelWhereUniqueInput[]
    update?: SubLevelUpdateWithWhereUniqueWithoutUserInput | SubLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubLevelUpdateManyWithWhereWithoutUserInput | SubLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
  }

  export type InnerLevelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput> | InnerLevelCreateWithoutUserInput[] | InnerLevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InnerLevelCreateOrConnectWithoutUserInput | InnerLevelCreateOrConnectWithoutUserInput[]
    upsert?: InnerLevelUpsertWithWhereUniqueWithoutUserInput | InnerLevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InnerLevelCreateManyUserInputEnvelope
    set?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    disconnect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    delete?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    connect?: InnerLevelWhereUniqueInput | InnerLevelWhereUniqueInput[]
    update?: InnerLevelUpdateWithWhereUniqueWithoutUserInput | InnerLevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InnerLevelUpdateManyWithWhereWithoutUserInput | InnerLevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
  }

  export type LevelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput> | LevelCreateWithoutUserInput[] | LevelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LevelCreateOrConnectWithoutUserInput | LevelCreateOrConnectWithoutUserInput[]
    upsert?: LevelUpsertWithWhereUniqueWithoutUserInput | LevelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LevelCreateManyUserInputEnvelope
    set?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    disconnect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    delete?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    connect?: LevelWhereUniqueInput | LevelWhereUniqueInput[]
    update?: LevelUpdateWithWhereUniqueWithoutUserInput | LevelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LevelUpdateManyWithWhereWithoutUserInput | LevelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LevelScalarWhereInput | LevelScalarWhereInput[]
  }

  export type GempoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput> | GempoCreateWithoutUserInput[] | GempoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoCreateOrConnectWithoutUserInput | GempoCreateOrConnectWithoutUserInput[]
    upsert?: GempoUpsertWithWhereUniqueWithoutUserInput | GempoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoCreateManyUserInputEnvelope
    set?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    disconnect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    delete?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    connect?: GempoWhereUniqueInput | GempoWhereUniqueInput[]
    update?: GempoUpdateWithWhereUniqueWithoutUserInput | GempoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoUpdateManyWithWhereWithoutUserInput | GempoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoScalarWhereInput | GempoScalarWhereInput[]
  }

  export type ChampionshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput> | ChampionshipCreateWithoutUserInput[] | ChampionshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipCreateOrConnectWithoutUserInput | ChampionshipCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipUpsertWithWhereUniqueWithoutUserInput | ChampionshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipCreateManyUserInputEnvelope
    set?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    disconnect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    delete?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    connect?: ChampionshipWhereUniqueInput | ChampionshipWhereUniqueInput[]
    update?: ChampionshipUpdateWithWhereUniqueWithoutUserInput | ChampionshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipUpdateManyWithWhereWithoutUserInput | ChampionshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
  }

  export type GempoRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput> | GempoRecordCreateWithoutUserInput[] | GempoRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GempoRecordCreateOrConnectWithoutUserInput | GempoRecordCreateOrConnectWithoutUserInput[]
    upsert?: GempoRecordUpsertWithWhereUniqueWithoutUserInput | GempoRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GempoRecordCreateManyUserInputEnvelope
    set?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    disconnect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    delete?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    connect?: GempoRecordWhereUniqueInput | GempoRecordWhereUniqueInput[]
    update?: GempoRecordUpdateWithWhereUniqueWithoutUserInput | GempoRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GempoRecordUpdateManyWithWhereWithoutUserInput | GempoRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
  }

  export type ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput> | ChampionshipRecordCreateWithoutUserInput[] | ChampionshipRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChampionshipRecordCreateOrConnectWithoutUserInput | ChampionshipRecordCreateOrConnectWithoutUserInput[]
    upsert?: ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput | ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChampionshipRecordCreateManyUserInputEnvelope
    set?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    disconnect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    delete?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    connect?: ChampionshipRecordWhereUniqueInput | ChampionshipRecordWhereUniqueInput[]
    update?: ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput | ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChampionshipRecordUpdateManyWithWhereWithoutUserInput | ChampionshipRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
  }

  export type CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CodeRedemeerCreateWithoutUserInput, CodeRedemeerUncheckedCreateWithoutUserInput> | CodeRedemeerCreateWithoutUserInput[] | CodeRedemeerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutUserInput | CodeRedemeerCreateOrConnectWithoutUserInput[]
    upsert?: CodeRedemeerUpsertWithWhereUniqueWithoutUserInput | CodeRedemeerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CodeRedemeerCreateManyUserInputEnvelope
    set?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    disconnect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    delete?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    update?: CodeRedemeerUpdateWithWhereUniqueWithoutUserInput | CodeRedemeerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CodeRedemeerUpdateManyWithWhereWithoutUserInput | CodeRedemeerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CodeRedemeerScalarWhereInput | CodeRedemeerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutZonesInput = {
    create?: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutZonesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutZonesInput
    upsert?: UserUpsertWithoutZonesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZonesInput, UserUpdateWithoutZonesInput>, UserUncheckedUpdateWithoutZonesInput>
  }

  export type UserCreateNestedOneWithoutLevelsInput = {
    create?: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLevelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLevelsNestedInput = {
    create?: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLevelsInput
    upsert?: UserUpsertWithoutLevelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLevelsInput, UserUpdateWithoutLevelsInput>, UserUncheckedUpdateWithoutLevelsInput>
  }

  export type UserCreateNestedOneWithoutSubLevelsInput = {
    create?: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubLevelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubLevelsNestedInput = {
    create?: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubLevelsInput
    upsert?: UserUpsertWithoutSubLevelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubLevelsInput, UserUpdateWithoutSubLevelsInput>, UserUncheckedUpdateWithoutSubLevelsInput>
  }

  export type UserCreateNestedOneWithoutInnerLevelsInput = {
    create?: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInnerLevelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInnerLevelsNestedInput = {
    create?: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInnerLevelsInput
    upsert?: UserUpsertWithoutInnerLevelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInnerLevelsInput, UserUpdateWithoutInnerLevelsInput>, UserUncheckedUpdateWithoutInnerLevelsInput>
  }

  export type UserCreateNestedOneWithoutGemposInput = {
    create?: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
    connectOrCreate?: UserCreateOrConnectWithoutGemposInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGemposNestedInput = {
    create?: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
    connectOrCreate?: UserCreateOrConnectWithoutGemposInput
    upsert?: UserUpsertWithoutGemposInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGemposInput, UserUpdateWithoutGemposInput>, UserUncheckedUpdateWithoutGemposInput>
  }

  export type UserCreateNestedOneWithoutChampionshipsInput = {
    create?: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChampionshipsNestedInput = {
    create?: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipsInput
    upsert?: UserUpsertWithoutChampionshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChampionshipsInput, UserUpdateWithoutChampionshipsInput>, UserUncheckedUpdateWithoutChampionshipsInput>
  }

  export type UserCreateNestedOneWithoutGempoRecordsInput = {
    create?: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGempoRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGempoRecordsNestedInput = {
    create?: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGempoRecordsInput
    upsert?: UserUpsertWithoutGempoRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGempoRecordsInput, UserUpdateWithoutGempoRecordsInput>, UserUncheckedUpdateWithoutGempoRecordsInput>
  }

  export type UserCreateNestedOneWithoutChampionshipRecordsInput = {
    create?: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChampionshipRecordsNestedInput = {
    create?: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionshipRecordsInput
    upsert?: UserUpsertWithoutChampionshipRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChampionshipRecordsInput, UserUpdateWithoutChampionshipRecordsInput>, UserUncheckedUpdateWithoutChampionshipRecordsInput>
  }

  export type UserCreateNestedOneWithoutUserLoginInput = {
    create?: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLoginNestedInput = {
    create?: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLoginInput
    upsert?: UserUpsertWithoutUserLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLoginInput, UserUpdateWithoutUserLoginInput>, UserUncheckedUpdateWithoutUserLoginInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutAdminInput = {
    create?: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAdminInput = {
    create?: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdminInput
    connect?: CityWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutAdminInput = {
    create?: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminInput
    connect?: SchoolWhereUniqueInput
  }

  export type AdminAuthorityCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminOperationHistoryCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminOperationHistoryCreateNestedManyWithoutOpAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type BannerCreateNestedManyWithoutAdminInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminTransactionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type AdminTransactionCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type RedeemCodeCreateNestedManyWithoutAdminInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
  }

  export type AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
  }

  export type BannerUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
  }

  export type AdminTransactionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
  }

  export type RedeemCodeUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type UserUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type ProvinceUpdateOneWithoutAdminNestedInput = {
    create?: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminInput
    upsert?: ProvinceUpsertWithoutAdminInput
    disconnect?: ProvinceWhereInput | boolean
    delete?: ProvinceWhereInput | boolean
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutAdminInput, ProvinceUpdateWithoutAdminInput>, ProvinceUncheckedUpdateWithoutAdminInput>
  }

  export type CityUpdateOneWithoutAdminNestedInput = {
    create?: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdminInput
    upsert?: CityUpsertWithoutAdminInput
    disconnect?: CityWhereInput | boolean
    delete?: CityWhereInput | boolean
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAdminInput, CityUpdateWithoutAdminInput>, CityUncheckedUpdateWithoutAdminInput>
  }

  export type SchoolUpdateOneWithoutAdminNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminInput
    upsert?: SchoolUpsertWithoutAdminInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAdminInput, SchoolUpdateWithoutAdminInput>, SchoolUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput | AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput | AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutAdminInput | AdminAuthorityUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminOperationHistoryUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type BannerUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutAdminInput | BannerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutAdminInput | BannerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutAdminInput | BannerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminTransactionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutAdminInput | AdminTransactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutAdminInput | AdminTransactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutAdminInput | AdminTransactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type AdminTransactionUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutProcessedByInput | AdminTransactionUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type RedeemCodeUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    upsert?: RedeemCodeUpsertWithWhereUniqueWithoutAdminInput | RedeemCodeUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    set?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    disconnect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    delete?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    update?: RedeemCodeUpdateWithWhereUniqueWithoutAdminInput | RedeemCodeUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RedeemCodeUpdateManyWithWhereWithoutAdminInput | RedeemCodeUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput> | AdminAuthorityCreateWithoutAdminInput[] | AdminAuthorityUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuthorityCreateOrConnectWithoutAdminInput | AdminAuthorityCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput | AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuthorityCreateManyAdminInputEnvelope
    set?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    disconnect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    delete?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    connect?: AdminAuthorityWhereUniqueInput | AdminAuthorityWhereUniqueInput[]
    update?: AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput | AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuthorityUpdateManyWithWhereWithoutAdminInput | AdminAuthorityUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput> | AdminOperationHistoryCreateWithoutAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutAdminInput | AdminOperationHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminOperationHistoryCreateManyAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput = {
    create?: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput> | AdminOperationHistoryCreateWithoutOpAdminInput[] | AdminOperationHistoryUncheckedCreateWithoutOpAdminInput[]
    connectOrCreate?: AdminOperationHistoryCreateOrConnectWithoutOpAdminInput | AdminOperationHistoryCreateOrConnectWithoutOpAdminInput[]
    upsert?: AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput[]
    createMany?: AdminOperationHistoryCreateManyOpAdminInputEnvelope
    set?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    disconnect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    delete?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    connect?: AdminOperationHistoryWhereUniqueInput | AdminOperationHistoryWhereUniqueInput[]
    update?: AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput | AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput[]
    updateMany?: AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput | AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput[]
    deleteMany?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
  }

  export type BannerUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput> | BannerCreateWithoutAdminInput[] | BannerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: BannerCreateOrConnectWithoutAdminInput | BannerCreateOrConnectWithoutAdminInput[]
    upsert?: BannerUpsertWithWhereUniqueWithoutAdminInput | BannerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: BannerCreateManyAdminInputEnvelope
    set?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    disconnect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    delete?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    connect?: BannerWhereUniqueInput | BannerWhereUniqueInput[]
    update?: BannerUpdateWithWhereUniqueWithoutAdminInput | BannerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: BannerUpdateManyWithWhereWithoutAdminInput | BannerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: BannerScalarWhereInput | BannerScalarWhereInput[]
  }

  export type AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput> | AdminTransactionCreateWithoutAdminInput[] | AdminTransactionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutAdminInput | AdminTransactionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutAdminInput | AdminTransactionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminTransactionCreateManyAdminInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutAdminInput | AdminTransactionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutAdminInput | AdminTransactionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput> | AdminTransactionCreateWithoutProcessedByInput[] | AdminTransactionUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutProcessedByInput | AdminTransactionCreateOrConnectWithoutProcessedByInput[]
    upsert?: AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: AdminTransactionCreateManyProcessedByInputEnvelope
    set?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    disconnect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    delete?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    connect?: AdminTransactionWhereUniqueInput | AdminTransactionWhereUniqueInput[]
    update?: AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput | AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: AdminTransactionUpdateManyWithWhereWithoutProcessedByInput | AdminTransactionUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
  }

  export type RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput> | RedeemCodeCreateWithoutAdminInput[] | RedeemCodeUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutAdminInput | RedeemCodeCreateOrConnectWithoutAdminInput[]
    upsert?: RedeemCodeUpsertWithWhereUniqueWithoutAdminInput | RedeemCodeUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RedeemCodeCreateManyAdminInputEnvelope
    set?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    disconnect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    delete?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    connect?: RedeemCodeWhereUniqueInput | RedeemCodeWhereUniqueInput[]
    update?: RedeemCodeUpdateWithWhereUniqueWithoutAdminInput | RedeemCodeUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RedeemCodeUpdateManyWithWhereWithoutAdminInput | RedeemCodeUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutOperationHistoriesInput = {
    create?: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationHistoriesInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutOperationsInput = {
    create?: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationsInput
    connect?: AdminWhereUniqueInput
  }

  export type EnumOperationFieldUpdateOperationsInput = {
    set?: $Enums.Operation
  }

  export type AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput = {
    create?: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationHistoriesInput
    upsert?: AdminUpsertWithoutOperationHistoriesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOperationHistoriesInput, AdminUpdateWithoutOperationHistoriesInput>, AdminUncheckedUpdateWithoutOperationHistoriesInput>
  }

  export type AdminUpdateOneRequiredWithoutOperationsNestedInput = {
    create?: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutOperationsInput
    upsert?: AdminUpsertWithoutOperationsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutOperationsInput, AdminUpdateWithoutOperationsInput>, AdminUncheckedUpdateWithoutOperationsInput>
  }

  export type AdminAuthorityCreategradesInput = {
    set: number[]
  }

  export type AdminCreateNestedOneWithoutAuthorityInput = {
    create?: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthorityInput
    connect?: AdminWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutAdminAuthorityInput = {
    create?: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminAuthorityInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type AdminAuthorityUpdategradesInput = {
    set?: number[]
    push?: number | number[]
  }

  export type AdminUpdateOneRequiredWithoutAuthorityNestedInput = {
    create?: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAuthorityInput
    upsert?: AdminUpsertWithoutAuthorityInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAuthorityInput, AdminUpdateWithoutAuthorityInput>, AdminUncheckedUpdateWithoutAuthorityInput>
  }

  export type ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput = {
    create?: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutAdminAuthorityInput
    upsert?: ProvinceUpsertWithoutAdminAuthorityInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutAdminAuthorityInput, ProvinceUpdateWithoutAdminAuthorityInput>, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type CityUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutAdminAuthorityInput | CityUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutAdminAuthorityInput | CityUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: CityUpdateManyWithWhereWithoutAdminAuthorityInput | CityUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAdminAuthorityInput | SchoolUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput> | CityCreateWithoutAdminAuthorityInput[] | CityUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: CityCreateOrConnectWithoutAdminAuthorityInput | CityCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutAdminAuthorityInput | CityUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutAdminAuthorityInput | CityUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: CityUpdateManyWithWhereWithoutAdminAuthorityInput | CityUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput = {
    create?: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput> | SchoolCreateWithoutAdminAuthorityInput[] | SchoolUncheckedCreateWithoutAdminAuthorityInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutAdminAuthorityInput | SchoolCreateOrConnectWithoutAdminAuthorityInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput[]
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput | SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutAdminAuthorityInput | SchoolUpdateManyWithWhereWithoutAdminAuthorityInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type BannerVisitorCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutBannerInput = {
    create?: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    connectOrCreate?: AdminCreateOrConnectWithoutBannerInput
    connect?: AdminWhereUniqueInput
  }

  export type BannerLocationCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type BannerVisitorUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
  }

  export type BannerLocationUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
  }

  export type BannerVisitorUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutBannerInput | BannerVisitorUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutBannerInput | BannerVisitorUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutBannerInput | BannerVisitorUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type AdminUpdateOneRequiredWithoutBannerNestedInput = {
    create?: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    connectOrCreate?: AdminCreateOrConnectWithoutBannerInput
    upsert?: AdminUpsertWithoutBannerInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutBannerInput, AdminUpdateWithoutBannerInput>, AdminUncheckedUpdateWithoutBannerInput>
  }

  export type BannerLocationUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutBannerInput | BannerLocationUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutBannerInput | BannerLocationUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutBannerInput | BannerLocationUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput> | BannerVisitorCreateWithoutBannerInput[] | BannerVisitorUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerVisitorCreateOrConnectWithoutBannerInput | BannerVisitorCreateOrConnectWithoutBannerInput[]
    upsert?: BannerVisitorUpsertWithWhereUniqueWithoutBannerInput | BannerVisitorUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerVisitorCreateManyBannerInputEnvelope
    set?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    disconnect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    delete?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    connect?: BannerVisitorWhereUniqueInput | BannerVisitorWhereUniqueInput[]
    update?: BannerVisitorUpdateWithWhereUniqueWithoutBannerInput | BannerVisitorUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerVisitorUpdateManyWithWhereWithoutBannerInput | BannerVisitorUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
  }

  export type BannerLocationUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput> | BannerLocationCreateWithoutBannerInput[] | BannerLocationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerLocationCreateOrConnectWithoutBannerInput | BannerLocationCreateOrConnectWithoutBannerInput[]
    upsert?: BannerLocationUpsertWithWhereUniqueWithoutBannerInput | BannerLocationUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerLocationCreateManyBannerInputEnvelope
    set?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    disconnect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    delete?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    connect?: BannerLocationWhereUniqueInput | BannerLocationWhereUniqueInput[]
    update?: BannerLocationUpdateWithWhereUniqueWithoutBannerInput | BannerLocationUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerLocationUpdateManyWithWhereWithoutBannerInput | BannerLocationUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
  }

  export type BannerCreateNestedOneWithoutBannerLocationInput = {
    create?: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: BannerCreateOrConnectWithoutBannerLocationInput
    connect?: BannerWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutBannerLocationInput = {
    create?: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannerLocationInput
    connect?: ProvinceWhereUniqueInput
  }

  export type CityCreateNestedManyWithoutBannerLocationInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type CityUncheckedCreateNestedManyWithoutBannerLocationInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
  }

  export type BannerUpdateOneRequiredWithoutBannerLocationNestedInput = {
    create?: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: BannerCreateOrConnectWithoutBannerLocationInput
    upsert?: BannerUpsertWithoutBannerLocationInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutBannerLocationInput, BannerUpdateWithoutBannerLocationInput>, BannerUncheckedUpdateWithoutBannerLocationInput>
  }

  export type ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput = {
    create?: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutBannerLocationInput
    upsert?: ProvinceUpsertWithoutBannerLocationInput
    connect?: ProvinceWhereUniqueInput
    update?: XOR<XOR<ProvinceUpdateToOneWithWhereWithoutBannerLocationInput, ProvinceUpdateWithoutBannerLocationInput>, ProvinceUncheckedUpdateWithoutBannerLocationInput>
  }

  export type CityUpdateManyWithoutBannerLocationNestedInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutBannerLocationInput | CityUpsertWithWhereUniqueWithoutBannerLocationInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutBannerLocationInput | CityUpdateWithWhereUniqueWithoutBannerLocationInput[]
    updateMany?: CityUpdateManyWithWhereWithoutBannerLocationInput | CityUpdateManyWithWhereWithoutBannerLocationInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type CityUncheckedUpdateManyWithoutBannerLocationNestedInput = {
    create?: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput> | CityCreateWithoutBannerLocationInput[] | CityUncheckedCreateWithoutBannerLocationInput[]
    connectOrCreate?: CityCreateOrConnectWithoutBannerLocationInput | CityCreateOrConnectWithoutBannerLocationInput[]
    upsert?: CityUpsertWithWhereUniqueWithoutBannerLocationInput | CityUpsertWithWhereUniqueWithoutBannerLocationInput[]
    set?: CityWhereUniqueInput | CityWhereUniqueInput[]
    disconnect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    delete?: CityWhereUniqueInput | CityWhereUniqueInput[]
    connect?: CityWhereUniqueInput | CityWhereUniqueInput[]
    update?: CityUpdateWithWhereUniqueWithoutBannerLocationInput | CityUpdateWithWhereUniqueWithoutBannerLocationInput[]
    updateMany?: CityUpdateManyWithWhereWithoutBannerLocationInput | CityUpdateManyWithWhereWithoutBannerLocationInput[]
    deleteMany?: CityScalarWhereInput | CityScalarWhereInput[]
  }

  export type BannerCreateNestedOneWithoutVisitorsInput = {
    create?: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutVisitorsInput
    connect?: BannerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBannerVisitorInput = {
    create?: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannerVisitorInput
    connect?: UserWhereUniqueInput
  }

  export type BannerUpdateOneRequiredWithoutVisitorsNestedInput = {
    create?: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutVisitorsInput
    upsert?: BannerUpsertWithoutVisitorsInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutVisitorsInput, BannerUpdateWithoutVisitorsInput>, BannerUncheckedUpdateWithoutVisitorsInput>
  }

  export type UserUpdateOneRequiredWithoutBannerVisitorNestedInput = {
    create?: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    connectOrCreate?: UserCreateOrConnectWithoutBannerVisitorInput
    upsert?: UserUpsertWithoutBannerVisitorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBannerVisitorInput, UserUpdateWithoutBannerVisitorInput>, UserUncheckedUpdateWithoutBannerVisitorInput>
  }

  export type TestParticipantCreateNestedManyWithoutTestInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type TestParticipantUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type EnumTestTypeFieldUpdateOperationsInput = {
    set?: $Enums.TestType
  }

  export type TestParticipantUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutTestInput | TestParticipantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutTestInput | TestParticipantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutTestInput | TestParticipantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type TestParticipantUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput> | TestParticipantCreateWithoutTestInput[] | TestParticipantUncheckedCreateWithoutTestInput[]
    connectOrCreate?: TestParticipantCreateOrConnectWithoutTestInput | TestParticipantCreateOrConnectWithoutTestInput[]
    upsert?: TestParticipantUpsertWithWhereUniqueWithoutTestInput | TestParticipantUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: TestParticipantCreateManyTestInputEnvelope
    set?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    disconnect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    delete?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    connect?: TestParticipantWhereUniqueInput | TestParticipantWhereUniqueInput[]
    update?: TestParticipantUpdateWithWhereUniqueWithoutTestInput | TestParticipantUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: TestParticipantUpdateManyWithWhereWithoutTestInput | TestParticipantUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
  }

  export type TestCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TestCreateOrConnectWithoutParticipantsInput
    connect?: TestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestParticipantInput = {
    create?: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type TestParticipantRecordCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
  }

  export type TestUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TestCreateOrConnectWithoutParticipantsInput
    upsert?: TestUpsertWithoutParticipantsInput
    connect?: TestWhereUniqueInput
    update?: XOR<XOR<TestUpdateToOneWithWhereWithoutParticipantsInput, TestUpdateWithoutParticipantsInput>, TestUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutTestParticipantNestedInput = {
    create?: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestParticipantInput
    upsert?: UserUpsertWithoutTestParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestParticipantInput, UserUpdateWithoutTestParticipantInput>, UserUncheckedUpdateWithoutTestParticipantInput>
  }

  export type TestParticipantRecordUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput | TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput> | TestParticipantRecordCreateWithoutParticipantInput[] | TestParticipantRecordUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: TestParticipantRecordCreateOrConnectWithoutParticipantInput | TestParticipantRecordCreateOrConnectWithoutParticipantInput[]
    upsert?: TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: TestParticipantRecordCreateManyParticipantInputEnvelope
    set?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    disconnect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    delete?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    connect?: TestParticipantRecordWhereUniqueInput | TestParticipantRecordWhereUniqueInput[]
    update?: TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput | TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput | TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
  }

  export type TestParticipantCreateNestedOneWithoutRecordsInput = {
    create?: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TestParticipantCreateOrConnectWithoutRecordsInput
    connect?: TestParticipantWhereUniqueInput
  }

  export type TestParticipantUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TestParticipantCreateOrConnectWithoutRecordsInput
    upsert?: TestParticipantUpsertWithoutRecordsInput
    connect?: TestParticipantWhereUniqueInput
    update?: XOR<XOR<TestParticipantUpdateToOneWithWhereWithoutRecordsInput, TestParticipantUpdateWithoutRecordsInput>, TestParticipantUncheckedUpdateWithoutRecordsInput>
  }

  export type AdminTransactionCreatezonesInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionsInput
    connect?: AdminWhereUniqueInput
  }

  export type RedeemCodeCreateNestedOneWithoutTransactionInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutTransactionProcessedInput = {
    create?: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionProcessedInput
    connect?: AdminWhereUniqueInput
  }

  export type RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type EnumTransactionFieldUpdateOperationsInput = {
    set?: $Enums.Transaction
  }

  export type AdminTransactionUpdatezonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionsInput
    upsert?: AdminUpsertWithoutTransactionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutTransactionsInput, AdminUpdateWithoutTransactionsInput>, AdminUncheckedUpdateWithoutTransactionsInput>
  }

  export type RedeemCodeUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    upsert?: RedeemCodeUpsertWithoutTransactionInput
    disconnect?: RedeemCodeWhereInput | boolean
    delete?: RedeemCodeWhereInput | boolean
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutTransactionInput, RedeemCodeUpdateWithoutTransactionInput>, RedeemCodeUncheckedUpdateWithoutTransactionInput>
  }

  export type AdminUpdateOneWithoutTransactionProcessedNestedInput = {
    create?: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTransactionProcessedInput
    upsert?: AdminUpsertWithoutTransactionProcessedInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutTransactionProcessedInput, AdminUpdateWithoutTransactionProcessedInput>, AdminUncheckedUpdateWithoutTransactionProcessedInput>
  }

  export type RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutTransactionInput
    upsert?: RedeemCodeUpsertWithoutTransactionInput
    disconnect?: RedeemCodeWhereInput | boolean
    delete?: RedeemCodeWhereInput | boolean
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutTransactionInput, RedeemCodeUpdateWithoutTransactionInput>, RedeemCodeUncheckedUpdateWithoutTransactionInput>
  }

  export type RedeemCodeCreatedataInput = {
    set: string[]
  }

  export type AdminTransactionCreateNestedOneWithoutRedeemCodeInput = {
    create?: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutRedeemCodeInput
    connect?: AdminTransactionWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutRedeemCodesInput = {
    create?: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRedeemCodesInput
    connect?: AdminWhereUniqueInput
  }

  export type CodeRedemeerCreateNestedManyWithoutCodeInput = {
    create?: XOR<CodeRedemeerCreateWithoutCodeInput, CodeRedemeerUncheckedCreateWithoutCodeInput> | CodeRedemeerCreateWithoutCodeInput[] | CodeRedemeerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutCodeInput | CodeRedemeerCreateOrConnectWithoutCodeInput[]
    createMany?: CodeRedemeerCreateManyCodeInputEnvelope
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
  }

  export type CodeRedemeerUncheckedCreateNestedManyWithoutCodeInput = {
    create?: XOR<CodeRedemeerCreateWithoutCodeInput, CodeRedemeerUncheckedCreateWithoutCodeInput> | CodeRedemeerCreateWithoutCodeInput[] | CodeRedemeerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutCodeInput | CodeRedemeerCreateOrConnectWithoutCodeInput[]
    createMany?: CodeRedemeerCreateManyCodeInputEnvelope
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
  }

  export type RedeemCodeUpdatedataInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput = {
    create?: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
    connectOrCreate?: AdminTransactionCreateOrConnectWithoutRedeemCodeInput
    upsert?: AdminTransactionUpsertWithoutRedeemCodeInput
    connect?: AdminTransactionWhereUniqueInput
    update?: XOR<XOR<AdminTransactionUpdateToOneWithWhereWithoutRedeemCodeInput, AdminTransactionUpdateWithoutRedeemCodeInput>, AdminTransactionUncheckedUpdateWithoutRedeemCodeInput>
  }

  export type AdminUpdateOneRequiredWithoutRedeemCodesNestedInput = {
    create?: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRedeemCodesInput
    upsert?: AdminUpsertWithoutRedeemCodesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutRedeemCodesInput, AdminUpdateWithoutRedeemCodesInput>, AdminUncheckedUpdateWithoutRedeemCodesInput>
  }

  export type CodeRedemeerUpdateManyWithoutCodeNestedInput = {
    create?: XOR<CodeRedemeerCreateWithoutCodeInput, CodeRedemeerUncheckedCreateWithoutCodeInput> | CodeRedemeerCreateWithoutCodeInput[] | CodeRedemeerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutCodeInput | CodeRedemeerCreateOrConnectWithoutCodeInput[]
    upsert?: CodeRedemeerUpsertWithWhereUniqueWithoutCodeInput | CodeRedemeerUpsertWithWhereUniqueWithoutCodeInput[]
    createMany?: CodeRedemeerCreateManyCodeInputEnvelope
    set?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    disconnect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    delete?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    update?: CodeRedemeerUpdateWithWhereUniqueWithoutCodeInput | CodeRedemeerUpdateWithWhereUniqueWithoutCodeInput[]
    updateMany?: CodeRedemeerUpdateManyWithWhereWithoutCodeInput | CodeRedemeerUpdateManyWithWhereWithoutCodeInput[]
    deleteMany?: CodeRedemeerScalarWhereInput | CodeRedemeerScalarWhereInput[]
  }

  export type CodeRedemeerUncheckedUpdateManyWithoutCodeNestedInput = {
    create?: XOR<CodeRedemeerCreateWithoutCodeInput, CodeRedemeerUncheckedCreateWithoutCodeInput> | CodeRedemeerCreateWithoutCodeInput[] | CodeRedemeerUncheckedCreateWithoutCodeInput[]
    connectOrCreate?: CodeRedemeerCreateOrConnectWithoutCodeInput | CodeRedemeerCreateOrConnectWithoutCodeInput[]
    upsert?: CodeRedemeerUpsertWithWhereUniqueWithoutCodeInput | CodeRedemeerUpsertWithWhereUniqueWithoutCodeInput[]
    createMany?: CodeRedemeerCreateManyCodeInputEnvelope
    set?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    disconnect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    delete?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    connect?: CodeRedemeerWhereUniqueInput | CodeRedemeerWhereUniqueInput[]
    update?: CodeRedemeerUpdateWithWhereUniqueWithoutCodeInput | CodeRedemeerUpdateWithWhereUniqueWithoutCodeInput[]
    updateMany?: CodeRedemeerUpdateManyWithWhereWithoutCodeInput | CodeRedemeerUpdateManyWithWhereWithoutCodeInput[]
    deleteMany?: CodeRedemeerScalarWhereInput | CodeRedemeerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRedemeedCodesInput = {
    create?: XOR<UserCreateWithoutRedemeedCodesInput, UserUncheckedCreateWithoutRedemeedCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedemeedCodesInput
    connect?: UserWhereUniqueInput
  }

  export type RedeemCodeCreateNestedOneWithoutRedemeersInput = {
    create?: XOR<RedeemCodeCreateWithoutRedemeersInput, RedeemCodeUncheckedCreateWithoutRedemeersInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutRedemeersInput
    connect?: RedeemCodeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRedemeedCodesNestedInput = {
    create?: XOR<UserCreateWithoutRedemeedCodesInput, UserUncheckedCreateWithoutRedemeedCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRedemeedCodesInput
    upsert?: UserUpsertWithoutRedemeedCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRedemeedCodesInput, UserUpdateWithoutRedemeedCodesInput>, UserUncheckedUpdateWithoutRedemeedCodesInput>
  }

  export type RedeemCodeUpdateOneRequiredWithoutRedemeersNestedInput = {
    create?: XOR<RedeemCodeCreateWithoutRedemeersInput, RedeemCodeUncheckedCreateWithoutRedemeersInput>
    connectOrCreate?: RedeemCodeCreateOrConnectWithoutRedemeersInput
    upsert?: RedeemCodeUpsertWithoutRedemeersInput
    connect?: RedeemCodeWhereUniqueInput
    update?: XOR<XOR<RedeemCodeUpdateToOneWithWhereWithoutRedemeersInput, RedeemCodeUpdateWithoutRedemeersInput>, RedeemCodeUncheckedUpdateWithoutRedemeersInput>
  }

  export type MultiPlayerMemberCreateNestedManyWithoutRoomInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type MultiPlayerMemberUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
  }

  export type MultiPlayerMemberUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput | MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput> | MultiPlayerMemberCreateWithoutRoomInput[] | MultiPlayerMemberUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MultiPlayerMemberCreateOrConnectWithoutRoomInput | MultiPlayerMemberCreateOrConnectWithoutRoomInput[]
    upsert?: MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MultiPlayerMemberCreateManyRoomInputEnvelope
    set?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    disconnect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    delete?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    connect?: MultiPlayerMemberWhereUniqueInput | MultiPlayerMemberWhereUniqueInput[]
    update?: MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput | MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput | MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMultiPlayerMemberInput = {
    create?: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMultiPlayerMemberInput
    connect?: UserWhereUniqueInput
  }

  export type MultiplayerRoomCreateNestedOneWithoutMembersInput = {
    create?: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MultiplayerRoomCreateOrConnectWithoutMembersInput
    connect?: MultiplayerRoomWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMultiPlayerMemberNestedInput = {
    create?: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutMultiPlayerMemberInput
    upsert?: UserUpsertWithoutMultiPlayerMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMultiPlayerMemberInput, UserUpdateWithoutMultiPlayerMemberInput>, UserUncheckedUpdateWithoutMultiPlayerMemberInput>
  }

  export type MultiplayerRoomUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
    connectOrCreate?: MultiplayerRoomCreateOrConnectWithoutMembersInput
    upsert?: MultiplayerRoomUpsertWithoutMembersInput
    connect?: MultiplayerRoomWhereUniqueInput
    update?: XOR<XOR<MultiplayerRoomUpdateToOneWithWhereWithoutMembersInput, MultiplayerRoomUpdateWithoutMembersInput>, MultiplayerRoomUncheckedUpdateWithoutMembersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationFilter<$PrismaModel> | $Enums.Operation
  }

  export type NestedEnumOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Operation | EnumOperationFieldRefInput<$PrismaModel>
    in?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Operation[] | ListEnumOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumOperationWithAggregatesFilter<$PrismaModel> | $Enums.Operation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationFilter<$PrismaModel>
    _max?: NestedEnumOperationFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeFilter<$PrismaModel> | $Enums.TestType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TestType | EnumTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TestType[] | ListEnumTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.TestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTestTypeFilter<$PrismaModel>
    _max?: NestedEnumTestTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTransactionFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFilter<$PrismaModel> | $Enums.Transaction
  }

  export type NestedEnumTransactionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Transaction | EnumTransactionFieldRefInput<$PrismaModel>
    in?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Transaction[] | ListEnumTransactionFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionWithAggregatesFilter<$PrismaModel> | $Enums.Transaction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionFilter<$PrismaModel>
    _max?: NestedEnumTransactionFilter<$PrismaModel>
  }

  export type CityCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
    admin?: AdminCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutProvinceInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityCreateManyProvinceInputEnvelope = {
    data: CityCreateManyProvinceInput | CityCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutProvinceInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
    admin?: AdminCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutProvinceInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput>
  }

  export type SchoolCreateManyProvinceInputEnvelope = {
    data: SchoolCreateManyProvinceInput | SchoolCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProvinceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput>
  }

  export type UserCreateManyProvinceInputEnvelope = {
    data: UserCreateManyProvinceInput | UserCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutProvinceInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutProvinceInput = {
    id?: string
    adminId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput>
  }

  export type AdminAuthorityCreateManyProvinceInputEnvelope = {
    data: AdminAuthorityCreateManyProvinceInput | AdminAuthorityCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type BannerLocationCreateWithoutProvinceInput = {
    id?: string
    banner: BannerCreateNestedOneWithoutBannerLocationInput
    cities?: CityCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateWithoutProvinceInput = {
    id?: string
    bannerId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationCreateOrConnectWithoutProvinceInput = {
    where: BannerLocationWhereUniqueInput
    create: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput>
  }

  export type BannerLocationCreateManyProvinceInputEnvelope = {
    data: BannerLocationCreateManyProvinceInput | BannerLocationCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutProvinceInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutProvinceInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput>
  }

  export type AdminCreateManyProvinceInputEnvelope = {
    data: AdminCreateManyProvinceInput | AdminCreateManyProvinceInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
  }

  export type CityUpdateManyWithWhereWithoutProvinceInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutProvinceInput>
  }

  export type CityScalarWhereInput = {
    AND?: CityScalarWhereInput | CityScalarWhereInput[]
    OR?: CityScalarWhereInput[]
    NOT?: CityScalarWhereInput | CityScalarWhereInput[]
    id?: StringFilter<"City"> | string
    name?: StringFilter<"City"> | string
    longitude?: FloatFilter<"City"> | number
    latitude?: FloatFilter<"City"> | number
    geoId?: StringFilter<"City"> | string
    provinceId?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
  }

  export type SchoolUpsertWithWhereUniqueWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutProvinceInput, SchoolUncheckedUpdateWithoutProvinceInput>
    create: XOR<SchoolCreateWithoutProvinceInput, SchoolUncheckedCreateWithoutProvinceInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutProvinceInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutProvinceInput, SchoolUncheckedUpdateWithoutProvinceInput>
  }

  export type SchoolUpdateManyWithWhereWithoutProvinceInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutProvinceInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: StringFilter<"School"> | string
    identity?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    longitude?: FloatFilter<"School"> | number
    latitude?: FloatFilter<"School"> | number
    cityId?: StringFilter<"School"> | string
    provinceId?: StringFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutProvinceInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProvinceInput, UserUncheckedUpdateWithoutProvinceInput>
    create: XOR<UserCreateWithoutProvinceInput, UserUncheckedCreateWithoutProvinceInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProvinceInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProvinceInput, UserUncheckedUpdateWithoutProvinceInput>
  }

  export type UserUpdateManyWithWhereWithoutProvinceInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProvinceInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    authId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    suspend?: BoolFilter<"User"> | boolean
    accountType?: EnumAccountTypeFilter<"User"> | $Enums.AccountType
    firstTest?: BoolFilter<"User"> | boolean
    fullname?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    grade?: IntFilter<"User"> | number
    lastGradeUpdateAt?: DateTimeNullableFilter<"User"> | Date | string | null
    schoolIdentity?: StringFilter<"User"> | string
    loginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    logoutAt?: DateTimeNullableFilter<"User"> | Date | string | null
    playTime?: IntFilter<"User"> | number
    characterUsed?: StringFilter<"User"> | string
    inventory?: IntNullableListFilter<"User">
    schoolId?: StringNullableFilter<"User"> | string | null
    cityId?: StringNullableFilter<"User"> | string | null
    provinceId?: StringNullableFilter<"User"> | string | null
    adminId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringFilter<"User"> | string
    lastIdZoneUnlocked?: StringFilter<"User"> | string
    lastIdZonePosition?: StringFilter<"User"> | string
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutProvinceInput, AdminAuthorityUncheckedUpdateWithoutProvinceInput>
    create: XOR<AdminAuthorityCreateWithoutProvinceInput, AdminAuthorityUncheckedCreateWithoutProvinceInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutProvinceInput, AdminAuthorityUncheckedUpdateWithoutProvinceInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutProvinceInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutProvinceInput>
  }

  export type AdminAuthorityScalarWhereInput = {
    AND?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
    OR?: AdminAuthorityScalarWhereInput[]
    NOT?: AdminAuthorityScalarWhereInput | AdminAuthorityScalarWhereInput[]
    id?: StringFilter<"AdminAuthority"> | string
    adminId?: StringFilter<"AdminAuthority"> | string
    provinceId?: StringFilter<"AdminAuthority"> | string
    grades?: IntNullableListFilter<"AdminAuthority">
  }

  export type BannerLocationUpsertWithWhereUniqueWithoutProvinceInput = {
    where: BannerLocationWhereUniqueInput
    update: XOR<BannerLocationUpdateWithoutProvinceInput, BannerLocationUncheckedUpdateWithoutProvinceInput>
    create: XOR<BannerLocationCreateWithoutProvinceInput, BannerLocationUncheckedCreateWithoutProvinceInput>
  }

  export type BannerLocationUpdateWithWhereUniqueWithoutProvinceInput = {
    where: BannerLocationWhereUniqueInput
    data: XOR<BannerLocationUpdateWithoutProvinceInput, BannerLocationUncheckedUpdateWithoutProvinceInput>
  }

  export type BannerLocationUpdateManyWithWhereWithoutProvinceInput = {
    where: BannerLocationScalarWhereInput
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyWithoutProvinceInput>
  }

  export type BannerLocationScalarWhereInput = {
    AND?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
    OR?: BannerLocationScalarWhereInput[]
    NOT?: BannerLocationScalarWhereInput | BannerLocationScalarWhereInput[]
    id?: StringFilter<"BannerLocation"> | string
    bannerId?: StringFilter<"BannerLocation"> | string
    provinceId?: StringFilter<"BannerLocation"> | string
  }

  export type AdminUpsertWithWhereUniqueWithoutProvinceInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutProvinceInput, AdminUncheckedUpdateWithoutProvinceInput>
    create: XOR<AdminCreateWithoutProvinceInput, AdminUncheckedCreateWithoutProvinceInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutProvinceInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutProvinceInput, AdminUncheckedUpdateWithoutProvinceInput>
  }

  export type AdminUpdateManyWithWhereWithoutProvinceInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutProvinceInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    authId?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    suspend?: BoolFilter<"Admin"> | boolean
    role?: EnumRoleNullableFilter<"Admin"> | $Enums.Role | null
    provinceId?: StringNullableFilter<"Admin"> | string | null
    cityId?: StringNullableFilter<"Admin"> | string | null
    schoolId?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type ProvinceCreateWithoutCitiesInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
    admin?: AdminCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutCitiesInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
  }

  export type SchoolCreateWithoutCityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
    admin?: AdminCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutCityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutCityInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput>
  }

  export type SchoolCreateManyCityInputEnvelope = {
    data: SchoolCreateManyCityInput | SchoolCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutCitiesInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutCitiesInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput>
  }

  export type BannerLocationCreateWithoutCitiesInput = {
    id?: string
    banner: BannerCreateNestedOneWithoutBannerLocationInput
    province: ProvinceCreateNestedOneWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateWithoutCitiesInput = {
    id?: string
    bannerId: string
    provinceId: string
  }

  export type BannerLocationCreateOrConnectWithoutCitiesInput = {
    where: BannerLocationWhereUniqueInput
    create: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput>
  }

  export type AdminCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCityInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput>
  }

  export type AdminCreateManyCityInputEnvelope = {
    data: AdminCreateManyCityInput | AdminCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type ProvinceUpsertWithoutCitiesInput = {
    update: XOR<ProvinceUpdateWithoutCitiesInput, ProvinceUncheckedUpdateWithoutCitiesInput>
    create: XOR<ProvinceCreateWithoutCitiesInput, ProvinceUncheckedCreateWithoutCitiesInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutCitiesInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutCitiesInput, ProvinceUncheckedUpdateWithoutCitiesInput>
  }

  export type ProvinceUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
    admin?: AdminUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type SchoolUpsertWithWhereUniqueWithoutCityInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutCityInput, SchoolUncheckedUpdateWithoutCityInput>
    create: XOR<SchoolCreateWithoutCityInput, SchoolUncheckedCreateWithoutCityInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutCityInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutCityInput, SchoolUncheckedUpdateWithoutCityInput>
  }

  export type SchoolUpdateManyWithWhereWithoutCityInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutCityInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCityInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutCitiesInput, AdminAuthorityUncheckedUpdateWithoutCitiesInput>
    create: XOR<AdminAuthorityCreateWithoutCitiesInput, AdminAuthorityUncheckedCreateWithoutCitiesInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutCitiesInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutCitiesInput, AdminAuthorityUncheckedUpdateWithoutCitiesInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutCitiesInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutCitiesInput>
  }

  export type BannerLocationUpsertWithWhereUniqueWithoutCitiesInput = {
    where: BannerLocationWhereUniqueInput
    update: XOR<BannerLocationUpdateWithoutCitiesInput, BannerLocationUncheckedUpdateWithoutCitiesInput>
    create: XOR<BannerLocationCreateWithoutCitiesInput, BannerLocationUncheckedCreateWithoutCitiesInput>
  }

  export type BannerLocationUpdateWithWhereUniqueWithoutCitiesInput = {
    where: BannerLocationWhereUniqueInput
    data: XOR<BannerLocationUpdateWithoutCitiesInput, BannerLocationUncheckedUpdateWithoutCitiesInput>
  }

  export type BannerLocationUpdateManyWithWhereWithoutCitiesInput = {
    where: BannerLocationScalarWhereInput
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyWithoutCitiesInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutCityInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutCityInput, AdminUncheckedUpdateWithoutCityInput>
    create: XOR<AdminCreateWithoutCityInput, AdminUncheckedCreateWithoutCityInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutCityInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutCityInput, AdminUncheckedUpdateWithoutCityInput>
  }

  export type AdminUpdateManyWithWhereWithoutCityInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutCityInput>
  }

  export type CityCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
    admin?: AdminCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutSchoolsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
  }

  export type ProvinceCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
    admin?: AdminCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutSchoolsInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserCreateManySchoolInputEnvelope = {
    data: UserCreateManySchoolInput | UserCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuthorityCreateWithoutSchoolsInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    admin: AdminCreateNestedOneWithoutAuthorityInput
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutSchoolsInput = {
    id?: string
    adminId: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput>
  }

  export type AdminCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSchoolInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSchoolInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput>
  }

  export type AdminCreateManySchoolInputEnvelope = {
    data: AdminCreateManySchoolInput | AdminCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutSchoolsInput = {
    update: XOR<CityUpdateWithoutSchoolsInput, CityUncheckedUpdateWithoutSchoolsInput>
    create: XOR<CityCreateWithoutSchoolsInput, CityUncheckedCreateWithoutSchoolsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutSchoolsInput, CityUncheckedUpdateWithoutSchoolsInput>
  }

  export type CityUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
    admin?: AdminUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
  }

  export type ProvinceUpsertWithoutSchoolsInput = {
    update: XOR<ProvinceUpdateWithoutSchoolsInput, ProvinceUncheckedUpdateWithoutSchoolsInput>
    create: XOR<ProvinceCreateWithoutSchoolsInput, ProvinceUncheckedCreateWithoutSchoolsInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutSchoolsInput, ProvinceUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProvinceUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
    admin?: AdminUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateManyWithWhereWithoutSchoolInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutSchoolsInput, AdminAuthorityUncheckedUpdateWithoutSchoolsInput>
    create: XOR<AdminAuthorityCreateWithoutSchoolsInput, AdminAuthorityUncheckedCreateWithoutSchoolsInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutSchoolsInput, AdminAuthorityUncheckedUpdateWithoutSchoolsInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutSchoolsInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutSchoolInput, AdminUncheckedUpdateWithoutSchoolInput>
    create: XOR<AdminCreateWithoutSchoolInput, AdminUncheckedCreateWithoutSchoolInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutSchoolInput, AdminUncheckedUpdateWithoutSchoolInput>
  }

  export type AdminUpdateManyWithWhereWithoutSchoolInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutSchoolInput>
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
    admin?: AdminCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type ProvinceCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
    admin?: AdminCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutUsersInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
  }

  export type SchoolCreateWithoutUsersInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
    admin?: AdminCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUsersInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUsersInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type ZoneCreateWithoutUserInput = {
    id?: string
    inGameId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUncheckedCreateWithoutUserInput = {
    id?: string
    inGameId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneCreateOrConnectWithoutUserInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput>
  }

  export type ZoneCreateManyUserInputEnvelope = {
    data: ZoneCreateManyUserInput | ZoneCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLoginCreateWithoutUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginUncheckedCreateWithoutUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type UserLoginCreateOrConnectWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    create: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput>
  }

  export type UserLoginCreateManyUserInputEnvelope = {
    data: UserLoginCreateManyUserInput | UserLoginCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BannerVisitorCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    banner: BannerCreateNestedOneWithoutVisitorsInput
  }

  export type BannerVisitorUncheckedCreateWithoutUserInput = {
    id?: string
    bannerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorCreateOrConnectWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    create: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput>
  }

  export type BannerVisitorCreateManyUserInputEnvelope = {
    data: BannerVisitorCreateManyUserInput | BannerVisitorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestParticipantCreateWithoutUserInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    testId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantCreateOrConnectWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantCreateManyUserInputEnvelope = {
    data: TestParticipantCreateManyUserInput | TestParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MultiPlayerMemberCreateWithoutUserInput = {
    id?: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    room: MultiplayerRoomCreateNestedOneWithoutMembersInput
  }

  export type MultiPlayerMemberUncheckedCreateWithoutUserInput = {
    id?: string
    roomId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberCreateOrConnectWithoutUserInput = {
    where: MultiPlayerMemberWhereUniqueInput
    create: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput>
  }

  export type MultiPlayerMemberCreateManyUserInputEnvelope = {
    data: MultiPlayerMemberCreateManyUserInput | MultiPlayerMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubLevelCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubLevelUncheckedCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubLevelCreateOrConnectWithoutUserInput = {
    where: SubLevelWhereUniqueInput
    create: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput>
  }

  export type SubLevelCreateManyUserInputEnvelope = {
    data: SubLevelCreateManyUserInput | SubLevelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InnerLevelCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelUncheckedCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelCreateOrConnectWithoutUserInput = {
    where: InnerLevelWhereUniqueInput
    create: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput>
  }

  export type InnerLevelCreateManyUserInputEnvelope = {
    data: InnerLevelCreateManyUserInput | InnerLevelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LevelCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelUncheckedCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelCreateOrConnectWithoutUserInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput>
  }

  export type LevelCreateManyUserInputEnvelope = {
    data: LevelCreateManyUserInput | LevelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GempoCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoCreateOrConnectWithoutUserInput = {
    where: GempoWhereUniqueInput
    create: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput>
  }

  export type GempoCreateManyUserInputEnvelope = {
    data: GempoCreateManyUserInput | GempoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChampionshipCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipUncheckedCreateWithoutUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipCreateOrConnectWithoutUserInput = {
    where: ChampionshipWhereUniqueInput
    create: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipCreateManyUserInputEnvelope = {
    data: ChampionshipCreateManyUserInput | ChampionshipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GempoRecordCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordUncheckedCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordCreateOrConnectWithoutUserInput = {
    where: GempoRecordWhereUniqueInput
    create: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput>
  }

  export type GempoRecordCreateManyUserInputEnvelope = {
    data: GempoRecordCreateManyUserInput | GempoRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChampionshipRecordCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordUncheckedCreateWithoutUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordCreateOrConnectWithoutUserInput = {
    where: ChampionshipRecordWhereUniqueInput
    create: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipRecordCreateManyUserInputEnvelope = {
    data: ChampionshipRecordCreateManyUserInput | ChampionshipRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CodeRedemeerCreateWithoutUserInput = {
    id?: string
    banned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: RedeemCodeCreateNestedOneWithoutRedemeersInput
  }

  export type CodeRedemeerUncheckedCreateWithoutUserInput = {
    id?: string
    banned?: boolean
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedemeerCreateOrConnectWithoutUserInput = {
    where: CodeRedemeerWhereUniqueInput
    create: XOR<CodeRedemeerCreateWithoutUserInput, CodeRedemeerUncheckedCreateWithoutUserInput>
  }

  export type CodeRedemeerCreateManyUserInputEnvelope = {
    data: CodeRedemeerCreateManyUserInput | CodeRedemeerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutUsersInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
    admin?: AdminUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
  }

  export type ProvinceUpsertWithoutUsersInput = {
    update: XOR<ProvinceUpdateWithoutUsersInput, ProvinceUncheckedUpdateWithoutUsersInput>
    create: XOR<ProvinceCreateWithoutUsersInput, ProvinceUncheckedCreateWithoutUsersInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutUsersInput, ProvinceUncheckedUpdateWithoutUsersInput>
  }

  export type ProvinceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
    admin?: AdminUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type SchoolUpsertWithoutUsersInput = {
    update: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
    create: XOR<SchoolCreateWithoutUsersInput, SchoolUncheckedCreateWithoutUsersInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutUsersInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutUsersInput, SchoolUncheckedUpdateWithoutUsersInput>
  }

  export type SchoolUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type ZoneUpsertWithWhereUniqueWithoutUserInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutUserInput, ZoneUncheckedUpdateWithoutUserInput>
    create: XOR<ZoneCreateWithoutUserInput, ZoneUncheckedCreateWithoutUserInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutUserInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutUserInput, ZoneUncheckedUpdateWithoutUserInput>
  }

  export type ZoneUpdateManyWithWhereWithoutUserInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutUserInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: StringFilter<"Zone"> | string
    inGameId?: StringFilter<"Zone"> | string
    userId?: StringFilter<"Zone"> | string
    isComplete?: BoolFilter<"Zone"> | boolean
    completedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    lastLevelId?: StringFilter<"Zone"> | string
    lastSubLevelId?: StringFilter<"Zone"> | string
    lastInnerLevelId?: StringFilter<"Zone"> | string
    lastLevelUnlock?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
  }

  export type UserLoginUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    update: XOR<UserLoginUpdateWithoutUserInput, UserLoginUncheckedUpdateWithoutUserInput>
    create: XOR<UserLoginCreateWithoutUserInput, UserLoginUncheckedCreateWithoutUserInput>
  }

  export type UserLoginUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLoginWhereUniqueInput
    data: XOR<UserLoginUpdateWithoutUserInput, UserLoginUncheckedUpdateWithoutUserInput>
  }

  export type UserLoginUpdateManyWithWhereWithoutUserInput = {
    where: UserLoginScalarWhereInput
    data: XOR<UserLoginUpdateManyMutationInput, UserLoginUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLoginScalarWhereInput = {
    AND?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
    OR?: UserLoginScalarWhereInput[]
    NOT?: UserLoginScalarWhereInput | UserLoginScalarWhereInput[]
    id?: StringFilter<"UserLogin"> | string
    userId?: StringFilter<"UserLogin"> | string
    loginDate?: DateTimeFilter<"UserLogin"> | Date | string
    logoutDate?: DateTimeNullableFilter<"UserLogin"> | Date | string | null
  }

  export type BannerVisitorUpsertWithWhereUniqueWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    update: XOR<BannerVisitorUpdateWithoutUserInput, BannerVisitorUncheckedUpdateWithoutUserInput>
    create: XOR<BannerVisitorCreateWithoutUserInput, BannerVisitorUncheckedCreateWithoutUserInput>
  }

  export type BannerVisitorUpdateWithWhereUniqueWithoutUserInput = {
    where: BannerVisitorWhereUniqueInput
    data: XOR<BannerVisitorUpdateWithoutUserInput, BannerVisitorUncheckedUpdateWithoutUserInput>
  }

  export type BannerVisitorUpdateManyWithWhereWithoutUserInput = {
    where: BannerVisitorScalarWhereInput
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyWithoutUserInput>
  }

  export type BannerVisitorScalarWhereInput = {
    AND?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
    OR?: BannerVisitorScalarWhereInput[]
    NOT?: BannerVisitorScalarWhereInput | BannerVisitorScalarWhereInput[]
    id?: StringFilter<"BannerVisitor"> | string
    bannerId?: StringFilter<"BannerVisitor"> | string
    userId?: StringFilter<"BannerVisitor"> | string
    createdAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    updatedAt?: DateTimeFilter<"BannerVisitor"> | Date | string
    traffic?: IntFilter<"BannerVisitor"> | number
  }

  export type TestParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    update: XOR<TestParticipantUpdateWithoutUserInput, TestParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<TestParticipantCreateWithoutUserInput, TestParticipantUncheckedCreateWithoutUserInput>
  }

  export type TestParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: TestParticipantWhereUniqueInput
    data: XOR<TestParticipantUpdateWithoutUserInput, TestParticipantUncheckedUpdateWithoutUserInput>
  }

  export type TestParticipantUpdateManyWithWhereWithoutUserInput = {
    where: TestParticipantScalarWhereInput
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type TestParticipantScalarWhereInput = {
    AND?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
    OR?: TestParticipantScalarWhereInput[]
    NOT?: TestParticipantScalarWhereInput | TestParticipantScalarWhereInput[]
    id?: StringFilter<"TestParticipant"> | string
    testId?: StringFilter<"TestParticipant"> | string
    userId?: StringFilter<"TestParticipant"> | string
    firstTimeAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    lastTestAt?: DateTimeNullableFilter<"TestParticipant"> | Date | string | null
    createdAt?: DateTimeFilter<"TestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipant"> | Date | string
    highscore?: FloatFilter<"TestParticipant"> | number
  }

  export type MultiPlayerMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MultiPlayerMemberWhereUniqueInput
    update: XOR<MultiPlayerMemberUpdateWithoutUserInput, MultiPlayerMemberUncheckedUpdateWithoutUserInput>
    create: XOR<MultiPlayerMemberCreateWithoutUserInput, MultiPlayerMemberUncheckedCreateWithoutUserInput>
  }

  export type MultiPlayerMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MultiPlayerMemberWhereUniqueInput
    data: XOR<MultiPlayerMemberUpdateWithoutUserInput, MultiPlayerMemberUncheckedUpdateWithoutUserInput>
  }

  export type MultiPlayerMemberUpdateManyWithWhereWithoutUserInput = {
    where: MultiPlayerMemberScalarWhereInput
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MultiPlayerMemberScalarWhereInput = {
    AND?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
    OR?: MultiPlayerMemberScalarWhereInput[]
    NOT?: MultiPlayerMemberScalarWhereInput | MultiPlayerMemberScalarWhereInput[]
    id?: StringFilter<"MultiPlayerMember"> | string
    roomId?: StringFilter<"MultiPlayerMember"> | string
    userId?: StringFilter<"MultiPlayerMember"> | string
    point?: IntFilter<"MultiPlayerMember"> | number
    bonusPoint?: IntFilter<"MultiPlayerMember"> | number
    isReady?: BoolFilter<"MultiPlayerMember"> | boolean
    isComplete?: BoolFilter<"MultiPlayerMember"> | boolean
    isBot?: BoolFilter<"MultiPlayerMember"> | boolean
    joinedAt?: DateTimeFilter<"MultiPlayerMember"> | Date | string
    finishedAt?: DateTimeNullableFilter<"MultiPlayerMember"> | Date | string | null
    isDisconnect?: BoolFilter<"MultiPlayerMember"> | boolean
  }

  export type SubLevelUpsertWithWhereUniqueWithoutUserInput = {
    where: SubLevelWhereUniqueInput
    update: XOR<SubLevelUpdateWithoutUserInput, SubLevelUncheckedUpdateWithoutUserInput>
    create: XOR<SubLevelCreateWithoutUserInput, SubLevelUncheckedCreateWithoutUserInput>
  }

  export type SubLevelUpdateWithWhereUniqueWithoutUserInput = {
    where: SubLevelWhereUniqueInput
    data: XOR<SubLevelUpdateWithoutUserInput, SubLevelUncheckedUpdateWithoutUserInput>
  }

  export type SubLevelUpdateManyWithWhereWithoutUserInput = {
    where: SubLevelScalarWhereInput
    data: XOR<SubLevelUpdateManyMutationInput, SubLevelUncheckedUpdateManyWithoutUserInput>
  }

  export type SubLevelScalarWhereInput = {
    AND?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
    OR?: SubLevelScalarWhereInput[]
    NOT?: SubLevelScalarWhereInput | SubLevelScalarWhereInput[]
    id?: StringFilter<"SubLevel"> | string
    inGameId?: StringFilter<"SubLevel"> | string
    zoneInGameId?: StringFilter<"SubLevel"> | string
    levelInGameId?: StringFilter<"SubLevel"> | string
    isUnlock?: BoolFilter<"SubLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    isComplete?: BoolFilter<"SubLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"SubLevel"> | Date | string | null
    createdAt?: DateTimeFilter<"SubLevel"> | Date | string
    updatedAt?: DateTimeFilter<"SubLevel"> | Date | string
    userId?: StringFilter<"SubLevel"> | string
  }

  export type InnerLevelUpsertWithWhereUniqueWithoutUserInput = {
    where: InnerLevelWhereUniqueInput
    update: XOR<InnerLevelUpdateWithoutUserInput, InnerLevelUncheckedUpdateWithoutUserInput>
    create: XOR<InnerLevelCreateWithoutUserInput, InnerLevelUncheckedCreateWithoutUserInput>
  }

  export type InnerLevelUpdateWithWhereUniqueWithoutUserInput = {
    where: InnerLevelWhereUniqueInput
    data: XOR<InnerLevelUpdateWithoutUserInput, InnerLevelUncheckedUpdateWithoutUserInput>
  }

  export type InnerLevelUpdateManyWithWhereWithoutUserInput = {
    where: InnerLevelScalarWhereInput
    data: XOR<InnerLevelUpdateManyMutationInput, InnerLevelUncheckedUpdateManyWithoutUserInput>
  }

  export type InnerLevelScalarWhereInput = {
    AND?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
    OR?: InnerLevelScalarWhereInput[]
    NOT?: InnerLevelScalarWhereInput | InnerLevelScalarWhereInput[]
    id?: StringFilter<"InnerLevel"> | string
    inGameId?: StringFilter<"InnerLevel"> | string
    zoneInGameId?: StringFilter<"InnerLevel"> | string
    levelInGameId?: StringFilter<"InnerLevel"> | string
    subLevelInGameId?: StringFilter<"InnerLevel"> | string
    isUnlock?: BoolFilter<"InnerLevel"> | boolean
    unlockedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    isComplete?: BoolFilter<"InnerLevel"> | boolean
    completedAt?: DateTimeNullableFilter<"InnerLevel"> | Date | string | null
    correctAttempt?: FloatFilter<"InnerLevel"> | number
    playTime?: IntFilter<"InnerLevel"> | number
    point?: IntFilter<"InnerLevel"> | number
    played?: IntFilter<"InnerLevel"> | number
    createdAt?: DateTimeFilter<"InnerLevel"> | Date | string
    updatedAt?: DateTimeFilter<"InnerLevel"> | Date | string
    userId?: StringFilter<"InnerLevel"> | string
  }

  export type LevelUpsertWithWhereUniqueWithoutUserInput = {
    where: LevelWhereUniqueInput
    update: XOR<LevelUpdateWithoutUserInput, LevelUncheckedUpdateWithoutUserInput>
    create: XOR<LevelCreateWithoutUserInput, LevelUncheckedCreateWithoutUserInput>
  }

  export type LevelUpdateWithWhereUniqueWithoutUserInput = {
    where: LevelWhereUniqueInput
    data: XOR<LevelUpdateWithoutUserInput, LevelUncheckedUpdateWithoutUserInput>
  }

  export type LevelUpdateManyWithWhereWithoutUserInput = {
    where: LevelScalarWhereInput
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyWithoutUserInput>
  }

  export type LevelScalarWhereInput = {
    AND?: LevelScalarWhereInput | LevelScalarWhereInput[]
    OR?: LevelScalarWhereInput[]
    NOT?: LevelScalarWhereInput | LevelScalarWhereInput[]
    id?: StringFilter<"Level"> | string
    inGameId?: StringFilter<"Level"> | string
    zoneInGameId?: StringFilter<"Level"> | string
    isUnlock?: BoolFilter<"Level"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    isComplete?: BoolFilter<"Level"> | boolean
    completedAt?: DateTimeNullableFilter<"Level"> | Date | string | null
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
    userId?: StringFilter<"Level"> | string
  }

  export type GempoUpsertWithWhereUniqueWithoutUserInput = {
    where: GempoWhereUniqueInput
    update: XOR<GempoUpdateWithoutUserInput, GempoUncheckedUpdateWithoutUserInput>
    create: XOR<GempoCreateWithoutUserInput, GempoUncheckedCreateWithoutUserInput>
  }

  export type GempoUpdateWithWhereUniqueWithoutUserInput = {
    where: GempoWhereUniqueInput
    data: XOR<GempoUpdateWithoutUserInput, GempoUncheckedUpdateWithoutUserInput>
  }

  export type GempoUpdateManyWithWhereWithoutUserInput = {
    where: GempoScalarWhereInput
    data: XOR<GempoUpdateManyMutationInput, GempoUncheckedUpdateManyWithoutUserInput>
  }

  export type GempoScalarWhereInput = {
    AND?: GempoScalarWhereInput | GempoScalarWhereInput[]
    OR?: GempoScalarWhereInput[]
    NOT?: GempoScalarWhereInput | GempoScalarWhereInput[]
    id?: StringFilter<"Gempo"> | string
    isUnlock?: BoolFilter<"Gempo"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Gempo"> | Date | string | null
    inGameId?: StringFilter<"Gempo"> | string
    zoneInGameId?: StringFilter<"Gempo"> | string
    createdAt?: DateTimeFilter<"Gempo"> | Date | string
    updatedAt?: DateTimeFilter<"Gempo"> | Date | string
    userId?: StringFilter<"Gempo"> | string
  }

  export type ChampionshipUpsertWithWhereUniqueWithoutUserInput = {
    where: ChampionshipWhereUniqueInput
    update: XOR<ChampionshipUpdateWithoutUserInput, ChampionshipUncheckedUpdateWithoutUserInput>
    create: XOR<ChampionshipCreateWithoutUserInput, ChampionshipUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipUpdateWithWhereUniqueWithoutUserInput = {
    where: ChampionshipWhereUniqueInput
    data: XOR<ChampionshipUpdateWithoutUserInput, ChampionshipUncheckedUpdateWithoutUserInput>
  }

  export type ChampionshipUpdateManyWithWhereWithoutUserInput = {
    where: ChampionshipScalarWhereInput
    data: XOR<ChampionshipUpdateManyMutationInput, ChampionshipUncheckedUpdateManyWithoutUserInput>
  }

  export type ChampionshipScalarWhereInput = {
    AND?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
    OR?: ChampionshipScalarWhereInput[]
    NOT?: ChampionshipScalarWhereInput | ChampionshipScalarWhereInput[]
    id?: StringFilter<"Championship"> | string
    isUnlock?: BoolFilter<"Championship"> | boolean
    unlockedAt?: DateTimeNullableFilter<"Championship"> | Date | string | null
    inGameId?: StringFilter<"Championship"> | string
    zoneInGameId?: StringFilter<"Championship"> | string
    createdAt?: DateTimeFilter<"Championship"> | Date | string
    updatedAt?: DateTimeFilter<"Championship"> | Date | string
    userId?: StringFilter<"Championship"> | string
  }

  export type GempoRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: GempoRecordWhereUniqueInput
    update: XOR<GempoRecordUpdateWithoutUserInput, GempoRecordUncheckedUpdateWithoutUserInput>
    create: XOR<GempoRecordCreateWithoutUserInput, GempoRecordUncheckedCreateWithoutUserInput>
  }

  export type GempoRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: GempoRecordWhereUniqueInput
    data: XOR<GempoRecordUpdateWithoutUserInput, GempoRecordUncheckedUpdateWithoutUserInput>
  }

  export type GempoRecordUpdateManyWithWhereWithoutUserInput = {
    where: GempoRecordScalarWhereInput
    data: XOR<GempoRecordUpdateManyMutationInput, GempoRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type GempoRecordScalarWhereInput = {
    AND?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
    OR?: GempoRecordScalarWhereInput[]
    NOT?: GempoRecordScalarWhereInput | GempoRecordScalarWhereInput[]
    id?: StringFilter<"GempoRecord"> | string
    inGameId?: StringFilter<"GempoRecord"> | string
    zoneInGameId?: StringFilter<"GempoRecord"> | string
    gempoInGameId?: StringFilter<"GempoRecord"> | string
    played?: IntFilter<"GempoRecord"> | number
    point?: IntFilter<"GempoRecord"> | number
    lastPlayedAt?: DateTimeNullableFilter<"GempoRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"GempoRecord"> | Date | string
    updatedAt?: DateTimeFilter<"GempoRecord"> | Date | string
    userId?: StringFilter<"GempoRecord"> | string
  }

  export type ChampionshipRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: ChampionshipRecordWhereUniqueInput
    update: XOR<ChampionshipRecordUpdateWithoutUserInput, ChampionshipRecordUncheckedUpdateWithoutUserInput>
    create: XOR<ChampionshipRecordCreateWithoutUserInput, ChampionshipRecordUncheckedCreateWithoutUserInput>
  }

  export type ChampionshipRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: ChampionshipRecordWhereUniqueInput
    data: XOR<ChampionshipRecordUpdateWithoutUserInput, ChampionshipRecordUncheckedUpdateWithoutUserInput>
  }

  export type ChampionshipRecordUpdateManyWithWhereWithoutUserInput = {
    where: ChampionshipRecordScalarWhereInput
    data: XOR<ChampionshipRecordUpdateManyMutationInput, ChampionshipRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type ChampionshipRecordScalarWhereInput = {
    AND?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
    OR?: ChampionshipRecordScalarWhereInput[]
    NOT?: ChampionshipRecordScalarWhereInput | ChampionshipRecordScalarWhereInput[]
    id?: StringFilter<"ChampionshipRecord"> | string
    inGameId?: StringFilter<"ChampionshipRecord"> | string
    zoneInGameId?: StringFilter<"ChampionshipRecord"> | string
    championshipInGameId?: StringFilter<"ChampionshipRecord"> | string
    teamWin?: IntFilter<"ChampionshipRecord"> | number
    teamLose?: IntFilter<"ChampionshipRecord"> | number
    teamPlayed?: IntFilter<"ChampionshipRecord"> | number
    teamPoint?: IntFilter<"ChampionshipRecord"> | number
    teamLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    soloWin?: IntFilter<"ChampionshipRecord"> | number
    soloLose?: IntFilter<"ChampionshipRecord"> | number
    soloPlayed?: IntFilter<"ChampionshipRecord"> | number
    soloPoint?: IntFilter<"ChampionshipRecord"> | number
    soloLastPlayedAt?: DateTimeNullableFilter<"ChampionshipRecord"> | Date | string | null
    createdAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ChampionshipRecord"> | Date | string
    userId?: StringFilter<"ChampionshipRecord"> | string
  }

  export type CodeRedemeerUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeRedemeerWhereUniqueInput
    update: XOR<CodeRedemeerUpdateWithoutUserInput, CodeRedemeerUncheckedUpdateWithoutUserInput>
    create: XOR<CodeRedemeerCreateWithoutUserInput, CodeRedemeerUncheckedCreateWithoutUserInput>
  }

  export type CodeRedemeerUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeRedemeerWhereUniqueInput
    data: XOR<CodeRedemeerUpdateWithoutUserInput, CodeRedemeerUncheckedUpdateWithoutUserInput>
  }

  export type CodeRedemeerUpdateManyWithWhereWithoutUserInput = {
    where: CodeRedemeerScalarWhereInput
    data: XOR<CodeRedemeerUpdateManyMutationInput, CodeRedemeerUncheckedUpdateManyWithoutUserInput>
  }

  export type CodeRedemeerScalarWhereInput = {
    AND?: CodeRedemeerScalarWhereInput | CodeRedemeerScalarWhereInput[]
    OR?: CodeRedemeerScalarWhereInput[]
    NOT?: CodeRedemeerScalarWhereInput | CodeRedemeerScalarWhereInput[]
    id?: StringFilter<"CodeRedemeer"> | string
    banned?: BoolFilter<"CodeRedemeer"> | boolean
    userId?: StringFilter<"CodeRedemeer"> | string
    codeId?: StringFilter<"CodeRedemeer"> | string
    createdAt?: DateTimeFilter<"CodeRedemeer"> | Date | string
    updatedAt?: DateTimeFilter<"CodeRedemeer"> | Date | string
  }

  export type UserCreateWithoutZonesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZonesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
  }

  export type UserUpsertWithoutZonesInput = {
    update: XOR<UserUpdateWithoutZonesInput, UserUncheckedUpdateWithoutZonesInput>
    create: XOR<UserCreateWithoutZonesInput, UserUncheckedCreateWithoutZonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZonesInput, UserUncheckedUpdateWithoutZonesInput>
  }

  export type UserUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLevelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
  }

  export type UserUpsertWithoutLevelsInput = {
    update: XOR<UserUpdateWithoutLevelsInput, UserUncheckedUpdateWithoutLevelsInput>
    create: XOR<UserCreateWithoutLevelsInput, UserUncheckedCreateWithoutLevelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLevelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLevelsInput, UserUncheckedUpdateWithoutLevelsInput>
  }

  export type UserUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubLevelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
  }

  export type UserUpsertWithoutSubLevelsInput = {
    update: XOR<UserUpdateWithoutSubLevelsInput, UserUncheckedUpdateWithoutSubLevelsInput>
    create: XOR<UserCreateWithoutSubLevelsInput, UserUncheckedCreateWithoutSubLevelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubLevelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubLevelsInput, UserUncheckedUpdateWithoutSubLevelsInput>
  }

  export type UserUpdateWithoutSubLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInnerLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInnerLevelsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInnerLevelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
  }

  export type UserUpsertWithoutInnerLevelsInput = {
    update: XOR<UserUpdateWithoutInnerLevelsInput, UserUncheckedUpdateWithoutInnerLevelsInput>
    create: XOR<UserCreateWithoutInnerLevelsInput, UserUncheckedCreateWithoutInnerLevelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInnerLevelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInnerLevelsInput, UserUncheckedUpdateWithoutInnerLevelsInput>
  }

  export type UserUpdateWithoutInnerLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInnerLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGemposInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGemposInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGemposInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
  }

  export type UserUpsertWithoutGemposInput = {
    update: XOR<UserUpdateWithoutGemposInput, UserUncheckedUpdateWithoutGemposInput>
    create: XOR<UserCreateWithoutGemposInput, UserUncheckedCreateWithoutGemposInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGemposInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGemposInput, UserUncheckedUpdateWithoutGemposInput>
  }

  export type UserUpdateWithoutGemposInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGemposInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChampionshipsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChampionshipsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChampionshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
  }

  export type UserUpsertWithoutChampionshipsInput = {
    update: XOR<UserUpdateWithoutChampionshipsInput, UserUncheckedUpdateWithoutChampionshipsInput>
    create: XOR<UserCreateWithoutChampionshipsInput, UserUncheckedCreateWithoutChampionshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChampionshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChampionshipsInput, UserUncheckedUpdateWithoutChampionshipsInput>
  }

  export type UserUpdateWithoutChampionshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChampionshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGempoRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGempoRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGempoRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
  }

  export type UserUpsertWithoutGempoRecordsInput = {
    update: XOR<UserUpdateWithoutGempoRecordsInput, UserUncheckedUpdateWithoutGempoRecordsInput>
    create: XOR<UserCreateWithoutGempoRecordsInput, UserUncheckedCreateWithoutGempoRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGempoRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGempoRecordsInput, UserUncheckedUpdateWithoutGempoRecordsInput>
  }

  export type UserUpdateWithoutGempoRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGempoRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChampionshipRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChampionshipRecordsInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChampionshipRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
  }

  export type UserUpsertWithoutChampionshipRecordsInput = {
    update: XOR<UserUpdateWithoutChampionshipRecordsInput, UserUncheckedUpdateWithoutChampionshipRecordsInput>
    create: XOR<UserCreateWithoutChampionshipRecordsInput, UserUncheckedCreateWithoutChampionshipRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChampionshipRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChampionshipRecordsInput, UserUncheckedUpdateWithoutChampionshipRecordsInput>
  }

  export type UserUpdateWithoutChampionshipRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChampionshipRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserLoginInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLoginInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
  }

  export type UserUpsertWithoutUserLoginInput = {
    update: XOR<UserUpdateWithoutUserLoginInput, UserUncheckedUpdateWithoutUserLoginInput>
    create: XOR<UserCreateWithoutUserLoginInput, UserUncheckedCreateWithoutUserLoginInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLoginInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLoginInput, UserUncheckedUpdateWithoutUserLoginInput>
  }

  export type UserUpdateWithoutUserLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type ProvinceCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutAdminInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
  }

  export type CityCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
  }

  export type CityUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type CityCreateOrConnectWithoutAdminInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
  }

  export type SchoolCreateWithoutAdminInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateWithoutAdminInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type SchoolCreateOrConnectWithoutAdminInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityCreateWithoutAdminInput = {
    id?: string
    grades?: AdminAuthorityCreategradesInput | number[]
    province: ProvinceCreateNestedOneWithoutAdminAuthorityInput
    cities?: CityCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityUncheckedCreateWithoutAdminInput = {
    id?: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
    cities?: CityUncheckedCreateNestedManyWithoutAdminAuthorityInput
    schools?: SchoolUncheckedCreateNestedManyWithoutAdminAuthorityInput
  }

  export type AdminAuthorityCreateOrConnectWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    create: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityCreateManyAdminInputEnvelope = {
    data: AdminAuthorityCreateManyAdminInput | AdminAuthorityCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminOperationHistoryCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    opAdmin: AdminCreateNestedOneWithoutOperationsInput
  }

  export type AdminOperationHistoryUncheckedCreateWithoutAdminInput = {
    id?: string
    createdAt?: Date | string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateOrConnectWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    create: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput>
  }

  export type AdminOperationHistoryCreateManyAdminInputEnvelope = {
    data: AdminOperationHistoryCreateManyAdminInput | AdminOperationHistoryCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminOperationHistoryCreateWithoutOpAdminInput = {
    id?: string
    createdAt?: Date | string
    operation?: $Enums.Operation
    admin: AdminCreateNestedOneWithoutOperationHistoriesInput
  }

  export type AdminOperationHistoryUncheckedCreateWithoutOpAdminInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateOrConnectWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    create: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryCreateManyOpAdminInputEnvelope = {
    data: AdminOperationHistoryCreateManyOpAdminInput | AdminOperationHistoryCreateManyOpAdminInput[]
    skipDuplicates?: boolean
  }

  export type BannerCreateWithoutAdminInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutAdminInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutAdminInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput>
  }

  export type BannerCreateManyAdminInputEnvelope = {
    data: BannerCreateManyAdminInput | BannerCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionCreateWithoutAdminInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedAt?: Date | string | null
    redeemCode?: RedeemCodeCreateNestedOneWithoutTransactionInput
    processedBy?: AdminCreateNestedOneWithoutTransactionProcessedInput
  }

  export type AdminTransactionUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
    redeemCode?: RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionCreateOrConnectWithoutAdminInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput>
  }

  export type AdminTransactionCreateManyAdminInputEnvelope = {
    data: AdminTransactionCreateManyAdminInput | AdminTransactionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionCreateWithoutProcessedByInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutTransactionsInput
    redeemCode?: RedeemCodeCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionUncheckedCreateWithoutProcessedByInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedAt?: Date | string | null
    redeemCode?: RedeemCodeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type AdminTransactionCreateOrConnectWithoutProcessedByInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput>
  }

  export type AdminTransactionCreateManyProcessedByInputEnvelope = {
    data: AdminTransactionCreateManyProcessedByInput | AdminTransactionCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type RedeemCodeCreateWithoutAdminInput = {
    id?: string
    suspend?: boolean
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: AdminTransactionCreateNestedOneWithoutRedeemCodeInput
    redemeers?: CodeRedemeerCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeUncheckedCreateWithoutAdminInput = {
    id?: string
    suspend?: boolean
    transactionId: string
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    redemeers?: CodeRedemeerUncheckedCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeCreateOrConnectWithoutAdminInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput>
  }

  export type RedeemCodeCreateManyAdminInputEnvelope = {
    data: RedeemCodeCreateManyAdminInput | RedeemCodeCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProvinceUpsertWithoutAdminInput = {
    update: XOR<ProvinceUpdateWithoutAdminInput, ProvinceUncheckedUpdateWithoutAdminInput>
    create: XOR<ProvinceCreateWithoutAdminInput, ProvinceUncheckedCreateWithoutAdminInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutAdminInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutAdminInput, ProvinceUncheckedUpdateWithoutAdminInput>
  }

  export type ProvinceUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type CityUpsertWithoutAdminInput = {
    update: XOR<CityUpdateWithoutAdminInput, CityUncheckedUpdateWithoutAdminInput>
    create: XOR<CityCreateWithoutAdminInput, CityUncheckedCreateWithoutAdminInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAdminInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAdminInput, CityUncheckedUpdateWithoutAdminInput>
  }

  export type CityUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
  }

  export type CityUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type SchoolUpsertWithoutAdminInput = {
    update: XOR<SchoolUpdateWithoutAdminInput, SchoolUncheckedUpdateWithoutAdminInput>
    create: XOR<SchoolCreateWithoutAdminInput, SchoolUncheckedCreateWithoutAdminInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAdminInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAdminInput, SchoolUncheckedUpdateWithoutAdminInput>
  }

  export type SchoolUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type AdminAuthorityUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    update: XOR<AdminAuthorityUpdateWithoutAdminInput, AdminAuthorityUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuthorityCreateWithoutAdminInput, AdminAuthorityUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuthorityWhereUniqueInput
    data: XOR<AdminAuthorityUpdateWithoutAdminInput, AdminAuthorityUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuthorityUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuthorityScalarWhereInput
    data: XOR<AdminAuthorityUpdateManyMutationInput, AdminAuthorityUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminOperationHistoryUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    update: XOR<AdminOperationHistoryUpdateWithoutAdminInput, AdminOperationHistoryUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminOperationHistoryCreateWithoutAdminInput, AdminOperationHistoryUncheckedCreateWithoutAdminInput>
  }

  export type AdminOperationHistoryUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    data: XOR<AdminOperationHistoryUpdateWithoutAdminInput, AdminOperationHistoryUncheckedUpdateWithoutAdminInput>
  }

  export type AdminOperationHistoryUpdateManyWithWhereWithoutAdminInput = {
    where: AdminOperationHistoryScalarWhereInput
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminOperationHistoryScalarWhereInput = {
    AND?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
    OR?: AdminOperationHistoryScalarWhereInput[]
    NOT?: AdminOperationHistoryScalarWhereInput | AdminOperationHistoryScalarWhereInput[]
    id?: StringFilter<"AdminOperationHistory"> | string
    createdAt?: DateTimeFilter<"AdminOperationHistory"> | Date | string
    adminId?: StringFilter<"AdminOperationHistory"> | string
    opAdminId?: StringFilter<"AdminOperationHistory"> | string
    operation?: EnumOperationFilter<"AdminOperationHistory"> | $Enums.Operation
  }

  export type AdminOperationHistoryUpsertWithWhereUniqueWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    update: XOR<AdminOperationHistoryUpdateWithoutOpAdminInput, AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput>
    create: XOR<AdminOperationHistoryCreateWithoutOpAdminInput, AdminOperationHistoryUncheckedCreateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryUpdateWithWhereUniqueWithoutOpAdminInput = {
    where: AdminOperationHistoryWhereUniqueInput
    data: XOR<AdminOperationHistoryUpdateWithoutOpAdminInput, AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput>
  }

  export type AdminOperationHistoryUpdateManyWithWhereWithoutOpAdminInput = {
    where: AdminOperationHistoryScalarWhereInput
    data: XOR<AdminOperationHistoryUpdateManyMutationInput, AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminInput>
  }

  export type BannerUpsertWithWhereUniqueWithoutAdminInput = {
    where: BannerWhereUniqueInput
    update: XOR<BannerUpdateWithoutAdminInput, BannerUncheckedUpdateWithoutAdminInput>
    create: XOR<BannerCreateWithoutAdminInput, BannerUncheckedCreateWithoutAdminInput>
  }

  export type BannerUpdateWithWhereUniqueWithoutAdminInput = {
    where: BannerWhereUniqueInput
    data: XOR<BannerUpdateWithoutAdminInput, BannerUncheckedUpdateWithoutAdminInput>
  }

  export type BannerUpdateManyWithWhereWithoutAdminInput = {
    where: BannerScalarWhereInput
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyWithoutAdminInput>
  }

  export type BannerScalarWhereInput = {
    AND?: BannerScalarWhereInput | BannerScalarWhereInput[]
    OR?: BannerScalarWhereInput[]
    NOT?: BannerScalarWhereInput | BannerScalarWhereInput[]
    id?: StringFilter<"Banner"> | string
    thumbnailId?: StringFilter<"Banner"> | string
    thumbnail?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    startedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    isHide?: BoolFilter<"Banner"> | boolean
    adminId?: StringFilter<"Banner"> | string
  }

  export type AdminTransactionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminTransactionWhereUniqueInput
    update: XOR<AdminTransactionUpdateWithoutAdminInput, AdminTransactionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminTransactionCreateWithoutAdminInput, AdminTransactionUncheckedCreateWithoutAdminInput>
  }

  export type AdminTransactionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminTransactionWhereUniqueInput
    data: XOR<AdminTransactionUpdateWithoutAdminInput, AdminTransactionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminTransactionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminTransactionScalarWhereInput
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminTransactionScalarWhereInput = {
    AND?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
    OR?: AdminTransactionScalarWhereInput[]
    NOT?: AdminTransactionScalarWhereInput | AdminTransactionScalarWhereInput[]
    id?: StringFilter<"AdminTransaction"> | string
    name?: StringFilter<"AdminTransaction"> | string
    status?: EnumTransactionFilter<"AdminTransaction"> | $Enums.Transaction
    archived?: BoolFilter<"AdminTransaction"> | boolean
    createdAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"AdminTransaction"> | Date | string
    adminId?: StringFilter<"AdminTransaction"> | string
    quantity?: IntFilter<"AdminTransaction"> | number
    subscriptionTime?: IntFilter<"AdminTransaction"> | number
    zones?: StringNullableListFilter<"AdminTransaction">
    transactionRef?: StringNullableFilter<"AdminTransaction"> | string | null
    amount?: IntFilter<"AdminTransaction"> | number
    description?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageId?: StringNullableFilter<"AdminTransaction"> | string | null
    transactionImageUrl?: StringNullableFilter<"AdminTransaction"> | string | null
    processedById?: StringNullableFilter<"AdminTransaction"> | string | null
    processedAt?: DateTimeNullableFilter<"AdminTransaction"> | Date | string | null
  }

  export type AdminTransactionUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: AdminTransactionWhereUniqueInput
    update: XOR<AdminTransactionUpdateWithoutProcessedByInput, AdminTransactionUncheckedUpdateWithoutProcessedByInput>
    create: XOR<AdminTransactionCreateWithoutProcessedByInput, AdminTransactionUncheckedCreateWithoutProcessedByInput>
  }

  export type AdminTransactionUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: AdminTransactionWhereUniqueInput
    data: XOR<AdminTransactionUpdateWithoutProcessedByInput, AdminTransactionUncheckedUpdateWithoutProcessedByInput>
  }

  export type AdminTransactionUpdateManyWithWhereWithoutProcessedByInput = {
    where: AdminTransactionScalarWhereInput
    data: XOR<AdminTransactionUpdateManyMutationInput, AdminTransactionUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type RedeemCodeUpsertWithWhereUniqueWithoutAdminInput = {
    where: RedeemCodeWhereUniqueInput
    update: XOR<RedeemCodeUpdateWithoutAdminInput, RedeemCodeUncheckedUpdateWithoutAdminInput>
    create: XOR<RedeemCodeCreateWithoutAdminInput, RedeemCodeUncheckedCreateWithoutAdminInput>
  }

  export type RedeemCodeUpdateWithWhereUniqueWithoutAdminInput = {
    where: RedeemCodeWhereUniqueInput
    data: XOR<RedeemCodeUpdateWithoutAdminInput, RedeemCodeUncheckedUpdateWithoutAdminInput>
  }

  export type RedeemCodeUpdateManyWithWhereWithoutAdminInput = {
    where: RedeemCodeScalarWhereInput
    data: XOR<RedeemCodeUpdateManyMutationInput, RedeemCodeUncheckedUpdateManyWithoutAdminInput>
  }

  export type RedeemCodeScalarWhereInput = {
    AND?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
    OR?: RedeemCodeScalarWhereInput[]
    NOT?: RedeemCodeScalarWhereInput | RedeemCodeScalarWhereInput[]
    id?: StringFilter<"RedeemCode"> | string
    suspend?: BoolFilter<"RedeemCode"> | boolean
    transactionId?: StringFilter<"RedeemCode"> | string
    adminId?: StringFilter<"RedeemCode"> | string
    code?: StringFilter<"RedeemCode"> | string
    expiredAt?: DateTimeFilter<"RedeemCode"> | Date | string
    currentAmount?: IntFilter<"RedeemCode"> | number
    maxAmount?: IntFilter<"RedeemCode"> | number
    data?: StringNullableListFilter<"RedeemCode">
    createdAt?: DateTimeFilter<"RedeemCode"> | Date | string
    updatedAt?: DateTimeFilter<"RedeemCode"> | Date | string
  }

  export type AdminCreateWithoutOperationHistoriesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutOperationHistoriesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutOperationHistoriesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
  }

  export type AdminCreateWithoutOperationsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutOperationsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutOperationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
  }

  export type AdminUpsertWithoutOperationHistoriesInput = {
    update: XOR<AdminUpdateWithoutOperationHistoriesInput, AdminUncheckedUpdateWithoutOperationHistoriesInput>
    create: XOR<AdminCreateWithoutOperationHistoriesInput, AdminUncheckedCreateWithoutOperationHistoriesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOperationHistoriesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOperationHistoriesInput, AdminUncheckedUpdateWithoutOperationHistoriesInput>
  }

  export type AdminUpdateWithoutOperationHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutOperationHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUpsertWithoutOperationsInput = {
    update: XOR<AdminUpdateWithoutOperationsInput, AdminUncheckedUpdateWithoutOperationsInput>
    create: XOR<AdminCreateWithoutOperationsInput, AdminUncheckedCreateWithoutOperationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutOperationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutOperationsInput, AdminUncheckedUpdateWithoutOperationsInput>
  }

  export type AdminUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutAuthorityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAuthorityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutAuthorityInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
  }

  export type ProvinceCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutProvinceInput
    admin?: AdminCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutProvinceInput
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutAdminAuthorityInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type CityCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutCitiesInput
    admin?: AdminCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutCitiesInput
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SchoolCreateWithoutAdminAuthorityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    createdAt?: Date | string
    updatedAt?: Date | string
    city: CityCreateNestedOneWithoutSchoolsInput
    province: ProvinceCreateNestedOneWithoutSchoolsInput
    users?: UserCreateNestedManyWithoutSchoolInput
    admin?: AdminCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAdminAuthorityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSchoolInput
    admin?: AdminUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type AdminUpsertWithoutAuthorityInput = {
    update: XOR<AdminUpdateWithoutAuthorityInput, AdminUncheckedUpdateWithoutAuthorityInput>
    create: XOR<AdminCreateWithoutAuthorityInput, AdminUncheckedCreateWithoutAuthorityInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAuthorityInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAuthorityInput, AdminUncheckedUpdateWithoutAuthorityInput>
  }

  export type AdminUpdateWithoutAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type ProvinceUpsertWithoutAdminAuthorityInput = {
    update: XOR<ProvinceUpdateWithoutAdminAuthorityInput, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<ProvinceCreateWithoutAdminAuthorityInput, ProvinceUncheckedCreateWithoutAdminAuthorityInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutAdminAuthorityInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutAdminAuthorityInput, ProvinceUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type ProvinceUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutProvinceNestedInput
    admin?: AdminUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutProvinceNestedInput
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutAdminAuthorityInput, CityUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<CityCreateWithoutAdminAuthorityInput, CityUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type CityUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutAdminAuthorityInput, CityUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type CityUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type SchoolUpsertWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutAdminAuthorityInput, SchoolUncheckedUpdateWithoutAdminAuthorityInput>
    create: XOR<SchoolCreateWithoutAdminAuthorityInput, SchoolUncheckedCreateWithoutAdminAuthorityInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutAdminAuthorityInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutAdminAuthorityInput, SchoolUncheckedUpdateWithoutAdminAuthorityInput>
  }

  export type SchoolUpdateManyWithWhereWithoutAdminAuthorityInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutAdminAuthorityInput>
  }

  export type BannerVisitorCreateWithoutBannerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
    user: UserCreateNestedOneWithoutBannerVisitorInput
  }

  export type BannerVisitorUncheckedCreateWithoutBannerInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerVisitorCreateOrConnectWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    create: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput>
  }

  export type BannerVisitorCreateManyBannerInputEnvelope = {
    data: BannerVisitorCreateManyBannerInput | BannerVisitorCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutBannerInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutBannerInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutBannerInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
  }

  export type BannerLocationCreateWithoutBannerInput = {
    id?: string
    province: ProvinceCreateNestedOneWithoutBannerLocationInput
    cities?: CityCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationUncheckedCreateWithoutBannerInput = {
    id?: string
    provinceId: string
    cities?: CityUncheckedCreateNestedManyWithoutBannerLocationInput
  }

  export type BannerLocationCreateOrConnectWithoutBannerInput = {
    where: BannerLocationWhereUniqueInput
    create: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput>
  }

  export type BannerLocationCreateManyBannerInputEnvelope = {
    data: BannerLocationCreateManyBannerInput | BannerLocationCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type BannerVisitorUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    update: XOR<BannerVisitorUpdateWithoutBannerInput, BannerVisitorUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerVisitorCreateWithoutBannerInput, BannerVisitorUncheckedCreateWithoutBannerInput>
  }

  export type BannerVisitorUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerVisitorWhereUniqueInput
    data: XOR<BannerVisitorUpdateWithoutBannerInput, BannerVisitorUncheckedUpdateWithoutBannerInput>
  }

  export type BannerVisitorUpdateManyWithWhereWithoutBannerInput = {
    where: BannerVisitorScalarWhereInput
    data: XOR<BannerVisitorUpdateManyMutationInput, BannerVisitorUncheckedUpdateManyWithoutBannerInput>
  }

  export type AdminUpsertWithoutBannerInput = {
    update: XOR<AdminUpdateWithoutBannerInput, AdminUncheckedUpdateWithoutBannerInput>
    create: XOR<AdminCreateWithoutBannerInput, AdminUncheckedCreateWithoutBannerInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutBannerInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutBannerInput, AdminUncheckedUpdateWithoutBannerInput>
  }

  export type AdminUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type BannerLocationUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerLocationWhereUniqueInput
    update: XOR<BannerLocationUpdateWithoutBannerInput, BannerLocationUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerLocationCreateWithoutBannerInput, BannerLocationUncheckedCreateWithoutBannerInput>
  }

  export type BannerLocationUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerLocationWhereUniqueInput
    data: XOR<BannerLocationUpdateWithoutBannerInput, BannerLocationUncheckedUpdateWithoutBannerInput>
  }

  export type BannerLocationUpdateManyWithWhereWithoutBannerInput = {
    where: BannerLocationScalarWhereInput
    data: XOR<BannerLocationUpdateManyMutationInput, BannerLocationUncheckedUpdateManyWithoutBannerInput>
  }

  export type BannerCreateWithoutBannerLocationInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    visitors?: BannerVisitorCreateNestedManyWithoutBannerInput
    admin: AdminCreateNestedOneWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutBannerLocationInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
    visitors?: BannerVisitorUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutBannerLocationInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
  }

  export type ProvinceCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityCreateNestedManyWithoutProvinceInput
    schools?: SchoolCreateNestedManyWithoutProvinceInput
    users?: UserCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutProvinceInput
    admin?: AdminCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: CityUncheckedCreateNestedManyWithoutProvinceInput
    schools?: SchoolUncheckedCreateNestedManyWithoutProvinceInput
    users?: UserUncheckedCreateNestedManyWithoutProvinceInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutProvinceInput
    admin?: AdminUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutBannerLocationInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
  }

  export type CityCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    province: ProvinceCreateNestedOneWithoutCitiesInput
    schools?: SchoolCreateNestedManyWithoutCityInput
    users?: UserCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityCreateNestedManyWithoutCitiesInput
    admin?: AdminCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutBannerLocationInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    schools?: SchoolUncheckedCreateNestedManyWithoutCityInput
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    adminAuthority?: AdminAuthorityUncheckedCreateNestedManyWithoutCitiesInput
    admin?: AdminUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutBannerLocationInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput>
  }

  export type BannerUpsertWithoutBannerLocationInput = {
    update: XOR<BannerUpdateWithoutBannerLocationInput, BannerUncheckedUpdateWithoutBannerLocationInput>
    create: XOR<BannerCreateWithoutBannerLocationInput, BannerUncheckedCreateWithoutBannerLocationInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutBannerLocationInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutBannerLocationInput, BannerUncheckedUpdateWithoutBannerLocationInput>
  }

  export type BannerUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type ProvinceUpsertWithoutBannerLocationInput = {
    update: XOR<ProvinceUpdateWithoutBannerLocationInput, ProvinceUncheckedUpdateWithoutBannerLocationInput>
    create: XOR<ProvinceCreateWithoutBannerLocationInput, ProvinceUncheckedCreateWithoutBannerLocationInput>
    where?: ProvinceWhereInput
  }

  export type ProvinceUpdateToOneWithWhereWithoutBannerLocationInput = {
    where?: ProvinceWhereInput
    data: XOR<ProvinceUpdateWithoutBannerLocationInput, ProvinceUncheckedUpdateWithoutBannerLocationInput>
  }

  export type ProvinceUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUpdateManyWithoutProvinceNestedInput
    users?: UserUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutProvinceNestedInput
    admin?: AdminUpdateManyWithoutProvinceNestedInput
  }

  export type ProvinceUncheckedUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: CityUncheckedUpdateManyWithoutProvinceNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutProvinceNestedInput
    users?: UserUncheckedUpdateManyWithoutProvinceNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutProvinceNestedInput
    admin?: AdminUncheckedUpdateManyWithoutProvinceNestedInput
  }

  export type CityUpsertWithWhereUniqueWithoutBannerLocationInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutBannerLocationInput, CityUncheckedUpdateWithoutBannerLocationInput>
    create: XOR<CityCreateWithoutBannerLocationInput, CityUncheckedCreateWithoutBannerLocationInput>
  }

  export type CityUpdateWithWhereUniqueWithoutBannerLocationInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutBannerLocationInput, CityUncheckedUpdateWithoutBannerLocationInput>
  }

  export type CityUpdateManyWithWhereWithoutBannerLocationInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutBannerLocationInput>
  }

  export type BannerCreateWithoutVisitorsInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    admin: AdminCreateNestedOneWithoutBannerInput
    bannerLocation?: BannerLocationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutVisitorsInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
    adminId: string
    bannerLocation?: BannerLocationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutVisitorsInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
  }

  export type UserCreateWithoutBannerVisitorInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBannerVisitorInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBannerVisitorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
  }

  export type BannerUpsertWithoutVisitorsInput = {
    update: XOR<BannerUpdateWithoutVisitorsInput, BannerUncheckedUpdateWithoutVisitorsInput>
    create: XOR<BannerCreateWithoutVisitorsInput, BannerUncheckedCreateWithoutVisitorsInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutVisitorsInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutVisitorsInput, BannerUncheckedUpdateWithoutVisitorsInput>
  }

  export type BannerUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutBannerNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutVisitorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type UserUpsertWithoutBannerVisitorInput = {
    update: XOR<UserUpdateWithoutBannerVisitorInput, UserUncheckedUpdateWithoutBannerVisitorInput>
    create: XOR<UserCreateWithoutBannerVisitorInput, UserUncheckedCreateWithoutBannerVisitorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBannerVisitorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBannerVisitorInput, UserUncheckedUpdateWithoutBannerVisitorInput>
  }

  export type UserUpdateWithoutBannerVisitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBannerVisitorInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TestParticipantCreateWithoutTestInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    user: UserCreateNestedOneWithoutTestParticipantInput
    records?: TestParticipantRecordCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutTestInput = {
    id?: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    records?: TestParticipantRecordUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type TestParticipantCreateOrConnectWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput>
  }

  export type TestParticipantCreateManyTestInputEnvelope = {
    data: TestParticipantCreateManyTestInput | TestParticipantCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TestParticipantUpsertWithWhereUniqueWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    update: XOR<TestParticipantUpdateWithoutTestInput, TestParticipantUncheckedUpdateWithoutTestInput>
    create: XOR<TestParticipantCreateWithoutTestInput, TestParticipantUncheckedCreateWithoutTestInput>
  }

  export type TestParticipantUpdateWithWhereUniqueWithoutTestInput = {
    where: TestParticipantWhereUniqueInput
    data: XOR<TestParticipantUpdateWithoutTestInput, TestParticipantUncheckedUpdateWithoutTestInput>
  }

  export type TestParticipantUpdateManyWithWhereWithoutTestInput = {
    where: TestParticipantScalarWhereInput
    data: XOR<TestParticipantUpdateManyMutationInput, TestParticipantUncheckedUpdateManyWithoutTestInput>
  }

  export type TestCreateWithoutParticipantsInput = {
    id?: string
    name?: string
    category: $Enums.Role
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestUncheckedCreateWithoutParticipantsInput = {
    id?: string
    name?: string
    category: $Enums.Role
    question: $Enums.QuestionType
    duration?: number
    passedPoint?: number
    remidialCount?: number
    type: $Enums.TestType
    quota?: number
    currentQuota?: number
    code?: string | null
    zoneId?: string | null
    startedAt: Date | string
    endedAt?: Date | string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestCreateOrConnectWithoutParticipantsInput = {
    where: TestWhereUniqueInput
    create: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutTestParticipantInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestParticipantInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
  }

  export type TestParticipantRecordCreateWithoutParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedCreateWithoutParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordCreateOrConnectWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    create: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput>
  }

  export type TestParticipantRecordCreateManyParticipantInputEnvelope = {
    data: TestParticipantRecordCreateManyParticipantInput | TestParticipantRecordCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TestUpsertWithoutParticipantsInput = {
    update: XOR<TestUpdateWithoutParticipantsInput, TestUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TestCreateWithoutParticipantsInput, TestUncheckedCreateWithoutParticipantsInput>
    where?: TestWhereInput
  }

  export type TestUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TestWhereInput
    data: XOR<TestUpdateWithoutParticipantsInput, TestUncheckedUpdateWithoutParticipantsInput>
  }

  export type TestUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    question?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    duration?: IntFieldUpdateOperationsInput | number
    passedPoint?: IntFieldUpdateOperationsInput | number
    remidialCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTestTypeFieldUpdateOperationsInput | $Enums.TestType
    quota?: IntFieldUpdateOperationsInput | number
    currentQuota?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTestParticipantInput = {
    update: XOR<UserUpdateWithoutTestParticipantInput, UserUncheckedUpdateWithoutTestParticipantInput>
    create: XOR<UserCreateWithoutTestParticipantInput, UserUncheckedCreateWithoutTestParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestParticipantInput, UserUncheckedUpdateWithoutTestParticipantInput>
  }

  export type UserUpdateWithoutTestParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TestParticipantRecordUpsertWithWhereUniqueWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    update: XOR<TestParticipantRecordUpdateWithoutParticipantInput, TestParticipantRecordUncheckedUpdateWithoutParticipantInput>
    create: XOR<TestParticipantRecordCreateWithoutParticipantInput, TestParticipantRecordUncheckedCreateWithoutParticipantInput>
  }

  export type TestParticipantRecordUpdateWithWhereUniqueWithoutParticipantInput = {
    where: TestParticipantRecordWhereUniqueInput
    data: XOR<TestParticipantRecordUpdateWithoutParticipantInput, TestParticipantRecordUncheckedUpdateWithoutParticipantInput>
  }

  export type TestParticipantRecordUpdateManyWithWhereWithoutParticipantInput = {
    where: TestParticipantRecordScalarWhereInput
    data: XOR<TestParticipantRecordUpdateManyMutationInput, TestParticipantRecordUncheckedUpdateManyWithoutParticipantInput>
  }

  export type TestParticipantRecordScalarWhereInput = {
    AND?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
    OR?: TestParticipantRecordScalarWhereInput[]
    NOT?: TestParticipantRecordScalarWhereInput | TestParticipantRecordScalarWhereInput[]
    id?: StringFilter<"TestParticipantRecord"> | string
    participantId?: StringFilter<"TestParticipantRecord"> | string
    startedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TestParticipantRecord"> | Date | string | null
    score?: FloatFilter<"TestParticipantRecord"> | number
    createdAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TestParticipantRecord"> | Date | string
    answers?: JsonFilter<"TestParticipantRecord">
  }

  export type TestParticipantCreateWithoutRecordsInput = {
    id?: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
    test: TestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutTestParticipantInput
  }

  export type TestParticipantUncheckedCreateWithoutRecordsInput = {
    id?: string
    testId: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type TestParticipantCreateOrConnectWithoutRecordsInput = {
    where: TestParticipantWhereUniqueInput
    create: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
  }

  export type TestParticipantUpsertWithoutRecordsInput = {
    update: XOR<TestParticipantUpdateWithoutRecordsInput, TestParticipantUncheckedUpdateWithoutRecordsInput>
    create: XOR<TestParticipantCreateWithoutRecordsInput, TestParticipantUncheckedCreateWithoutRecordsInput>
    where?: TestParticipantWhereInput
  }

  export type TestParticipantUpdateToOneWithWhereWithoutRecordsInput = {
    where?: TestParticipantWhereInput
    data: XOR<TestParticipantUpdateWithoutRecordsInput, TestParticipantUncheckedUpdateWithoutRecordsInput>
  }

  export type TestParticipantUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type AdminCreateWithoutTransactionsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutTransactionsInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutTransactionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
  }

  export type RedeemCodeCreateWithoutTransactionInput = {
    id?: string
    suspend?: boolean
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutRedeemCodesInput
    redemeers?: CodeRedemeerCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeUncheckedCreateWithoutTransactionInput = {
    id?: string
    suspend?: boolean
    adminId: string
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    redemeers?: CodeRedemeerUncheckedCreateNestedManyWithoutCodeInput
  }

  export type RedeemCodeCreateOrConnectWithoutTransactionInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
  }

  export type AdminCreateWithoutTransactionProcessedInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutTransactionProcessedInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    redeemCodes?: RedeemCodeUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutTransactionProcessedInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
  }

  export type AdminUpsertWithoutTransactionsInput = {
    update: XOR<AdminUpdateWithoutTransactionsInput, AdminUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AdminCreateWithoutTransactionsInput, AdminUncheckedCreateWithoutTransactionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutTransactionsInput, AdminUncheckedUpdateWithoutTransactionsInput>
  }

  export type AdminUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type RedeemCodeUpsertWithoutTransactionInput = {
    update: XOR<RedeemCodeUpdateWithoutTransactionInput, RedeemCodeUncheckedUpdateWithoutTransactionInput>
    create: XOR<RedeemCodeCreateWithoutTransactionInput, RedeemCodeUncheckedCreateWithoutTransactionInput>
    where?: RedeemCodeWhereInput
  }

  export type RedeemCodeUpdateToOneWithWhereWithoutTransactionInput = {
    where?: RedeemCodeWhereInput
    data: XOR<RedeemCodeUpdateWithoutTransactionInput, RedeemCodeUncheckedUpdateWithoutTransactionInput>
  }

  export type RedeemCodeUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutRedeemCodesNestedInput
    redemeers?: CodeRedemeerUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemeers?: CodeRedemeerUncheckedUpdateManyWithoutCodeNestedInput
  }

  export type AdminUpsertWithoutTransactionProcessedInput = {
    update: XOR<AdminUpdateWithoutTransactionProcessedInput, AdminUncheckedUpdateWithoutTransactionProcessedInput>
    create: XOR<AdminCreateWithoutTransactionProcessedInput, AdminUncheckedCreateWithoutTransactionProcessedInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutTransactionProcessedInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutTransactionProcessedInput, AdminUncheckedUpdateWithoutTransactionProcessedInput>
  }

  export type AdminUpdateWithoutTransactionProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutTransactionProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminTransactionCreateWithoutRedeemCodeInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedAt?: Date | string | null
    admin: AdminCreateNestedOneWithoutTransactionsInput
    processedBy?: AdminCreateNestedOneWithoutTransactionProcessedInput
  }

  export type AdminTransactionUncheckedCreateWithoutRedeemCodeInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
  }

  export type AdminTransactionCreateOrConnectWithoutRedeemCodeInput = {
    where: AdminTransactionWhereUniqueInput
    create: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
  }

  export type AdminCreateWithoutRedeemCodesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAdminInput
    province?: ProvinceCreateNestedOneWithoutAdminInput
    city?: CityCreateNestedOneWithoutAdminInput
    school?: SchoolCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryCreateNestedManyWithoutOpAdminInput
    banner?: BannerCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionCreateNestedManyWithoutProcessedByInput
  }

  export type AdminUncheckedCreateWithoutRedeemCodesInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutAdminInput
    authority?: AdminAuthorityUncheckedCreateNestedManyWithoutAdminInput
    operationHistories?: AdminOperationHistoryUncheckedCreateNestedManyWithoutAdminInput
    operations?: AdminOperationHistoryUncheckedCreateNestedManyWithoutOpAdminInput
    banner?: BannerUncheckedCreateNestedManyWithoutAdminInput
    transactions?: AdminTransactionUncheckedCreateNestedManyWithoutAdminInput
    transactionProcessed?: AdminTransactionUncheckedCreateNestedManyWithoutProcessedByInput
  }

  export type AdminCreateOrConnectWithoutRedeemCodesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
  }

  export type CodeRedemeerCreateWithoutCodeInput = {
    id?: string
    banned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRedemeedCodesInput
  }

  export type CodeRedemeerUncheckedCreateWithoutCodeInput = {
    id?: string
    banned?: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedemeerCreateOrConnectWithoutCodeInput = {
    where: CodeRedemeerWhereUniqueInput
    create: XOR<CodeRedemeerCreateWithoutCodeInput, CodeRedemeerUncheckedCreateWithoutCodeInput>
  }

  export type CodeRedemeerCreateManyCodeInputEnvelope = {
    data: CodeRedemeerCreateManyCodeInput | CodeRedemeerCreateManyCodeInput[]
    skipDuplicates?: boolean
  }

  export type AdminTransactionUpsertWithoutRedeemCodeInput = {
    update: XOR<AdminTransactionUpdateWithoutRedeemCodeInput, AdminTransactionUncheckedUpdateWithoutRedeemCodeInput>
    create: XOR<AdminTransactionCreateWithoutRedeemCodeInput, AdminTransactionUncheckedCreateWithoutRedeemCodeInput>
    where?: AdminTransactionWhereInput
  }

  export type AdminTransactionUpdateToOneWithWhereWithoutRedeemCodeInput = {
    where?: AdminTransactionWhereInput
    data: XOR<AdminTransactionUpdateWithoutRedeemCodeInput, AdminTransactionUncheckedUpdateWithoutRedeemCodeInput>
  }

  export type AdminTransactionUpdateWithoutRedeemCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutTransactionsNestedInput
    processedBy?: AdminUpdateOneWithoutTransactionProcessedNestedInput
  }

  export type AdminTransactionUncheckedUpdateWithoutRedeemCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminUpsertWithoutRedeemCodesInput = {
    update: XOR<AdminUpdateWithoutRedeemCodesInput, AdminUncheckedUpdateWithoutRedeemCodesInput>
    create: XOR<AdminCreateWithoutRedeemCodesInput, AdminUncheckedCreateWithoutRedeemCodesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutRedeemCodesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutRedeemCodesInput, AdminUncheckedUpdateWithoutRedeemCodesInput>
  }

  export type AdminUpdateWithoutRedeemCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
  }

  export type AdminUncheckedUpdateWithoutRedeemCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
  }

  export type CodeRedemeerUpsertWithWhereUniqueWithoutCodeInput = {
    where: CodeRedemeerWhereUniqueInput
    update: XOR<CodeRedemeerUpdateWithoutCodeInput, CodeRedemeerUncheckedUpdateWithoutCodeInput>
    create: XOR<CodeRedemeerCreateWithoutCodeInput, CodeRedemeerUncheckedCreateWithoutCodeInput>
  }

  export type CodeRedemeerUpdateWithWhereUniqueWithoutCodeInput = {
    where: CodeRedemeerWhereUniqueInput
    data: XOR<CodeRedemeerUpdateWithoutCodeInput, CodeRedemeerUncheckedUpdateWithoutCodeInput>
  }

  export type CodeRedemeerUpdateManyWithWhereWithoutCodeInput = {
    where: CodeRedemeerScalarWhereInput
    data: XOR<CodeRedemeerUpdateManyMutationInput, CodeRedemeerUncheckedUpdateManyWithoutCodeInput>
  }

  export type UserCreateWithoutRedemeedCodesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRedemeedCodesInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    multiPlayerMember?: MultiPlayerMemberUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRedemeedCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRedemeedCodesInput, UserUncheckedCreateWithoutRedemeedCodesInput>
  }

  export type RedeemCodeCreateWithoutRedemeersInput = {
    id?: string
    suspend?: boolean
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: AdminTransactionCreateNestedOneWithoutRedeemCodeInput
    admin: AdminCreateNestedOneWithoutRedeemCodesInput
  }

  export type RedeemCodeUncheckedCreateWithoutRedemeersInput = {
    id?: string
    suspend?: boolean
    transactionId: string
    adminId: string
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RedeemCodeCreateOrConnectWithoutRedemeersInput = {
    where: RedeemCodeWhereUniqueInput
    create: XOR<RedeemCodeCreateWithoutRedemeersInput, RedeemCodeUncheckedCreateWithoutRedemeersInput>
  }

  export type UserUpsertWithoutRedemeedCodesInput = {
    update: XOR<UserUpdateWithoutRedemeedCodesInput, UserUncheckedUpdateWithoutRedemeedCodesInput>
    create: XOR<UserCreateWithoutRedemeedCodesInput, UserUncheckedCreateWithoutRedemeedCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRedemeedCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRedemeedCodesInput, UserUncheckedUpdateWithoutRedemeedCodesInput>
  }

  export type UserUpdateWithoutRedemeedCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRedemeedCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RedeemCodeUpsertWithoutRedemeersInput = {
    update: XOR<RedeemCodeUpdateWithoutRedemeersInput, RedeemCodeUncheckedUpdateWithoutRedemeersInput>
    create: XOR<RedeemCodeCreateWithoutRedemeersInput, RedeemCodeUncheckedCreateWithoutRedemeersInput>
    where?: RedeemCodeWhereInput
  }

  export type RedeemCodeUpdateToOneWithWhereWithoutRedemeersInput = {
    where?: RedeemCodeWhereInput
    data: XOR<RedeemCodeUpdateWithoutRedemeersInput, RedeemCodeUncheckedUpdateWithoutRedemeersInput>
  }

  export type RedeemCodeUpdateWithoutRedemeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput
    admin?: AdminUpdateOneRequiredWithoutRedeemCodesNestedInput
  }

  export type RedeemCodeUncheckedUpdateWithoutRedemeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiPlayerMemberCreateWithoutRoomInput = {
    id?: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
    user: UserCreateNestedOneWithoutMultiPlayerMemberInput
  }

  export type MultiPlayerMemberUncheckedCreateWithoutRoomInput = {
    id?: string
    userId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberCreateOrConnectWithoutRoomInput = {
    where: MultiPlayerMemberWhereUniqueInput
    create: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput>
  }

  export type MultiPlayerMemberCreateManyRoomInputEnvelope = {
    data: MultiPlayerMemberCreateManyRoomInput | MultiPlayerMemberCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type MultiPlayerMemberUpsertWithWhereUniqueWithoutRoomInput = {
    where: MultiPlayerMemberWhereUniqueInput
    update: XOR<MultiPlayerMemberUpdateWithoutRoomInput, MultiPlayerMemberUncheckedUpdateWithoutRoomInput>
    create: XOR<MultiPlayerMemberCreateWithoutRoomInput, MultiPlayerMemberUncheckedCreateWithoutRoomInput>
  }

  export type MultiPlayerMemberUpdateWithWhereUniqueWithoutRoomInput = {
    where: MultiPlayerMemberWhereUniqueInput
    data: XOR<MultiPlayerMemberUpdateWithoutRoomInput, MultiPlayerMemberUncheckedUpdateWithoutRoomInput>
  }

  export type MultiPlayerMemberUpdateManyWithWhereWithoutRoomInput = {
    where: MultiPlayerMemberScalarWhereInput
    data: XOR<MultiPlayerMemberUpdateManyMutationInput, MultiPlayerMemberUncheckedUpdateManyWithoutRoomInput>
  }

  export type UserCreateWithoutMultiPlayerMemberInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    city?: CityCreateNestedOneWithoutUsersInput
    province?: ProvinceCreateNestedOneWithoutUsersInput
    school?: SchoolCreateNestedOneWithoutUsersInput
    admin?: AdminCreateNestedOneWithoutUserInput
    zones?: ZoneCreateNestedManyWithoutUserInput
    userLogin?: UserLoginCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantCreateNestedManyWithoutUserInput
    subLevels?: SubLevelCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelCreateNestedManyWithoutUserInput
    levels?: LevelCreateNestedManyWithoutUserInput
    gempos?: GempoCreateNestedManyWithoutUserInput
    championships?: ChampionshipCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMultiPlayerMemberInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
    zones?: ZoneUncheckedCreateNestedManyWithoutUserInput
    userLogin?: UserLoginUncheckedCreateNestedManyWithoutUserInput
    bannerVisitor?: BannerVisitorUncheckedCreateNestedManyWithoutUserInput
    testParticipant?: TestParticipantUncheckedCreateNestedManyWithoutUserInput
    subLevels?: SubLevelUncheckedCreateNestedManyWithoutUserInput
    innerLevels?: InnerLevelUncheckedCreateNestedManyWithoutUserInput
    levels?: LevelUncheckedCreateNestedManyWithoutUserInput
    gempos?: GempoUncheckedCreateNestedManyWithoutUserInput
    championships?: ChampionshipUncheckedCreateNestedManyWithoutUserInput
    gempoRecords?: GempoRecordUncheckedCreateNestedManyWithoutUserInput
    championshipRecords?: ChampionshipRecordUncheckedCreateNestedManyWithoutUserInput
    redemeedCodes?: CodeRedemeerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMultiPlayerMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
  }

  export type MultiplayerRoomCreateWithoutMembersInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type MultiplayerRoomUncheckedCreateWithoutMembersInput = {
    id?: string
    max?: number
    gameplayId: string
    botOwner: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    expiredAt?: Date | string | null
    isStarted?: boolean
    isEnded?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMember?: number
  }

  export type MultiplayerRoomCreateOrConnectWithoutMembersInput = {
    where: MultiplayerRoomWhereUniqueInput
    create: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutMultiPlayerMemberInput = {
    update: XOR<UserUpdateWithoutMultiPlayerMemberInput, UserUncheckedUpdateWithoutMultiPlayerMemberInput>
    create: XOR<UserCreateWithoutMultiPlayerMemberInput, UserUncheckedCreateWithoutMultiPlayerMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMultiPlayerMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMultiPlayerMemberInput, UserUncheckedUpdateWithoutMultiPlayerMemberInput>
  }

  export type UserUpdateWithoutMultiPlayerMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMultiPlayerMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MultiplayerRoomUpsertWithoutMembersInput = {
    update: XOR<MultiplayerRoomUpdateWithoutMembersInput, MultiplayerRoomUncheckedUpdateWithoutMembersInput>
    create: XOR<MultiplayerRoomCreateWithoutMembersInput, MultiplayerRoomUncheckedCreateWithoutMembersInput>
    where?: MultiplayerRoomWhereInput
  }

  export type MultiplayerRoomUpdateToOneWithWhereWithoutMembersInput = {
    where?: MultiplayerRoomWhereInput
    data: XOR<MultiplayerRoomUpdateWithoutMembersInput, MultiplayerRoomUncheckedUpdateWithoutMembersInput>
  }

  export type MultiplayerRoomUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type MultiplayerRoomUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max?: IntFieldUpdateOperationsInput | number
    gameplayId?: StringFieldUpdateOperationsInput | string
    botOwner?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isStarted?: BoolFieldUpdateOperationsInput | boolean
    isEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMember?: IntFieldUpdateOperationsInput | number
  }

  export type CityCreateManyProvinceInput = {
    id?: string
    name: string
    longitude: number
    latitude: number
    geoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolCreateManyProvinceInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    cityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyProvinceInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    cityId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminAuthorityCreateManyProvinceInput = {
    id?: string
    adminId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type BannerLocationCreateManyProvinceInput = {
    id?: string
    bannerId: string
  }

  export type AdminCreateManyProvinceInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    cityId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
    admin?: AdminUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerLocationUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: BannerUpdateOneRequiredWithoutBannerLocationNestedInput
    cities?: CityUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutProvinceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateManyCityInput = {
    id?: string
    identity: string
    name: string
    longitude: number
    latitude: number
    provinceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCityInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    schoolId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminCreateManyCityInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    schoolId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutSchoolsNestedInput
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    school?: SchoolUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type BannerLocationUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: BannerUpdateOneRequiredWithoutBannerLocationNestedInput
    province?: ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type BannerLocationUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    school?: SchoolUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManySchoolInput = {
    id?: string
    authId: string
    email: string
    role?: $Enums.Role
    suspend?: boolean
    accountType?: $Enums.AccountType
    firstTest?: boolean
    fullname?: string
    birthDate?: Date | string | null
    grade?: number
    lastGradeUpdateAt?: Date | string | null
    schoolIdentity: string
    loginAt?: Date | string | null
    logoutAt?: Date | string | null
    playTime?: number
    characterUsed?: string
    inventory?: UserCreateinventoryInput | number[]
    cityId?: string | null
    provinceId?: string | null
    adminId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username: string
    lastIdZoneUnlocked?: string
    lastIdZonePosition?: string
  }

  export type AdminCreateManySchoolInput = {
    id?: string
    authId: string
    email: string
    name: string
    suspend?: boolean
    role?: $Enums.Role | null
    provinceId?: string | null
    cityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneWithoutUsersNestedInput
    province?: ProvinceUpdateOneWithoutUsersNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    zones?: ZoneUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUpdateManyWithoutUserNestedInput
    levels?: LevelUpdateManyWithoutUserNestedInput
    gempos?: GempoUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
    zones?: ZoneUncheckedUpdateManyWithoutUserNestedInput
    userLogin?: UserLoginUncheckedUpdateManyWithoutUserNestedInput
    bannerVisitor?: BannerVisitorUncheckedUpdateManyWithoutUserNestedInput
    testParticipant?: TestParticipantUncheckedUpdateManyWithoutUserNestedInput
    multiPlayerMember?: MultiPlayerMemberUncheckedUpdateManyWithoutUserNestedInput
    subLevels?: SubLevelUncheckedUpdateManyWithoutUserNestedInput
    innerLevels?: InnerLevelUncheckedUpdateManyWithoutUserNestedInput
    levels?: LevelUncheckedUpdateManyWithoutUserNestedInput
    gempos?: GempoUncheckedUpdateManyWithoutUserNestedInput
    championships?: ChampionshipUncheckedUpdateManyWithoutUserNestedInput
    gempoRecords?: GempoRecordUncheckedUpdateManyWithoutUserNestedInput
    championshipRecords?: ChampionshipRecordUncheckedUpdateManyWithoutUserNestedInput
    redemeedCodes?: CodeRedemeerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    suspend?: BoolFieldUpdateOperationsInput | boolean
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    firstTest?: BoolFieldUpdateOperationsInput | boolean
    fullname?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: IntFieldUpdateOperationsInput | number
    lastGradeUpdateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schoolIdentity?: StringFieldUpdateOperationsInput | string
    loginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    playTime?: IntFieldUpdateOperationsInput | number
    characterUsed?: StringFieldUpdateOperationsInput | string
    inventory?: UserUpdateinventoryInput | number[]
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: StringFieldUpdateOperationsInput | string
    lastIdZoneUnlocked?: StringFieldUpdateOperationsInput | string
    lastIdZonePosition?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuthorityUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    admin?: AdminUpdateOneRequiredWithoutAuthorityNestedInput
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAdminNestedInput
    province?: ProvinceUpdateOneWithoutAdminNestedInput
    city?: CityUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutAdminNestedInput
    authority?: AdminAuthorityUncheckedUpdateManyWithoutAdminNestedInput
    operationHistories?: AdminOperationHistoryUncheckedUpdateManyWithoutAdminNestedInput
    operations?: AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminNestedInput
    banner?: BannerUncheckedUpdateManyWithoutAdminNestedInput
    transactions?: AdminTransactionUncheckedUpdateManyWithoutAdminNestedInput
    transactionProcessed?: AdminTransactionUncheckedUpdateManyWithoutProcessedByNestedInput
    redeemCodes?: RedeemCodeUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    provinceId?: NullableStringFieldUpdateOperationsInput | string | null
    cityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateManyUserInput = {
    id?: string
    inGameId: string
    isComplete?: boolean
    completedAt?: Date | string | null
    lastLevelId?: string
    lastSubLevelId?: string
    lastInnerLevelId?: string
    lastLevelUnlock?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLoginCreateManyUserInput = {
    id?: string
    loginDate: Date | string
    logoutDate?: Date | string | null
  }

  export type BannerVisitorCreateManyUserInput = {
    id?: string
    bannerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type TestParticipantCreateManyUserInput = {
    id?: string
    testId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type MultiPlayerMemberCreateManyUserInput = {
    id?: string
    roomId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type SubLevelCreateManyUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InnerLevelCreateManyUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    levelInGameId: string
    subLevelInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    correctAttempt?: number
    playTime?: number
    point?: number
    played?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelCreateManyUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    isComplete?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipCreateManyUserInput = {
    id?: string
    isUnlock?: boolean
    unlockedAt?: Date | string | null
    inGameId: string
    zoneInGameId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GempoRecordCreateManyUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    gempoInGameId: string
    played?: number
    point?: number
    lastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChampionshipRecordCreateManyUserInput = {
    id?: string
    inGameId: string
    zoneInGameId: string
    championshipInGameId: string
    teamWin?: number
    teamLose?: number
    teamPlayed?: number
    teamPoint?: number
    teamLastPlayedAt?: Date | string | null
    soloWin?: number
    soloLose?: number
    soloPlayed?: number
    soloPoint?: number
    soloLastPlayedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedemeerCreateManyUserInput = {
    id?: string
    banned?: boolean
    codeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLevelId?: StringFieldUpdateOperationsInput | string
    lastSubLevelId?: StringFieldUpdateOperationsInput | string
    lastInnerLevelId?: StringFieldUpdateOperationsInput | string
    lastLevelUnlock?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLoginUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerVisitorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    banner?: BannerUpdateOneRequiredWithoutVisitorsNestedInput
  }

  export type BannerVisitorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type TestParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    test?: TestUpdateOneRequiredWithoutParticipantsNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type MultiPlayerMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    room?: MultiplayerRoomUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MultiPlayerMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubLevelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubLevelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubLevelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InnerLevelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    levelInGameId?: StringFieldUpdateOperationsInput | string
    subLevelInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    correctAttempt?: FloatFieldUpdateOperationsInput | number
    playTime?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    played?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUnlock?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GempoRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    gempoInGameId?: StringFieldUpdateOperationsInput | string
    played?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChampionshipRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inGameId?: StringFieldUpdateOperationsInput | string
    zoneInGameId?: StringFieldUpdateOperationsInput | string
    championshipInGameId?: StringFieldUpdateOperationsInput | string
    teamWin?: IntFieldUpdateOperationsInput | number
    teamLose?: IntFieldUpdateOperationsInput | number
    teamPlayed?: IntFieldUpdateOperationsInput | number
    teamPoint?: IntFieldUpdateOperationsInput | number
    teamLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    soloWin?: IntFieldUpdateOperationsInput | number
    soloLose?: IntFieldUpdateOperationsInput | number
    soloPlayed?: IntFieldUpdateOperationsInput | number
    soloPoint?: IntFieldUpdateOperationsInput | number
    soloLastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedemeerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: RedeemCodeUpdateOneRequiredWithoutRedemeersNestedInput
  }

  export type CodeRedemeerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedemeerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    codeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuthorityCreateManyAdminInput = {
    id?: string
    provinceId: string
    grades?: AdminAuthorityCreategradesInput | number[]
  }

  export type AdminOperationHistoryCreateManyAdminInput = {
    id?: string
    createdAt?: Date | string
    opAdminId: string
    operation?: $Enums.Operation
  }

  export type AdminOperationHistoryCreateManyOpAdminInput = {
    id?: string
    createdAt?: Date | string
    adminId: string
    operation?: $Enums.Operation
  }

  export type BannerCreateManyAdminInput = {
    id?: string
    thumbnailId: string
    thumbnail: string
    link?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    isHide?: boolean
  }

  export type AdminTransactionCreateManyAdminInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedById?: string | null
    processedAt?: Date | string | null
  }

  export type AdminTransactionCreateManyProcessedByInput = {
    id?: string
    name: string
    status?: $Enums.Transaction
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminId: string
    quantity?: number
    subscriptionTime: number
    zones?: AdminTransactionCreatezonesInput | string[]
    transactionRef?: string | null
    amount: number
    description?: string | null
    transactionImageId?: string | null
    transactionImageUrl?: string | null
    processedAt?: Date | string | null
  }

  export type RedeemCodeCreateManyAdminInput = {
    id?: string
    suspend?: boolean
    transactionId: string
    code?: string
    expiredAt: Date | string
    currentAmount: number
    maxAmount: number
    data?: RedeemCodeCreatedataInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAuthorityUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    province?: ProvinceUpdateOneRequiredWithoutAdminAuthorityNestedInput
    cities?: CityUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
    cities?: CityUncheckedUpdateManyWithoutAdminAuthorityNestedInput
    schools?: SchoolUncheckedUpdateManyWithoutAdminAuthorityNestedInput
  }

  export type AdminAuthorityUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    grades?: AdminAuthorityUpdategradesInput | number[]
  }

  export type AdminOperationHistoryUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    opAdmin?: AdminUpdateOneRequiredWithoutOperationsNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opAdminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUpdateWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
    admin?: AdminUpdateOneRequiredWithoutOperationHistoriesNestedInput
  }

  export type AdminOperationHistoryUncheckedUpdateWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type AdminOperationHistoryUncheckedUpdateManyWithoutOpAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    operation?: EnumOperationFieldUpdateOperationsInput | $Enums.Operation
  }

  export type BannerUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUpdateManyWithoutBannerNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
    visitors?: BannerVisitorUncheckedUpdateManyWithoutBannerNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    thumbnailId?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isHide?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminTransactionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemCode?: RedeemCodeUpdateOneWithoutTransactionNestedInput
    processedBy?: AdminUpdateOneWithoutTransactionProcessedNestedInput
  }

  export type AdminTransactionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemCode?: RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminTransactionUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin?: AdminUpdateOneRequiredWithoutTransactionsNestedInput
    redeemCode?: RedeemCodeUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemCode?: RedeemCodeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type AdminTransactionUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionFieldUpdateOperationsInput | $Enums.Transaction
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    subscriptionTime?: IntFieldUpdateOperationsInput | number
    zones?: AdminTransactionUpdatezonesInput | string[]
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RedeemCodeUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: AdminTransactionUpdateOneRequiredWithoutRedeemCodeNestedInput
    redemeers?: CodeRedemeerUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemeers?: CodeRedemeerUncheckedUpdateManyWithoutCodeNestedInput
  }

  export type RedeemCodeUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    suspend?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAmount?: IntFieldUpdateOperationsInput | number
    maxAmount?: IntFieldUpdateOperationsInput | number
    data?: RedeemCodeUpdatedataInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    bannerLocation?: BannerLocationUpdateManyWithoutCitiesNestedInput
    admin?: AdminUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    bannerLocation?: BannerLocationUncheckedUpdateManyWithoutCitiesNestedInput
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutSchoolsNestedInput
    province?: ProvinceUpdateOneRequiredWithoutSchoolsNestedInput
    users?: UserUpdateManyWithoutSchoolNestedInput
    admin?: AdminUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSchoolNestedInput
    admin?: AdminUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateManyWithoutAdminAuthorityInput = {
    id?: StringFieldUpdateOperationsInput | string
    identity?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    cityId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerVisitorCreateManyBannerInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    traffic?: number
  }

  export type BannerLocationCreateManyBannerInput = {
    id?: string
    provinceId: string
  }

  export type BannerVisitorUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBannerVisitorNestedInput
  }

  export type BannerVisitorUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerVisitorUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    traffic?: IntFieldUpdateOperationsInput | number
  }

  export type BannerLocationUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    province?: ProvinceUpdateOneRequiredWithoutBannerLocationNestedInput
    cities?: CityUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    cities?: CityUncheckedUpdateManyWithoutBannerLocationNestedInput
  }

  export type BannerLocationUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
  }

  export type CityUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    province?: ProvinceUpdateOneRequiredWithoutCitiesNestedInput
    schools?: SchoolUpdateManyWithoutCityNestedInput
    users?: UserUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUpdateManyWithoutCitiesNestedInput
    admin?: AdminUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: SchoolUncheckedUpdateManyWithoutCityNestedInput
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    adminAuthority?: AdminAuthorityUncheckedUpdateManyWithoutCitiesNestedInput
    admin?: AdminUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateManyWithoutBannerLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    geoId?: StringFieldUpdateOperationsInput | string
    provinceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestParticipantCreateManyTestInput = {
    id?: string
    userId: string
    firstTimeAt?: Date | string | null
    lastTestAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highscore?: number
  }

  export type TestParticipantUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutTestParticipantNestedInput
    records?: TestParticipantRecordUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
    records?: TestParticipantRecordUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TestParticipantUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastTestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highscore?: FloatFieldUpdateOperationsInput | number
  }

  export type TestParticipantRecordCreateManyParticipantInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answers: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type TestParticipantRecordUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: JsonNullValueInput | InputJsonValue
  }

  export type CodeRedemeerCreateManyCodeInput = {
    id?: string
    banned?: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeRedemeerUpdateWithoutCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRedemeedCodesNestedInput
  }

  export type CodeRedemeerUncheckedUpdateWithoutCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeRedemeerUncheckedUpdateManyWithoutCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    banned?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiPlayerMemberCreateManyRoomInput = {
    id?: string
    userId: string
    point?: number
    bonusPoint?: number
    isReady?: boolean
    isComplete?: boolean
    isBot?: boolean
    joinedAt?: Date | string
    finishedAt?: Date | string | null
    isDisconnect?: boolean
  }

  export type MultiPlayerMemberUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMultiPlayerMemberNestedInput
  }

  export type MultiPlayerMemberUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MultiPlayerMemberUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    point?: IntFieldUpdateOperationsInput | number
    bonusPoint?: IntFieldUpdateOperationsInput | number
    isReady?: BoolFieldUpdateOperationsInput | boolean
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isBot?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDisconnect?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}